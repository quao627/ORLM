[
  {
    "task_id":"D000",
    "description":"RapidLink Logistics, a regional delivery company, needs to optimize its daily outbound operations from its main distribution hub. Today, they have 3 delivery trucks of varying capacities and 8 high-priority parcels that must be shipped. The goal is to assign each of the 8 parcels to exactly one of the three trucks to maximize the total revenue for the day.\n\nThe total revenue is composed of two parts: a standard shipping fee for each parcel and a significant synergy bonus that is gained when specific pairs of parcels are placed in the *same* truck. These bonuses arise because certain parcels are headed to the same dense urban block or large corporate campus, allowing for a much more efficient final-mile delivery.\n\nThe capacities of the three available trucks are:\n- Truck 1: 100 kg\n- Truck 2: 120 kg\n- Truck 3: 80 kg\n\nThe details for the 8 high-priority parcels are listed below:\n| Parcel ID | Weight (kg) | Base Revenue ($) |\n| :--- | :--- | :--- |\n| 1 | 35 | 50 |\n| 2 | 45 | 75 |\n| 3 | 25 | 40 |\n| 4 | 50 | 80 |\n| 5 | 30 | 60 |\n| 6 | 40 | 65 |\n| 7 | 20 | 35 |\n| 8 | 55 | 90 |\n\nAdditionally, the logistics team has identified specific pairs of parcels that generate a synergy bonus if shipped in the same truck. These pairings and their associated bonuses are:\n| Parcel Pair | Synergy Bonus ($) | Reason |\n| :--- | :--- | :--- |\n| (1, 3) | 25 | Same residential complex |\n| (2, 5) | 30 | Same industrial park |\n| (2, 6) | 20 | Neighboring corporate offices |\n| (4, 8) | 40 | Both are heavy-lift items for one client |\n| (5, 7) | 22 | Same downtown skyscraper |\n\nThe company must decide which parcels go into which truck, respecting the weight capacity of each truck, to achieve the maximum possible total revenue.",
    "formulation":"Set:\n1. Parcels\nThe set of parcels, \\( I = \\{1, 2, ..., 8\\} \\)\n2. Trucks\nThe set of trucks, \\( J = \\{1, 2, 3\\} \\)\n3. Synergy Pairs\nThe set of parcel pairs with a synergy bonus, \\( P = \\{(1, 3), (2, 5), (2, 6), (4, 8), (5, 7)\\} \\)\n\nParameter:\n1. Parcel Weights (kg)\n\\( w = [35, 45, 25, 50, 30, 40, 20, 55] \\)\n2. Base Revenues ($)\n\\( r = [50, 75, 40, 80, 60, 65, 35, 90] \\)\n3. Truck Capacities (kg)\n\\( C = [100, 120, 80] \\)\n4. Synergy Bonuses ($)\n\\( s_{1,3}=25, s_{2,5}=30, s_{2,6}=20, s_{4,8}=40, s_{5,7}=22 \\) (and \\( s_{ik}=0 \\) for all other pairs)\n\n# Decision variable\n# x_ij: A binary variable that indicates the assignment of parcels to trucks.\nDecision variable:\n1. AssignmentVariable\nBinary variable,  \\( x_{ij} \\in \\{0, 1\\} \\) for all \\( i \\in I, j \\in J \\), where \\( x_{ij} = 1 \\) if parcel \\( i \\) is assigned to truck \\( j \\), and 0 otherwise.\n\nObjective:\nMaximize total revenue\n# To maximize the total revenue, which is the sum of the base revenues for all parcels \n# plus the sum of all achieved synergy bonuses. A bonus for pair (i,k) is achieved if\n# both parcels are assigned to the same truck j.\nmax: \\( \\sum_{i \\in I} \\sum_{j \\in J} r_i \\cdot x_{ij} + \\sum_{j \\in J} \\sum_{(i,k) \\in P} s_{ik} \\cdot x_{ij} \\cdot x_{kj} \\)\n\n# Constraint\nConstraint:\n1. Parcel Assignment\n# Each parcel must be assigned to exactly one truck.\n\\( \\sum_{j \\in J} x_{ij} = 1, \\quad \\forall i \\in I \\)\n2. Truck Capacity\n# For each truck, the sum of the weights of the parcels assigned to it must not exceed its capacity.\n\\( \\sum_{i \\in I} w_i \\cdot x_{ij} \\leq C_j, \\quad \\forall j \\in J \\)\n\nType:\nInteger, Non-linear, Linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_logistics_optimization(\n    parcels=[1, 2, 3, 4, 5, 6, 7, 8],\n    trucks=[1, 2, 3],\n    weights={1: 35, 2: 45, 3: 25, 4: 50, 5: 30, 6: 40, 7: 20, 8: 55},\n    base_revenues={\n        1: 50,\n        2: 75,\n        3: 40,\n        4: 80,\n        5: 60,\n        6: 65,\n        7: 35,\n        8: 90\n    },\n    capacities={1: 100, 2: 120, 3: 80},\n    synergy_bonuses={\n        (1, 3): 25,\n        (2, 5): 30,\n        (2, 6): 20,\n        (4, 8): 40,\n        (5, 7): 22\n    }\n):\n    \"\"\"\n    Models and solves the quadratic multiple knapsack problem for RapidLink Logistics\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"QuadraticKnapsackLogistics\")\n\n    # --- 2. Decision Variables ---\n    # x[i, j] = 1 if parcel i is assigned to truck j, 0 otherwise.\n    x = model.addVars(parcels, trucks, vtype=GRB.BINARY, name=\"assign\")\n\n    # --- 3. Objective Function ---\n    # The total revenue is the sum of base revenues plus synergy bonuses.\n    synergy_revenue = gp.quicksum(synergy_bonuses[i, k] * x[i, j] * x[k, j]\n                                    for (i, k) in synergy_bonuses\n                                    for j in trucks)\n    sum_base_revenue = gp.quicksum(base_revenues[i] for i in parcels)\n\n    model.setObjective(synergy_revenue + sum_base_revenue, GRB.MAXIMIZE)\n\n    # --- 4. Constraints ---\n\n    # Constraint 1: Each parcel must be assigned to exactly one truck.\n    for i in parcels:\n        model.addConstr(gp.quicksum(x[i, j] for j in trucks) == 1,\n                        name=f\"parcel_assign_{i}\")\n\n    # Constraint 2: The weight in each truck cannot exceed its capacity.\n    for j in trucks:\n        model.addConstr(gp.quicksum(weights[i] * x[i, j] for i in parcels)\n                        <= capacities[j],\n                        name=f\"truck_capacity_{j}\")\n\n    # --- 5. Solve the Model ---\n    model.optimize()\n\n    # --- 6. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_logistics_optimization()\n    print(result)\n",
    "ground_truth":537.0
  },
  {
    "task_id":"D001",
    "description":"An airport has two available gates (G1, G2) and needs to assign three flights (F1: 10:00-11:00, F2: 10:30-11:30, F3: 11:15-12:30, F4: 10:45-11:45) to these gates. Flights assigned to the same gate must have non-overlapping time intervals, and the goal is to minimize flight delays, where each 1-minute delay beyond the scheduled departure time incurs a cost of 1 unit. How should the flights be assigned to the gates to achieve this objective?",
    "formulation":"Set:\n1. Gates\nThe set of gates available at the airport, \\( G = \\{1, 2\\} \\)\n2. Flights\nThe set of flights to be assigned to the gates, \\( F = \\{1, 2, 3, 4\\} \\)\n\nParameter:\n1. ArrangeStartTime\n[600, 630, 645, 675]\n2. Duration\n[60, 60, 75, 60]\n3. CostPerDelyTime\n1\n4. M: A large positive number\n1500\n\nDecision variable:\n1. Assignment\nBinary variable \\( x_{fg} \\in \\{0, 1\\} \\) for all \\( f \\in F, g \\in G \\), where \\( x_{fg} = 1 \\) if flight \\( f \\) is assigned to gate \\( g \\), and \\( x_{fg} = 0 \\) otherwise.\n2. ActualStartTime\nInteger variable \\( s_f \\) representing the actual start time of flight \\( f \\in F\\)\n\nObjective:\nThe total cost of flight delays\nmin: \\sum_{f\\in F}\\sum_{g\\in G}CostPerDelyTime\\cdot (s_f-ArrangeStartTime_f)\\cdot x_{fg}\n\nConstraint:\n1. Actual start time should be greater than or equal to the scheduled start time.\ns_f \\geq ArrangeStartTime_f, \\forall f \\in F\n\n2. Every flight should be assigned to exactly one gate.\n\\sum_{g\\in G}x_{fg} = 1, \\forall f \\in F\n\n3. The actual start time should be greater than or equal to the end time of the previous flight at the same gate.\ns_{f2} \\geq s_{f1}+Duration_{f1} - M*(2-x[f1, g]-x[f2, g]), \\forall f1, f2 \\in F, f1 < f2, x_{f1g} = 1, x_{f2g} = 1 \\forall g \\in G\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_flight_gate_assignment(\n    gates=[1, 2],\n    flights=[1, 2, 3, 4],\n    arrange_start_time={1: 600, 2: 630, 4: 645, 3: 675},\n    duration={1: 60, 2: 60, 3: 75, 4: 60},\n    cost_per_delay=1,\n    big_m=1500,\n):\n    \"\"\"\n    Models and solves the flight gate assignment problem to minimize total delay.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"FlightGateAssignment\")\n\n    # --- 2. Decision Variables ---\n    # x[f,g] = 1 if flight f is assigned to gate g, else 0\n    x = model.addVars([(f, g) for f in flights for g in gates], vtype=GRB.BINARY, name=\"x\")\n\n    # s[f] = actual start time of flight f\n    s = model.addVars(flights, vtype=GRB.INTEGER, name=\"s\")\n\n    # --- 3. Objective Function ---\n    # Minimize total delay cost\n    obj = gp.quicksum(cost_per_delay * (s[f] - arrange_start_time[f])\n                      for f in flights)\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # --- 4. Constraints ---\n    # Constraint 1: Actual start time should be greater than or equal to the scheduled start time\n    for f in flights:\n        model.addConstr(s[f] >= arrange_start_time[f], f\"start_time_constraint_{f}\")\n\n    # Constraint 2: Every flight should be assigned to exactly one gate\n    for f in flights:\n        model.addConstr(gp.quicksum(x[f, g] for g in gates) == 1, f\"one_gate_per_flight_{f}\")\n\n    # Constraint 3: The actual start time should be greater than or equal to the end time\n    # of the previous flight at the same gate (linearized using Big-M).\n    # This formulation imposes a fixed sequence f1 -> f2 if f1 < f2.\n    for g in gates:\n        for f1 in flights:\n            for f2 in flights:\n                if f1 < f2:  # for flights where f1 comes before f2\n                    # If both flights are assigned to the same gate g,\n                    # then f2 must start after f1 ends\n                    model.addConstr(\n                        s[f2] >= s[f1] + duration[f1] - big_m * (2 - x[f1, g] - x[f2, g]),\n                        f\"sequence_constraint_{f1}_{f2}_{g}\",\n                    )\n\n    # --- 5. Solve the Model ---\n    # model.setParam(\"OutputFlag\", 0) # Suppress Gurobi output\n    model.optimize()\n\n    # --- 6. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_flight_gate_assignment()\n    print(result)",
    "ground_truth":30.0
  },
  {
    "task_id":"D002",
    "description":"A logistics company has many boxes with the same structure and capacity, and the number of boxes is sufficient for the purpose at hand. The capacity of each box is 10. There are 7 items with loads of 6, 7, 8, 3, 2, 4 and 5 that need to be packed into the boxes. Find a loading method that uses the minimum number of boxes to pack all 7 items.",
    "formulation":"Set:\n1. Boxes\nThe set of Boxes, \\( B = \\{1, 2, ..., ItemNum\\} \\)\n2. Items\nThe set of Items, \\( I = \\{1, 2, ..., ItemNum\\} \\)\n\nParameter:\n1. BoxCapacity\n10\n2. ItemNum\n7\n3. Item Loads\n[6, 7, 8, 3, 2, 4, 5]\n\nDecision variable:\n1. BoxUsed\nBinary variable \\( x_b \\in \\{0, 1\\} \\) for all \\( b \\in B \\), where \\( x_b = 1 \\) if box \\( b \\) is used, and \\( x_b = 0 \\) otherwise\n2. ItemInBox\nBinary variable \\( y_{ib} \\in \\{0, 1\\} \\) for all \\( i \\in I, b \\in B \\), where \\( y_{ib} = 1 \\) if item \\( i \\) is packed in box \\( b \\), and \\( y_{ib} = 0 \\) otherwise\n\nObjective:\nThe minimum number of boxes used\nmin: \\sum_{b\\in B}x_b\n\nConstraint:\n1. Each item must be packed in exactly one box\n\\sum_{b\\in B}y_{ib} = 1, \\forall i \\in I\n2. The total load of items in each box must not exceed the box capacity\n\\sum_{i\\in I}ItemLoads_i \\cdot y_{ib} \\leq BoxCapacity \\cdot x_b, \\forall b \\in B\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_bin_packing(\n    item_loads={1: 6, 2: 7, 3: 8, 4: 3, 5: 2, 6: 4, 7: 5},\n    box_capacity=10\n):\n    \"\"\"\n    Models and solves the Bin Packing problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"BinPacking\")\n\n    # --- 2. Sets and Parameters ---\n    items = list(item_loads.keys())\n    # The number of bins cannot exceed the number of items\n    bins = range(1, len(items) + 1)\n\n    # --- 3. Decision Variables ---\n    # x[b] = 1 if bin b is used, 0 otherwise\n    x = model.addVars(bins, vtype=GRB.BINARY, name=\"BinUsed\")\n\n    # y[i,b] = 1 if item i is packed in bin b, 0 otherwise\n    y = model.addVars(items, bins, vtype=GRB.BINARY, name=\"ItemInBin\")\n\n    # --- 4. Objective Function ---\n    # Minimize the number of bins used\n    model.setObjective(gp.quicksum(x[b] for b in bins), GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Each item must be packed in exactly one bin\n    for i in items:\n        model.addConstr(gp.quicksum(y[i, b] for b in bins) == 1,\n                        name=f\"item_assign_{i}\")\n\n    # Constraint 2: The total load of items in each bin must not exceed its capacity.\n    # This also links the y and x variables: if a bin is not used (x[b]=0),\n    # no items can be placed in it (sum of y[i,b] must be 0).\n    for b in bins:\n        model.addConstr(\n            gp.quicksum(item_loads[i] * y[i, b] for i in items) <= box_capacity * x[b],\n            name=f\"bin_capacity_{b}\"\n        )\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        # Gurobi objective value can be a float, so we cast to int for bin packing\n        return {\"status\": \"optimal\", \"obj\": int(model.ObjVal)}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_bin_packing()\n    print(result)",
    "ground_truth":4.0
  },
  {
    "task_id":"D003",
    "description":"A logistics company has 6 boxes with capacity of [5, 9, 8, 7, 7, 8] and 7 items with loads of 6, 7, 8, 3, 2, 4 and 5 that need to be packed into the boxes. Find a loading method that uses the minimum number of boxes to pack all 7 items.",
    "formulation":"Set:\n1. Boxes\nThe set of Boxes, \\( B = \\{1, 2, ..., 6\\} \\)\n2. Items\nThe set of Items, \\( I = \\{1, 2, ..., 7\\} \\)\n\nParameter:\n1. BoxNum\n6\n2. BoxCapacity\n[5, 9, 8, 7, 7, 8]\n2. ItemNum\n7\n2. Item Loads\n[6, 7, 8, 3, 2, 4, 5]\n\nDecision variable:\n1. BosUsed\nBinary variable \\( x_b \\in \\{0, 1\\} \\) for all \\( b \\in B \\), where \\( x_b = 1 \\) if box \\( b \\) is used, and \\( x_b = 0 \\) otherwise\n2. ItemInBox\nBinary variable \\( y_{ib} \\in \\{0, 1\\} \\) for all \\( i \\in I, b \\in B \\), where \\( y_{ib} = 1 \\) if item \\( i \\) is packed in box \\( b \\), and \\( y_{ib} = 0 \\) otherwise\n\nObjective:\nThe minimum number of boxes used\nmin: \\sum_{b\\in B}x_b\n\nConstraint:\n1. Each item must be packed in exactly one box\n\\sum_{b\\in B}y_{ib} = 1, \\forall i \\in I\n2. The total load of items in each box must not exceed the box capacity\n\\sum_{i\\in I}y_{ib}\\cdot ItemLoads[i] \\leq BoxCapacity[b], \\forall b \\in B\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_variable_bin_packing(\n    box_capacity={1: 5, 2: 9, 3: 8, 4: 7, 5: 7, 6: 8},\n    item_loads={1: 6, 2: 7, 3: 8, 4: 3, 5: 2, 6: 4, 7: 5},\n):\n    \"\"\"\n    Models and solves the Bin Packing problem with variable bin capacities.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"BinPackingVariableCapacity\")\n\n    # --- 2. Sets ---\n    # Derive sets from the keys of the input data for flexibility\n    boxes = list(box_capacity.keys())\n    items = list(item_loads.keys())\n\n    # --- 3. Decision Variables ---\n    # x[b] = 1 if box b is used, 0 otherwise\n    x = model.addVars(boxes, vtype=GRB.BINARY, name=\"BoxUsed\")\n\n    # y[i,b] = 1 if item i is packed in box b, 0 otherwise\n    y = model.addVars(items, boxes, vtype=GRB.BINARY, name=\"ItemInBox\")\n\n    # --- 4. Objective Function ---\n    # Minimize the number of boxes used\n    model.setObjective(gp.quicksum(x[b] for b in boxes), GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Each item must be packed in exactly one box\n    for i in items:\n        model.addConstr(gp.quicksum(y[i, b] for b in boxes) == 1,\n                        name=f\"item_assign_{i}\")\n\n    # Constraint 2: The total load of items in each box must not exceed its capacity.\n    # This also links the y and x variables.\n    for b in boxes:\n        model.addConstr(\n            gp.quicksum(item_loads[i] * y[i, b] for i in items) <= box_capacity[b] * x[b],\n            name=f\"box_capacity_{b}\"\n        )\n\n    # --- 6. Solve the Model ---\n    # model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        # The objective value for bin packing is an integer\n        return {\"status\": \"optimal\", \"obj\": int(model.ObjVal)}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_variable_bin_packing()\n    print(result)",
    "ground_truth":5.0
  },
  {
    "task_id":"D004",
    "description":"A company has three industries located in different locations and needs to deliver goods to five shops in different locations. The delivery costs from the first industry to the shops are 4, 9, 2, 6, and 5, respectively, with a storage capacity of 60. The delivery costs from the second industry to the shops are 2, 6, 1, 7, and 9, respectively, with a storage capacity of 30. The delivery costs from the third industry to the shops are 2, 4, 9, 8, and 3, respectively, with a storage capacity of 45. The demands of the five shops are 15, 35, 20, 5, and 40. How can the goods be transported to minimize the cost?",
    "formulation":"Set:\n1. Industries\nThe set of industries, \\( I = \\{1, 2, \\dots, IndustryNum\\} \\)\n2. Shops\nThe set of shops, \\( S = \\{1, 2, \\dots, ShopNum\\} \\)\n\nParameter:\n1. IndustryNum\n3\n2. ShopNum\n5\n3. IndustryStorage\n[60, 30, 45]\n4. ShopDemand\n[15, 35, 20, 5, 40]\n5. TransportationCost(row: industry, column: shop)\n[[4, 9, 2, 6, 5], \n [2, 6, 1, 7, 9], \n [2, 4, 9, 8, 3]]\n\nDecision variable:\n1. Transportation\nInteger variable, \\( t_{ij} \\geq 0 \\) for all \\( i \\in I, j \\in S \\), representing the amount of goods transported from industry \\( i \\) to shop \\( j \\)\n\nObjective:\nThe total transportation cost\nmin: \\sum_{i\\in I}\\sum_{j\\in S}TransportationCost_{ij}\\cdot t_{ij}\n\nConstraint:\n1. Industry storage capacity\n\\sum_{j\\in S}t_{ij} \\leq IndustryStorage_i, \\forall i \\in I\n2. Shop demand\n\\sum_{i\\in I}t_{ij} = ShopDemand_j, \\forall j \\in S\n\nType:\nInteger, linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_transportation_problem(\n    industry_storage=[60, 30, 45],\n    shop_demand=[15, 35, 20, 5, 40],\n    transportation_cost=[\n        [4, 9, 2, 6, 5],\n        [2, 6, 1, 7, 9],\n        [2, 4, 9, 8, 3]\n    ]\n):\n    \"\"\"\n    Models and solves the classic transportation problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"TransportationProblem\")\n\n    # --- 2. Sets and Parameters ---\n    # Derive dimensions from the input data for robustness\n    industries = range(len(industry_storage))\n    shops = range(len(shop_demand))\n\n    # --- 3. Decision Variables ---\n    # t[i, j] = amount transported from industry i to shop j\n    t = model.addVars(industries, shops, vtype=GRB.INTEGER, name=\"transport\")\n\n    # --- 4. Objective Function ---\n    # Minimize total transportation cost\n    model.setObjective(\n        gp.quicksum(transportation_cost[i][j] * t[i, j] for i in industries for j in shops),\n        GRB.MINIMIZE\n    )\n\n    # --- 5. Constraints ---\n    # Constraint 1: Supply constraint for each industry\n    for i in industries:\n        model.addConstr(gp.quicksum(t[i, j] for j in shops) <= industry_storage[i],\n                        name=f\"supply_{i}\")\n\n    # Constraint 2: Demand constraint for each shop\n    for j in shops:\n        model.addConstr(gp.quicksum(t[i, j] for i in industries) == shop_demand[j],\n                        name=f\"demand_{j}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_transportation_problem()\n    print(result)",
    "ground_truth":405.0
  },
  {
    "task_id":"D005",
    "description":"A company has three warehouses storing three products with inventory: Warehouse 1 (600, 900, 750), Warehouse 2 (500, 1500, 1200), Warehouse 3 (800, 1100, 100). These products must be shipped to seven sales locations with demands: Location 1 (200, 400, 300), Location 2 (300, 800, 50), Location 3 (200, 300, 50), Location 4 (75, 250, 80), Location 5 (600, 700, 200), Location 6 (225, 850, 100), Location 7 (300, 200, 200). Transportation costs vary by product, warehouse, and destination: For Warehouse 1, the costs per unit are Product 1: 30, 10, 8, 10, 11, 71, 6 for Locations 1–7; Product 2: 39, 14, 11, 14, 16, 82, 8 for Locations 1–7; and Product 3: 41, 15, 12, 16, 17, 86, 8 for Locations 1–7. For Warehouse 2, the costs per unit are Product 1: 22, 7, 10, 7, 21, 82, 13 for Locations 1–7; Product 2: 27, 9, 12, 9, 26, 95, 17 for Locations 1–7; and Product 3: 29, 9, 13, 9, 28, 99, 18 for Locations 1–7. For Warehouse 3, the costs per unit are Product 1: 19, 11, 12, 10, 25, 83, 15 for Locations 1–7; Product 2: 24, 14, 17, 13, 28, 99, 20 for Locations 1–7; and Product 3: 26, 14, 17, 13, 31, 104, 20 for Locations 1–7. And shipments from any warehouse to any location cannot exceed 625 units. How to allocate shipments to minimize total transportation cost?",
    "formulation":"Set:\n1. Warehouses\nThe set of warehouses, \\( W = \\{1, 2, \\dots, WarehouseNum\\} \\)\n2. SalesLocations\nThe set of sales locations, \\( L = \\{1, 2, \\dots, LocationNum\\} \\)\n3. Products\nThe set of products, \\( P = \\{1, 2, \\dots, ProductNum\\} \\)\n\nParameter:\n1. WarehouseNum\n3\n2. LocationNum\n7\n3. ProductNum\n3\n4. WarehouseStorage\n[[800, 900, 750], [500, 1500, 1200], [800, 110, 100]]\n5. LocationDemand\n[[200, 400, 300], [300, 800, 50], [200, 300, 50], [75, 250, 80], [600, 900, 200], [225, 850, 100], [300, 500, 200]]\n6. TransportationCost(warehouse: location: product)\n[[[30, 39, 41], [10, 14, 15], [8, 11, 12], [10, 14, 16], [11, 16, 17], [71, 82, 86], [6, 8, 8]], \n [[22, 27, 29], [7, 9, 9], [10, 12, 13], [7, 9, 9], [21, 26, 28], [82, 95, 99], [13, 17, 18]], \n [[19, 24, 26], [11, 14, 14], [12, 17, 17], [10, 13, 13], [25, 28, 31], [83, 99, 104], [15, 20, 20]]]\n\nDecision variable:\n1. Transportation\nInteger variable, \\( t_{ijp} \\geq 0 \\) for all \\( i \\in W, j \\in L, p \\in P \\), representing the amount of product \\( p \\) transported from warehouse \\( i \\) to sales location \\( j \\)\n\nObjective:\nThe total transportation costs\nmin: \\sum_{i\\in W}\\sum_{j\\in L}\\sum_{p\\in P}TransportationCost_{ijp}\\cdot t_{ijp}\n\nConstraint:\n1. Warehouse storage capacity\n\\sum_{j\\in L}t_{ijp} \\leq WarehouseStorage_{ip}, \\forall i \\in W, p \\in P\n2. Sales location demand\n\\sum_{i\\in W}t_{ijp} = LocationDemand_{jp}, \\forall j \\in L, p \\in P\n3. Shipment limit\n\\sum_{p\\in P}t_{ijp} \\leq 625, \\forall i \\in W, j \\in L\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_multi_product_transportation(\n    warehouse_storage=[\n        [600, 900, 750],\n        [500, 1500, 1200],\n        [800, 1100, 100]\n    ],\n    location_demand=[\n        [200, 400, 300],\n        [300, 800, 50],\n        [200, 300, 50],\n        [75, 250, 80],\n        [600, 700, 200],\n        [225, 850, 100],\n        [300, 200, 200]\n    ],\n    transportation_cost=[\n        [[30, 39, 41], [10, 14, 15], [8, 11, 12], [10, 14, 16], [11, 16, 17], [71, 82, 86], [6, 8, 8]],\n        [[22, 27, 29], [7, 9, 9], [10, 12, 13], [7, 9, 9], [21, 26, 28], [82, 95, 99], [13, 17, 18]],\n        [[19, 24, 26], [11, 14, 14], [12, 17, 17], [10, 13, 13], [25, 28, 31], [83, 99, 104], [15, 20, 20]]\n    ],\n    max_one_shipment=625\n):\n    \"\"\"\n    Models and solves the multi-product transportation problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"WarehouseTransportation\")\n\n    # --- 2. Sets ---\n    # Derive sets from the dimensions of the input data\n    warehouses = range(len(warehouse_storage))\n    locations = range(len(location_demand))\n    products = range(len(warehouse_storage[0]))\n\n    # --- 3. Decision Variables ---\n    # t[i, j, p] = amount of product p transported from warehouse i to location j\n    t = model.addVars(warehouses, locations, products, vtype=GRB.INTEGER, lb=0, name=\"transport\")\n\n    # --- 4. Objective Function ---\n    # Minimize total transportation cost\n    objective = gp.quicksum(transportation_cost[i][j][p] * t[i, j, p]\n                           for i in warehouses\n                           for j in locations\n                           for p in products)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Warehouse storage capacity\n    for i in warehouses:\n        for p in products:\n            model.addConstr(gp.quicksum(t[i, j, p] for j in locations) <= warehouse_storage[i][p],\n                           name=f\"warehouse_capacity_{i+1}_{p+1}\")\n\n    # Constraint 2: Sales location demand must be met\n    for j in locations:\n        for p in products:\n            model.addConstr(gp.quicksum(t[i, j, p] for i in warehouses) == location_demand[j][p],\n                           name=f\"location_demand_{j+1}_{p+1}\")\n\n    # Constraint 3: Shipment limit for each warehouse-location pair\n    for i in warehouses:\n        for j in locations:\n            model.addConstr(gp.quicksum(t[i, j, p] for p in products) <= max_one_shipment,\n                           name=f\"shipment_limit_{i+1}_{j+1}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        # Return the Gurobi status code if no optimal solution is found\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_multi_product_transportation()\n    print(result)",
    "ground_truth":181320.0
  },
  {
    "task_id":"D006",
    "description":"Now, from 6 individuals (A, B, C, D, E, F), 5 are to be selected to complete 5 tasks (1-5). The time each person takes to complete each task is shown in the table below:\n\n| task\\person | A | B | C | D | E | F |\n|---|---|---|---|---|---|---|\n| 1 | 5 | 2 | 3 | 15 | 9 | 10 |\n| 2 | 5 | 6 | 15 | 2 | 4 | 7 |\n| 3 | 15 | 5 | 14 | 7 | 15 | 6 |\n| 4 | 20 | 15 | 18 | 6 | 8 | 11 |\n| 5 | 8 | 11 | 18 | 10 | 15 | 6 |\n\nIt is stipulated that each person can only complete one task. Due to certain reasons, individual A must be assigned a task, and individual D cannot be assigned task 4. What is the minimum total time spent?",
    "formulation":"Set:\n1. Person\nThe set of persons, \\( P = \\{A, B, \\dots, F\\} \\)\n2. Tasks\nThe set of tasks, \\( T = \\{1, 2, \\dots, 5\\} \\)\n\nParameter:\n1. PersonNum\n6\n2. TaskNum\n5\n3. CompleteTime\n[[5, 2, 3, 15, 9, 10], [5, 6, 15, 2, 4, 7], [15, 5, 14, 7, 15, 6], [20, 15, 18, 6, 8, 11], [8, 11, 18, 10, 15, 6]]\n\nDecision variable:\n1. Assignment\nBinary variable, \\( x_{ij} \\) for all \\( i \\in P, j \\in T \\), representing whether person \\( i \\) is assigned to task \\( j \\) (1 if assigned, 0 otherwise)\n\nObjective:\nThe total time spent\nmin: \\sum_{i\\in P}\\sum_{j\\in T}CompleteTime_{ij}\\cdot x_{ij}\n\nConstraint:\n1. Person assignment\n\\sum_{j\\in T}x_{ij} \\leq 1, \\forall i \\in P\n2. Task assignment\n\\sum_{i\\in P}x_{ij} = 1, \\forall j \\in T\n3. Person A \n\\sum_{j\\in T}x_{P[0]j} = 1\n4. Person D \nx_{P[3]j} = 0, \\forall j \\in T\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_task_assignment(\n    complete_time=[\n        [5, 2, 3, 15, 9, 10],\n        [5, 6, 15, 2, 4, 7],\n        [15, 5, 14, 7, 15, 6],\n        [20, 15, 18, 6, 8, 11],\n        [8, 11, 18, 10, 15, 6],\n    ]\n):\n    \"\"\"\n    Models and solves the task assignment problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"TaskAssignment\")\n\n    # --- 2. Sets ---\n    # The number of tasks is the number of rows in complete_time.\n    # The number of persons is the number of columns.\n    num_tasks = len(complete_time)\n    num_persons = len(complete_time[0])\n    tasks = range(num_tasks)\n    persons = range(num_persons)\n\n    # --- 3. Decision Variables ---\n    # x[p, t] = 1 if person p is assigned to task t, 0 otherwise\n    x = model.addVars(persons, tasks, vtype=GRB.BINARY, name=\"assign\")\n\n    # --- 4. Objective Function ---\n    # Minimize total completion time. Note: complete_time is indexed by [task][person].\n    objective = gp.quicksum(complete_time[t][p] * x[p, t]\n                           for p in persons for t in tasks)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Each person can be assigned to at most one task.\n    for p in persons:\n        model.addConstr(gp.quicksum(x[p, t] for t in tasks) <= 1,\n                        name=f\"person_at_most_one_task_{p}\")\n\n    # Constraint 2: Each task must be assigned to exactly one person.\n    for t in tasks:\n        model.addConstr(gp.quicksum(x[p, t] for p in persons) == 1,\n                        name=f\"task_must_be_assigned_{t}\")\n\n    # Constraint 3: Person A (index 0) must be assigned to exactly one task.\n    # This makes the general constraint (<=1) redundant for Person A, but is included\n    # to match the problem's specific requirements.\n    model.addConstr(gp.quicksum(x[0, t] for t in tasks) == 1,\n                    name=\"person_A_must_work\")\n\n    # Constraint 4: Person D (index 3) cannot be assigned to task 4 (index 3).\n    model.addConstr(x[3, 3] == 0, name=\"person_D_task_4_restriction\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_task_assignment()\n    print(result)\n",
    "ground_truth":26.0
  },
  {
    "task_id":"D007",
    "description":"A container terminal needs to allocate berths (which are arranged in a straight line with a total length of 900) for 9 vessels (A, B, C, D, E, F, G, H, I) arriving within 4 days. The lengths of the vessels are 287, 196, 261, 288, 208, 238, 190, 217 and 254 respectively. The arrival times of the vessels are 9, 27, 34, 40, 1, 31, 28, 20, and 22 hours respectively, while the required working times for loading and unloading after docking are 7, 31, 31, 25, 29, 11, 28, 24, and 20 hours respectively. The optimal berthing positions for the vessels are 375, 419, 591, 510, 567, 64, 507, 377, and 93 respectively. A berthing plan now needs to be devised, where the additional operational costs caused by deviations from the original optimal berthing positions are 8, 4, 5, 5, 2, 6, 8, 6, and 8 per unit of distance, and the delay costs are 7, 7, 3, 4, 4, 7, 2, 4, and 7 per hour of delay. What is the minimum total additional cost resulting from deviations from the optimal berthing positions and delays? (Assume vessels can only dock at integer positions on the hour.)",
    "formulation":"Set:\n1. Vessels\nThe set of vessels, \\( V = \\{A, B, C, D, E, F, G, H, I\\} \\)\n\nParameter:\n1. BerthLength\n900\n2. VesselNum\n9\n3. BestBerthLocation\n[375, 419, 591, 510, 567, 64, 507, 377, 93]\n4. ExpectedArrivalTime\n[9, 27, 34, 40, 1, 31, 28, 20, 22]\n5. OperationTime\n[7, 31, 31, 25, 29, 11, 28, 24, 20]\n6. VesselLength\n[287, 196, 261, 288, 208, 238, 190, 217, 254]\n7. AdditionalTravelCost\n[8, 4, 5, 5, 2, 6, 8, 6, 8]\n8. PenaltyCost\n[7, 7, 3, 4, 4, 7, 2, 4, 7]\n9. Period\n96\n10. M (a large number)\n2000\n\nDecision variable:\n1. BerthLocation\nInteger variable, \\( BerthLocation_{i} \\) for all \\( i \\in V \\), representing the berth location of vessel \\( i \\)\n2. BerthTime\nInteger variable, \\( BerthTime_{i} \\) for all \\( i \\in V \\), representing the berthing time of vessel \\( i \\)\n3. LocationRelation\nBinary variable, \\( LocationRelation_{ij} \\) for all \\( i, j \\in V \\), representing the vessel \\( i \\) located to the left-hand side of vessel \\( j \\) (1 if true, 0 otherwise)\n4. TimeRelation\nBinary variable, \\( TimeRelation_{ij} \\) for all \\( i, j \\in V \\), representing the vessel \\( i \\) berthing before vessel \\( j \\) (1 if true, 0 otherwise)\n\nObjective:\nThe total distance between vessels to the yard and the total penalty cost incurred due to delays\nmin: \\sum_{i\\in V}[AdditionalTravelCost_{j}\\cdot\\left|BerthLocation_{i} - BestBerthLocation_{j}\\right| + PenaltyCost_{i} \\cdot (BerthTime_{i} - ExpectedArrivalTime_{i}, 0)]\n\nConstraint:\n1. MaxBerthLocation\nx_{i} + VesselLength_{i} \\leq BerthLength, \\forall i \\in V\n2. BerthLocationRelation\nx_{i} + VesselLength_{i} \\leq x_{j} + M \\cdot (1 - LocationRelation_{ij}), \\forall i, j \\in V, i \\neq j\n3. BerthTimeRelation\nBerthTime_{i} + OperationTime_{i} \\leq BerthTime_{j} + M \\cdot (1 - TimeRelation_{ij}), \\forall i, j \\in V, i \\neq j\n4. Relation\nLocationRelation_{ij} + LocationRelation_{ji} + TimeRelation_{ij} + TimeRelation_{ji} \\geq 1, \\forall i, j \\in V, i < j\n5. BerthTime\nBerthTime_{i} \\geq ExpectedArrivalTime_{i}, \\forall i \\in V\n6. BerthLocation\nBerthLocation_{i} \\geq 0, \\forall i \\in V\n\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_vessel_berth_allocation(\n    berth_length=900,\n    best_berth_location=[375, 419, 591, 510, 567, 64, 507, 377, 93],\n    expected_arrival_time=[9, 27, 34, 40, 1, 31, 28, 20, 22],\n    operation_time=[7, 31, 31, 25, 29, 11, 28, 24, 20],\n    vessel_length=[287, 196, 261, 288, 208, 238, 190, 217, 254],\n    additional_travel_cost=[8, 4, 5, 5, 2, 6, 8, 6, 8],\n    penalty_cost=[7, 7, 3, 4, 4, 7, 2, 4, 7],\n    period=96,  # Note: This parameter is not used in the current model logic\n    big_m=2000\n):\n    \"\"\"\n    Models and solves the Vessel Berth Allocation Problem (VBAP).\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"VesselBerthAllocation\")\n\n    # --- 2. Sets ---\n    # Derive the set of vessels from the length of the input data lists\n    vessels = range(len(vessel_length))\n    vessel_pairs = [(i, j) for i in vessels for j in vessels if i != j]\n\n    # --- 3. Decision Variables ---\n    # berth_location: position of each vessel along the quay\n    berth_location = model.addVars(vessels, vtype=GRB.INTEGER, lb=0, name=\"berth_location\")\n\n    # berth_time: start time of berthing for each vessel\n    berth_time = model.addVars(vessels, vtype=GRB.INTEGER, lb=0, name=\"berth_time\")\n\n    # location_relation[i,j]: 1 if vessel i is to the left of vessel j, 0 otherwise\n    location_relation = model.addVars(vessel_pairs, vtype=GRB.BINARY, name=\"location_relation\")\n\n    # time_relation[i,j]: 1 if vessel i is berthed before vessel j, 0 otherwise\n    time_relation = model.addVars(vessel_pairs, vtype=GRB.BINARY, name=\"time_relation\")\n\n    # position_deviation: auxiliary variable for absolute value of location deviation\n    position_deviation = model.addVars(vessels, vtype=GRB.INTEGER, lb=0, name=\"position_deviation\")\n\n    # --- 4. Objective Function ---\n    # Minimize total cost (travel deviation cost + delay penalty cost)\n    objective = gp.quicksum(\n        additional_travel_cost[i] * position_deviation[i] +\n        penalty_cost[i] * (berth_time[i] - expected_arrival_time[i])\n        for i in vessels\n    )\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Linearize the absolute value for position deviation\n    for i in vessels:\n        model.addConstr(position_deviation[i] >= berth_location[i] - best_berth_location[i], name=f\"abs_pos_dev_{i}\")\n        model.addConstr(position_deviation[i] >= best_berth_location[i] - berth_location[i], name=f\"abs_neg_dev_{i}\")\n\n    # Constraint 2: Vessels must be fully within the berth's length\n    for i in vessels:\n        model.addConstr(berth_location[i] + vessel_length[i] <= berth_length, name=f\"max_berth_loc_{i}\")\n\n    # Constraint 3: No spatial overlap between vessels (Big-M)\n    for i, j in vessel_pairs:\n        model.addConstr(\n            berth_location[i] + vessel_length[i] <= berth_location[j] + big_m * (1 - location_relation[i, j]),\n            name=f\"loc_rel_{i}_{j}\"\n        )\n\n    # Constraint 4: No temporal overlap between vessels (Big-M)\n    for i, j in vessel_pairs:\n        model.addConstr(\n            berth_time[i] + operation_time[i] <= berth_time[j] + big_m * (1 - time_relation[i, j]),\n            name=f\"time_rel_{i}_{j}\"\n        )\n\n    # Constraint 5: Vessels must not overlap in both space and time simultaneously.\n    # For any pair of vessels (i, j), they must be separated either in space or in time.\n    for i in vessels:\n        for j in vessels:\n            if i < j:\n                model.addConstr(\n                    location_relation[i, j] + location_relation[j, i] +\n                    time_relation[i, j] + time_relation[j, i] >= 1,\n                    name=f\"no_overlap_{i}_{j}\"\n                )\n\n    # Constraint 6: Vessels cannot be berthed before their expected arrival time\n    for i in vessels:\n        model.addConstr(berth_time[i] >= expected_arrival_time[i], name=f\"arrival_time_{i}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_vessel_berth_allocation()\n    print(result)\n",
    "ground_truth":729.0
  },
  {
    "task_id":"D008",
    "description":"In a city planning scenario, it is necessary to select locations for public transport stations to serve a set of 15 passenger demand points, with 5 potential station locations available. The distance from each demand point to each potential station is known, and a demand point is considered \"\"covered\"\" by a station only if the distance between them is no more than 300 meters. What is the minimum number of stations that need to be selected to ensure all demand points are covered?\nThe distance matrix between each demand point and each potential station is as follows:\n| demand node\\stop | 1    | 2    | 3    | 4    | 5    |\n|-----------|------|------|------|------|------|\n| 1         | 389  | 515  | 170  | 143  | 617  |\n| 2         | 562  | 678  | 265  | 640  | 629  |\n| 3         | 206  | 594  | 180  | 564  | 683  |\n| 4         | 574  | 105  | 311  | 99   | 550  |\n| 5         | 616  | 490  | 99   | 473  | 682  |\n| 6         | 571  | 258  | 494  | 749  | 61   |\n| 7         | 573  | 234  | 207  | 635  | 318  |\n| 8         | 70   | 53   | 399  | 740  | 494  |\n| 9         | 229  | 190  | 550  | 654  | 394  |\n| 10        | 50   | 56   | 459  | 143  | 478  |\n| 11        | 95   | 378  | 507  | 647  | 135  |\n| 12        | 767  | 200  | 569  | 689  | 621  |\n| 13        | 729  | 333  | 91   | 86   | 386  |\n| 14        | 633  | 163  | 562  | 184  | 384  |\n| 15        | 67   | 515  | 224  | 502  | 345  |",
    "formulation":"Set:\n1. DemandNode\nThe set of demand nodes, \\( D = \\{1, 2, \\dots, DemandNodeNum\\} \\)\n2. Stop\nThe set of stops, \\( S = \\{1, 2, \\dots, StopNum\\} \\)\n\nParameter:\n1. DemandNodeNum\n15\n2. StopNum\n5\n3. CoverageDistance\n300\n4. Distance\n[[389, 515, 170, 143, 617], [562, 678, 265, 640, 629], [206, 594, 180, 564, 683], [574, 105, 311, 99, 550], [616, 490, 99, 473, 682], [571, 258, 494, 749, 61], [573, 234, 207, 635, 318], [70, 53, 399, 740, 494], [229, 190, 550, 654, 394], [50, 56, 459, 143,478], [95,378 ,507 ,647 ,135], [767 ,200 ,569 ,689 ,621], [729 ,333 ,91 ,86 ,386], [633 ,163 ,562 ,184 ,384], [67 ,515 ,224 ,502 ,345]]\n\nDecision variable:\n1. SeletStop\nBinary variable, \\( x_{i} \\) for all \\( i \\in S \\), representing whether stop \\( i \\) is selected (1 if selected, 0 otherwise) \n\nObjective:\nThe total stops selected\nmin: \\sum_{i\\in S}x_{i}\n\nConstraint:\n1. DemandNode coverage\n\\sum_{i\\in S}x_{i}Ifcoverage_{ji} \\geq 1, \\forall j \\in D\n# Ifcoverage is a binary matrix determined based on the CoverageDistance and Distance, where Ifcoverage_{ji} = 1 if demand node \\( j \\) is covered by stop \\( i \\), and 0 otherwise.\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_stop_location(\n    distance=[\n        [389, 515, 170, 143, 617], [562, 678, 265, 640, 629],\n        [206, 594, 180, 564, 683], [574, 105, 311, 99, 550],\n        [616, 490, 99, 473, 682], [571, 258, 494, 749, 61],\n        [573, 234, 207, 635, 318], [70, 53, 399, 740, 494],\n        [229, 190, 550, 654, 394], [50, 56, 459, 143, 478],\n        [95, 378, 507, 647, 135], [767, 200, 569, 689, 621],\n        [729, 333, 91, 86, 386], [633, 163, 562, 184, 384],\n        [67, 515, 224, 502, 345]\n    ],\n    coverage_distance=300\n):\n    \"\"\"\n    Models and solves the set covering problem for stop locations.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"StopLocationProblem\")\n\n    # --- 2. Sets and Parameters ---\n    # Derive sets from the dimensions of the input data\n    demand_nodes = range(len(distance))\n    stops = range(len(distance[0]))\n\n    # Create a coverage parameter: a[j, i] = 1 if stop i covers demand node j\n    a = {}\n    for j in demand_nodes:\n        for i in stops:\n            if distance[j][i] <= coverage_distance:\n                a[j, i] = 1\n            else:\n                a[j, i] = 0\n\n    # --- 3. Decision Variables ---\n    # x[i] = 1 if stop i is selected, 0 otherwise\n    x = model.addVars(stops, vtype=GRB.BINARY, name=\"select_stop\")\n\n    # --- 4. Objective Function ---\n    # Minimize the number of stops selected\n    model.setObjective(gp.quicksum(x[i] for i in stops), GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Each demand node must be covered by at least one selected stop\n    for j in demand_nodes:\n        model.addConstr(gp.quicksum(a[j, i] * x[i] for i in stops) >= 1,\n                        name=f\"cover_demand_{j}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        # The objective value for this problem is an integer\n        return {\"status\": \"optimal\", \"obj\": int(model.ObjVal)}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_stop_location()\n    print(result)\n",
    "ground_truth":3.0
  },
  {
    "task_id":"D009",
    "description":"A logistics company needs to construct a logistics transfer center in a certain area. The company has identified 5 candidate locations for the transfer centers, which will need to deliver goods to 10 subordinate outlets. The distance matrix between the 5 candidate locations and the 10 outlets is as follows:\n\n| Candidate Location \\ Outlet | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n|------------------------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|-----------|\n| 1                            | 15       | 22       | 30       | 45       | 50       | 12       | 28       | 35       | 40       | 25        |\n| 2                            | 10       | 18       | 25       | 35       | 40       | 8        | 20       | 28       | 32       | 18        |\n| 3                            | 25       | 30       | 35       | 50       | 55       | 22       | 32       | 40       | 45       | 30        |\n| 4                            | 30       | 35       | 40       | 55       | 60       | 25       | 35       | 45       | 50       | 35        |\n| 5                            | 5        | 12       | 20       | 30       | 35       | 5        | 15       | 22       | 28       | 12        |\n\nIf 2 out of the 5 candidate locations are to be selected to build transfer centers, what is the minimum possible value of the maximum distance from all outlets to their nearest transfer center?",
    "formulation":"Set:\n1. CandidateLocation\nThe set of candidate locations, \\( L = \\{1, 2, \\dots, CandidateLocationNum\\} \\)\n2. Outlet\nThe set of outlets, \\( O = \\{1, 2, \\dots, OutletNum\\} \\)\n\nParameter:\n1. CandidateLocationNum\n5\n2. OutletNum\n10\n3. Distance\n[[15, 22, 30, 45, 50, 12, 28, 35, 40, 25], [10, 18, 25, 35, 40, 8, 20, 28, 32, 18], [25, 30, 35, 50, 55, 22, 32, 40, 45, 30], [30, 35, 40, 55, 60, 25, 35, 45, 50, 35], [5 ,12 ,20 ,30 ,35 ,5 ,15 ,22 ,28 ,12]]\n4. SeletLocationNum\n2\n\nDecision variable:\n1. SeletLocation\nBinary variable, \\( x_{i} \\) for all \\( i \\in L \\), representing whether candidate location \\( i \\) is selected (1 if selected, 0 otherwise)\n2. Auxiliary variable for min-max obj\nInteger variable, \\( z \\) representing the maximum distance from any outlet to its nearest transfer center.\n3. Auxiliary variables to track relationships between outlets and candidate locations\nBinary variable, \\(y_{ij}\\) for all \\( i \\in L, j \\in O \\), representing whether outlet \\( j \\) is served by candidate location \\( i \\) (1 if covered, 0 otherwise).\n\nObjective:\nThe minimum possible value of the maximum distance from any outlets to its nearest transfer center.\nmin: z\n\nConstraint:\n1. Location selection\n\\sum_{i\\in L} x_{i} = SeletLocationNum\n2. Outlet assignment 1\n\\sum_{i\\in L} y_{ij} = 1, \\forall j \\in O\n3. Outlet assignment 2\ny_{ij} \\leq x_{i}, \\forall i \\in L, j \\in O\n4. Max distance\nz \\geq Distance_{ij}*y_{ij}, \\forall i \\in L, j \\in O\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_p_center(\n    distance=[\n        [15, 22, 30, 45, 50, 12, 28, 35, 40, 25],\n        [10, 18, 25, 35, 40, 8, 20, 28, 32, 18],\n        [25, 30, 35, 50, 55, 22, 32, 40, 45, 30],\n        [30, 35, 40, 55, 60, 25, 35, 45, 50, 35],\n        [5, 12, 20, 30, 35, 5, 15, 22, 28, 12]\n    ],\n    select_location_num=2\n):\n    \"\"\"\n    Models and solves the P-Center facility location problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"P-Center-Problem\")\n\n    # --- 2. Sets ---\n    # Derive sets from the dimensions of the input data\n    candidate_locations = range(len(distance))\n    outlets = range(len(distance[0]))\n\n    # --- 3. Decision Variables ---\n    # x[i] = 1 if location i is selected, 0 otherwise\n    x = model.addVars(candidate_locations, vtype=GRB.BINARY, name=\"select_location\")\n\n    # z = auxiliary variable for the min-max objective (maximum distance)\n    z = model.addVar(vtype=GRB.CONTINUOUS, name=\"max_distance\")\n\n    # y[i, j] = 1 if outlet j is assigned to location i, 0 otherwise\n    y = model.addVars(candidate_locations, outlets, vtype=GRB.BINARY, name=\"assign\")\n\n    # --- 4. Objective Function ---\n    # Minimize the maximum distance (z)\n    model.setObjective(z, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Select exactly 'p' (select_location_num) locations\n    model.addConstr(gp.quicksum(x[i] for i in candidate_locations) == select_location_num,\n                    name=\"p_selection\")\n\n    # Constraint 2: Each outlet must be assigned to exactly one location\n    for j in outlets:\n        model.addConstr(gp.quicksum(y[i, j] for i in candidate_locations) == 1,\n                        name=f\"outlet_assignment_{j}\")\n\n    # Constraint 3: An outlet can only be assigned to a selected (opened) location\n    for i in candidate_locations:\n        for j in outlets:\n            model.addConstr(y[i, j] <= x[i], name=f\"valid_assignment_{i}_{j}\")\n\n    # Constraint 4: Define the maximum distance 'z'\n    # If outlet j is assigned to location i (y[i,j]=1), then z must be at least\n    # as large as the distance between them.\n    for i in candidate_locations:\n        for j in outlets:\n            model.addConstr(z >= distance[i][j] * y[i, j],\n                            name=f\"max_distance_link_{i}_{j}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_p_center()\n    print(result)\n",
    "ground_truth":35.0
  },
  {
    "task_id":"D010",
    "description":"A city plans to establish a low-altitude drone delivery network covering a 100×100 area (with both horizontal and vertical coordinates ranging from [0, 100]). There are 8 demand points within this area, with coordinates at (10, 20), (25, 60), (40, 80), (65, 50), (80, 20), (15, 45), (70, 75), and (90, 90). The goal is to select 2 drone logistics hubs at arbitrary locations within the area. What is the minimum possible value of the maximum Euclidean distance from all demand points to their nearest drone logistics hub?",
    "formulation":"Set:\n1. DemandNode\nThe set of demand nodes, \\( D = \\{1, 2, \\dots, DemandNodeNum\\} \\)\n2. Hub\nThe set of drone logistics hubs, \\( H = \\{1, 2, \\dots, HubNum\\} \\)\n\nParameter:\n1. DemandNodeNum\n8\n2. DemandNodeCoordinates\n[[10, 20], [25, 60], [40, 80], [65, 50], [80, 20], [15, 45], [70, 75], [90, 90]]\n3. HubNum\n2\n4. HubCoordinatesRange\n[[0, 100], [0, 100]]\n5. M, a large number\n20000\n\nDecision variable:\n1. HubX\nContinuous variable, \\( x_{i} \\) for all \\( i \\in H \\), representing the x-coordinate of hub \\( i \\)\n2. HubY\nContinuous variable, \\( y_{i} \\) for all \\( i \\in H \\), representing the y-coordinate of hub \\( i \\)\n3. Auxiliary variables to track relationships between demand nodes and hubs\nBinary variable, \\(a_{ij}\\) for all \\( i \\in H, j \\in D \\), representing whether demand node \\( j \\) is served by hub \\( i \\) (1 if covered, 0 otherwise).\n4. Auxiliary variable for min-max obj\nContinuous variable, \\( z \\) representing the maximum distance from any demand node to its nearest hub\n\nObjective:\nThe minimum possible value of the maximum distance from any demand node to its nearest hub.\nmin: z\n\nConstraint:\n1. Hub assignment\n\\sum_{i\\in H} a_{ij} = 1, \\forall j \\in D\n2. Max distance\nHubX_{i}**2 + HubY_{i}**2 \\leq z**2 + M(1 - a_{ij}), \\forall i \\in H, j \\in D\n3. Hub coordinates range\nHubCoordinatesRange[0][0] \\leq HubX_{i} \\leq HubCoordinatesRange[0][1], \\forall i \\in H\nHubCoordinatesRange[1][0] \\leq HubY_{i} \\leq HubCoordinatesRange[1][1], \\forall i \\in H\n\nType:\nMixed, Non-linear, Linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_drone_hub_location(\n    demand_nodes=[(10, 20), (25, 60), (40, 80), (65, 50), (80, 20), (15, 45),\n                  (70, 75), (90, 90)],\n    num_hubs=2,\n    hub_coordinates_range=[[0, 100], [0, 100]],\n    big_m=20000\n):\n    \"\"\"\n    Models and solves the drone hub location problem (a type of P-Center problem\n    in a continuous space).\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"DroneHubLocation\")\n    # This parameter is crucial for Gurobi to solve non-convex quadratic problems\n    model.Params.NonConvex = 2\n\n    # --- 2. Sets and Parameters ---\n    num_demands = len(demand_nodes)\n    hubs = range(num_hubs)\n    demands = range(num_demands)\n    xl, xu = hub_coordinates_range[0]\n    yl, yu = hub_coordinates_range[1]\n\n    # --- 3. Decision Variables ---\n    # hub_x, hub_y: coordinates of the selected hubs\n    hub_x = model.addVars(hubs, lb=xl, ub=xu, name=\"HubX\")\n    hub_y = model.addVars(hubs, lb=yl, ub=yu, name=\"HubY\")\n    # a[i,j]: 1 if demand node j is assigned to hub i, 0 otherwise\n    a = model.addVars(hubs, demands, vtype=GRB.BINARY, name=\"Assignment\")\n    # z: the maximum distance from any demand node to its assigned hub\n    z = model.addVar(vtype=GRB.CONTINUOUS, name=\"MaxDistance\")\n\n    # --- 4. Objective Function ---\n    # Minimize the maximum distance (z)\n    model.setObjective(z, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Each demand node must be assigned to exactly one hub\n    for j in demands:\n        model.addConstr(gp.quicksum(a[i, j] for i in hubs) == 1, f\"Assign_{j}\")\n\n    # Constraint 2: Link the maximum distance 'z' to the hub locations.\n    # This is a non-convex quadratic constraint of the form:\n    # (distance_squared) <= z^2, which only applies if a[i,j] = 1.\n    for i in hubs:\n        for j in demands:\n            x_j, y_j = demand_nodes[j]\n            dx = hub_x[i] - x_j\n            dy = hub_y[i] - y_j\n            model.addConstr(dx * dx + dy * dy <= z * z + big_m * (1 - a[i, j]),\n                            f\"Distance_{i}_{j}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_drone_hub_location()\n    print(result)\n",
    "ground_truth":35.35170935
  },
  {
    "task_id":"D011",
    "description":"A milk supplier needs to deliver milk to all scheduled customers, with the supplier's warehouse location coordinates being (5, 5), and 5 trucks with a capacity of 25 units of milk can be used for delivery. It is known that there are 20 customer points to be delivered to, with coordinates (5.2, 3.8), (8.7, 4.0), (7.9, 8.8), (1.6, 4.1), (8.3, 2.4), (4.5, 3.3), (3.7, 6.2), (8.9, 5.5), (8.4, 0.3), (0.7, 8.9), (0.3, 7.8), (5.5, 5.7), (2.4, 1.8), (3.5, 6.9), (5.4, 7.8), (2.8, 4.0), (4.9, 1.1), (6.8, 4.3), (9.2, 4.3), (0.1, 8.6), and the milk requirements are 6, 2, 7, 3, 4, 8, 7, 7, 1, 4, 1, 3, 5, 1, 2, 2, 6, 8, 2, 7 units respectively. Every truck departs from the warehouse, delivers milk to customers on the planned route, and returns to the warehouse after delivering to all customers. Under the condition of meeting all customer demands, what is the shortest total driving distance for the trucks? (Assuming that the distance between each point is calculated based on the straight-line distance.)",
    "formulation":"Set:\n1. Customer\nThe set of customers, \\( C = \\{1, 2, \\dots, CustomerNum\\} \\)\n2. Node\nThe set of nodes, \\( N = C \\cup \\{0\\} \\)\n# 0 is the warehouse\n3. Truck\nThe set of trucks, \\( K = \\{1, 2, \\dots, TruckNum\\} \\)\n\nParameter:\n1. CustomerNum\n20\n2. NodeCoordinates\n# Coordinates of the warehouse(0) and customers\n[(5, 5), (5.2, 3.8), (8.7, 4.0), (7.9, 8.8), (1.6, 4.1), (8.3, 2.4), (4.5, 3.3), (3.7, 6.2), (8.9, 5.5), (8.4, 0.3), (0.7, 8.9), (0.3, 7.8), (5.5, 5.7), (2.4, 1.8), (3.5, 6.9), (5.4, 7.8), (2.8, 4.0), (4.9, 1.1), (6.8, 4.3), (9.2, 4.3), (0.1, 8.6)]\n3. CustomerDemand\n[6, 2, 7, 3, 4, 8, 7, 7, 1, 4, 1, 3, 5, 1, 2, 2, 6, 8, 2, 7]\n4. TruckNum\n5\n5. TruckCapacity\n25\n\n\nDecision variable:\n1. X\nBinary variable, \\( x_{ijk} \\forall i, j \\in N, i \\neq j \\forall k \\in K\\), where \\( x_{ijk} = 1 \\) if truck \\( k \\) travels from node \\( i \\) to node \\( j \\), otherwise \\( x_{ijk} = 0 \\).\n\nObjective:\nThe minimum total distance of the truck routes.\nmin: \\sum_{k \\in K}\\sum_{i \\in N} \\sum_{j \\in N} Distance[i][j] * x_{ijk}\n# Where \\( Distance[i][j] \\) is the Euclidean distance between node \\( i \\) and node \\( j \\).\n\nConstraint:\n1. Each customer must be visited exactly once.\n\\sum_{i \\in N} x_{ijk} = 1 \\forall j \\in C \\forall k \\in K\n2. Truck leaves customer that it enters.\n\\sum_{j \\in N} x_{ijk} - \\sum_{j \\in N} x_{jik} = 0 \\forall i \\in C \\forall k \\in K\n3. Every truck must leave the warehouse exactly once.\n\\sum_{j \\in N} x_{0jk} = 1 \\forall k \\in K\n4. Capacity constraint for each truck.\n\\sum_{i \\in C}\\sum_{j \\in C} CustomerDemand[i] * x_{ijk} <= TruckCapacity \\forall k \\in K\n5. Eliminate sub-tours.\n\\sum_{i \\in S} \\sum_{j \\in S} x_{ijk} <= |S| - 1 \\forall k \\in K, \\forall S \\subseteq N, 1 < |S| < |N|\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_vehicle_routing(\n    customer_num=20,\n    truck_num=5,\n    truck_capacity=25,\n    node_coordinates = [\n        (5, 5),  # Warehouse (0)\n        (5.2, 3.8),\n        (8.7, 4.0),\n        (7.9, 8.8),\n        (1.6, 4.1),\n        (8.3, 2.4),\n        (4.5, 3.3),\n        (3.7, 6.2),\n        (8.9, 5.5),\n        (8.4, 0.3),\n        (0.7, 8.9),\n        (0.3, 7.8),\n        (5.5, 5.7),\n        (2.4, 1.8),\n        (3.5, 6.9),\n        (5.4, 7.8),\n        (2.8, 4.0),\n        (4.9, 1.1),\n        (6.8, 4.3),\n        (9.2, 4.3),\n        (0.1, 8.6)\n    ],\n    customer_demand = [6, 2, 7, 3, 4, 8, 7, 7, 1, 4, 1, 3, 5, 1, 2, 2, 6, 8, 2, 7],\n    \n):\n    # --- Model Initialization ---\n    model = gp.Model(\"VehicleRoutingProblem\")\n    \n    # --- Define sets ---\n    warehouse = 0  # Warehouse is node 0\n    customers = range(1, customer_num + 1)  # Customers are 1 to 20\n    nodes = [warehouse] + list(customers)  # All nodes including warehouse\n    trucks = range(1, truck_num + 1)  # Trucks are 1 to 5\n\n    # Calculate distances between nodes\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:  # No self-loops\n                x1, y1 = node_coordinates[i]\n                x2, y2 = node_coordinates[j]\n                distance[i, j] = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    # --- Decision Variables ---\n    # x[i,j,k] = 1 if truck k travels from node i to node j, 0 otherwise\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:  # No self-loops\n                for k in trucks:\n                    x[i, j, k] = model.addVar(vtype=GRB.BINARY,\n                                            name=f\"x_{i}_{j}_{k}\")\n                    \n    # --- Objective Function ---\n    # minimize total distance traveled\n    objective = gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes\n                            for j in nodes for k in trucks if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Constraint 1: Each customer must be visited exactly once by exactly one truck\n    for j in customers:\n        model.addConstr(gp.quicksum(x[i, j, k] for i in nodes if i != j\n                                    for k in trucks) == 1,\n                        name=f\"customer_visited_{j}\")\n\n    # Constraint 2: Flow conservation - if a truck enters a customer, it must also leave\n    for i in customers:\n        for k in trucks:\n            model.addConstr(gp.quicksum(x[i, j, k] for j in nodes if j != i) -\n                            gp.quicksum(x[j, i, k] for j in nodes if j != i) == 0,\n                            name=f\"flow_conservation_{i}_{k}\")\n\n    # Constraint 3: Each truck must leave the warehouse exactly once and return to it\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[warehouse, j, k] for j in customers) == 1,\n                        name=f\"truck_{k}_leaves_warehouse\")\n        model.addConstr(gp.quicksum(x[j, warehouse, k] for j in customers) == 1,\n                        name=f\"truck_{k}_returns_warehouse\")\n\n    # Constraint 4: Capacity constraint for each truck\n    for k in trucks:\n        model.addConstr(gp.quicksum(customer_demand[j - 1] *\n                                    gp.quicksum(x[i, j, k]\n                                                for i in nodes if i != j)\n                                    for j in customers) <= truck_capacity,\n                        name=f\"truck_{k}_capacity\")\n\n\n    # Function to find subtours in the current solution\n    def find_subtours(x_vals, k):\n        \"\"\"Find subtours in the current solution for truck k\"\"\"\n        # Create an edge list from the solution\n        edges = [(i, j) for i in customers for j in customers\n                if i != j and x_vals[i, j, k] > 0.5]\n\n        if not edges:\n            return []\n\n        # Create an undirected graph for finding connected components\n        neighbors = {i: [] for i in customers}\n        for i, j in edges:\n            neighbors[i].append(j)\n\n        # Find all connected components (subtours)\n        unvisited = set(customers)\n        subtours = []\n\n        while unvisited:\n            # Start a new tour with an unvisited node\n            curr = next(iter(unvisited))\n            tour = [curr]\n            unvisited.remove(curr)\n\n            # Build the tour\n            while True:\n                neighbors_of_curr = [j for j in neighbors[curr] if j in unvisited]\n                if not neighbors_of_curr:\n                    break\n\n                curr = neighbors_of_curr[0]\n                tour.append(curr)\n                unvisited.remove(curr)\n\n            # Check if it's a subtour (not connected to the warehouse)\n            if any(x_vals[warehouse, i, k] > 0.5\n                for i in tour) and any(x_vals[i, warehouse, k] > 0.5\n                                        for i in tour):\n                # This is a valid tour connected to the warehouse\n                continue\n            elif tour:  # Only add non-empty tours\n                subtours.append(tour)\n\n        return subtours\n\n\n    # Callback function for lazy constraints\n    def subtour_elimination_callback(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get the current solution values\n            x_vals = {}\n            for i in nodes:\n                for j in nodes:\n                    if i != j:\n                        for k in trucks:\n                            if (i, j, k) in x:\n                                x_vals[i, j, k] = model.cbGetSolution(x[i, j, k])\n\n            # For each truck, find subtours and add constraints\n            for k in trucks:\n                subtours = find_subtours(x_vals, k)\n                for subtour in subtours:\n                    if len(subtour) < len(\n                            customers):  # Check if it's a proper subtour\n                        # Add DFJ subtour elimination constraint\n                        model.cbLazy(\n                            gp.quicksum(x[i, j, k] for i in subtour\n                                        for j in subtour\n                                        if i != j) <= len(subtour) - 1)\n\n\n    # Enable lazy constraints and store variables for callback\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # --- Solve the Model ---\n    model.optimize(subtour_elimination_callback)\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_vehicle_routing()\n    print(result)\n",
    "ground_truth":51.7829015493
  },
  {
    "task_id":"D012",
    "description":"A garbage dump needs to dispatch garbage trucks to fixed locations to collect garbage every day. The coordinates of the garbage dump are (0, 0), and it owns 4 garbage trucks, each with a capacity limit of 100 and a maximum driving distance of 45. There are 15 garbage collection points in total, with coordinates (3, -8), (-10, -5), (3, 0), (-3, -3), (5, -1), (-7, 3), (5, -3), (4, -5), (6, 4), (3, 1), (-10, 0), (-2, 7), (-6, -3), (-8, -7), (-1, 8), and garbage amounts of 20, 20, 28, 12, 30, 24, 30, 12, 27, 26, 21, 20, 12, 16, 19, respectively. Every garbage trucks need to start from the garbage dump, collect garbage from all collection points on the planned route, and return to the garbage dump. What is the shortest total driving distance for all garbage trucks? (Assume the distance between points is calculated as the straight-line distance.)",
    "formulation":"Set:\n1. CollectionPoint\nThe set of collection points, \\( CP = \\{1, 2, \\dots, CollectionPointsNum\\} \\)\n2. Node\nThe set of nodes, \\( N = CP \\cup \\{0\\} \\)\n# 0 is the Dump node\n3. Truck\nThe set of trucks, \\( K = \\{1, 2, \\dots, TruckNum\\} \\)\n\nParameter:\n1. CollectionPointsNum\n15\n2. NodesCoordinates\n[(0, 0), (3, -8), (-10, -5), (3, 0), (-3, -3), (5, -1), (-7, 3), (5, -3), (4, -5), (6, 4), (3, 1), (-10, 0), (-2, 7), (-6, -3), (-8, -7), (-1, 8)]\n3. CollectionPointsDemand\n[20, 20, 28, 12, 30, 24, 30, 12, 27, 26, 21, 20, 12, 16, 19]\n4. TruckNum\n4\n5. TruckCapacity\n100\n6. TruckMaxDistance\n45\n\nDecision variable:\n1. X\nBinary variable, \\( x_{ijk} \\forall i, j \\in N, i \\neq j \\forall k \\in K\\), where \\( x_{ijk} = 1 \\) if truck \\( k \\) travels from node \\( i \\) to node \\( j \\), otherwise \\( x_{ijk} = 0 \\).\n\nObjective:\nThe minimum total distance of the truck routes.\nmin: \\sum_{k \\in K}\\sum_{i \\in N} \\sum_{j \\in N} Distance[i][j] * x_{ijk}\n# Where \\( Distance[i][j] \\) is the Euclidean distance between node \\( i \\) and node \\( j \\).\n\nConstraint:\n1. Each collection point must be visited exactly once.\n\\sum_{i \\in N} x_{ijk} = 1 \\forall j \\in CP \\forall k \\in K\n2. Truck leaves collection point that it enters.\n\\sum_{j \\in N} x_{ijk} - \\sum_{j \\in N} x_{jik} = 0 \\forall i \\in CP \\forall k \\in K\n3. Every truck must leave the dump node exactly once.\n\\sum_{j \\in N} x_{0jk} = 1 \\forall k \\in K\n4. Capacity constraint for each truck.\n\\sum_{i \\in CP}\\sum_{j \\in CP} CollectionPointsDemand[i] * x_{ijk} <= TruckCapacity \\forall k \\in K\n5. Distance constraint for each truck.\n\\sum_{i \\in N} \\sum_{j \\in N} Distance[i][j] * x_{ijk} <= TruckMaxDistance \\forall k \\in K\n6. Eliminate sub-tours.\n\\sum_{i \\in S} \\sum_{j \\in S} x_{ijk} <= |S| - 1 \\forall k \\in K, \\forall S \\subseteq N, 1 < |S| < |N|\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\ndef solve_waste_collection_routing(\n    collection_points_num=15,\n    truck_num=4,\n    truck_capacity=100,\n    truck_max_distance=45,\n    nodes_coordinates=[\n        (0, 0), (3, -8), (-10, -5), (3, 0), (-3, -3), (5, -1),\n        (-7, 3), (5, -3), (4, -5), (6, 4), (3, 1), (-10, 0),\n        (-2, 7), (-6, -3), (-8, -7), (-1, 8)\n    ],\n    collection_points_demand=[\n        20, 20, 28, 12, 30, 24, 30, 12, 27, 26, 21, 20, 12, 16, 19\n    ]\n):\n    \"\"\"\n    Solves the vehicle routing problem for waste collection.\n    \"\"\"\n    model = gp.Model(\"WasteCollectionRouting\")\n\n    dump = 0\n    collection_points = range(1, collection_points_num + 1)\n    nodes = [dump] + list(collection_points)\n    trucks = range(1, truck_num + 1)\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                x1, y1 = nodes_coordinates[i]\n                x2, y2 = nodes_coordinates[j]\n                distance[i, j] = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f\"x_{i}_{j}_{k}\")\n\n    objective = gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes for j in nodes for k in trucks if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    for j in collection_points:\n        model.addConstr(gp.quicksum(x[i, j, k] for i in nodes if i != j for k in trucks) == 1, name=f\"visit_point_{j}\")\n\n    for i in collection_points:\n        for k in trucks:\n            model.addConstr(gp.quicksum(x[i, j, k] for j in nodes if j != i) - gp.quicksum(x[j, i, k] for j in nodes if j != i) == 0, name=f\"flow_conservation_{i}_{k}\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[dump, j, k] for j in collection_points) == 1, name=f\"truck_{k}_leaves_dump\")\n        model.addConstr(gp.quicksum(x[j, dump, k] for j in collection_points) == 1, name=f\"truck_{k}_returns_dump\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(collection_points_demand[j - 1] * gp.quicksum(x[i, j, k] for i in nodes if i != j) for j in collection_points) <= truck_capacity, name=f\"truck_{k}_capacity\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes for j in nodes if i != j) <= truck_max_distance, name=f\"truck_{k}_max_distance\")\n\n    def find_subtours(x_vals, k):\n        edges = [(i, j) for i in collection_points for j in collection_points if i != j and x_vals.get((i, j, k), 0) > 0.5]\n        if not edges:\n            return []\n        \n        neighbors = {i: [] for i in collection_points}\n        for i, j in edges:\n            neighbors[i].append(j)\n        \n        unvisited = set(collection_points)\n        subtours = []\n        while unvisited:\n            curr = next(iter(unvisited))\n            tour = [curr]\n            unvisited.remove(curr)\n            \n            while True:\n                neighbors_of_curr = [j for j in neighbors.get(curr, []) if j in unvisited]\n                if not neighbors_of_curr:\n                    break\n                curr = neighbors_of_curr[0]\n                tour.append(curr)\n                unvisited.remove(curr)\n            \n            is_valid_tour = any(x_vals.get((dump, i, k), 0) > 0.5 for i in tour) and any(x_vals.get((i, dump, k), 0) > 0.5 for i in tour)\n            if not is_valid_tour and tour:\n                subtours.append(tour)\n        return subtours\n\n    def subtour_elimination_callback(model, where):\n        if where == GRB.Callback.MIPSOL:\n            x_vals = model.cbGetSolution(x)\n            for k in trucks:\n                subtours = find_subtours(x_vals, k)\n                for subtour in subtours:\n                    if len(subtour) < collection_points_num:\n                        model.cbLazy(gp.quicksum(x[i, j, k] for i in subtour for j in subtour if i != j) <= len(subtour) - 1)\n\n    model.Params.lazyConstraints = 1\n    model.optimize(subtour_elimination_callback)\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_waste_collection_routing()\n    print(result)\n",
    "ground_truth":88.2662665881
  },
  {
    "task_id":"D013",
    "description":"A logistics company needs to deliver packages to multiple booked customer, the logistics center's coordinates are (0, 0), and the company has 5 trucks with a capacity of 15 units of packages available for delivery. It is known that there are 12 customer points that need to be delivered, with coordinates (4.36, -2.75), (-7.29, -3.22), (-8.74, -2.47), (-0.68, -5.15), (-0.39, -3.49), (-6.06, -5.52), (-2.67, 9.32), (9.91, 7.87), (2.03, -2.98), (2.33, -1.47), (5.1, -2.08), (-8.04, -9.78), and the demands are 6, 7, 1, 10, 8, 7, 3, 6, 5, 2, 4, 4 units of packages respectively. Trucks start from the logistics center, complete the delivery on the planned route, and then return to the logistics center. The number of trucks used should be less than or equal to the number of trucks owned by the company. Under the condition of meeting all customer demands, what is the shortest total driving distance for the trucks? (Assuming the distance between each point is calculated based on the straight-line distance.)",
    "formulation":"Set:\n1. Customer\nThe set of customers, \\( C = \\{1, 2, \\dots, CustomerNum\\} \\)\n2. Node\nThe set of nodes, \\( N = C \\cup \\{0\\} \\)\n# 0 is the logistics center\n3. Truck\nThe set of trucks, \\( K = \\{1, 2, \\dots, TruckNum\\} \\)\n\nParameter:\n1. CustomerNum\n12\n2. NodeCoordinates\n# Coordinates of the center(0) and customers\n[(0, 0), (4.36, -2.75), (-7.29, -3.22), (-8.74, -2.47), (-0.68, -5.15), (-0.39, -3.49), (-6.06, -5.52), (-2.67, 9.32), (9.91, 7.87), (2.03, -2.98), (2.33, -1.47), (5.1, -2.08), (-8.04, -9.78)]\n3. CustomerDemand\n[6, 7, 1, 10, 8, 7, 3, 6, 5, 2, 4, 4]\n4. TruckNum\n5\n5. TruckCapacity\n15\n\nDecision variable:\n1. X\nBinary variable, \\( x_{ijk} \\forall i, j \\in N, i \\neq j \\forall k \\in K\\), where \\( x_{ijk} = 1 \\) if truck \\( k \\) travels from node \\( i \\) to node \\( j \\), otherwise \\( x_{ijk} = 0 \\).\n\nObjective:\nThe minimum total distance of the truck routes.\nmin: \\sum_{k \\in K}\\sum_{i \\in N} \\sum_{j \\in N} Distance[i][j] * x_{ijk}\n# Where \\( Distance[i][j] \\) is the Euclidean distance between node \\( i \\) and node \\( j \\).\n\nConstraint:\n1. Each customer must be visited exactly once.\n\\sum_{i \\in N}\\sum_{k \\in K} x_{ijk} = 1 \\forall j \\in C\n2. Truck leaves customer that it enters.\n\\sum_{j \\in N} x_{ijk} - \\sum_{j \\in N} x_{jik} = 0 \\forall i \\in C \\forall k \\in K\n3. Each truck leaves the logistics center less than or equal to once.\n\\sum_{j \\in N} x_{0jk} <= 1 \\forall k \\in K\n4. The truck that leaves the logistics center must return to the logistics center.\n\\sum_{i \\in N} x_{i0k} = \\sum_{j \\in N} x_{0jk} \\forall k \\in K\n4. Capacity constraint for each truck.\n\\sum_{i \\in C}\\sum_{j \\in C} CustomerDemand[i] * x_{ijk} <= TruckCapacity \\forall k \\in K\n5. Eliminate sub-tours.\n\\sum_{i \\in S} \\sum_{j \\in S} x_{ijk} <= |S| - 1 \\forall k \\in K, \\forall S \\subseteq N, 1 < |S| < |N|\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\ndef solve_vehicle_routing(\n    customer_num=12,\n    truck_num=5,\n    truck_capacity=15,\n    node_coordinates=[\n        (0, 0), (4.36, -2.75), (-7.29, -3.22), (-8.74, -2.47),\n        (-0.68, -5.15), (-0.39, -3.49), (-6.06, -5.52),\n        (-2.67, 9.32), (9.91, 7.87), (2.03, -2.98), (2.33, -1.47),\n        (5.1, -2.08), (-8.04, -9.78)\n    ],\n    customer_demand=[6, 7, 1, 10, 8, 7, 3, 6, 5, 2, 4, 4]\n):\n    \"\"\"\n    Solves the vehicle routing problem.\n    \"\"\"\n    model = gp.Model(\"VehicleRoutingProblem\")\n\n    center = 0\n    customers = range(1, customer_num + 1)\n    nodes = [center] + list(customers)\n    trucks = range(1, truck_num + 1)\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                x1, y1 = node_coordinates[i]\n                x2, y2 = node_coordinates[j]\n                distance[i, j] = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f\"x_{i}_{j}_{k}\")\n\n    objective = gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes for j in nodes for k in trucks if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    for j in customers:\n        model.addConstr(gp.quicksum(x[i, j, k] for i in nodes if i != j for k in trucks) == 1, name=f\"customer_visited_{j}\")\n\n    for i in customers:\n        for k in trucks:\n            model.addConstr(gp.quicksum(x[i, j, k] for j in nodes if i != j) - gp.quicksum(x[j, i, k] for j in nodes if i != j) == 0, name=f\"flow_conservation_{i}_{k}\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[center, j, k] for j in customers) <= 1, name=f\"truck_{k}_leaves_center\")\n        model.addConstr(gp.quicksum(x[center, j, k] for j in customers) == gp.quicksum(x[j, center, k] for j in customers), name=f\"truck_{k}_returns_center\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(customer_demand[j - 1] * gp.quicksum(x[i, j, k] for i in nodes if i != j) for j in customers) <= truck_capacity, name=f\"truck_{k}_capacity\")\n\n    def find_subtours(x_vals, k):\n        edges = [(i, j) for i in customers for j in customers if i != j and x_vals.get((i, j, k), 0) > 0.5]\n        if not edges:\n            return []\n        \n        neighbors = {i: [] for i in customers}\n        for i, j in edges:\n            neighbors[i].append(j)\n        \n        unvisited = set(customers)\n        subtours = []\n        while unvisited:\n            curr = next(iter(unvisited))\n            tour = [curr]\n            unvisited.remove(curr)\n            \n            while True:\n                neighbors_of_curr = [j for j in neighbors.get(curr, []) if j in unvisited]\n                if not neighbors_of_curr:\n                    break\n                curr = neighbors_of_curr[0]\n                tour.append(curr)\n                unvisited.remove(curr)\n            \n            is_valid_tour = any(x_vals.get((center, i, k), 0) > 0.5 for i in tour) and any(x_vals.get((i, center, k), 0) > 0.5 for i in tour)\n            if not is_valid_tour and tour:\n                subtours.append(tour)\n        return subtours\n\n    def subtour_elimination_callback(model, where):\n        if where == GRB.Callback.MIPSOL:\n            x_vals = model.cbGetSolution(x)\n            for k in trucks:\n                subtours = find_subtours(x_vals, k)\n                for subtour in subtours:\n                    if len(subtour) < customer_num:\n                        model.cbLazy(gp.quicksum(x[i, j, k] for i in subtour for j in subtour if i != j) <= len(subtour) - 1)\n\n    model.Params.lazyConstraints = 1\n    model.optimize(subtour_elimination_callback)\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_vehicle_routing()\n    print(result)\n\n",
    "ground_truth":104.3352564869
  },
  {
    "task_id":"D014",
    "description":"A logistics company has a batch of goods to transport, and the packaging boxes are neatly arranged with the same side dimensions but different thicknesses and weights. The company has 12 trucks, and each truck has space for placing goods on both sides. The total weight capacity of each truck is 10 tons, and to ensure smooth driving, the weight difference of goods on both sides of the truck should not exceed 500 kg. The total thickness capacity of each truck is 5 meters. There are 100 pieces of goods to be loaded, with thicknesses (cm) of 108, 62, 121, 31, 37, 90, 49, 49, 53, 156, 37, 62, 85, 78, 110, 119, 58, 159, 62, 150, 97, 131, 88, 89, 146, 50, 69, 58, 106, 138, 105, 95, 131, 38, 38, 92, 41, 40, 76, 133, 101, 103, 82, 134, 36, 126, 73, 121, 30, 116, 104, 140, 116, 74, 59, 66, 80, 64, 124, 100, 65, 47, 96, 83, 146, 139, 36, 47, 58, 133, 93, 60, 41, 38, 105, 31, 119, 115, 98, 93, 37, 90, 121, 83, 92, 36, 32, 56, 74, 126, 117, 72, 43, 38, 78, 65, 112, 149, 33, 88, and weights(kg) of 469, 301, 673, 239, 451, 723, 513, 417, 397, 1715, 261, 578, 916, 736, 1024, 634, 346, 1038, 428, 1008, 709, 1396, 876, 694, 737, 398, 656, 356, 1165, 1112, 729, 1070, 1015, 224, 437, 917, 273, 303, 614, 738, 1069, 636, 686, 1035, 188, 1103, 647, 1269, 271, 1234, 631, 1577, 1201, 614, 435, 564, 695, 375, 1541, 693, 413, 270, 482, 979, 1461, 1251, 329, 389, 606, 1491, 445, 493, 357, 403, 706, 196, 1405, 571, 1097, 872, 279, 581, 973, 814, 585, 221, 235, 664, 817, 929, 951, 509, 434, 339, 525, 499, 1250, 1419, 140, 720. What is the minimum number of trucks needed to meet the transportation requirements?",
    "formulation":"Set:\n1. Truck\nThe set of trucks, \\( K = \\{1, 2, \\dots, TruckNum\\} \\)\n2. Goods\nThe set of goods, \\( G = \\{1, 2, \\dots, GoodsNum\\} \\)\n3. TruckSide\nThe set of truck sides, \\( S = \\{0, 1\\} \\)\n\nParameter:\n1. TruckNum\n12\n2. GoodsNum\n100\n3. TruckMaxCapacitySide\n[5250, 4750]\n4. TruckMaxWeightDifference\n500\n5. TruckMaxThickness\n500\n6. GoodsThickness\n[108, 62, 121, 31, 37, 90, 49, 49, 53, 156, 37, 62, 85, 78, 110, 119, 58, 159, 62, 150, 97, 131, 88, 89, 146, 50, 69, 58, 106, 138, 105, 95, 131, 38, 38, 92, 41, 40, 76, 133, 101, 103, 82, 134, 36, 126, 73, 121, 30, 116, 104, 140, 116, 74, 59, 66, 80, 64, 124, 100, 65, 47, 96, 83, 146, 139, 36, 47, 58, 133, 93, 60, 41, 38, 105, 31, 119, 115, 98, 93, 37, 90, 121, 83, 92, 36, 32, 56, 74, 126, 117, 72, 43, 38, 78, 65, 112, 149, 33, 88]\n7. GoodsWeight\n[469, 301, 673, 239, 451, 723, 513, 417, 397, 1715, 261, 578, 916, 736, 1024, 634, 346, 1038, 428, 1008, 709, 1396, 876, 694, 737, 398, 656, 356, 1165, 1112, 729, 1070, 1015, 224, 437, 917, 273, 303, 614, 738, 1069, 636, 686, 1035, 188, 1103, 647, 1269, 271, 1234, 631, 1577, 1201, 614, 435, 564, 695, 375, 1541, 693, 413, 270, 482, 979, 1461, 1251, 329, 389, 606, 1491, 445, 493, 357, 403, 706, 196, 1405, 571, 1097, 872, 279, 581, 973, 814, 585, 221, 235, 664, 817, 929, 951, 509, 434, 339, 525, 499, 1250, 1419, 140, 720]\n\n\nDecision variable:\n1. X\nBinary variable, \\( x_{gks} \\forall g \\in G, k \\in K, s \\in S\\), where \\( x_{gks} = 1 \\) if good \\( g \\) is loaded on truck \\( k \\) on side \\( s \\), otherwise \\( x_{gks} = 0 \\).\n2. Y\nBinary variable, \\( y_{k} \\forall k \\in K\\), where \\( y_{k} = 1 \\) if truck \\( k \\) is used, otherwise \\( y_{k} = 0 \\).\n\nObjective:\nThe minimum number of trucks used.\nmin: \\sum_{k \\in K} y_{k}\n\nConstraint:\n1. Each good must be loaded on one truck side.\n\\sum_{k \\in K} \\sum_{s \\in S} x_{gks} = 1 \\forall g \\in G\n2. Truck capacity side constraint.\n\\sum_{g \\in G} GoodsWeight[g] * x_{gks} <= TruckMaxCapacitySide[s] \\forall k \\in K, s \\in S\n3. Truck side difference constraint.\n0 <= \\sum_{g \\in G} GoodsWeight[g] * x_{gk0} - \\sum_{g \\in G} GoodsWeight[g] * x_{gk1} <= TruckMaxWeightDifference \\forall k \\in K\n4. Truck thickness constraint.\n\\sum_{g \\in G} GoodsThickness[g] * x_{gks} <= TruckMaxThickness \\forall k \\in K, s \\in S\n5. Truck used constraint 1.\n\\sum_{g \\in G}\\sum_{s \\in S} x_{gks} >= y_{k} \\forall k \\in K\n6. Truck used constraint 2.\ny_{k} >= x_{gks} \\forall g \\in G, k \\in K, s \\in S\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_truck_loading(\n    truck_num=12,\n    goods_num=100,\n    truck_max_capacity_side=[5250, 4750],\n    truck_max_weight_difference=500,\n    truck_max_thickness=500,\n    goods_thickness=[\n        108, 62, 121, 31, 37, 90, 49, 49, 53, 156, 37, 62, 85, 78, 110, 119, 58,\n        159, 62, 150, 97, 131, 88, 89, 146, 50, 69, 58, 106, 138, 105, 95, 131, 38,\n        38, 92, 41, 40, 76, 133, 101, 103, 82, 134, 36, 126, 73, 121, 30, 116, 104,\n        140, 116, 74, 59, 66, 80, 64, 124, 100, 65, 47, 96, 83, 146, 139, 36, 47,\n        58, 133, 93, 60, 41, 38, 105, 31, 119, 115, 98, 93, 37, 90, 121, 83, 92,\n        36, 32, 56, 74, 126, 117, 72, 43, 38, 78, 65, 112, 149, 33, 88\n    ],\n    goods_weight=[\n        469, 301, 673, 239, 451, 723, 513, 417, 397, 1715, 261, 578, 916, 736,\n        1024, 634, 346, 1038, 428, 1008, 709, 1396, 876, 694, 737, 398, 656, 356,\n        1165, 1112, 729, 1070, 1015, 224, 437, 917, 273, 303, 614, 738, 1069, 636,\n        686, 1035, 188, 1103, 647, 1269, 271, 1234, 631, 1577, 1201, 614, 435, 564,\n        695, 375, 1541, 693, 413, 270, 482, 979, 1461, 1251, 329, 389, 606, 1491,\n        445, 493, 357, 403, 706, 196, 1405, 571, 1097, 872, 279, 581, 973, 814,\n        585, 221, 235, 664, 817, 929, 951, 509, 434, 339, 525, 499, 1250, 1419,\n        140, 720\n    ]\n):\n    \"\"\"\n    Solves the truck loading problem.\n    \"\"\"\n    model = gp.Model(\"TruckLoadingProblem\")\n\n    trucks = range(1, truck_num + 1)\n    goods = range(1, goods_num + 1)\n    sides = [0, 1]\n\n    x = {}\n    for g in goods:\n        for k in trucks:\n            for s in sides:\n                x[g, k, s] = model.addVar(vtype=GRB.BINARY, name=f\"x_{g}_{k}_{s}\")\n\n    y = {}\n    for k in trucks:\n        y[k] = model.addVar(vtype=GRB.BINARY, name=f\"y_{k}\")\n\n    objective = gp.quicksum(y[k] for k in trucks)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    for g in goods:\n        model.addConstr(gp.quicksum(x[g, k, s] for k in trucks for s in sides) == 1, name=f\"good_{g}_assigned_once\")\n\n    for k in trucks:\n        for s in sides:\n            model.addConstr(gp.quicksum(goods_weight[g - 1] * x[g, k, s] for g in goods) <= truck_max_capacity_side[s], name=f\"truck_{k}_side_{s}_capacity\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(goods_weight[g - 1] * x[g, k, 0] for g in goods) - gp.quicksum(goods_weight[g - 1] * x[g, k, 1] for g in goods) <= truck_max_weight_difference, name=f\"truck_{k}_side_difference_upper\")\n        model.addConstr(gp.quicksum(goods_weight[g - 1] * x[g, k, 0] for g in goods) - gp.quicksum(goods_weight[g - 1] * x[g, k, 1] for g in goods) >= 0, name=f\"truck_{k}_side_difference_lower\")\n\n    for k in trucks:\n        for s in sides:\n            model.addConstr(gp.quicksum(goods_thickness[g - 1] * x[g, k, s] for g in goods) <= truck_max_thickness, name=f\"truck_{k}_side_{s}_thickness\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[g, k, s] for g in goods for s in sides) >= y[k], name=f\"truck_{k}_used_if_loaded_1\")\n\n    for g in goods:\n        for k in trucks:\n            for s in sides:\n                model.addConstr(y[k] >= x[g, k, s], name=f\"truck_{k}_used_if_loaded_2_{g}_{s}\")\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_truck_loading()\n    print(result)\n",
    "ground_truth":9.0
  },
  {
    "task_id":"D015",
    "description":"A certain urban delivery company needs to provide fresh produce delivery services to 10 customer locations distributed across the city and surrounding areas. The company operates two distribution centers, A and B. Distribution center A is located at coordinates (-5, -5) and has 3 refrigerated trucks with a capacity of 20 tons each. Distribution center B is located at coordinates (5, 5) and has 3 refrigerated trucks with a capacity of 18 tons each. The coordinates of the 10 customers are as follows: (-4.53, -5.12), (2.14, 5.85), (-4.88, -8.33), (2.24, 1.63), (3.91, -5.88), (-1.1, 0.25), (7.92, -3.4), (-1.89, -5.0), (0.72, -8.8), (-1.88, -2.89). Their respective fresh produce demands are 2, 2, 9, 1, 4, 4, 10, 6, 4, and 4 tons. The delivery requirements are as follows: 1. Each truck must depart from its assigned distribution center and return to the same distribution center after completing deliveries; 2. Each customer must be visited exactly once. Under these conditions, what is the shortest total travel distance for the trucks? (The distance between two points is calculated as the straight-line distance.)",
    "formulation":"Set:\n1. Customer\nThe set of customers, \\( C = \\{1, 2, \\dots, CustomerNum\\} \\)\n2. DistributionCenter\nThe set of distribution centers, \\( D = \\{CustomerNum + 1, \\dots, CustomerNum + CenterNum\\} \\)\n3. Node\nThe set of nodes, \\( N = C \\cup D \\)\n4. Truck\nThe set of trucks, \\( K = \\bigcup_{d\\in D}K_d \\)\n# Where \\( K_d \\) is the set of trucks at distribution center \\( d \\)\n\nParameter:\n1. CustomerNum\n10\n2. CustomerDemand\n[2, 2, 9, 1, 4, 4, 10, 6, 4, 4]\n3. CustomerCoord\n[(-4.53, -5.12), (2.14, 5.85), (-4.88, -8.33), (2.24, 1.63), (3.91, -5.88), (-1.1, 0.25), (7.92, -3.4), (-1.89, -5.0), (0.72, -8.8), (-1.88, -2.89)]\n2. TruckNum\n[3, 3]\n4. TruckCapacity\n[20, 18]\n4. CenterNum\n2\n5. CenterCoord\n[(-5, -5), (5, 5)]\n\nDecision variable:\n1. X\nBinary variable, \\( x_{ijk} \\forall i \\in N, j \\in N, k \\in K\\), where \\( x_{ijk} = 1 \\) if truck \\( k \\) departs from node \\( i \\) and arrives at node \\( j \\), otherwise \\( x_{ijk} = 0 \\).\n\nObjective:\nThe minimum total distance of the truck routes.\nmin: \\sum_{k \\in K}\\sum_{i \\in N} \\sum_{j \\in N} Distance[i][j] * x_{ijk}\n# Where \\( Distance[i][j] \\) is the Euclidean distance between node \\( i \\) and node \\( j \\).\n\nConstraint:\n1. Each customer must be visited exactly once.\n\\sum_{i \\in N}\\sum_{k \\in K} x_{ijk} = 1 \\forall j \\in C\n2. Truck leaves customer that it enters.\n\\sum_{j \\in N} x_{ijk} - \\sum_{j \\in N} x_{jik} = 0 \\forall i \\in C \\forall k \\in K\n3. Each truck leaves the distribution center exactly once.\n\\sum_{j \\in N} x_{djk} = 1 \\forall k \\in K_d \\forall d \\in D\n4. The truck that leaves the distribution center must return to the distribution center.\n\\sum_{i \\in C} x_{idk} - \\sum_{j \\in C} x_{djk} = 0 \\forall k \\in K_d \\forall d \\in D\n5. Capacity constraint for each truck.\n\\sum_{i \\in C}\\sum_{j \\in N} CustomerDemand[i] * x_{ijk} <= TruckCapacity[d] \\forall k \\in K_d \\forall d \\in D\n6. Eliminate sub-tours.\n\\sum_{i \\in S} \\sum_{j \\in S} x_{ijk} <= |S| - 1 \\forall k \\in K, \\forall S \\subseteq N, 1 < |S| < |N|\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\ndef solve_MultiDepotVRP(\n    customer_num = 10,\n    center_num = 2,\n    customer_demand = [2, 2, 9, 1, 4, 4, 10, 6, 4, 4],\n    truck_num = [3, 3],  # 3 trucks at DC 1, 3 trucks at DC 2\n    truck_capacity = [20, 18],  # Capacity of trucks at DC 1 and DC 2\n    customer_coord = [(-4.53, -5.12), (2.14, 5.85), (-4.88, -8.33), (2.24, 1.63),\n                    (3.91, -5.88), (-1.1, 0.25), (7.92, -3.4), (-1.89, -5.0),\n                    (0.72, -8.8), (-1.88, -2.89)],\n    center_coord = [(-5, -5), (5, 5)]\n):\n    # --- Model Initialization ---\n    model = gp.Model(\"MultiDepotVRP\")\n    \n\n    # Define sets\n    customers = range(1, customer_num + 1)  # Customers are 1 to 10\n    dcs = range(customer_num + 1,\n                customer_num + center_num + 1)  # DCs are 11 and 12\n    nodes = list(customers) + list(dcs)  # All nodes\n\n    # Create trucks for each distribution center\n    all_trucks = []\n    dc_to_trucks = {}\n    for i, dc in enumerate(dcs):\n        dc_trucks = list(range(sum(truck_num[:i]) + 1, sum(truck_num[:i + 1]) + 1))\n        dc_to_trucks[dc] = dc_trucks\n        all_trucks.extend(dc_trucks)\n\n    # Create a list of all coordinates for visualization\n    all_coords = {}\n    for i, coord in enumerate(customer_coord):\n        all_coords[i + 1] = coord  # Customer i+1 has coordinates coord\n    for i, coord in enumerate(center_coord):\n        all_coords[customer_num + i + 1] = coord  # DC i+1 has coordinates coord\n\n    # Calculate distances between nodes\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:  # No self-loops\n                x1, y1 = all_coords[i]\n                x2, y2 = all_coords[j]\n                distance[i, j] = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    # --- Decision variables ---\n    # x[i,j,k] = 1 if truck k travels from node i to node j, 0 otherwise\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:  # No self-loops\n                for k in all_trucks:\n                    x[i, j, k] = model.addVar(vtype=GRB.BINARY,\n                                            name=f\"x_{i}_{j}_{k}\")\n\n    # --- Objective function ---\n    # minimize total distance traveled\n    objective = gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes\n                            for j in nodes for k in all_trucks if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Constraint 1: Each customer must be visited exactly once (by one truck)\n    for j in customers:\n        model.addConstr(gp.quicksum(x[i, j, k] for i in nodes if i != j\n                                    for k in all_trucks) == 1,\n                        name=f\"customer_visited_{j}\")\n\n    # Constraint 2: Flow conservation - a truck that enters a customer must also leave it\n    for i in customers:\n        for k in all_trucks:\n            model.addConstr(gp.quicksum(x[i, j, k] for j in nodes if j != i) -\n                            gp.quicksum(x[j, i, k] for j in nodes if j != i) == 0,\n                            name=f\"flow_conservation_{i}_{k}\")\n\n    # Constraint 3: Each truck leaves its distribution center exactly once\n    for d in dcs:\n        for k in dc_to_trucks[d]:\n            model.addConstr(gp.quicksum(x[d, j, k] for j in nodes if j != d) == 1,\n                            name=f\"truck_{k}_leaves_dc_{d}\")\n\n    # Constraint 4: Each truck returns to its distribution center\n    for d in dcs:\n        for k in dc_to_trucks[d]:\n            model.addConstr(gp.quicksum(x[i, d, k] for i in customers) -\n                            gp.quicksum(x[d, j, k] for j in customers) == 0,\n                            name=f\"truck_{k}_returns_to_dc_{d}\")\n\n    # Constraint 5: Capacity constraint for each truck\n    for d_idx, d in enumerate(dcs):\n        for k in dc_to_trucks[d]:\n            model.addConstr(gp.quicksum(\n                customer_demand[j - 1] * gp.quicksum(x[i, j, k]\n                                                    for i in nodes if i != j)\n                for j in customers) <= truck_capacity[d_idx],\n                            name=f\"truck_{k}_capacity\")\n\n\n    # Function to find subtours in the current solution\n    def find_subtours(x_vals, k):\n        \"\"\"Find subtours in the current solution for truck k\"\"\"\n        # Create an edge list from the solution\n        edges = [(i, j) for i in nodes for j in nodes\n                if i != j and (i, j, k) in x_vals and x_vals[i, j, k] > 0.5]\n\n        if not edges:\n            return []\n\n        # Create an undirected graph for finding connected components\n        neighbors = {i: [] for i in nodes}\n        for i, j in edges:\n            neighbors[i].append(j)\n\n        # Find all connected components (subtours)\n        unvisited = set(customers)  # Only consider customer nodes for subtours\n        subtours = []\n\n        while unvisited:\n            # Start a new tour with an unvisited node\n            if not unvisited:\n                break\n            curr = next(iter(unvisited))\n            tour = [curr]\n            unvisited.remove(curr)\n\n            # Build the tour\n            while neighbors[curr]:\n                neighbors_of_curr = [j for j in neighbors[curr] if j in unvisited]\n                if not neighbors_of_curr:\n                    break\n\n                curr = neighbors_of_curr[0]\n                if curr in unvisited:  # Only add if not already in tour\n                    tour.append(curr)\n                    unvisited.remove(curr)\n\n            # Check if it's a subtour (not connected to any distribution center)\n            is_connected_to_dc = any(d in neighbors[node] for node in tour\n                                    for d in dcs)\n\n            if not is_connected_to_dc and len(tour) > 1:\n                subtours.append(tour)\n\n        return subtours\n\n\n    # Callback function for lazy constraints\n    def subtour_elimination_callback(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get the current solution values\n            x_vals = {}\n            for i in nodes:\n                for j in nodes:\n                    if i != j:\n                        for k in all_trucks:\n                            if (i, j, k) in x:\n                                val = model.cbGetSolution(x[i, j, k])\n                                if val > 0.5:\n                                    x_vals[i, j, k] = val\n\n            # For each truck, find subtours and add constraints\n            for k in all_trucks:\n                subtours = find_subtours(x_vals, k)\n                for subtour in subtours:\n                    if len(subtour\n                        ) >= 2:  # Only add constraints for actual subtours\n                        # Add subtour elimination constraint\n                        model.cbLazy(\n                            gp.quicksum(x[i, j, k] for i in subtour\n                                        for j in subtour\n                                        if i != j) <= len(subtour) - 1)\n\n\n    # Enable lazy constraints\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # Optimize the model with the callback\n    model.optimize(subtour_elimination_callback)\n\n    # Check if the model was solved to optimality\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_MultiDepotVRP()\n    print(result)\n",
    "ground_truth":68.9235439081
  },
  {
    "task_id":"D016",
    "description":"The Health Bureau of a city, in order to strengthen primary healthcare services, has equipped a mobile medical vehicle to regularly provide basic medical check-ups and medicines to various communities in the suburbs. To improve service efficiency, it is necessary to optimize the route of the mobile medical vehicle. The starting point of the medical vehicle is the Central City Hospital, located at coordinates (0, 0). The location information of the 10 communities to be served is as follows:\n\n| COMMUNITY ID | (x, y)      |\n|--------------|-------------|\n| C1           | (3.5, 4.2)  |\n| C2           | (-2.1, 5.6) |\n| C3           | (4.8, -3.2) |\n| C4           | (-3.6, -2.8)|\n| C5           | (5.2, 2.4)  |\n| C6           | (-4.1, 3.7) |\n| C7           | (2.8, -4.5) |\n| C8           | (6.3, -2.1) |\n| C9           | (-5.2, -1.8)|\n| C10          | (3.9, 5.8)  |\n\nWhat is the shortest travel distance for the medical vehicle to start from the Central City Hospital, visit all communities, and return to the Central City Hospital? (Distance is calculated as the straight-line distance.)",
    "formulation":"Set:\n1. Node\nThe set of nodes, \\( N = \\{0, 1, \\dots, CommunityNum\\} \\)\n# where node 0 is the starting point (Central City Hospital) and nodes 1 to n are the communities to be served.\n\nParameter:\n1. CommunityNum\n10\n2. Coordinate\n[(0, 0), (3.5, 4.2), (-2.1, 5.6), (4.8, -3.2), (-3.6, -2.8), (5.2, 2.4), (-4.1, 3.7), (2.8, -4.5), (6.3, -2.1), (-5.2, -1.8), (3.9, 5.8)]\n\nDecision variable:\n1. X\nBinary variable, \\( x_{ij} \\forall i \\in N, j \\in N\\), where \\( x_{ij} = 1 \\) if the vehicle departs from node \\( i \\) and arrives at node \\( j \\), otherwise \\( x_{ij} = 0 \\).\n\nObjective:\n1. Minimize the total distance traveled by the vehicle.\nmin: \\sum_{i \\in N}\\sum_{j \\in N} Distance[i][j] * x_{ij}\n# Where \\( Distance[i][j] \\) is the Euclidean distance between node \\( i \\) and node \\( j \\).\n\nConstraint:\n1. Each community must be visited exactly once.\n\\sum_{i \\in N} x_{ij} = 1 \\forall j \\in N\n2. Each community must be exited exactly once.\n\\sum_{j \\in N} x_{ij} = 1 \\forall i \\in N\n3. Eliminate sub-tours.\n\\sum_{i \\in N} \\sum_{j \\in N} x_{ij} \\leq |S| - 1 \\forall S \\subseteq N, 1 < |S| < |N|\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_tsp(\n    coordinates=[(0, 0), (3.5, 4.2), (-2.1, 5.6), (4.8, -3.2), (-3.6, -2.8),\n                 (5.2, 2.4), (-4.1, 3.7), (2.8, -4.5), (6.3, -2.1),\n                 (-5.2, -1.8), (3.9, 5.8)]):\n    \"\"\"\n    Solves the Traveling Salesperson Problem (TSP) for community health services.\n    \"\"\"\n    community_num = len(coordinates) - 1\n    nodes = range(community_num + 1\n                  )  # 0 is the central hospital, 1-10 are communities\n\n    # Calculate distance matrix\n    def calculate_distance(coord1, coord2):\n        return math.sqrt((coord1[0] - coord2[0])**2 +\n                         (coord1[1] - coord2[1])**2)\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                distance[i,\n                         j] = calculate_distance(coordinates[i], coordinates[j])\n\n    # Create a new model\n    model = gp.Model(\"TSP\")\n\n    # Decision variables: x[i,j] = 1 if the path goes from i to j\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                x[i, j] = model.addVar(vtype=GRB.BINARY, name=f'x_{i}_{j}')\n\n    # Set objective: minimize total distance\n    objective = gp.quicksum(distance[i, j] * x[i, j] for i in nodes\n                            for j in nodes if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # Constraint 1: Each node must be visited exactly once\n    for j in nodes:\n        model.addConstr(gp.quicksum(x[i, j] for i in nodes if i != j) == 1,\n                        name=f'visit_to_{j}')\n\n    # Constraint 2: Must leave each node exactly once\n    for i in nodes:\n        model.addConstr(gp.quicksum(x[i, j] for j in nodes if i != j) == 1,\n                        name=f'leave_from_{i}')\n\n    # Constraint 3: Subtour elimination using subset constraints\n    def find_subtours(edges):\n        # Create adjacency list\n        adj = {i: [] for i in nodes}\n        for i, j in edges:\n            adj[i].append(j)\n\n        # Find all subtours\n        unvisited = set(nodes)\n        subtours = []\n        while unvisited:\n            # Start from any unvisited node\n            current = next(iter(unvisited))\n            subtour = []\n            while current in unvisited:\n                unvisited.remove(current)\n                subtour.append(current)\n                # Move to next node in path\n                next_nodes = adj.get(current, [])\n                if not next_nodes:\n                    break\n                current = next_nodes[0]\n            if len(subtour) < len(nodes):\n                subtours.append(subtour)\n        return subtours\n\n    # Callback function for lazy constraints\n    def subtour_cb(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get values of decision variables\n            x_vals = model.cbGetSolution(model._vars)\n            edges = [(i, j) for i in nodes for j in nodes\n                     if i != j and x_vals[i, j] > 0.5]\n\n            # Find subtours\n            subtours = find_subtours(edges)\n\n            # Add subtour elimination constraints\n            for S in subtours:\n                if len(S) < len(nodes):\n                    model.cbLazy(\n                        gp.quicksum(x[i, j] for i in S for j in S\n                                    if i != j) <= len(S) - 1)\n\n    # Enable lazy constraints\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # Optimize model with callback\n    model.optimize(subtour_cb)\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_tsp()\n    print(result)\n",
    "ground_truth":39.1214741163
  },
  {
    "task_id":"D017",
    "description":"To strengthen grassroots medical services, the Health Bureau of a city has equipped a mobile medical vehicle to regularly provide basic medical check-ups and medicines to various communities in the suburbs. To improve service efficiency, it is necessary to optimize the route of the mobile medical vehicle. The starting point of the medical vehicle is the Central City Hospital, located at coordinates (0, 0). The information for the 10 communities to be served is as follows:\n\n|  COMMUNITY ID |        (x, y)       | TIME WINDOW |\n|---------------|---------------------|-------------|\n| C1            | (-5.87, -3.3)       | [8, 12]     |\n| C2            | (-4.1, 4.6)         | [9, 13]     |\n| C3            | (-2.27, -7.45)      | [10, 15]    |\n| C4            | (4.36, 3.38)        | [11, 15]    |\n| C5            | (9.05, 5.02)        | [9, 16]     |\n| C6            | (-7.46, 6.97)       | [9, 17]     |\n| C7            | (7.75, 7.38)        | [10, 18]    |\n| C8            | (0.06, -4.25)       | [13, 19]    |\n| C9            | (-6.13, -9.78)      | [8, 16]     |\n| C10           | (3.25, 9.86)        | [8, 16]     |\n\nEach community has a time window during which the medical vehicle must arrive. The medical vehicle departs from the Central City Hospital at 8:00 AM and travels at a speed of 15 km\/h. After visiting all communities, the vehicle must return to the Central City Hospital. What is the shortest travel distance? (Distances are calculated as straight-line distances in kilometers.)",
    "formulation":"Set:\n1. Node\nThe set of nodes, \\( N = \\{0, 1, \\dots, CommunityNum\\} \\)\n# where node 0 is the starting point (Central City Hospital) and nodes 1 to n are the communities to be served.\n\nParameter:\n1. CommunityNum\n10\n2. Coordinate\n[(0, 0), (-5.87, -3.3), (-4.1, 4.6), (-2.27, -7.45), (4.36, 3.38), (9.05, 5.02), (-7.46, 6.97), (7.75, 7.38), (0.06, -4.25), (-6.13, -9.78), (3.25, 9.86)]\n3. Timewindow\n[(8, 16), (8, 12), (9, 13), (10, 15), (11, 15), (9, 16), (9, 17), (10, 18), (13, 19), (8, 16), (8, 16)]\n4. StartTime\n8\n5. Speed\n15\n6. M\n10000\n\nDecision variable:\n1. X\nBinary variable, \\( x_{ij} \\forall i \\in N, j \\in N\\), where \\( x_{ij} = 1 \\) if the vehicle departs from node \\( i \\) and arrives at node \\( j \\), otherwise \\( x_{ij} = 0 \\).\n2. T^a\nContinous variable, \\( t^a_i \\forall i \\in N\\), where \\( t^a_i \\) is the time at which the vehicle arrives at node \\( i \\).\n3. T^d\nContinous variable, \\( t^d_i \\forall i \\in N\\), where \\( t^d_i \\) is the time at which the vehicle departs from node \\( i \\).\n\nObjective:\n1. Minimize the total distance traveled by the vehicle.\nmin: \\sum_{i \\in N}\\sum_{j \\in N} Distance[i][j] * x_{ij}\n# Where \\( Distance[i][j] \\) is the Euclidean distance between node \\( i \\) and node \\( j \\).\n\nConstraint:\n1. Each community must be visited exactly once.\n\\sum_{i \\in N} x_{ij} = 1 \\forall j \\in N\n2. Each community must be exited exactly once.\n\\sum_{j \\in N} x_{ij} = 1 \\forall i \\in N\n3. Eliminate sub-tours.\n\\sum_{i \\in N} \\sum_{j \\in N} x_{ij} \\leq |S| - 1 \\forall S \\subseteq N, 1 < |S| < |N|\n4. The vehicle must arrive at each community within its time window.\nt^a_i \\geq Timewindow[i][0] \\forall i \\in N\n5. The vehicle must depart from each community within its time window.\nt^d_i \\leq Timewindow[i][1] \\forall i \\in N\n6. The vehicle's arriveal time at each node must be equal to the departure time from the previous node plus the travel time between the two nodes. \nt^d_i + \\frac{Distance[i][j]}{Speed} - M * (1 - x_{ij}) \\leq t^a_j \\forall i, j \\in N\nt^d_i + \\frac{Distance[i][j]}{Speed} + M * (1 - x_{ij}) \\geq t^a_j \\forall i, j \\in N\n\nType:\nMixed, Linear, Linear\nMILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_time_windowed_tsp(\n    coordinates=[(0, 0), (-5.87, -3.3), (-4.1, 4.6), (-2.27, -7.45),\n                 (4.36, 3.38), (9.05, 5.02), (-7.46, 6.97), (7.75, 7.38),\n                 (0.06, -4.25), (-6.13, -9.78), (3.25, 9.86)],\n    time_windows=[(8, 16), (8, 12), (9, 13), (10, 15), (11, 15), (9, 16),\n                  (9, 17), (10, 18), (13, 19), (8, 16), (8, 16)],\n    speed=15,\n    M=10000,\n    start_time=8):\n    \"\"\"\n    Solves the Traveling Salesperson Problem with Time Windows (TSPTW).\n    \"\"\"\n    community_num = len(coordinates) - 1\n    nodes = range(community_num + 1)  # 0 is hospital, 1-10 are communities\n\n    # Calculate distance matrix\n    def calculate_distance(coord1, coord2):\n        return math.sqrt(\n            (coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                distance[i, j] = calculate_distance(coordinates[i],\n                                                    coordinates[j])\n\n    # --- Model Initialization ---\n    model = gp.Model(\"TimeWindowedTSP\")\n\n    # --- Decision variables ---\n    # x[i,j] = 1 if path goes from i to j\n    x = model.addVars(nodes, nodes, vtype=GRB.BINARY, name='x')\n    for i in nodes:\n        x[i, i].ub = 0\n\n    # t_a[i] = arrival time at node i\n    t_a = model.addVars(nodes,\n                        lb=[tw[0] for tw in time_windows],\n                        ub=[tw[1] for tw in time_windows],\n                        vtype=GRB.CONTINUOUS,\n                        name='t_a')\n\n    # t_d[i] = departure time from node i\n    t_d = model.addVars(nodes,\n                        lb=[tw[0] for tw in time_windows],\n                        ub=[tw[1] for tw in time_windows],\n                        vtype=GRB.CONTINUOUS,\n                        name='t_d')\n\n    # Hospital departure time is fixed\n    t_d[0].lb = start_time\n    t_d[0].ub = start_time\n\n    # --- Objective Function ---\n    # minimize total distance\n    objective = gp.quicksum(distance[i, j] * x[i, j] for i in nodes\n                            for j in nodes if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Constraint 1: Each node must be visited exactly once\n    model.addConstrs((gp.quicksum(x[i, j] for i in nodes if i != j) == 1\n                      for j in nodes if j != 0),\n                     name='visit_to')\n\n    # Constraint 2: Must leave each node exactly once\n    model.addConstrs((gp.quicksum(x[i, j] for j in nodes if i != j) == 1\n                      for i in nodes if i != 0),\n                     name='leave_from')\n\n    # Hospital constraints: must leave once and return once\n    model.addConstr(gp.quicksum(x[0, j] for j in nodes if j != 0) == 1,\n                    name='leave_hospital')\n    model.addConstr(gp.quicksum(x[i, 0] for i in nodes if i != 0) == 1,\n                    name='return_hospital')\n\n    # Time window constraints\n    for i in nodes[1:]:  # Skip hospital\n        # Departure time must be after arrival time\n        model.addConstr(t_d[i] >= t_a[i], name=f'depart_after_arrival_{i}')\n\n    # Time consistency constraints\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                # If we go from i to j, arrival time at j must be after departure from i plus travel time\n                model.addConstr(\n                    t_d[i] + distance[i, j] \/ speed - M * (1 - x[i, j]) <=\n                    t_a[j], f'time_consistency_min_{i}_{j}')\n                model.addConstr(\n                    t_d[i] + distance[i, j] \/ speed + M * (1 - x[i, j]) >=\n                    t_a[j], f'time_consistency_max_{i}_{j}')\n\n    def find_subtours(edges):\n        # Create adjacency list\n        adj = {i: [] for i in nodes}\n        for i, j in edges:\n            adj[i].append(j)\n\n        # Find all subtours\n        unvisited = set(nodes)\n        subtours = []\n        while unvisited:\n            current = next(iter(unvisited))\n            subtour = []\n            while current in unvisited:\n                unvisited.remove(current)\n                subtour.append(current)\n                next_nodes = adj.get(current, [])\n                if not next_nodes:\n                    break\n                current = next_nodes[0]\n            if len(subtour) < len(nodes):\n                subtours.append(subtour)\n        return subtours\n\n    def subtour_cb(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get values of binary variables\n            x_vals = model.cbGetSolution(model._vars)\n            edges = [(i, j) for i, j in x_vals.keys() if x_vals[i, j] > 0.5]\n\n            # Find subtours\n            subtours = find_subtours(edges)\n\n            # Add subtour elimination constraints\n            for S in subtours:\n                if len(S) < len(nodes):\n                    model.cbLazy(\n                        gp.quicksum(x[i, j] for i in S for j in S\n                                    if i != j) <= len(S) - 1)\n\n    # Enable lazy constraints\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # Optimize model with callback\n    model.optimize(subtour_cb)\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_time_windowed_tsp()\n    print(result)\n",
    "ground_truth":70.6552168606
  },
  {
    "task_id":"D018",
    "description":"A fresh food e-commerce platform has one distribution center in the city and needs to use a fleet of refrigerated trucks to deliver fresh products to 12 supermarkets. Each supermarket has a specified time window for receiving goods and a specified unloading time. The distribution center has 5 identical refrigerated trucks, each with a maximum load of 3 tons and a speed of 40 km\/h. The coordinates of the distribution center are (0, 0), and the information of the supermarkets is as follows:\n\n| SUPERMARKET ID | (x,y) | DEMAND(kg) | TIME WINDOW | UNLOADING TIME(min) |\n|---------|-----------|------------|--------------|--------------|\n| S1      | (-5, 4)   | 800        | [7:00-9:00]  | 20           |\n| S2      | (3, 6)    | 600        | [8:00-10:00] | 15           |\n| S3      | (-2, -3)  | 900        | [7:30-9:30]  | 25           |\n| S4      | (4, -2)   | 700        | [8:30-10:30] | 20           |\n| S5      | (-4, -5)  | 500        | [9:00-11:00] | 15           |\n| S6      | (6, 3)    | 850        | [7:00-9:00]  | 25           |\n| S7      | (-3, 5)   | 750        | [8:00-10:00] | 20           |\n| S8      | (5, -4)   | 600        | [9:30-11:30] | 15           |\n| S9      | (-6, -2)  | 450        | [8:00-10:00] | 15           |\n| S10     | (2, 7)    | 800        | [7:30-9:30]  | 20           |\n| S11     | (-1, -6)  | 550        | [9:00-11:00] | 15           |\n| S12     | (4, 5)    | 700        | [8:30-10:30] | 20           |\n\nThe 5 refrigerated trucks leave the distribution center after 6:30 AM to deliver fresh products to the designated supermarkets and must return to the distribution center before 12:00 PM. What is the shortest total travel distance for the refrigerated trucks? (Distances are calculated as straight-line distances in kilometers.)",
    "formulation":"Set:\n1. Node\nThe set of nodes, \\( N = \\{0, 1, \\dots, SupermarketNum\\} \\)\n# where node 0 is the starting point (Distribution Center) and nodes 1 to n are the supermarkets to be served.\n2. Trucks\nThe set of trucks, \\( K = \\{1, 2, \\dots, TruckNum\\} \\)\n\nParameter:\n1. SupermarketNum\n12\n2. Coordinate\n[(0, 0), (-5, 4), (3, 6), (-2, -3), (4, -2), (-4, -5), (6, 3), (-3, 5), (5, -4), (-6, -2), (2, 7), (-1, -6), (4, 5)]\n3. Demand\n[0, 800, 600, 900, 700, 500, 850, 750, 600, 450, 800, 550, 700]\n4. Timewindow\n[(6.5, 12), (7, 9), (8, 10), (7.5, 9.5), (8.5, 10.5), (9, 11), (7, 9), (8, 10), (9.5, 11.5), (8, 10), (7.5, 9.5), (9, 11), (8.5, 10.5)]\n5. UnloadingTime\n[0, 20, 15, 25, 20, 15, 25, 20, 15, 15, 20, 15, 20]\n6. TruckNum\n5\n7. Speed\n40\n8. M\n50000\n\nDecision variable:\n1. X\nBinary variable, \\( x_{ijk} \\forall i \\in N, j \\in N, k \\in K\\), where \\( x_{ijk} = 1 \\) if truck \\( k \\) departs from node \\( i \\) and arrives at node \\( j \\), otherwise \\( x_{ijk} = 0 \\).\n2. T^a\nContinous variable, \\( t^a_i \\forall i \\in N\\), where \\( t^a_i \\) is the time at which the truck arrives at node \\( i \\).\n3. T^d\nContinous variable, \\( t^d_i \\forall i \\in N\\), where \\( t^d_i \\) is the time at which the truck departs from node \\( i \\).\n\nObjective:\n1. Minimize the total distance traveled by the trucks.\nmin: \\sum_{k \\in K}\\sum_{i \\in N} \\sum_{j \\in N} Distance[i][j] * x_{ijk}\n# Where \\( Distance[i][j] \\) is the Euclidean distance between node \\( i \\) and node \\( j \\).\n\nConstraint:\n1. Each supermarket must be visited exactly once by one truck.\n\\sum_{k \\in K} \\sum_{i \\in N} x_{ijk} = 1 \\forall j \\in N\/{0}\n2. Each supermarket must be exited exactly once by one truck.\n\\sum_{k \\in K} \\sum_{j \\in N} x_{ijk} = 1 \\forall i \\in N\/{0}\n3. Each truck must leave the distribution center once.\n\\sum_{j \\in N} x_{0jk} = 1 \\forall k \\in K\n4. Each truck must return to the distribution center once.\n\\sum_{i \\in N} x_{i0k} = 1 \\forall k \\in K\n5. Eliminate sub-tours.\n\\sum_{i \\in N} \\sum_{j \\in N} x_{ijk} \\leq |S| - 1 \\forall S \\subseteq N, 1 < |S| < |N|, k \\in K\n6. The truck must arrive at each supermarket within its time window.\nt^a_i \\geq Timewindow[i][0] \\forall i \\in N\/{0}\n7. The truck must depart from each supermarket within its time window.\nt^d_i \\leq Timewindow[i][1] \\forall i \\in N\/{0}\n8. The truck's arrival time at each node must be more than or equal to the departure time from the previous node plus the travel time between the two nodes.\nt^d_i + \\frac{Distance[i][j]}{Speed} - M * (1 - x_{ijk}) \\leq t^a_j \\forall i, j \\in N, k \\in K\nt^d_i + \\frac{Distance[i][j]}{Speed} + M * (1 - x_{ijk}) \\geq t^a_j \\forall i, j \\in N, k \\in K\n\nType:\nMixed, Linear, Linear\nMILP\n",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_vrptw(\n    coordinates=[(0, 0), (-5, 4), (3, 6), (-2, -3), (4, -2), (-4, -5), (6, 3),\n                 (-3, 5), (5, -4), (-6, -2), (2, 7), (-1, -6), (4, 5)],\n    time_windows=[(6.5, 12), (7, 9), (8, 10), (7.5, 9.5), (8.5, 10.5),\n                  (9, 11), (7, 9), (8, 10), (9.5, 11.5), (8, 10), (7.5, 9.5),\n                  (9, 11), (8.5, 10.5)],\n    demands=[0, 800, 600, 900, 700, 500, 850, 750, 600, 450, 800, 550, 700],\n    unloading_times=[0, 20, 15, 25, 20, 15, 25, 20, 15, 15, 20, 15, 20],\n    truck_num=5,\n    speed=40,\n    M=50000):\n    \"\"\"\n    Solves the Vehicle Routing Problem with Time Windows (VRPTW).\n    \"\"\"\n    supermarket_num = len(coordinates) - 1\n    nodes = range(supermarket_num + 1)  # 0 is DC, 1-12 are supermarkets\n    trucks = range(truck_num)  # 0-4 are trucks\n\n    # Calculate distance matrix\n    def calculate_distance(coord1, coord2):\n        return math.sqrt((coord1[0] - coord2[0])**2 +\n                         (coord1[1] - coord2[1])**2)\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                distance[i, j] = calculate_distance(coordinates[i],\n                                                    coordinates[j])\n\n    # --- Model Initialization ---\n    model = gp.Model(\"MultiVehicleTimeWindowedVRP\")\n\n    # --- Decision variables ---\n    # x[i,j,k] = 1 if truck k travels from i to j\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    x[i, j, k] = model.addVar(vtype=GRB.BINARY,\n                                              name=f'x_{i}_{j}_{k}')\n\n    # t_a[i] = arrival time at node i\n    t_a = model.addVars(nodes,\n                        lb=[time_windows[i][0] for i in nodes],\n                        ub=[time_windows[i][1] for i in nodes],\n                        name='t_a')\n\n    # t_d[i] = departure time from node i\n    t_d = model.addVars(nodes,\n                        lb=[time_windows[i][0] for i in nodes],\n                        ub=[time_windows[i][1] for i in nodes],\n                        name='t_d')\n\n    # --- Objective function ---\n    # Set objective: minimize total distance\n    objective = gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes\n                            for j in nodes for k in trucks if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Constraint 1: Each supermarket must be visited exactly once by one truck\n    for j in nodes:\n        if j != 0:  # Skip DC\n            model.addConstr(\n                gp.quicksum(x[i, j, k] for i in nodes for k in trucks\n                            if i != j) == 1,\n                name=f'visit_to_{j}')\n\n    # Constraint 2: Each supermarket must be exited exactly once by one truck\n    for i in nodes:\n        if i != 0:  # Skip DC\n            model.addConstr(\n                gp.quicksum(x[i, j, k] for j in nodes for k in trucks\n                            if i != j) == 1,\n                name=f'leave_from_{i}')\n\n    # Constraint 3: Each truck must leave the DC once\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[0, j, k] for j in nodes if j != 0) == 1,\n                        name=f'truck_{k}_leaves_dc')\n\n    # Constraint 4: Each truck must return to the DC once\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[i, 0, k] for i in nodes if i != 0) == 1,\n                        name=f'truck_{k}_returns_dc')\n\n    # Flow conservation for each truck at each supermarket\n    for k in trucks:\n        for h in nodes:\n            if h != 0:  # Skip DC\n                model.addConstr(\n                    gp.quicksum(x[i, h, k] for i in nodes if i != h) ==\n                    gp.quicksum(x[h, j, k] for j in nodes if j != h),\n                    name=f'flow_cons_truck_{k}_node_{h}')\n\n    # Time window constraints\n    for i in nodes[1:]:  # Skip DC\n        # Departure time must be after arrival time plus unloading time\n        model.addConstr(t_d[i] >= t_a[i] + unloading_times[i] \/ 60,\n                        name=f'depart_after_unload_{i}')\n\n    # Time consistency constraints\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    # If truck k goes from i to j, arrival time at j must be after\n                    # departure from i plus travel time\n                    model.addConstr(\n                        t_d[i] + distance[i, j] \/ speed - M *\n                        (1 - x[i, j, k]) <= t_a[j],\n                        name=f'time_cons_min_{i}_{j}_{k}')\n                    model.addConstr(\n                        t_d[i] + distance[i, j] \/ speed + M *\n                        (1 - x[i, j, k]) >= t_a[j],\n                        name=f'time_cons_max_{i}_{j}_{k}')\n\n    def find_subtours(edges):\n        # Create adjacency list\n        adj = {i: [] for i in nodes}\n        for i, j in edges:\n            adj[i].append(j)\n\n        # Find all subtours\n        unvisited = set(nodes)\n        subtours = []\n        while unvisited:\n            current = next(iter(unvisited))\n            subtour = []\n            while current in unvisited:\n                unvisited.remove(current)\n                subtour.append(current)\n                next_nodes = adj.get(current, [])\n                if not next_nodes:\n                    break\n                current = next_nodes[0]\n            if len(subtour) < len(nodes):\n                subtours.append(subtour)\n        return subtours\n\n    def subtour_cb(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get values of binary variables\n            x_vals = model.cbGetSolution(model._vars)\n            edges = [(i, j, k) for i in nodes for j in nodes for k in trucks\n                     if i != j and x_vals[i, j, k] > 0.5]\n\n            # Find subtours for each truck\n            for k in trucks:\n                truck_edges = [(i, j) for i, j, k_idx in edges if k_idx == k]\n                subtours = find_subtours(truck_edges)\n\n                # Add subtour elimination constraints\n                for S in subtours:\n                    if len(S) < len(nodes) and 0 not in S:\n                        model.cbLazy(\n                            gp.quicksum(x[i, j, k] for i in S for j in S\n                                        if i != j) <= len(S) - 1)\n\n    # Enable lazy constraints\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # Optimize model with callback\n    model.optimize(subtour_cb)\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_vrptw()\n    print(result)\n",
    "ground_truth":78.7839681501
  },
  {
    "task_id":"D019",
    "description":"A delivery company has a fleet of vehicles at a certain location, consisting of 3 trucks. Each truck has a load limit of 1 ton (i.e., 1000 kg) and a speed of 30 km\/h. The delivery fleet needs to provide pickup and delivery services for a group of customers. Each order has independent time windows for the pickup point and the delivery point. Below are the detailed customer order details:\n\n| Order ID | Pickup Point (x, y) | Pickup Time Window | Delivery Point (x, y) | Delivery Time Window | Delivery Weight (kg) |\n|----------|---------------------|---------------|---------------------|---------------|-------------------|\n| 1        | (1.41, 2.64)        | [9:30, 10:00] | (8.56, 1.11)        | [9:40, 10:40] | 198               |\n| 2        | (6.34, -4.45)       | [12:00, 12:30]| (3.63, -7.65)       | [12:10, 13:10]| 252               |\n| 3        | (3.04, 7.82)        | [10:30, 11:00]| (-8.88, 9.6)        | [10:50, 11:50]| 94                |\n| 4        | (8.18, -6.27)       | [12:00, 12:30]| (-4.31, -5.73)      | [12:20, 12:20]| 223               |\n| 5        | (3.03, 2.34)        | [12:30, 13:00]| (7.93, 5.0)         | [12:40, 13:40]| 163               |\n| 6        | (0.07, 9.32)        | [8:30, 9: 00] | (-7.54, -3.57)      | [9:00, 10:00] | 247               |\n| 7        | (0.57, -1.09)       | [8:00, 8:30]  | (-5.15, -4.55)      | [8:10, 9:10]  | 133               |\n| 8        | (8.87, 2.71)        | [14:00, 14:30]| (-9.87, 0.49)       | [14:30, 15:30]| 188               |\n| 9        | (-3.97, -3.81)      | [10:00, 10:30]| (-3.91, -2.12)      | [10:00, 11:00]| 216               |\n| 10       | (-0.08, -8.95)      | [9:30, 10:00] | (-6.29, -7.8)       | [9:40, 10:40] | 225               |\n\nThe delivery fleet departs from the depot at coordinates (0, 0), serves all orders, and then returns to the depot. How should the routes be planned to minimize the total distance traveled by the trucks? (Distances are calculated as straight-line distances.)",
    "formulation":"Set:\n1. Node_o\nThe set of pickup nodes, \\( N_o = \\{1, \\dots, OrderNum\\} \\)\n2. Node_d\nThe set of delivery nodes, \\( N_d = \\{OrderNum+1, \\dots, OrderNum*2\\} \\)\n3. Node\nThe set of nodes, \\( N = \\{0\\} \\cup N_o \\cup N_d \\)\n2. Trucks\nThe set of trucks, \\( K = \\{1, 2, \\dots, TruckNum\\} \\)\n\nParameter:\n1. OrderNum\n10\n2. Coordinate\n[(0, 0), (1.41, 2.64), (6.34, -4.45), (3.04, 7.82), (8.18, -6.27), (3.03, 2.34), (0.07, 9.32), (0.57, -1.09), (8.87, 2.71), (-3.97, -3.81), (-0.08, -8.95), (8.56, 1.11), (3.63, -7.65), (-8.88, 9.6), (-4.31, -5.73), (7.93, 5.0), (-7.54, -3.57), (-5.15, -4.55), (-9.87, 0.49), (-3.91, -2.12), (-6.29, -7.8)]\n3. Demand\n[0, 198, 252, 94, 223, 163, 247, 133, 188, 216, 225, -198, -252, -94, -223, -163, -247, -133, -188, -216, -225]\n4. Timewindow\n[(0, 1440), (570, 600), (720, 750), (630, 660), (720, 750), (750, 780), (510, 540), (480, 510), (840, 870), (600, 630), (570, 600), (580, 640), (730, 760), (650, 680), (720, 750), (780, 810), (540, 570), (490, 520), (870, 900), (630, 660), (580, 610)]\n7. TruckNum\n3\n8. Speed\n30\n9. Maxload\n1000\n10. M\n1e5\n\nDecision variable:\n1. X\nBinary variable, \\( x_{ijk} \\forall i \\in N, j \\in N, k \\in K\\), where \\( x_{ijk} = 1 \\) if truck \\( k \\) departs from node \\( i \\) and arrives at node \\( j \\), otherwise \\( x_{ijk} = 0 \\).\n2. T^a\nInteger variable, \\( t^a_{i} \\forall i \\in N\\), where \\( t^a_{i} \\) is the time at which the truck arrives at node \\( i \\).\n3. T^d\nInteger variable, \\( t^d_{i} \\forall i \\in N\\), where \\( t^d_{i} \\) is the time at which the truck departs from node \\( i \\).\n4. Load\nInteger variable, \\(Load_{ik} \\forall i \\in N, k \\in K\\), where \\( Load_{ik} \\) is the load of truck \\( k \\) departs node \\( i \\).\n\nObjective:\n1. Minimize the total distance traveled by the trucks.\nmin: \\sum_{k \\in K}\\sum_{i \\in N} \\sum_{j \\in N} Distance[i][j] * x_{ijk}\n# Where \\( Distance[i][j] \\) is the Euclidean distance between node \\( i \\) and node \\( j \\).\n\nConstraint:\n1. Each pickup&delivery point must be visited exactly once by one truck.\n\\sum_{k \\in K} \\sum_{i \\in N} x_{ijk} = 1 \\forall j \\in N\/{0}\n2. One order's pickup point and delivery point must be visited by the same truck.\n\\sum_{j \\in N} x_{ijk} = \\sum_{j \\in N} x_{i+OrderNum,j,k} \\forall i \\in N_o, k \\in K\n3. Flow conservation for each point.\n\\sum_{j \\in N} x_{ijk} = \\sum_{j \\in N} x_{j,i,k} \\forall i \\in N, k \\in K\n4. Each truck must leave the distribution center once.\n\\sum_{j \\in N} x_{0jk} = 1 \\forall k \\in K\n5. The order's pickup point must be visited before its delivery point.\nt^a_{i} \\leq t^d_{i+OrderNum} \\forall i \\in N_o\n6. The truck must arrive at each pickup&delivery point within its time window.\nt^a_{i} \\geq Timewindow[i][0] \\forall i \\in N\nt^a_{i} \\leq Timewindow[i][1] \\forall i \\in N\n7. The truck must leave each pickup&delivery point within its time window.\nt^d_{i} \\leq Timewindow[i][1] \\forall i \\in N\nt^d_{i} \\geq Timewindow[i][0] \\forall i \\in N\n8. The truck's arrival time at each node must be more than or equal to the departure time from the previous node plus the travel time between the two nodes.\nt^d_{i} + 60*\\frac{Distance[i][j]}{Speed} - M * (1 - x_{ijk}) \\leq t^a_{j} \\forall i, j \\in N, k \\in K\n9. The truck's load must not exceed its maximum load at every visited point.\nLoad_{ik} \\leq Maxload \\forall i \\in N, k \\in K\n10. The truck's load must be updated at every visited point.\nLoad_{jk} \\geq Load_{ik} + Demand[j] - M * (1 - x_{ijk}) \\forall i, j \\in N, k \\in K\nLoad_{jk} \\leq Load_{ik} + Demand[j] + M * (1 - x_{ijk}) \\forall i, j \\in N, k \\in K\n11. The truck's load must be initialized at the distribution center.\nLoad_{0k} = 0 \\forall k \\in K\n12. Eliminate sub-tours.\n\\sum_{i \\in N} \\sum_{j \\in N} x_{ijk} \\leq |S| - 1 \\forall S \\subseteq N, 1 < |S| < |N|, k \\in K\n\nType:\nInteger, Linear, Linear\nILP\n",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_PickupDeliveryVRP(\n    order_num=10,\n    truck_num=3,\n    speed=30,\n    maxload=1000,\n    M=1e5,\n    coordinates = [(0, 0), (1.41, 2.64), (6.34, -4.45), (3.04, 7.82),\n                (8.18, -6.27), (3.03, 2.34), (0.07, 9.32), (0.57, -1.09),\n                (8.87, 2.71), (-3.97, -3.81), (-0.08, -8.95), (8.56, 1.11),\n                (3.63, -7.65), (-8.88, 9.6), (-4.31, -5.73), (7.93, 5.0),\n                (-7.54, -3.57), (-5.15, -4.55), (-9.87, 0.49), (-3.91, -2.12),\n                (-6.29, -7.8)],\n    demands = [\n        0, 198, 252, 94, 223, 163, 247, 133, 188, 216, 225, -198, -252, -94, -223,\n        -163, -247, -133, -188, -216, -225\n    ],\n    time_windows = [(0, 1440), (570, 600), (720, 750), (630, 660), (720, 750),\n                    (750, 780), (510, 540), (480, 510), (840, 870), (600, 630),\n                    (570, 600), (580, 640), (730, 760), (650, 680), (720, 750),\n                    (780, 810), (540, 570), (490, 520), (870, 900), (630, 660),\n                    (580, 610)]\n):\n    # --- Model Initialization ---\n    model = gp.Model(\"PickupDeliveryVRP\")\n\n    # Define sets\n    nodes = range(order_num * 2 + 1)  # 0 is depot, 1-10 are pickup, 11-20 are delivery\n    pickup_nodes = range(1, order_num + 1)\n    trucks = range(truck_num)\n\n    # Calculate distance matrix\n    def calculate_distance(coord1, coord2):\n        return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)\n\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                distance[i, j] = calculate_distance(coordinates[i], coordinates[j])\n\n    # --- Decision variables ---\n    # x[i,j,k] = 1 if truck k travels from i to j\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    x[i, j, k] = model.addVar(vtype=GRB.BINARY,\n                                            name=f'x_{i}_{j}_{k}')\n\n    # t_a[i] = arrival time at node i\n    t_a = {}\n    for i in nodes:\n        t_a[i] = model.addVar(lb=time_windows[i][0],\n                            ub=time_windows[i][1],\n                            name=f't_a_{i}')\n\n    # t_d[i] = departure time from node i\n    t_d = {}\n    for i in nodes:\n        t_d[i] = model.addVar(lb=time_windows[i][0],\n                            ub=time_windows[i][1],\n                            name=f't_d_{i}')\n\n    # load[i,k] = load of truck k when departing from node i\n    load = {}\n    for i in nodes:\n        for k in trucks:\n            load[i, k] = model.addVar(lb=0, ub=maxload, name=f'load_{i}_{k}')\n\n    # --- Objective function ---\n    # minimize total distance\n    objective = gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes\n                            for j in nodes for k in trucks if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Constraint 1: Each pickup & delivery point must be visited exactly once by one truck\n    for j in nodes:\n        if j != 0:  # Skip depot\n            model.addConstr(gp.quicksum(x[i, j, k] for i in nodes for k in trucks\n                                        if i != j) == 1,\n                            name=f'visit_to_{j}')\n\n    # Constraint 2: One order's pickup and delivery points must be visited by the same truck\n    for i in pickup_nodes:\n        for k in trucks:\n            model.addConstr(gp.quicksum(x[i, j, k] for j in nodes\n                                        if j != i) == gp.quicksum(\n                                            x[i + order_num, j, k] for j in nodes\n                                            if j != i + order_num),\n                            name=f'same_truck_{i}_{k}')\n\n    # Constraint 3: Flow conservation for each point\n    for i in nodes:\n        for k in trucks:\n            model.addConstr(gp.quicksum(x[i, j, k] for j in nodes\n                                        if j != i) == gp.quicksum(x[j, i, k]\n                                                                for j in nodes\n                                                                if j != i),\n                            name=f'flow_cons_{i}_{k}')\n\n    # Constraint 4: Each truck must leave the depot once\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[0, j, k] for j in nodes if j != 0) == 1,\n                        name=f'truck_{k}_leaves_depot')\n\n    # Constraint 5: The order's pickup point must be visited before its delivery point\n    for i in pickup_nodes:\n        model.addConstr(t_a[i] <= t_d[i + order_num],\n                        name=f'pickup_before_delivery_{i}')\n\n    # Constraints 6 & 7: Time window constraints (already handled by variable bounds)\n\n    # Constraint 8: Time consistency constraints\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    # If truck k goes from i to j, arrival time at j must be after departure from i plus travel time\n                    model.addConstr(t_d[i] + 60 * distance[i, j] \/ speed - M *\n                                    (1 - x[i, j, k]) <= t_a[j],\n                                    name=f'time_cons_{i}_{j}_{k}')\n\n    # Constraint 9: The truck's load must not exceed its maximum load (handled by variable bounds)\n\n    # Constraint 10: The truck's load must be updated at every visited point\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    model.addConstr(load[j, k] >= load[i, k] + demands[j] - M *\n                                    (1 - x[i, j, k]),\n                                    name=f'load_update_lb_{i}_{j}_{k}')\n                    model.addConstr(load[j, k] <= load[i, k] + demands[j] + M *\n                                    (1 - x[i, j, k]),\n                                    name=f'load_update_ub_{i}_{j}_{k}')\n\n    # Constraint 11: The truck's load must be initialized at the depot\n    for k in trucks:\n        model.addConstr(load[0, k] == 0, name=f'initial_load_{k}')\n\n\n    # Constraint 12: Eliminate sub-tours (using lazy constraints approach)\n    def find_subtours(edges):\n        # Create adjacency list\n        adj = {i: [] for i in nodes}\n        for i, j in edges:\n            adj[i].append(j)\n\n        # Find all subtours\n        unvisited = set(nodes)\n        subtours = []\n        while unvisited:\n            current = next(iter(unvisited))\n            subtour = []\n            while current in unvisited:\n                unvisited.remove(current)\n                subtour.append(current)\n                next_nodes = adj.get(current, [])\n                if not next_nodes:\n                    break\n                current = next_nodes[0]\n            if len(subtour) < len(nodes):\n                subtours.append(subtour)\n        return subtours\n\n\n    def subtour_cb(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get values of binary variables\n            x_vals = model.cbGetSolution(model._vars)\n            for k in trucks:\n                edges = [\n                    (i, j) for i in nodes for j in nodes\n                    if i != j and (i, j, k) in x_vals and x_vals[i, j, k] > 0.5\n                ]\n\n                subtours = find_subtours(edges)\n\n                # Add subtour elimination constraints\n                for S in subtours:\n                    if len(S) < len(\n                            nodes\n                    ) and 0 not in S:  # Exclude depot from subtour check\n                        model.cbLazy(\n                            gp.quicksum(x[i, j, k] for i in S for j in S\n                                        if i != j) <= len(S) - 1)\n\n\n    # Enable lazy constraints\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # Set a time limit (optional)\n    model.Params.timeLimit = 3600  # 1 hour\n\n    # Optimize model with callback\n    model.optimize(subtour_cb)\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_PickupDeliveryVRP()\n    print(result)",
    "ground_truth":172.4960492825
  },
  {
    "task_id":"D020",
    "description":"A logistics company needs to arrange forklifts for a newly built warehouse to meet daily operational demands. The forklift requirements for the warehouse over the next 7 weeks are 6, 9, 12, 8, 5, 7 and 4. The logistics company plans to lease forklifts from a rental company, which offers the following leasing options:\n\n1. Long-term forklift rental: The lease term is fixed at 7 weeks, with a rental cost of 240 yuan per week. Forklifts under long-term lease are available for the entire lease period.\n2. Short-term forklift rental: The lease term is flexible, available on a weekly basis, with a rental cost of 390 yuan per week. Short-term leased forklifts are only available during the week they are leased.\n3. Shared forklifts: These are vehicles jointly leased with other warehouses, but they are only available in weeks 2, 4, and 5. The rental cost is 220 yuan per week.\n4. Promotional forklifts: These forklifts can be leased at a discounted rate during the last 4 weeks, with a rental cost of 190 yuan per week. A maximum of 2 promotional forklifts can be leased per week.\n\nPlease design a leasing plan that fully meets the warehouse's forklift requirements over the next 7 weeks while minimizing the total leasing cost.",
    "formulation":"Set:\n1. Week\nThe set of weeks, \\( W = \\{1, 2, \\dots, WeekNum\\} \\)\n\nParameter:\n1. WeekNum\n7\n2. Demand\n[6, 9, 12, 8, 5, 7, 4]\n3. LongTermCost\n240\n4. LongTermWeekNum\n7\n5. ShortTermCost\n390\n6. SharedCost\n220\n7. SharedWeek\n[2, 4, 5]\n8. PromoCost\n190\n9. PromoMaxNum\n2\n10. PromoWeek\n[4, 5, 6, 7]\n\nDecision variable:\n1. LongTermNum\nInteger variable, \\( LongTermNum \\), where \\( LongTermNum \\) is the number of long-term forklifts leased.\n2. ShortTermNum\nInteger variable, \\( ShortTermNum_{i} \\forall i \\in W\\), where \\( ShortTermNum_i \\) is the number of short-term forklifts leased in week \\( i \\).\n3. SharedNum\nInteger variable, \\( SharedNum \\), where \\( SharedNum \\) is the number of shared forklifts leased.\n4. PromoNum\nInteger variable, \\( PromoNum_{i} \\forall i \\in W\\), where \\( PromoNum_i \\) is the number of promotional forklifts leased in week \\( i \\).\n\nObjective:\n1. Minimize the total leasing cost.\nmin: LongTermCost * LongTermNum * LongTermWeekNum + ShortTermCost * \\sum_{i \\in W} ShortTermNum_i + SharedCost * SharedNum * len(SharedWeek) + PromoCost * \\sum_{i \\in PromoWeek} PromoNum_i\n\nConstraint:\n1. The total number of forklifts leased must meet the demand for each week.\nLongTermNum + ShortTermNum_i + PromoNum_i \\geq Demand_i \\forall i \\in (W \/ SharedWeek)\n2. The total number of forklifts leased must meet the demand for each week, considering shared forklifts.\nLongTermNum + ShortTermNum_i + SharedNum + PromoNum_i \\geq Demand_i \\forall i \\in SharedWeek\n3. The number of promotional forklifts leased in each week must not exceed the maximum limit.\nPromoNum_i \\leq PromoMaxNum \\forall i \\in PromoWeek\n4. The promotional forklifts can't be leased in weeks other than the promotional weeks.\nPromoNum_i = 0 \\forall i \\in (W \/ PromoWeek)\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_forklift_leasing(\n    demand=[6, 9, 12, 8, 5, 7, 4],\n    long_term_cost=240,\n    short_term_cost=390,\n    shared_cost=220,\n    shared_weeks=[2, 4, 5],\n    promo_cost=190,\n    promo_max_num=2,\n    promo_weeks=[4, 5, 6, 7]):\n    \"\"\"\n    Models and solves the forklift leasing optimization problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"ForkliftLeasing\")\n\n    # --- 2. Parameters & Sets ---\n    week_num = len(demand)\n    weeks = range(1, week_num + 1)\n    long_term_weeks = week_num\n\n    # --- 3. Decision Variables ---\n    long_term_num = model.addVar(vtype=GRB.INTEGER, name=\"LongTermNum\")\n    short_term_num = model.addVars(weeks, vtype=GRB.INTEGER, name=\"ShortTermNum\")\n    shared_num = model.addVar(vtype=GRB.INTEGER, name=\"SharedNum\")\n    promo_num = model.addVars(weeks, vtype=GRB.INTEGER, name=\"PromoNum\")\n\n    # --- 4. Objective Function ---\n    objective = long_term_cost * long_term_num * long_term_weeks\n    objective += short_term_cost * gp.quicksum(short_term_num[i] for i in weeks)\n    objective += shared_cost * shared_num * len(shared_weeks)\n    objective += promo_cost * gp.quicksum(promo_num[i]\n                                          for i in weeks if i in promo_weeks)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Total forklifts per week must meet demand (non-shared weeks)\n    for i in weeks:\n        if i not in shared_weeks:\n            model.addConstr(long_term_num + short_term_num[i] + promo_num[i]\n                            >= demand[i - 1],\n                            name=f\"Demand_Week_{i}\")\n\n    # Constraint 2: Total forklifts during shared weeks must meet demand\n    for i in shared_weeks:\n        model.addConstr(long_term_num + short_term_num[i] + shared_num +\n                        promo_num[i] >= demand[i - 1],\n                        name=f\"Demand_SharedWeek_{i}\")\n\n    # Constraint 3: Promotional forklift quantity must not exceed maximum limit\n    for i in promo_weeks:\n        model.addConstr(promo_num[i] <= promo_max_num, name=f\"PromoLimit_Week_{i}\")\n\n    # Constraint 4: Non-promotional weeks cannot lease promotional forklifts\n    for i in weeks:\n        if i not in promo_weeks:\n            model.addConstr(promo_num[i] == 0, name=f\"NoPromo_Week_{i}\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_forklift_leasing()\n    print(result)\n",
    "ground_truth":14110.0
  },
  {
    "task_id":"D021",
    "description":"A manufacturing plant specializes in producing customized parts, where production is scheduled based on customer orders. The factory has five machines (M1-M5), each with distinct functions: M1 for cutting, M2 for drilling, M3 for welding, M4 for polishing, and M5 for final assembly. Currently, four orders (J1-J4) have been received, each requiring a fixed sequence of processing steps that must be completed on specific machines in a prescribed order. The processing steps, required machines, and execution times for each task are as follows:\n\nJ1: (1) Cutting on M1, taking 3 hours; (2) Drilling on M2, taking 2 hours; (3) Assembly on M5, taking 4 hours.  \nJ2: (1) Welding on M3, taking 4 hours; (2) Polishing on M4, taking 3 hours; (3) Assembly on M5, taking 2 hours.  \nJ3: (1) Drilling on M2, taking 3 hours; (2) Cutting on M1, taking 5 hours; (3) Polishing on M4, taking 2 hours.  \nJ4: (1) Cutting on M1, taking 2 hours; (2) Welding on M3, taking 3 hours; (3) Polishing on M4, taking 4 hours.  \n\nEach machine can only handle one task at a time and cannot process multiple tasks simultaneously. Once a step begins processing, it cannot be paused or interrupted midway. How should the order processing be scheduled to minimize the total completion time for all tasks?",
    "formulation":"Set:\n1. Machine\nThe set of machines, \\( M = \\{1, 2, 3, 4, 5\\} \\)\n2. Job\nThe set of jobs, \\( J = \\{1, 2, 3, 4\\} \\)\n\nParameter:\n1. JobProcess\n[\n[(1, 3), (2, 2), (5, 4)],\n[(3, 4), (4, 3), (5, 2)],\n[(2, 3), (1, 5), (4, 2)],\n[(1, 2), (3, 3), (4, 4)]\n]\n2. MachineID\n['M1', 'M2', 'M3', 'M4', 'M5']\n3. JobID\n['J1', 'J2', 'J3', 'J4']\n4. BigM\nA sufficiently large number, computed as the sum of all processing times.\n\nDecision variable:\n1. StartTime\nInteger variable, \\( StartTime_{j,k} \\forall j \\in J, k \\in \\{0, 1, ..., |JobProcess_j|-1\\}\\), where \\( StartTime_{j,k} \\) is the start time of the \\( k^{th} \\) process of job \\( j \\).\n2. Makespan\nInteger variable representing the maximum completion time of all jobs.\n3. Indicator\nBinary variable, \\( Indicator_{j_1,k_1,j_2,k_2} \\) for each pair of processes on the same machine, where value 1 means process (j_1,k_1) comes before (j_2,k_2), and 0 means (j_2,k_2) comes before (j_1,k_1).\n\nObjective:\n1. Minimize the makespan.\nmin: Makespan\n\nConstraint:\n1. The start time of the next process must be greater than or equal to the end time of the previous process.\nStartTime_{j,k+1} \\geq StartTime_{j,k} + JobProcess_j[k][1] \\forall j \\in J, k \\in \\{0, 1, ..., |JobProcess_j|-2\\}\n\n2. One machine can only process one job at a time (disjunctive constraints using binary indicators).\nFor each machine m and each pair of processes (j_1,k_1) and (j_2,k_2) that use machine m:\na. StartTime_{j_1,k_1} + JobProcess_{j_1}[k_1][1] \\leq StartTime_{j_2,k_2} + BigM * Indicator_{j_1,k_1,j_2,k_2}\nb. StartTime_{j_2,k_2} + JobProcess_{j_2}[k_2][1] \\leq StartTime_{j_1,k_1} + BigM * (1 - Indicator_{j_1,k_1,j_2,k_2})\n\n3. The start time of all processes must be non-negative.\nStartTime_{j,k} \\geq 0 \\forall j \\in J, k \\in \\{0, 1, ..., |JobProcess_j|-1\\}\n\n4. Makespan definition: makespan must be at least the completion time of every job.\nMakespan \\geq StartTime_{j,|JobProcess_j|-1} + JobProcess_j[|JobProcess_j|-1][1] \\forall j \\in J\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport json\nimport os\nmachines = list(range(1, 6))  # M = {1, 2, 3, 4, 5}\njobs = list(range(1, 5))  # J = {1, 2, 3, 4}\n\n# JobProcess[j-1] contains a list of tuples (machine, process_time) for job j\njob_processes = [\n    [(1, 3), (2, 2), (5, 4)],  # Job 1 processes\n    [(3, 4), (4, 3), (5, 2)],  # Job 2 processes\n    [(2, 3), (1, 5), (4, 2)],  # Job 3 processes\n    [(1, 2), (3, 3), (4, 4)]  # Job 4 processes\n]\n\nmachine_id = ['M1', 'M2', 'M3', 'M4', 'M5']\njob_id = ['J1', 'J2', 'J3', 'J4']\n\ndef solve_job_shop_scheduling(job_processes=[[(1, 3), (2, 2), (5, 4)], [(3, 4), (4, 3), (5, 2)], [(2, 3), (1, 5), (4, 2)], [(1, 2), (3, 3), (4, 4)]]):\n    # Data\n    machines = list(range(1, 6))\n    jobs = list(range(1, 5))\n\n    # Create a new model\n    model = gp.Model(\"JobShopScheduling\")\n\n    # Calculate a big-M value (an upper bound on the makespan)\n    big_M = sum(duration for job in job_processes for _, duration in job)\n\n    # Create decision variables\n    start_times = {}\n    for j in range(len(jobs)):\n        for k in range(len(job_processes[j])):\n            start_times[j, k] = model.addVar(vtype=GRB.INTEGER,\n                                             lb=0,\n                                             name=f\"StartTime_{j+1}_{k+1}\")\n\n    # Create makespan variable\n    makespan = model.addVar(vtype=GRB.INTEGER, name=\"Makespan\")\n\n    # Set objective\n    model.setObjective(makespan, GRB.MINIMIZE)\n\n    # Constraint 1: The start time of the next process must be greater than or equal to the end time of the previous process\n    for j in range(len(jobs)):\n        for k in range(len(job_processes[j]) - 1):\n            model.addConstr(\n                start_times[j,\n                            k + 1] >= start_times[j, k] + job_processes[j][k][1],\n                f\"PrecedenceJob_{j+1}_Process_{k+1}_to_{k+2}\")\n\n    # Constraint 2: One machine can only process one job at a time\n    for m in machines:\n        # Find all processes that use this machine\n        processes_on_machine = []\n        for j in range(len(jobs)):\n            for k in range(len(job_processes[j])):\n                if job_processes[j][k][0] == m:\n                    processes_on_machine.append((j, k))\n\n        # Add non-overlap constraints for each pair of processes on this machine\n        for i in range(len(processes_on_machine)):\n            for j in range(i + 1, len(processes_on_machine)):\n                j1, k1 = processes_on_machine[i]\n                j2, k2 = processes_on_machine[j]\n\n                # Either j1,k1 finishes before j2,k2 starts OR j2,k2 finishes before j1,k1 starts\n                indicator = model.addVar(\n                    vtype=GRB.BINARY,\n                    name=f\"Indicator_{j1+1}_{k1+1}_{j2+1}_{k2+1}\")\n                model.addConstr(\n                    start_times[j1, k1] + job_processes[j1][k1][1]\n                    <= start_times[j2, k2] + big_M * (1 - indicator),\n                    f\"NoOverlap1_{j1+1}_{k1+1}_{j2+1}_{k2+1}\")\n                model.addConstr(\n                    start_times[j2, k2] + job_processes[j2][k2][1]\n                    <= start_times[j1, k1] + big_M * indicator,\n                    f\"NoOverlap2_{j1+1}_{k1+1}_{j2+1}_{k2+1}\")\n\n    # Constraint 3: The start time of the first process must be greater than or equal to 0\n    for j in range(len(jobs)):\n        model.addConstr(start_times[j, 0] >= 0, f\"NonNegativeStart_{j+1}\")\n\n    # Constraint for makespan: makespan is the maximum completion time among all jobs\n    for j in range(len(jobs)):\n        last_process = len(job_processes[j]) - 1\n        model.addConstr(\n            makespan\n            >= start_times[j, last_process] + job_processes[j][last_process][1],\n            f\"MakespanDef_{j+1}\")\n\n    # Solve the model\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_job_shop_scheduling()\n    print(result)\n",
    "ground_truth":13.0
  },
  {
    "task_id":"D022",
    "description":"HAPPY pharmaceutical produces the drug Panacea from four chemicals. Today they must produce 1,000 lb of the drug. The three active ingredients in Panacea are A, B, and C. By weight, at least 8% of Panacea must consist of A, at least 4% of B, and at least 2% of C. The cost per pound of each chemical and the amount of each active ingredient in 1 lb of each chemical are given in Table as follows:\n\n| Chemical | Cost ($ per Lb) | A    | B    | C    |\n|----------|-----------------|------|------|------|\n| 1        | 8               | .03  | .02  | .01  |\n| 2        | 10              | .06  | .04  | .01  |\n| 3        | 11              | .10  | .03  | .04  |\n| 4        | 14              | .12  | .09  | .04  |\n\nIt is necessary that at least 100 lb of chemical 2 be used. Find a solution would determine the cheapest way of producing today's batch of Panacea.",
    "formulation":"Set:\n1. Chemical\nThe set of chemicals, \\( C = \\{1, 2, 3, 4\\} \\)\n2. Ingredient\nThe set of ingredients, \\( I = \\{1, 2, 3\\} \\)\n\nParameter:\n1. ChemicalID\n['1', '2', '3', '4']\n2. IngredientID\n['A', 'B', 'C']\n3. ChemicalCost\n[8, 10, 11, 14]\n4. IngredientContent\n# units\/lb\n[\n[0.03, 0.02, 0.01],\n[0.06, 0.04, 0.01],\n[0.10, 0.03, 0.04],\n[0.12, 0.09, 0.04]\n]\n5. IngredientMin\n[0.08, 0.04, 0.02]\n6. ChemicalMin\n[0, 100, 0, 0]\n7. ProduceTarget\n1000\n\nDecision variable:\n1. ChemicalAmount\nContinuous variable, \\( ChemicalAmount_i \\forall i \\in C \\), where \\( ChemicalAmount_i \\) is the amount of chemical \\( i \\) used in the production of Panacea.\n\nObjective:\n1. Minimize the total cost of chemicals used.\nmin: \\sum_{i \\in C} ChemicalCost[i] * ChemicalAmount[i]\n\nConstraint:\n1. Ingredient minimum content. \n\\sum_{i \\in C} IngredientContent[i][j] * ChemicalAmount[i] \\geq IngredientMin[j] * ProduceTarget \\forall j \\in I\n2. Chemical minimum content.\nChemicalAmount[i] \\geq ChemicalMin[i] \\forall i \\in C\n3. Total amount of chemicals used.\n\\sum_{i \\in C} ChemicalAmount[i] = ProduceTarget\n4. Non-negativity constraint.\nChemicalAmount[i] \\geq 0 \\forall i \\in C\n\nType:\nContinuous, Linear, Linear\nLP\n",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_chemical_mixing(\n    chemical_cost=[8, 10, 11, 14],\n    ingredient_content=[\n        [0.03, 0.02, 0.01],  # Chemical 1\n        [0.06, 0.04, 0.01],  # Chemical 2\n        [0.10, 0.03, 0.04],  # Chemical 3\n        [0.12, 0.09, 0.04]  # Chemical 4\n    ],\n    ingredient_min=[0.08, 0.04, 0.02],\n    chemical_min=[0, 100, 0, 0],\n    produce_target=1000):\n    \"\"\"\n    Solves the chemical mixing problem to minimize cost.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"ChemicalMixing\")\n\n    # --- 2. Parameters & Sets ---\n    chemicals = range(len(chemical_cost))\n    ingredients = range(len(ingredient_min))\n\n    # --- 3. Decision Variables ---\n    chemical_amount = model.addVars(chemicals, lb=0, name=\"ChemicalAmount\")\n\n    # --- 4. Objective Function ---\n    # Minimize the total cost\n    model.setObjective(chemical_amount.prod(chemical_cost), GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Ingredient minimum content\n    model.addConstrs(\n        (gp.quicksum(ingredient_content[i][j] * chemical_amount[i]\n                     for i in chemicals) >= ingredient_min[j] * produce_target\n         for j in ingredients), \"IngredientMin\")\n\n    # Constraint 2: Chemical minimum content\n    model.addConstrs((chemical_amount[i] >= chemical_min[i] for i in chemicals),\n                     \"ChemicalMin\")\n\n    # Constraint 3: Total amount constraint\n    model.addConstr(\n        chemical_amount.sum() == produce_target,\n        \"TotalAmount\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_chemical_mixing()\n    print(result)",
    "ground_truth":10637.5
  },
  {
    "task_id":"D023",
    "description":"A commodities trader oversees a secure vault facility with a maximum capacity of 500 kilograms, dedicated to storing refined platinum. At the beginning of Quarter 1, the trader holds 150 kilograms of platinum. Each quarter, the trader assesses the current inventory, sells any amount of platinum up to the available stock at the prevailing selling price, then purchase platinum at the current purchase price for the season, while ensuring that the total inventory does not exceed the vault's capacity (requires selling first before buying). The selling and purchase prices for platinum for each quarter are as follows:\n\n| Quarter | Selling Price ($\/kg) | Purchase Price ($\/kg) |\n|---------|-----------------------|-----------------------|\n| 1       | 30,000               | 32,000               |\n| 2       | 35,000               | 36,000               |\n| 3       | 40,000               | 38,000               |\n| 4       | 36,000               | 33,000               |\n| 5       | 38,000               | 39,000               |\n| 6       | 42,000               | 40,000               |\n\nThe trader's objective is to devise an optimal strategy for buying and selling platinum over the six quarters to maximize total profit. What is the maximum achievable profit?",
    "formulation":"Set:\n1. Quarter\nThe set of quarters, \\( Q = \\{1, 2, ..., QuarterNum\\} \\)\n\nParameter:\n1. QuarterNum\n6\n2. VaultCapacity\n500\n3. InitialInventory\n150\n4. SellingPrice\n[30000, 35000, 40000, 36000, 38000, 42000]\n5. PurchasePrice\n[32000, 36000, 38000, 33000, 39000, 40000]\n\nDecision variable:\n1. SellingAmount\nContinuous variable, \\( SellingAmount_q \\forall q \\in Q \\), where \\( SellingAmount_q \\) is the amount of platinum sold in quarter \\( q \\).\n2. PurchaseAmount\nContinuous variable, \\( PurchaseAmount_q \\forall q \\in Q \\), where \\( PurchaseAmount_q \\) is the amount of platinum purchased in quarter \\( q \\).\n3. Inventory\nContinuous variable, \\( Inventory_q \\forall q \\in Q \\), where \\( Inventory_q \\) is the amount of platinum in the vault at the end of quarter \\( q \\).\n\nObjective:\n1. Maximize the total profit from selling platinum. \nmax: \\sum_{q \\in Q} (SellingPrice[q] * SellingAmount[q] - PurchasePrice[q] * PurchaseAmount[q])\n\nConstraint:\n1. Initial inventory constraint.\nInventory[1] = InitialInventory + PurchaseAmount[1] - SellingAmount[1]\n2. Inventory balance constraint.\nInventory[q] = Inventory[q-1] + PurchaseAmount[q] - SellingAmount[q] \\forall q \\in Q, q > 1\n3. Inventory capacity constraint.\nInventory[q] \\leq VaultCapacity \\forall q \\in Q\n4. Selling amount constraint.\nSellingAmount[q] \\leq Inventory[q-1] \\forall q \\in Q, q > 1\n5. Initial selling amount constraint.\nSellingAmount[1] \\leq InitialInventory\n6. Non-negativity constraint.\nPurchaseAmount[q] \\geq 0 \\forall q \\in Q\nSellingAmount[q] \\geq 0 \\forall q \\in Q\n7. Inventory non-negativity constraint.\nInventory[q] \\geq 0 \\forall q \\in Q\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_platinum_trading(\n    vault_capacity=500,\n    initial_inventory=150,\n    selling_price=[30000, 35000, 40000, 36000, 38000, 42000],\n    purchase_price=[32000, 36000, 38000, 33000, 39000, 40000]):\n    \"\"\"\n    Solves the platinum trading optimization problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"PlatinumTrading\")\n\n    # --- 2. Parameters & Sets ---\n    quarter_num = len(selling_price)\n    quarters = range(1, quarter_num + 1)\n\n    # --- 3. Decision Variables ---\n    selling_amount = model.addVars(quarters, lb=0, name=\"SellingAmount\")\n    purchase_amount = model.addVars(quarters, lb=0, name=\"PurchaseAmount\")\n    inventory = model.addVars(quarters,\n                              lb=0,\n                              ub=vault_capacity,\n                              name=\"Inventory\")\n\n    # --- 4. Objective Function ---\n    # Maximize total profit\n    objective = gp.quicksum(selling_price[q - 1] * selling_amount[q] -\n                            purchase_price[q - 1] * purchase_amount[q]\n                            for q in quarters)\n    model.setObjective(objective, GRB.MAXIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Initial inventory constraint\n    model.addConstr(inventory[1] == initial_inventory + purchase_amount[1] -\n                    selling_amount[1], \"InitialInventory\")\n\n    # Constraint 2: Inventory balance constraint\n    model.addConstrs(\n        (inventory[q] == inventory[q - 1] + purchase_amount[q] -\n         selling_amount[q] for q in range(2, quarter_num + 1)),\n        \"InventoryBalance\")\n\n    # Constraint 3: Selling amount must be less than or equal to inventory\n    model.addConstr(selling_amount[1] <= initial_inventory,\n                    \"InitialInventoryLimit\")\n    model.addConstrs((selling_amount[q] <= inventory[q - 1]\n                      for q in range(2, quarter_num + 1)), \"InventoryLimit\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_platinum_trading()\n    print(result)\n",
    "ground_truth":13300000.0
  },
  {
    "task_id":"D024",
    "description":"A publishing company needs to plan the optimal strategy for printing books over the next six months. The company has forecasted the monthly demand as follows: Month 1—5,000 copies; Month 2—6,000 copies; Month 3—5,500 copies; Month 4—7,000 copies; Month 5—4,500 copies; Month 6—4,000 copies. The cost of printing one copy is $2 during regular working hours (RT) and $3 during overtime (OT). Each month, regular-time production is limited to 6,000 copies, and overtime production is limited to 2,000 copies. Additionally, the inventory holding cost is $0.5 per copy per month. What is the minimum total cost to meet the demand for the next six months on time?",
    "formulation":"Set:\n1. Month\nThe set of months, \\( M = \\{1, 2, ..., MonthNum\\} \\)\n\nParameter:\n1. MonthNum\n6\n2. RegularTimeProductionLimit\n6000\n3. OvertimeProductionLimit\n2000\n4. RegularTimeCost\n2\n5. OvertimeCost\n3\n6. InventoryHoldingCost\n0.5\n7. Demand\n[5000, 6000, 5500, 7000, 4500, 4000]\n\nDecision variable:\n1. RegularTimeProduction\nInteger variable, \\( RegularTimeProduction_m \\forall m \\in M \\), where \\( RegularTimeProduction_m \\) is the amount of books produced in month \\( m \\) during regular time.\n2. OvertimeProduction\nInteger variable, \\( OvertimeProduction_m \\forall m \\in M \\), where \\( OvertimeProduction_m \\) is the amount of books produced in month \\( m \\) during overtime.\n3. Inventory\nInteger variable, \\( Inventory_m \\forall m \\in M \\), where \\( Inventory_m \\) is the amount of books in inventory at the end of month \\( m \\).\n\nObjective:\n1. Minimize the total cost of production and inventory holding.\nmin: \\sum_{m \\in M} (RegularTimeCost * RegularTimeProduction[m] + OvertimeCost * OvertimeProduction[m] + InventoryHoldingCost * Inventory[m])\n\nConstraint:\n1. Initial inventory constraint.\nInventory[1] = 0 + RegularTimeProduction[1] + OvertimeProduction[1] - Demand[1]\n2. Inventory balance constraint.\nInventory[m] = Inventory[m-1] + RegularTimeProduction[m] + OvertimeProduction[m] - Demand[m] \\forall m \\in M, m > 1\n3. Demand constraint.\nRegularTimeProduction[1] + OvertimeProduction[1] \\geq Demand[1] \nInventory[m-1]+ RegularTimeProduction[m] + OvertimeProduction[m] \\geq Demand[m] \\forall m \\in M, m > 1\n4. Regular time production limit constraint.\nRegularTimeProduction[m] \\leq RegularTimeProductionLimit \\forall m \\in M\n5. Overtime production limit constraint.\nOvertimeProduction[m] \\leq OvertimeProductionLimit \\forall m \\in M\n6. Non-negativity constraint.\nRegularTimeProduction[m] \\geq 0 \\forall m \\in M\nOvertimeProduction[m] \\geq 0 \\forall m \\in M\nInventory[m] \\geq 0 \\forall m \\in M\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_production_planning(\n    RegularTimeProductionLimit=6000,\n    OvertimeProductionLimit=2000,\n    RegularTimeCost=2,\n    OvertimeCost=3,\n    InventoryHoldingCost=0.5,\n    Demand=[5000, 6000, 5500, 7000, 4500, 4000]):\n    \"\"\"\n    Solves the production planning optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Production Planning\")\n\n    # Parameters\n    MonthNum = len(Demand)\n\n    # Define month set (1-indexed to match the model description)\n    Months = range(1, MonthNum + 1)\n\n    # Decision Variables\n    RegularTimeProduction = model.addVars(Months,\n                                          vtype=GRB.INTEGER,\n                                          name=\"RegularTimeProduction\")\n    OvertimeProduction = model.addVars(Months,\n                                       vtype=GRB.INTEGER,\n                                       name=\"OvertimeProduction\")\n    Inventory = model.addVars(Months, vtype=GRB.INTEGER, name=\"Inventory\")\n\n    # Objective: Minimize total cost\n    objective = gp.quicksum(RegularTimeCost * RegularTimeProduction[m] +\n                            OvertimeCost * OvertimeProduction[m] +\n                            InventoryHoldingCost * Inventory[m] for m in Months)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # Constraint 1: Initial inventory constraint\n    model.addConstr(\n        Inventory[1] == RegularTimeProduction[1] + OvertimeProduction[1] -\n        Demand[0], \"InitialInventory\")\n\n    # Constraint 2: Inventory balance constraint for months after the first\n    model.addConstrs(\n        (Inventory[m] == Inventory[m - 1] + RegularTimeProduction[m] +\n         OvertimeProduction[m] - Demand[m - 1]\n         for m in range(2, MonthNum + 1)), \"InventoryBalance\")\n\n    # Constraint 3: Demand constraint\n    # Note: This is redundant given inventory balance and non-negative inventory\n    model.addConstrs(\n        (RegularTimeProduction[m] + OvertimeProduction[m] >= Demand[m - 1]\n         for m in [1]), \"DemandSatisfaction_1\")\n    model.addConstrs(\n        (Inventory[m - 1] + RegularTimeProduction[m] +\n         OvertimeProduction[m] >= Demand[m - 1]\n         for m in range(2, MonthNum + 1)), \"DemandSatisfaction_Rest\")\n\n    # Constraint 4: Regular time production limit constraint\n    model.addConstrs((RegularTimeProduction[m] <= RegularTimeProductionLimit\n                      for m in Months), \"RegularTimeLimit\")\n\n    # Constraint 5: Overtime production limit constraint\n    model.addConstrs((OvertimeProduction[m] <= OvertimeProductionLimit\n                      for m in Months), \"OvertimeLimit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_production_planning()\n    print(result)",
    "ground_truth":64750.0
  },
  {
    "task_id":"D025",
    "description":"GreenWeave specializes in transforming raw materials such as organic cotton, jute, and linen into eco-friendly textiles: organic cotton fabric, jute fabric, and linen fabric. Organic cotton fabric can be manufactured by processing either organic cotton or jute. Linen fabric can be produced from any of the raw materials—organic cotton, jute, or linen. Jute fabric, on the other hand, can be created by processing jute or linen. The production process for organic cotton fabric reduces the input fiber by 30%, leaving 70% for the final product. For linen fabric, the process removes 20% of the input fiber. For jute fabric, the process removes 25% of the input fiber. The costs of purchasing and processing each raw material, along with their availability, are detailed as follows:\n\n| Raw Material      | Purchasing Cost ($\/ton) | Processing Cost ($\/ton)  | Availability (tons) |\n|-------------------|-------------------------|--------------------------|---------------------|\n| Organic Cotton    | 350                     | 100                      | 1000                |\n| Jute              | 400                     | 80                       | 800                 |\n| Linen             | 300                     | 150                      | 600                 |\n\nTo fulfill market requirements, GreenWeave must produce a minimum of 300 tons of organic cotton fabric fiber, 400 tons of jute fabric fiber, and 200 tons of linen fabric fiber. What is the minimum total cost to meet GreenWeave's production needs?",
    "formulation":"Set:\n1. RawMaterials\nThe set of raw materials, \\( R = \\{\"cotton\", \"jute\", \"linen\"\\} \\)\n2. Products\nThe set of products, \\( P = \\{\"cotton_fabric\", \"jute_fabric\", \"linen_fabric\"\\} \\)\n3. ProducedFrom\nThe set of products and their corresponding raw materials, \\( PF = \\{\"cotton_fabric\": (\"cotton\", \"jute\"), \"linen_fabric\": (\"linen\", \"jute\", \"cotton\"), \"jute_fabric\": (\"jute\", \"linen\")\\} \\)\n\nParameter:\n1. ReducedFiberRatio\nThe ratio of fiber remaining after processing, \\( RFR = \\{ \"cotton_fabric\": 0.7, \"jute_fabric\": 0.75, \"linen_fabric\": 0.8 \\} \\)\n2. PurchasingCost \nThe cost of purchasing each raw material, \\( PC = \\{ \"cotton\": 350, \"jute\": 400, \"linen\": 300 \\} \\) # ($\/ton)\n3. ProcessingCost\nThe cost of processing each raw material, \\( PrC = \\{ \"cotton\": 100, \"jute\": 80, \"linen\": 150 \\} \\) # ($\/ton)\n4. Availability\nThe availability of each raw material, \\( A = \\{ \"cotton\": 1000, \"jute\": 800, \"linen\": 600 \\} \\) # (tons)\n5. Demand\nThe demand for each product, \\( D = \\{ \"cotton_fabric\": 300, \"jute_fabric\": 400, \"linen_fabric\": 200 \\} \\) # (tons)\n\nDecision variable:\n1. X\nContinuous variable, \\( X_{r,p} \\forall r \\in PF[p], p \\in P \\), where \\( X_{r,p} \\) is the amount of raw material \\( r \\) used to produce product \\( p \\).\n\nObjective:\n1. Minimize the total cost of purchasing and processing raw materials.\nmin: \\sum_{p \\in P} \\sum_{r \\in PF[p]} (PC[r] + PrC[r]) * X_{r,p}\n\nConstraint:\n1. Demand constraint.\n\\sum_{r \\in PF[p]} RFR[p] * X_{r,p} \\geq D[p] \\forall p \\in P\n2. Availability constraint.\n\\sum_{p \\in P, r \\in PF[p]} X_{r,p} \\leq A[r] \\forall r \\in R\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_textile_manufacturing(\n    ProducedFrom={\n        \"cotton_fabric\": [\"cotton\", \"jute\"],\n        \"linen_fabric\": [\"linen\", \"jute\", \"cotton\"],\n        \"jute_fabric\": [\"jute\", \"linen\"]\n    },\n    ReducedFiberRatio={\n        \"cotton_fabric\": 0.7,\n        \"jute_fabric\": 0.75,\n        \"linen_fabric\": 0.8\n    },\n    PurchasingCost={\n        \"cotton\": 350,\n        \"jute\": 400,\n        \"linen\": 300\n    },\n    ProcessingCost={\n        \"cotton\": 100,\n        \"jute\": 80,\n        \"linen\": 150\n    },\n    Availability={\n        \"cotton\": 1000,\n        \"jute\": 800,\n        \"linen\": 600\n    },\n    Demand={\n        \"cotton_fabric\": 300,\n        \"jute_fabric\": 400,\n        \"linen_fabric\": 200\n    }):\n    \"\"\"\n    Solves the textile manufacturing optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Textile Manufacturing Optimization\")\n\n    # Sets\n    RawMaterials = list(PurchasingCost.keys())\n    Products = list(Demand.keys())\n\n    # Decision variables\n    X = model.addVars(RawMaterials, Products, vtype=GRB.CONTINUOUS, name=\"X\")\n\n    # Objective: Minimize total cost\n    obj = gp.quicksum(\n        (PurchasingCost[r] + ProcessingCost[r]) * X[r, p] for p in Products\n        for r in RawMaterials if r in ProducedFrom.get(p, []))\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # Constraint 1: Demand constraint\n    for p in Products:\n        model.addConstr(\n            gp.quicksum(ReducedFiberRatio[p] * X[r, p]\n                        for r in ProducedFrom[p]) >= Demand[p], f\"Demand_{p}\")\n\n    # Constraint 2: Availability constraint\n    for r in RawMaterials:\n        model.addConstr(\n            gp.quicksum(X[r, p] for p in Products\n                        if r in ProducedFrom.get(p, [])) <= Availability[r],\n            f\"Availability_{r}\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_textile_manufacturing()\n    print(result)",
    "ground_truth":545357.142857143
  },
  {
    "task_id":"D026",
    "description":"A national e-commerce company operates three distribution centers in the Metro region. Each center currently stores different quantities of standard and premium products as shown below:\n\n| Distribution Center | Standard Products | Premium Products |\n|---------------------|-------------------|------------------|\n| Center 1            | 150               | 30               |\n| Center 2            | 250               | 100              |\n| Center 3            | 300               | 70               |\n\nThe company plans to open three retail fulfillment hubs that will serve customers with same-day delivery. Corporate policy requires that each fulfillment hub must maintain exactly 300 products in total inventory, and each hub must stock the same number of premium products to ensure consistent customer experience across all locations. The shipping distances (in kilometers) between distribution centers and fulfillment hubs are shown as follows:\n\n| From \/ To           | Hub 1 | Hub 2 | Hub 3 |\n|---------------------|-------|-------|-------|\n| Center 1            | 0     | 12    | 18    |\n| Center 2            | 12    | 0     | 15    |\n| Center 3            | 18    | 15    | 0     |\n\nWhat is the minimum total transportation distance required to move the products under the company's inventory requirements?",
    "formulation":"Set:\n1. DistributionCenter\nThe set of distribution centers, \\( D = \\{1, 2, ..., DistributionCenterNum\\} \\)\n2. FulfillmentHub\nThe set of fulfillment hubs, \\( H = \\{1, 2, ..., FulfillmentHubNum\\} \\)\n3. ProductType\nThe set of product types, \\( P = \\{1, 2, ..., ProductTypeNum\\} \\) \n\nParameter:\n1. DistributionCenterNum\n3\n2. FulfillmentHubNum\n3\n3. ProductTypeNum\n2\n4. HubInventoryRequirement\n300\n5. StoreStandardProducts\n[150, 250, 300]\n6. StorePremiumProducts\n[30, 100, 70]\n7. ShippingDistance\n[\n    [0, 12, 18],\n    [12, 0, 15],\n    [18, 15, 0]\n]\n\nDecision variable:\n1. ShipAmount\nInteger variable, \\( ShipAmount_{d,h,p} \\forall d \\in D, h \\in H, p \\in P \\), where \\( ShipAmount_{d,h,p} \\) is the amount of product type \\( p \\) shipped from distribution center \\( d \\) to fulfillment hub \\( h \\).\n\nObjective:\n1. Minimize the total transportation distance required to move the products.\nmin: \\sum_{d \\in D} \\sum_{h \\in H} \\sum_{p \\in P} (ShippingDistance[d][h] * ShipAmount[d][h][p])\n\nConstraint:\n1. Fulfillment hub inventory constraint.\nHubInventoryRequirement = \\sum_{d \\in D} \\sum_{p \\in P} ShipAmount[d][h][p] \\forall h \\in H\n2. Product type balance constraint.\nShipAmount[d][h][1] \\leq StoreStandardProducts[d] \\forall d \\in D, h \\in H\n\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_product_distribution(\n    HubInventoryRequirement=300,\n    StoreStandardProducts=[150, 250, 300],\n    StorePremiumProducts=[30, 100, 70],\n    ShippingDistance=[[0, 12, 18], [12, 0, 15], [18, 15, 0]]):\n    \"\"\"\n    Solves the product distribution optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Product Distribution Optimization\")\n\n    # Parameters and Sets\n    DistributionCenterNum = len(StoreStandardProducts)\n    FulfillmentHubNum = len(ShippingDistance)\n    ProductTypeNum = 2  # 0 for standard, 1 for premium\n\n    DCs = range(DistributionCenterNum)\n    Hubs = range(FulfillmentHubNum)\n    Products = range(ProductTypeNum)\n\n    # Decision Variables\n    ShipAmount = model.addVars(DCs,\n                               Hubs,\n                               Products,\n                               vtype=GRB.INTEGER,\n                               name=\"ShipAmount\")\n\n    # Objective: Minimize total transportation distance\n    model.setObjective(\n        gp.quicksum(ShippingDistance[d][h] * ShipAmount[d, h, p]\n                    for d in DCs for h in Hubs for p in Products),\n        GRB.MINIMIZE)\n\n    # Constraint 1: Fulfillment hub inventory constraint\n    model.addConstrs(\n        (gp.quicksum(ShipAmount[d, h, p] for d in DCs for p in Products) ==\n         HubInventoryRequirement for h in Hubs),\n        name=\"Hub_Inventory\")\n\n    # Constraint 2: Product type balance constraint (standard products)\n    # This constraint limits the amount shipped on each individual path\n    # based on the total stock at the distribution center.\n    model.addConstrs(\n        (ShipAmount[d, h, 0] <= StoreStandardProducts[d] for d in DCs\n         for h in Hubs),\n        name=\"Standard_Product_Limit\")\n\n    # Constraint 3: Product type balance constraint (premium products)\n    model.addConstrs(\n        (ShipAmount[d, h, 1] <= StorePremiumProducts[d] for d in DCs\n         for h in Hubs),\n        name=\"Premium_Product_Limit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_product_distribution()\n    print(result)",
    "ground_truth":1440.0
  },
  {
    "task_id":"D027",
    "description":"A small-scale bakery operates in four towns: Greenville, Springfield, Riverside, and Hilltop. The bakery produces fresh bread, which is then delivered to local stores located in Maplewood, Oakdale, Pineville, Cedarhurst, and Brookside. The number of loaves of bread available at each bakery is provided in Table 1. Each store requires a specific number of loaves to meet daily customer demand, as shown in Table 2. The distances (in kilometers) between the bakeries and stores are given in Table 3.  Assuming the delivery cost (in USD) for each loaf of bread is calculated as the square root of the distance between the origin and destination towns, determine the optimal delivery schedule that minimizes total transportation costs while meeting all store requirements.  \n\nTable 1: Bread Availability at Bakeries  \n| Bakery       | Loaves Available |  \n|--------------|------------------|  \n| Greenville   | 200              |  \n| Springfield  | 150              |  \n| Riverside    | 250              |  \n| Hilltop      | 180              |  \n\nTable 2: Bread Requirements at Stores  \n| Store        | Loaves Required |  \n|--------------|-----------------|  \n| Maplewood    | 120             |  \n| Oakdale      | 100             |  \n| Pineville    | 130             |  \n| Cedarhurst   | 90              |  \n| Brookside    | 80              |  \n\nTable 3: Distances Between Bakeries and Stores (km)  \n| From \/ To    | Maplewood | Oakdale | Pineville | Cedarhurst | Brookside |  \n|--------------|-----------|---------|-----------|------------|-----------|  \n| Greenville   | 10        | 15      | 20        | 25         | 30        |  \n| Springfield  | 12        | 8       | 18        | 22         | 28        |  \n| Riverside    | 14        | 10      | 16        | 20         | 26        |  \n| Hilltop      | 16        | 12      | 14        | 18         | 24        |",
    "formulation":"Set:\n1. Bakery\nThe set of bakeries, \\( B = \\{1, 2, ..., BakeryNum\\} \\)\n2. Store\nThe set of stores, \\( S = \\{1, 2, ..., StoreNum\\} \\)\n\nParameter:\n1. BakeryNum\n4\n2. StoreNum\n5\n3. BakerySupply\n[200, 150, 250, 180]\n4. StoreDemand\n[120, 100, 130, 90, 80]\n5. ShippingDistance\n[\n    [10, 15, 20, 25, 30],\n    [12, 8, 18, 22, 28],\n    [14, 10, 16, 20, 26],\n    [16, 12, 14, 18, 24]\n]\n6. ShippingCost\n[\n    [sqrt(10), sqrt(15), sqrt(20), sqrt(25), sqrt(30)],\n    [sqrt(12), sqrt(8), sqrt(18), sqrt(22), sqrt(28)],\n    [sqrt(14), sqrt(10), sqrt(16), sqrt(20), sqrt(26)],\n    [sqrt(16), sqrt(12), sqrt(14), sqrt(18), sqrt(24)]\n]\n\nDecision variable:\n1. ShipAmount\nInteger variable, \\( ShipAmount_{b,s} \\forall b \\in B, s \\in S \\), where \\( ShipAmount_{b,s} \\) is the amount of bread shipped from bakery \\( b \\) to store \\( s \\).\n\nObjective:\n1. Minimize the total transportation cost required to deliver the bread.\nmin: \\sum_{b \\in B} \\sum_{s \\in S} ShippingCost[b][s] * ShipAmount[b][s]\n\nConstraint:\n1. Bakery supply constraint.\n\\sum_{s \\in S} ShipAmount[b][s] \\leq BakerySupply[b] \\forall b \\in B\n2. Store demand constraint.\n\\sum_{b \\in B} ShipAmount[b][s] = StoreDemand[s] \\forall s \\in S\n\nType:\nInteger, Linear, Linear\nILP\n",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_bakery_distribution(\n    BakerySupply=[200, 150, 250, 180],\n    StoreDemand=[120, 100, 130, 90, 80],\n    ShippingDistance=[[10, 15, 20, 25, 30], [12, 8, 18, 22, 28],\n                      [14, 10, 16, 20, 26], [16, 12, 14, 18, 24]]):\n    \"\"\"\n    Solves the bakery distribution (transportation) problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"Bakery Distribution Optimization\")\n\n    # --- 2. Parameters & Sets ---\n    BakeryNum = len(BakerySupply)\n    StoreNum = len(StoreDemand)\n    Bakeries = range(BakeryNum)\n    Stores = range(StoreNum)\n\n    # Calculate shipping costs with square roots\n    ShippingCost = [[math.sqrt(dist) for dist in row]\n                    for row in ShippingDistance]\n\n    # --- 3. Decision Variables ---\n    ShipAmount = model.addVars(Bakeries,\n                               Stores,\n                               vtype=GRB.INTEGER,\n                               name=\"ShipAmount\")\n\n    # --- 4. Objective Function ---\n    # Minimize total transportation cost\n    model.setObjective(\n        gp.quicksum(ShippingCost[b][s] * ShipAmount[b, s] for b in Bakeries\n                    for s in Stores), GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Bakery supply constraint\n    model.addConstrs(\n        (gp.quicksum(ShipAmount[b, s] for s in Stores) <= BakerySupply[b]\n         for b in Bakeries),\n        name=\"BakerySupply\")\n\n    # Constraint 2: Store demand constraint\n    model.addConstrs(\n        (gp.quicksum(ShipAmount[b, s] for b in Bakeries) == StoreDemand[s]\n         for s in Stores),\n        name=\"StoreDemand\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_bakery_distribution()\n    print(result)",
    "ground_truth":1947.6705256188
  },
  {
    "task_id":"D028",
    "description":"A company produces seven types of food containers, ranging in volume from 17 to 33 liters. The demand and size of each container are given in Table as follows: \n\n| Container Type | Volume (liters) | Demand (units) |\n|----------------|-----------------|----------------|\n| 1              | 17              | 500            |\n| 2              | 19              | 400            |\n| 3              | 21              | 300            |\n| 4              | 23              | 250            |\n| 5              | 25              | 200            |\n| 6              | 29              | 150            |\n| 7              | 33              | 100            |\n\nThe variable cost (in dollars) of producing each container is equal to its volume. A fixed cost of $1,000 is incurred to produce any of a particular container type. If the company desires, demand for a container may be satisfied by a container of larger size. Formulate and solve a shortest-path problem whose solution will minimize the cost of meeting the demand for food containers.",
    "formulation":"Set:\n1. Containers\nThe set of container types, \\( C = \\{1, 2, ..., 7\\} \\)\n\nParameter:\n1. Volume\nThe volume of each container type (in liters):\n[17, 19, 21, 23, 25, 29, 33]\n\n2. Demand\nThe demand for each container type (in units):\n[500, 400, 300, 250, 200, 150, 100]\n\n3. VariableCost\nThe variable cost of producing each container type (equals its volume in dollars):\n[17, 19, 21, 23, 25, 29, 33]\n\n4. FixedCost\nThe fixed cost of producing any container type:\n1000\n\nDecision variable:\n1. Produce\nBinary variable, \\( Produce_j \\forall j \\in C \\), where \\( Produce_j = 1 \\) if container type j is produced, 0 otherwise.\n\n2. Assign\nInteger variable, \\( Assign_{i,j} \\forall i,j \\in C, i \\leq j \\), where \\( Assign_{i,j} \\) is the number of demand for container type i satisfied by container type j.\n\nObjective:\n1. Minimize the total cost of production.\nmin: \\sum_{j \\in C} (FixedCost * Produce_j + VariableCost[j] * \\sum_{i \\in C, i \\leq j} Assign_{i,j})\n\nConstraint:\n1. Demand satisfaction constraint.\n\\sum_{j \\in C, j \\geq i} Assign_{i,j} = Demand[i] \\forall i \\in C\n\n2. Production activation constraint.\n\\sum_{i \\in C, i \\leq j} Assign_{i,j} \\leq M * Produce_j \\forall j \\in C\n(where M is a sufficiently large number, such as the sum of all demands)\n\nType:\nMixed-integer, Linear, Linear\nMIP\n",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_container_optimization(\n    volumes=[17, 19, 21, 23, 25, 29, 33],\n    demands=[500, 400, 300, 250, 200, 150, 100],\n    fixed_cost=1000):\n    \"\"\"\n    Solves the container production and assignment optimization problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"Container_Optimization\")\n\n    # --- 2. Parameters & Sets ---\n    container_types = range(len(volumes))\n    variable_costs = volumes  # Variable cost equals volume\n\n    # --- 3. Decision Variables ---\n    # produce[j] = 1 if container type j is produced, 0 otherwise\n    produce = model.addVars(container_types, vtype=GRB.BINARY, name=\"Produce\")\n\n    # assign[i, j] = number of units of demand type i satisfied by container type j\n    assign_keys = [(i, j) for i in container_types for j in container_types\n                   if j >= i]\n    assign = model.addVars(assign_keys, vtype=GRB.INTEGER, name=\"Assign\")\n\n    # --- 4. Objective Function ---\n    # Minimize total cost (fixed production costs + variable assignment costs)\n    total_cost = gp.quicksum(fixed_cost * produce[j]\n                             for j in container_types) + \\\n                 gp.quicksum(variable_costs[j] * assign[i, j]\n                             for i, j in assign_keys)\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Demand satisfaction: All demand for type i must be met.\n    model.addConstrs(\n        (assign.sum(i, '*') == demands[i] for i in container_types),\n        name=\"Demand\")\n\n    # Production activation: If any containers of type j are used, we must incur the fixed cost.\n    M = sum(demands)  # Big-M: an upper bound on the total number of containers of one type\n    model.addConstrs(\n        (assign.sum('*', j) <= M * produce[j] for j in container_types),\n        name=\"Activation\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_container_optimization()\n    print(result)",
    "ground_truth":46700.0
  },
  {
    "task_id":"D029",
    "description":"LogiTrans operates two distribution centers to manage the shipment of three types of goods to various regional hubs. Each distribution center can be staffed by up to seven logistics coordinators at a time. Coordinators are paid $500 per week at distribution center 1 and $900 per week at distribution center 2. Activating a distribution center for a week incurs a fixed cost of $1,000 for center 1 and $2,000 for center 2. During a week at a distribution center, each coordinator can process the number of shipments of each type of goods as shown in Table as follows:\n\n| Goods Type \\ Distribution Center | Center 1 | Center 2 |\n|----------------------------------|----------|----------|\n| Type 1                           | 20       | 25       |\n| Type 2                           | 18       | 22       |\n| Type 3                           | 15       | 20       |\n\nEach week, LogiTrans must ensure that at least 120 shipments of goods type 1, at least 150 shipments of goods type 2, and at least 200 shipments of goods type 3 are processed. How to minimize the total cost of meeting weekly shipment demands?",
    "formulation":"Set:\n1. Center\nThe set of distribution centers, \\( C = \\{1, 2\\} \\)\n2. GoodsType\nThe set of goods types, \\( G = \\{1, 2, 3\\} \\)\n\nParameter:\n1. FixedCost\n[1000, 2000]\n2. StaffCost\n[500, 900]\n3. MaxStaffNum\n[7, 7]\n4. ProcessRate\n[\n    [20, 25],\n    [18, 22],\n    [15, 20]\n]\n5. Demand\n[120, 150, 200]\n\nDecision variable:\n1. ActivatingCenter\nBinary variable, \\( ActivatingCenter[c] \\forall c \\in C \\), where \\( ActivatingCenter[c] = 1 \\) if distribution center \\( c \\) is activated, and 0 otherwise.\n2. StaffNum\nInteger variable, \\( StaffNum[c] \\forall c \\in C \\), where \\( StaffNum[c] \\) is the number of staff at distribution center \\( c \\).\n\nObjective:\n1. Minimize the total cost of activating distribution centers and paying staff.\nmin: \\sum_{c \\in C} (FixedCost[c] * ActivatingCenter[c] + StaffCost[c] * StaffNum[c])\n\nConstraint:\n1. Staff number constraint.\nStaffNum[c] \\leq MaxStaffNum[c] * ActivatingCenter[c] \\forall c \\in C\n2. Demand satisfaction constraint.\n\\sum_{c \\in C} ProcessRate[g][c] * StaffNum[c] \\geq Demand[g] \\forall g \\in G\n3. Staff number non-negativity constraint.\nStaffNum[c] \\geq 0 \\forall c \\in C\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_staffing_optimization(\n    FixedCost=[1000, 2000],\n    StaffCost=[500, 900],\n    MaxStaffNum=[7, 7],\n    ProcessRate=[[20, 25], [18, 22], [15, 20]],\n    Demand=[120, 150, 200]):\n    \"\"\"\n    Solves the distribution center staffing optimization problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"Distribution Center Staffing\")\n\n    # --- 2. Parameters & Sets ---\n    Centers = range(len(FixedCost))\n    GoodsTypes = range(len(Demand))\n\n    # --- 3. Decision Variables ---\n    # ActivatingCenter[c] = 1 if center c is activated, 0 otherwise\n    ActivatingCenter = model.addVars(Centers,\n                                     vtype=GRB.BINARY,\n                                     name=\"ActivatingCenter\")\n\n    # StaffNum[c] = number of staff at center c\n    StaffNum = model.addVars(Centers, vtype=GRB.INTEGER, name=\"StaffNum\")\n\n    # --- 4. Objective Function ---\n    # Minimize total cost (fixed costs + staff costs)\n    obj = gp.quicksum(FixedCost[c] * ActivatingCenter[c] +\n                      StaffCost[c] * StaffNum[c] for c in Centers)\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Staff number constraint\n    model.addConstrs(\n        (StaffNum[c] <= MaxStaffNum[c] * ActivatingCenter[c] for c in Centers),\n        name=\"StaffLimit\")\n\n    # Constraint 2: Demand satisfaction constraint\n    model.addConstrs(\n        (gp.quicksum(ProcessRate[g][c] * StaffNum[c] for c in Centers) >=\n         Demand[g] for g in GoodsTypes),\n        name=\"DemandSatisfaction\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_staffing_optimization()\n    print(result)",
    "ground_truth":11000.0
  },
  {
    "task_id":"D030",
    "description":"Global Freight Solutions (GFS), a logistics company, needs to transport goods across three regions using services from three shipping providers. Each provider offers different cost structures and service mixes for large, medium, and small shipments, as detailed in Table as follows:\n\n| Supplier | Cost Per Shipment ($) | Percent Large | Percent Medium | Percent Small |\n|----------|-----------------------|---------------|----------------|---------------|\n| 1        | 5.2                   | 45            | 35             | 20            |\n| 2        | 4.7                   | 30            | 45             | 25            |\n| 3        | 3.5                   | 15            | 20             | 65            |\n\nGFS must fulfill a minimum monthly demand of at least 500 large shipments, 300 medium shipments, and 300 small shipments while minimizing total costs. Additionally, due to capacity constraints, no more than 700 shipments can be contracted from any single provider each month. Determine what the lowest possible cost is.",
    "formulation":"Set:\n1. Supplier\nThe set of suppliers, \\( S = \\{1, 2, 3\\} \\) \n2. ShipmentType\nThe set of shipment types, \\( T = \\{1, 2, 3\\} \\)  # 1: large, 2: medium, 3: small\n\nParameter:\n1. CostPerShipment\n[5.2, 4.7, 3.5]\n2. Percent\n[[45, 35, 20], [30, 45, 25], [15, 20, 65]]\n3. Demand\n[500, 300, 300]\n4. MaxShipment\n[700, 700, 700]\n\nDecision variable:\n1. ShipmentNum\nInteger variable, \\( ShipmentNum[s] \\forall s \\in S \\), where \\( ShipmentNum[s] \\) is the number of shipments contracted from supplier \\( s \\).\n\nObjective:\n1. Minimize the total cost of shipments.\nmin: \\sum_{s \\in S} CostPerShipment[s] * ShipmentNum[s]\n\nConstraint:\n1. Shipment number constraint.\nShipmentNum[s] \\leq MaxShipment[s] \\forall s \\in S\n2. Demand satisfaction constraint.\n\\sum_{s \\in S} Percent[s][g] * ShipmentNum[s] \\geq Demand[g] \\forall g \\in T\n3. Shipment number non-negativity constraint.\nShipmentNum[s] \\geq 0 \\forall s \\in S\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_supplier_shipment_optimization(\n    CostPerShipment=[5.2, 4.7, 3.5],\n    Percent=[\n        [45, 35, 20],\n        [30, 45, 25],\n        [15, 20, 65]\n    ],\n    Demand=[500, 300, 300],\n    MaxShipment=[700, 700, 700]\n):\n    # Create a new model\n    model = gp.Model(\"Supplier Shipment Optimization\")\n\n    # Sets\n    Suppliers = range(len(CostPerShipment))\n    ShipmentTypes = range(len(Demand))\n\n    # Decision Variables\n    ShipmentNum = model.addVars(Suppliers, vtype=GRB.INTEGER, name=\"ShipmentNum\")\n\n    # Objective: Minimize total cost of shipments\n    obj = gp.quicksum(CostPerShipment[s] * ShipmentNum[s] for s in Suppliers)\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # Constraint 1: Shipment number constraint (cannot exceed maximum)\n    for s in Suppliers:\n        model.addConstr(\n            ShipmentNum[s] <= MaxShipment[s],\n            f\"MaxShipment_{s+1}\"\n        )\n\n    # Constraint 2: Demand satisfaction constraint\n    for t in ShipmentTypes:\n        # Convert percentage to decimal\n        model.addConstr(\n            gp.quicksum((Percent[s][t] \/ 100) * ShipmentNum[s] for s in Suppliers) >= Demand[t],\n            f\"DemandSatisfaction_{t+1}\"\n        )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_supplier_shipment_optimization()\n    print(result)",
    "ground_truth":6553.7
  },
  {
    "task_id":"D031",
    "description":"A manufacturing company operates three production facilities (1, 2, and 3) that produce two types of components (X and Y). Each facility generates waste during production, which can be treated to reduce environmental impact. Treating the waste incurs a cost and reduces the amount of pollutants emitted. It costs $12 to treat a ton of waste from facility 1, and each ton treated reduces the amount of pollutant X by 0.15 ton and the amount of pollutant Y by 0.35 ton. It costs $8 to treat a ton of waste from facility 2, and each ton treated reduces the amount of pollutant X by 0.25 ton and the amount of pollutant Y by 0.20 ton. It costs $18 to treat a ton of waste from facility 3, and each ton treated reduces the amount of pollutant X by 0.30 ton and the amount of pollutant Y by 0.40 ton. The company aims to reduce the amount of pollutant X by at least 25 tons and the amount of pollutant Y by at least 35 tons. How to minimize the total cost of treating waste while meeting the pollution reduction targets?",
    "formulation":"Set:\n1. facility\nThe set of production facilities, \\( F = \\{1, 2, 3\\} \\)\n2. pollutant\nThe set of pollutants, \\( P = \\{1, 2\\} \\)  # 1: pollutant X, 2: pollutant Y\n\nParameter:\n1. TreatmentCost\n[12, 8, 18]\n2. PollutantReduction\n[\n    [0.15, 0.35],  # facility 1\n    [0.25, 0.20],  # facility 2\n    [0.30, 0.40]   # facility 3\n]\n3. PollutionTarget\n[25, 35]\n\nDecision variable:\n1. TreatmentAmount\nContinuous variable, \\( TreatmentAmount[f] \\forall f \\in F \\), where \\( TreatmentAmount[f] \\) is the amount of waste treated at facility \\( f \\).\n\nObjective:\n1. Minimize the total cost of treating waste.\nmin: \\sum_{f \\in F} TreatmentCost[f] * TreatmentAmount[f]\n\nConstraint:\n1. Pollution reduction constraint.\nPollutantReduction[f][p] * TreatmentAmount[f] \\geq PollutionTarget[p] \\forall p \\in P, f \\in F\n2. Treatment amount non-negativity constraint.\nTreatmentAmount[f] \\geq 0 \\forall f \\in F\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_waste_treatment_optimization(\n    TreatmentCost=[12, 8, 18],\n    PollutantReduction=[\n        [0.15, 0.35],\n        [0.25, 0.20],\n        [0.30, 0.40]\n    ],\n    PollutionTarget=[25, 35]\n):\n    # Create a new model\n    model = gp.Model(\"Waste Treatment Optimization\")\n\n    # Sets\n    Facilities = range(len(TreatmentCost))\n    Pollutants = range(len(PollutionTarget))\n\n    # Decision Variables\n    TreatmentAmount = model.addVars(Facilities, vtype=GRB.CONTINUOUS, name=\"TreatmentAmount\")\n\n    # Objective: Minimize total treatment cost\n    obj = gp.quicksum(TreatmentCost[f] * TreatmentAmount[f] for f in Facilities)\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # Constraint 1: Pollution reduction constraint\n    for p in Pollutants:\n        model.addConstr(\n            gp.quicksum(PollutantReduction[f][p] * TreatmentAmount[f] for f in Facilities) >= PollutionTarget[p],\n            f\"PollutionReduction_{p+1}\"\n        )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_waste_treatment_optimization()\n    print(result)",
    "ground_truth":1269.5652173913
  },
  {
    "task_id":"D032",
    "description":"A fruit processing company, NatureBounty, specializes in producing two product lines: packaged fresh apples and bottled apple juice. NatureBounty grades apples on a scale of 1 (poor) to 10 (excellent). The company currently has 90,000 lbs of grade 7 apples and 110,000 lbs of grade 4 apples in inventory. To maintain product quality, the average grade of apples sold in packages must be at least 5, and the average grade of apples used for juice production must be at least 6. Additionally, the company has a production capacity constraint: it can process no more than 150,000 lbs of apples in total due to equipment limitations. Each pound of apples used for juice generates a revenue of $1.10 and incurs a variable cost of $0.80. Each pound of apples sold in packages generates a revenue of $0.35 and incurs a variable cost of $0.12. The company also has a marketing constraint: at least 20% of the total processed apples must be sold in packages to meet market demand. How to help NatureBounty maximize its profit while adhering to all constraints.",
    "formulation":"Set:\n1. Product\nThe set of products, \\( P = \\{1, 2\\} \\)  # 1: packaged fresh apples, 2: bottled apple juice\n2. Grade\nThe set of apple grades the company has, \\( G = \\{7, 4\\} \\)\n\nParameter:\n1. Inventory\n[90000, 110000]\n2. Revenue\n[0.35, 1.10]\n3. VariableCost\n[0.12, 0.80]\n4. AverageGrade\n[5, 6]\n5. MaxProcessingCapacity\n150000\n6. MinPackagePercentage\n0.20\n\nDecision variable:\n1. ProcessedAmount\nContinuous variable, \\( ProcessedAmount[p][g] \\forall p \\in P, g \\in G \\), where \\( ProcessedAmount[p][g] \\) is the amount of apples of grade \\( g \\) used for product \\( p \\).\n\nObjective:\n1. Maximize the profit from selling apples.\nmax: \\sum_{p \\in P} \\sum_{g \\in G} (Revenue[p] - VariableCost[p]) * ProcessedAmount[p][g]\n\nConstraint:\n1. Inventory constraint.\n\\sum_{p \\in P} ProcessedAmount[p][g] \\leq Inventory[g] \\forall g \\in G\n2. Average grade constraint.\nAverageGrade[p] * \\sum_{g \\in G} ProcessedAmount[p][g] \\leq \\sum_{g \\in G} g * ProcessedAmount[p][g] \\forall p \\in P\n3. Processing capacity constraint.\n\\sum_{p \\in P} \\sum_{g \\in G} ProcessedAmount[p][g] \\leq MaxProcessingCapacity\n4. Marketing constraint.\n\\sum_{g \\in G} ProcessedAmount[1][g] \\geq MinPackagePercentage * \\sum_{p \\in P} \\sum_{g \\in G} ProcessedAmount[p][g]\n5. Non-negativity constraint.\nProcessedAmount[p][g] \\geq 0 \\forall p \\in P, g \\in G\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_apple_processing_optimization(\n    Inventory=[90000, 110000],\n    Revenue=[0.35, 1.10],\n    VariableCost=[0.12, 0.80],\n    AverageGrade=[5, 6],\n    MaxProcessingCapacity=150000,\n    MinPackagePercentage=0.20,\n    Grades=[7, 4]\n):\n    # Create a new model\n    model = gp.Model(\"Apple Processing Optimization\")\n\n    # Sets\n    Products = range(len(Revenue))\n\n    # Profit per unit for each product\n    Profit = [Revenue[p] - VariableCost[p] for p in Products]\n\n    # Create decision variables dictionary\n    ProcessedAmount = {}\n    for p in Products:\n        for g_idx, g in enumerate(Grades):\n            ProcessedAmount[p, g_idx] = model.addVar(\n                vtype=GRB.CONTINUOUS,\n                name=f\"ProcessedAmount_{p+1}_{g}\"\n            )\n\n    # Objective: Maximize profit\n    obj = gp.quicksum(\n        Profit[p] * ProcessedAmount[p, g_idx]\n        for p in Products\n        for g_idx in range(len(Grades))\n    )\n    model.setObjective(obj, GRB.MAXIMIZE)\n\n    # Constraint 1: Inventory constraint\n    for g_idx in range(len(Grades)):\n        model.addConstr(\n            gp.quicksum(ProcessedAmount[p, g_idx] for p in Products) <= Inventory[g_idx],\n            f\"Inventory_{Grades[g_idx]}\"\n        )\n\n    # Constraint 2: Average grade constraint\n    for p in Products:\n        model.addConstr(\n            AverageGrade[p] * gp.quicksum(ProcessedAmount[p, g_idx] for g_idx in range(len(Grades))) <=\n            gp.quicksum(Grades[g_idx] * ProcessedAmount[p, g_idx] for g_idx in range(len(Grades))),\n            f\"AverageGrade_{p+1}\"\n        )\n\n    # Constraint 3: Processing capacity constraint\n    model.addConstr(\n        gp.quicksum(ProcessedAmount[p, g_idx] for p in Products for g_idx in range(len(Grades))) <= MaxProcessingCapacity,\n        \"ProcessingCapacity\"\n    )\n\n    # Constraint 4: Marketing constraint\n    model.addConstr(\n        gp.quicksum(ProcessedAmount[0, g_idx] for g_idx in range(len(Grades))) >=\n        MinPackagePercentage * gp.quicksum(ProcessedAmount[p, g_idx]\n                                           for p in Products\n                                           for g_idx in range(len(Grades))),\n        \"Marketing\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_apple_processing_optimization()\n    print(result)",
    "ground_truth":42900.0
  },
  {
    "task_id":"D033",
    "description":"Green Energy Solutions specializes in producing two types of renewable fuel: bioethanol and biodiesel. The company has 8,000 liters of feedstock A and 12,000 liters of feedstock B in stock. The quality rating of each feedstock is as follows: feedstock A—12; feedstock B—6. Bioethanol must have an average quality rating of at least 10, while biodiesel must have an average quality rating of at least 8. The demand for each product is driven by marketing efforts. Each dollar spent on marketing bioethanol generates 8 liters of demand, and each dollar spent on marketing biodiesel generates 15 liters of demand. Bioethanol is sold for $30 per liter, and biodiesel is sold for $25 per liter. Help Green Energy Solutions maximize its profit. Assume that the company cannot purchase additional feedstock of either type.",
    "formulation":"Set:\n1. Fuel\nThe set of fuels, \\( F = \\{1, 2\\} \\)  # 1: gasoline, 2: diesel\n2. Feedstock\nThe set of feedstocks, \\( S = \\{1, 2\\} \\)  # 1: feedstock A, 2: feedstock B\n\nParameter:\n1. Inventory\n[8000, 12000]\n2. QualityRating\n[12, 6]\n3. Revenue\n[30, 25]\n4. DemandperMarketingDollar\n[8, 15]\n5. MinQualityRating\n[10, 8]\n\nDecision variable:\n1. ProductionAmount\nContinuous variable, \\( ProductionAmount[f][s] \\forall f \\in F, s \\in S \\), where \\( ProductionAmount[f][s] \\) is the amount of fuel \\( f \\) produced from feedstock \\( s \\).\n2. MarketingBudget\nContinuous variable, \\( MarketingBudget[f] \\forall f \\in F \\), where \\( MarketingBudget[f] \\) is the marketing budget for fuel \\( f \\).\n\nObjective:\n1. Maximize the profit from selling fuels.\nmax: \\sum_{f \\in F} Revenue[f] * \\sum_{s \\in S} ProductionAmount[f][s] - \\sum_{f \\in F} MarketingBudget[f]\n\nConstraint:\n1. Inventory constraint.\n\\sum_{f \\in F} ProductionAmount[f][s] \\leq Inventory[s] \\forall s \\in S\n2. Quality rating constraint.\n\\sum_{s \\in S} QualityRating[s] * ProductionAmount[f][s] \\geq MinQualityRating[f] * \\sum_{s \\in S} ProductionAmount[f][s] \\forall f \\in F\n3. Demand constraint.\nDemandperMarketingDollar[f] * MarketingBudget[f] \\geq \\sum_{s \\in S} ProductionAmount[f][s] \\forall f \\in F\n4. Non-negativity constraint.\nProductionAmount[f][s] \\geq 0 \\forall f \\in F, s \\in S\nMarketingBudget[f] \\geq 0 \\forall f \\in F\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_fuel_production_optimization(\n    Inventory=[8000, 12000],\n    QualityRating=[12, 6],\n    Revenue=[30, 25],\n    DemandperMarketingDollar=[8, 15],\n    MinQualityRating=[10, 8]\n):\n    \"\"\"\n    Models and solves the fuel production and marketing optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Fuel Production and Marketing Optimization\")\n\n    # Sets\n    Fuels = range(len(Revenue))\n    Feedstocks = range(len(Inventory))\n\n    # Decision Variables\n    # Amount of fuel f produced from feedstock s\n    ProductionAmount = {}\n    for f in Fuels:\n        for s in Feedstocks:\n            ProductionAmount[f, s] = model.addVar(\n                vtype=GRB.CONTINUOUS,\n                name=f\"ProductionAmount_{f+1}_{s+1}\"\n            )\n\n    # Marketing budget for each fuel\n    MarketingBudget = model.addVars(\n        Fuels,\n        vtype=GRB.CONTINUOUS,\n        name=\"MarketingBudget\"\n    )\n\n    # Objective: Maximize profit (revenue - marketing costs)\n    obj = gp.quicksum(\n        Revenue[f] * gp.quicksum(ProductionAmount[f, s] for s in Feedstocks)\n        for f in Fuels\n    ) - gp.quicksum(MarketingBudget[f] for f in Fuels)\n\n    model.setObjective(obj, GRB.MAXIMIZE)\n\n    # Constraint 1: Inventory constraint\n    for s in Feedstocks:\n        model.addConstr(\n            gp.quicksum(ProductionAmount[f, s] for f in Fuels) <= Inventory[s],\n            f\"Inventory_{s+1}\"\n        )\n\n    # Constraint 2: Quality rating constraint\n    for f in Fuels:\n        model.addConstr(\n            gp.quicksum(QualityRating[s] * ProductionAmount[f, s] for s in Feedstocks) >=\n            MinQualityRating[f] * gp.quicksum(ProductionAmount[f, s] for s in Feedstocks),\n            f\"Quality_{f+1}\"\n        )\n\n    # Constraint 3: Demand constraint\n    for f in Fuels:\n        model.addConstr(\n            DemandperMarketingDollar[f] * MarketingBudget[f] >=\n            gp.quicksum(ProductionAmount[f, s] for s in Feedstocks),\n            f\"Demand_{f+1}\"\n        )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_fuel_production_optimization()\n    print(result)\n",
    "ground_truth":518433.33333333
  },
  {
    "task_id":"D034",
    "description":"FreshFoods operates three farms (Farm A, Farm B, and Farm C) to grow and supply fresh produce to four grocery stores (Store 1, Store 2, Store 3, and Store 4). The production cost, yield capacity, water usage (per ton), and fertilizer usage (per ton) for each farm are given in the table below:\n\n| Farm | Production Cost ($\/ton) | Yield Capacity (tons) | Water Usage (m³\/ton) | Fertilizer Usage (kg\/ton) |\n| ---- | ----------------------- | --------------------- | -------------------- | ------------------------- |\n| A    | 100                     | 500                   | 6                    | 5                         |\n| B    | 120                     | 400                   | 8                    | 4                         |\n| C    | 150                     | 600                   | 6                    | 3                         |\n\nThe demand (in tons) for each grocery store is as follows:\n\n| Store 1 | Store 2 | Store 3 | Store 4 |\n| ------- | ------- | ------- | ------- |\n| 200     | 300     | 400     | 500     |\n\nThe transportation cost (in $\/ton) from each farm to each grocery store is given in the table below:\n\n| Farm | Store 1 | Store 2 | Store 3 | Store 4 |\n| ---- | ------- | ------- | ------- | ------- |\n| A    | 20      | 25      | 30      | 15      |\n| B    | 22      | 26      | 32      | 18      |\n| C    | 18      | 24      | 28      | 14      |\n\nTo meet sustainability goals, the total produce shipped must use no more than 7 m³ of water per ton and no more than 4 kg of fertilizer per ton. How to minimize the total cost while satisfying the demand and sustainability constraints?",
    "formulation":"Set:\n1. Farm\nThe set of farms, \\( F = \\{1, 2, 3\\} \\)  # 1: Farm A, 2: Farm B, 3: Farm C\n2. Store\nThe set of stores, \\( S = \\{1, 2, 3, 4\\} \\)  # 1: Store 1, 2: Store 2, 3: Store 3, 4: Store 4\n\nParameter:\n1. ProductionCost\n[100, 120, 150]\n2. YieldCapacity\n[500, 400, 600]\n3. WaterUsage\n[6, 8, 6]\n4. FertilizerUsage\n[5, 4, 3]\n5. Demand\n[200, 300, 400, 500]\n6. TransportationCost\n[[20, 25, 30, 15], \n [22, 26, 32, 18], \n [18, 24, 28, 14]]\n7. MaxWaterUsageperTon\n7\n8. MaxFertilizerUsageperTon\n4\n\nDecision variable:\n1. AmountProduced\nContinuous variable, \\( AmountProduced[f][s] \\forall f \\in F, s \\in S \\), where \\( AmountProduced[f][s] \\) is the amount of produce shipped from farm \\( f \\) to store \\( s \\).\n\nObjective:\n1. Minimize the total cost of production and transportation.\nmin: \\sum_{f \\in F} ProductionCost[f] * \\sum_{s \\in S} AmountProduced[f][s] + \\sum_{f \\in F} \\sum_{s \\in S} TransportationCost[f][s] * AmountProduced[f][s]\n\nConstraint:\n1. Demand constraint.\n\\sum_{f \\in F} AmountProduced[f][s] \\geq Demand[s] \\forall s \\in S\n2. Yield capacity constraint.\n\\sum_{s \\in S} AmountProduced[f][s] \\leq YieldCapacity[f] \\forall f \\in F\n3. Water usage constraint.\n\\sum_{f \\in F}\\sum_{s \\in S} WaterUsage[f] * AmountProduced[f][s] \\leq MaxWaterUsageperTon * \\sum_{s \\in S}\\sum_{f \\in F} AmountProduced[f][s]\n4. Fertilizer usage constraint.\n\\sum_{f \\in F}\\sum_{s \\in S} FertilizerUsage[f] * AmountProduced[f][s] \\leq MaxFertilizerUsageperTon * \\sum_{s \\in S}\\sum_{f \\in F} AmountProduced[f][s]\n5. Non-negativity constraint.\nAmountProduced[f][s] \\geq 0 \\forall f \\in F, s \\in S\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_farm_production_optimization(\n    ProductionCost=[100, 120, 150],\n    YieldCapacity=[500, 400, 600],\n    WaterUsage=[6, 8, 6],\n    FertilizerUsage=[5, 4, 3],\n    Demand=[200, 300, 400, 500],\n    TransportationCost=[\n        [20, 25, 30, 15],\n        [22, 26, 32, 18],\n        [18, 24, 28, 14]\n    ],\n    MaxWaterUsageperTon=7,\n    MaxFertilizerUsageperTon=4\n):\n    \"\"\"\n    Models and solves the farm production and distribution optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Farm Production and Distribution Optimization\")\n\n    # Sets\n    Farms = range(len(ProductionCost))\n    Stores = range(len(Demand))\n\n    # Decision Variables\n    AmountProduced = {}\n    for f in Farms:\n        for s in Stores:\n            AmountProduced[f, s] = model.addVar(\n                vtype=GRB.CONTINUOUS,\n                name=f\"AmountProduced_{f+1}_{s+1}\"\n            )\n\n    # Objective: Minimize total production and transportation costs\n    obj = gp.quicksum(\n        ProductionCost[f] * AmountProduced[f, s] + TransportationCost[f][s] * AmountProduced[f, s]\n        for f in Farms\n        for s in Stores\n    )\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # Constraint 1: Demand constraint - each store's demand must be met\n    for s in Stores:\n        model.addConstr(\n            gp.quicksum(AmountProduced[f, s] for f in Farms) >= Demand[s],\n            f\"Demand_{s+1}\"\n        )\n\n    # Constraint 2: Yield capacity constraint - each farm's production cannot exceed capacity\n    for f in Farms:\n        model.addConstr(\n            gp.quicksum(AmountProduced[f, s] for s in Stores) <= YieldCapacity[f],\n            f\"YieldCapacity_{f+1}\"\n        )\n\n    # Constraint 3: Water usage constraint - average water usage cannot exceed maximum\n    total_production = gp.quicksum(AmountProduced[f, s] for f in Farms for s in Stores)\n    total_water_usage = gp.quicksum(WaterUsage[f] * AmountProduced[f, s] for f in Farms for s in Stores)\n    model.addConstr(\n        total_water_usage <= MaxWaterUsageperTon * total_production,\n        \"WaterUsage\"\n    )\n\n    # Constraint 4: Fertilizer usage constraint - average fertilizer usage cannot exceed maximum\n    total_fertilizer_usage = gp.quicksum(FertilizerUsage[f] * AmountProduced[f, s] for f in Farms for s in Stores)\n    model.addConstr(\n        total_fertilizer_usage <= MaxFertilizerUsageperTon * total_production,\n        \"FertilizerUsage\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_farm_production_optimization()\n    print(result)\n",
    "ground_truth":203500.0
  },
  {
    "task_id":"D035",
    "description":"### Problem Description:\nChemCo produces two types of solvents: Standard and Premium. The solvents are produced by blending five raw materials: Alpha, Beta, Gamma, Delta, and Epsilon. Each raw material has four key properties:\n\n1.  Property 1: Viscosity Index (VI)\n2.  Property 2: Flash Point (°C)\n3.  Property 3: Boiling Point (°C)\n4.  Property 4: Density (g\/cm³)\n\nThe properties, daily availability (in liters), and cost (in ¢\/liter) of each raw material are given in Table 1.\n\nTable 1: Raw Materials' Properties, Daily Availability, and Costs\n\n| Raw Material | Availability (Liters) | Cost (¢\/Liter) | VI  | Flash Point (°C) | Boiling Point (°C) | Density (g\/cm³) |\n|--------------|-----------------------|----------------|-----|------------------|--------------------|-----------------|\n| Alpha        | 12,000                | 15.0           | 95  | 45               | 150                | 0.85            |\n| Beta         | 10,500                | 12.0           | 88  | 55               | 180                | 0.92            |\n| Gamma        | 8,000                 | 10.0           | 82  | 60               | 200                | 0.89            |\n| Delta        | 5,000                 | 18.0           | 105 | 40               | 130                | 0.87            |\n| Epsilon      | Unlimited             | 16.0           | 100 | 50               | 160                | 0.91            |\n\nThe final properties of the blended solvents are determined by the volume-weighted average of the properties of the raw materials used. The requirements for each solvent type are provided in Table 2. The Viscosity Index and Boiling Point requirements are minimums, while the Flash Point and Density requirements must be met exactly.\n\nTable 2: Solvent Requirements and Demand\n\n| Solvent  | Demand (Thousands of Liters) | VI (min) | Flash Point (°C) (exact) | Boiling Point (°C) (min) | Density (g\/cm³) (exact) |\n|----------|-------------------------------|----------|--------------------------|--------------------------|------------------------|\n| Standard | 8.5                           | 85       | 50                       | 140                      | 0.88                   |\n| Premium  | 25                            | 92       | 50                       | 140                      | 0.88                   |\n\nThe daily demand (in thousands of liters) for each solvent must be met, but additional production beyond the demand is allowed. Standard solvent sells for 25.50¢\/liter, while Premium solvent sells for 28.75¢\/liter. Additionally, no more than 35% of the volume of each solvent type can consist of raw material Beta. How can ChemCo formulate its solvents using the available raw materials to maximize its total daily profit? Total daily profit is defined as total revenue from sales minus total raw material costs.",
    "formulation":"Set:\n1. Solvent\nThe set of solvents, \\( S = \\{1, 2\\} \\)  # 1: Standard, 2: Premium\n2. RawMaterial\nThe set of raw materials, \\( R = \\{1, 2, 3, 4, 5\\} \\)  # 1: Alpha, 2: Beta, 3: Gamma, 4: Delta, 5: Epsilon\n3. Property\nThe set of properties, \\( P = \\{1, 2, 3, 4\\} \\)  # 1: Viscosity Index, 2: Flash Point, 3: Boiling Point, 4: Density\n\nParameter:\n1. Availability\n[12000, 10500, 8000, 5000, 999999]  # Daily availability of each raw material in liters\n2. Cost\n[15, 12, 10, 18, 16]  # Cost of each raw material in cents per liter\n3. PropertyValue\n[[95, 45, 150, 0.85], \n [88, 55, 180, 0.92], \n [82, 60, 200, 0.89], \n [105, 40, 130, 0.87], \n [100, 50, 160, 0.91]]  # Properties of each raw material\n4. SolventPropertyValue\n[[85, 50, 140, 0.88], \n [92, 50, 140, 0.88]]  # Properties of each solvent\n4. Demand\n[8500, 25000]  # Daily demand for each solvent in thousands of liters\n5. SellingPrice\n[25.50, 28.75]  # Selling price per liter for each solvent in cents\n6. MaxBetaPercentage\n0.35  # Maximum percentage of Beta in each solvent\n\nDecision variable:\n1. AmountProduced\nContinuous variable, \\( AmountProduced[s][r] \\forall s \\in S, r \\in R \\), where \\( AmountProduced[s][r] \\) is the amount of solvent \\( s \\) produced from raw material \\( r \\) in liters.\n\nObjective:\n1. Maximize the total daily profit.\nmax: \\sum_{s \\in S} SellingPrice[s] * Demand[s] - \\sum_{r \\in R} Cost[r] * \\sum_{s \\in S} AmountProduced[s][r]\n\nConstraint:\n1. Demand constraint.\n\\sum_{r \\in R} AmountProduced[s][r] \\geq Demand[s] \\forall s \\in S\n2. Availability constraint.\n\\sum_{s \\in S} AmountProduced[s][r] \\leq Availability[r] \\forall r \\in R\n3. Property constraints.\n\\sum_{r \\in R} PropertyValue[r][p] * AmountProduced[s][r] \\geq \\sum_{r \\in R} SolventPropertyValue[s][p] * AmountProduced[s][r] \\forall s \\in S, p \\in {1, 3}  # Viscosity Index and Boiling Point\n\\sum_{r \\in R} PropertyValue[r][p] * AmountProduced[s][r] = \\sum_{r \\in R} SolventPropertyValue[s][p] * AmountProduced[s][r] \\forall s \\in S, p \\in {2, 4}  # Flash Point and Density\n4. Beta constraint.\nAmountProduced[s][2] \\leq MaxBetaPercentage * \\sum_{r \\in R} AmountProduced[s][r] \\forall s \\in S # Beta is raw material 2\n5. Non-negativity constraint.\nAmountProduced[s][r] \\geq 0 \\forall s \\in S, r \\in R\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_solvent_blending_optimization(\n    Availability=[12000, 10500, 8000, 5000, 999999],\n    Cost=[15, 12, 10, 18, 16],\n    PropertyValue=[\n        [95, 45, 150, 0.85],\n        [88, 55, 180, 0.92],\n        [82, 60, 200, 0.89],\n        [105, 40, 130, 0.87],\n        [100, 50, 160, 0.91]\n    ],\n    SolventPropertyValue=[\n        [85, 50, 140, 0.88],\n        [92, 50, 140, 0.88]\n    ],\n    Demand=[8500, 25000],\n    SellingPrice=[25.50, 28.75],\n    MaxBetaPercentage=0.35\n):\n    \"\"\"\n    Models and solves the solvent blending optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Solvent Blending Optimization\")\n\n    # Sets\n    Solvents = range(len(Demand))\n    RawMaterials = range(len(Cost))\n    Properties = range(len(PropertyValue[0]))\n\n    # Decision Variables\n    AmountProduced = {}\n    for s in Solvents:\n        for r in RawMaterials:\n            AmountProduced[s, r] = model.addVar(\n                vtype=GRB.CONTINUOUS,\n                name=f\"AmountProduced_{s+1}_{r+1}\"\n            )\n\n    # Objective: Maximize profit (revenue from demand only - total production cost)\n    total_revenue = gp.quicksum(SellingPrice[s] * Demand[s] for s in Solvents)\n    total_cost = gp.quicksum(\n        Cost[r] * gp.quicksum(AmountProduced[s, r] for s in Solvents)\n        for r in RawMaterials\n    )\n    model.setObjective(total_revenue - total_cost, GRB.MAXIMIZE)\n\n    # Constraint 1: Demand constraint (production must meet exactly the demand)\n    for s in Solvents:\n        model.addConstr(\n            gp.quicksum(AmountProduced[s, r] for r in RawMaterials) == Demand[s],\n            f\"Demand_{s+1}\"\n        )\n\n    # Constraint 2: Availability constraint\n    for r in RawMaterials:\n        model.addConstr(\n            gp.quicksum(AmountProduced[s, r] for s in Solvents) <= Availability[r],\n            f\"Availability_{r+1}\"\n        )\n\n    # Constraint 3: Property constraints\n    for s in Solvents:\n        # For properties 0 (VI) and 2 (Boiling Point) - minimum requirements\n        for p in [0, 2]:\n            model.addConstr(\n                gp.quicksum(PropertyValue[r][p] * AmountProduced[s, r] for r in RawMaterials) >=\n                SolventPropertyValue[s][p] * gp.quicksum(AmountProduced[s, r] for r in RawMaterials),\n                f\"MinProperty_{s+1}_{p+1}\"\n            )\n\n        # For properties 1 (Flash Point) and 3 (Density) - exact requirements\n        for p in [1, 3]:\n            model.addConstr(\n                gp.quicksum(PropertyValue[r][p] * AmountProduced[s, r] for r in RawMaterials) ==\n                SolventPropertyValue[s][p] * gp.quicksum(AmountProduced[s, r] for r in RawMaterials),\n                f\"ExactProperty_{s+1}_{p+1}\"\n            )\n\n    # Constraint 4: Beta constraint (raw material 1 is Beta)\n    for s in Solvents:\n        model.addConstr(\n            AmountProduced[s, 1] <= MaxBetaPercentage * gp.quicksum(AmountProduced[s, r] for r in RawMaterials),\n            f\"BetaLimit_{s+1}\"\n        )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_solvent_blending_optimization()\n    print(result)\n",
    "ground_truth":474250.0
  },
  {
    "task_id":"D036",
    "description":"LogiCorp operates a logistics network that ships two types of products: Basic and Advanced. The raw materials needed to produce these products can be purchased for $5 per unit. Processing 1 unit of raw material requires 2 hours of warehouse labor. Each unit of processed raw material yields 2 units of Basic Product and 3 units of Advanced Product. Basic Product can be sold for $10\/unit, and Advanced Product can be sold for $12\/unit. LogiCorp also has the option of further processing Basic and Advanced Products to produce Premium Basic and Premium Advanced, which sell for $20\/unit and $25\/unit, respectively. Each unit of Basic Product processed further requires an additional 3 hours of warehouse labor and $5 processing cost, yielding 1 unit of Premium Basic. Each unit of Advanced Product processed further requires an additional 4 hours of warehouse labor and $6 processing cost, yielding 1 unit of Premium Advanced. Each year, LogiCorp has 8,000 hours of warehouse labor available and can purchase up to 3,000 units of raw material. How can LogiCorp maximize its profits? Assume that the cost of warehouse labor is a fixed cost, raw materials can only be purchased in whole units.",
    "formulation":"Set:\n1. Product\nThe set of products, \\( P = \\{1, 2, 3, 4\\} \\)  # 1: Basic Product, 2: Advanced Product, 3: Premium Basic, 4: Premium Advanced\n\nParameter:\n1. ProductPerRawMaterial\n[2, 3, 2, 3]\n2. LaborHoursPerRawMaterial\n2\n3. LaborHoursPerProduct\n[0, 0, 3, 4]\n4. SellingPrice\n[10, 12, 20, 25] \n5. ProcessingCost\n[0, 0, 5, 6]\n6. RawMaterialCost\n5\n7. MaxLaborHours\n8000\n8. MaxRawMaterial\n3000\n\nDecision variable:\n1. RawMaterialPurchased\nInteger variable, \\( RawMaterialPurchased \\), the amount of raw material purchased in units.\n2. ProductProduced\nInteger variable, \\( ProductProduced[p] \\forall p \\in P \\), the amount of product \\( p \\) produced in units.\n\nObjective:\n1. Maximize the total profit.\nmax: \\sum_{p \\in P} SellingPrice[p] * ProductProduced[p] - RawMaterialCost * RawMaterialPurchased - \\sum_{p \\in P} ProcessingCost[p] * ProductProduced[p]\n\nConstraint:\n1. Labor hours constraint.\nLaborHoursPerRawMaterial * RawMaterialPurchased + \\sum_{p \\in P} LaborHoursPerProduct[p] * ProductProduced[p] \\leq MaxLaborHours\n2. Raw material constraint.\nRawMaterialPurchased \\leq MaxRawMaterial\n3. Product production constraint.\n\\sum_{p \\in P}ProductProduced[p] == \\sum_{p \\in P}ProductPerRawMaterial[p] * RawMaterialPurchased\n4. Non-negativity constraint.\nProductProduced[p] \\geq 0 \\forall p \\in P\nRawMaterialPurchased \\geq 0\n\nType:\nInteger, Linear, Linear\nILP\n",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_product_manufacturing_optimization(\n    ProductPerRawMaterial=[2, 3, 2, 3],\n    LaborHoursPerRawMaterial=2,\n    LaborHoursPerProduct=[0, 0, 3, 4],\n    SellingPrice=[10, 12, 20, 25],\n    ProcessingCost=[0, 0, 5, 6],\n    RawMaterialCost=5,\n    MaxLaborHours=8000,\n    MaxRawMaterial=3000\n):\n    \"\"\"\n    Models and solves the product manufacturing optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Product Manufacturing Optimization\")\n\n    # Sets\n    Products = range(len(SellingPrice))\n\n    # Decision Variables\n    RawMaterialPurchased = model.addVar(vtype=GRB.INTEGER, name=\"RawMaterialPurchased\")\n    ProductProduced = model.addVars(Products, vtype=GRB.INTEGER, name=\"ProductProduced\")\n\n    # Objective: Maximize profit\n    revenue = gp.quicksum(SellingPrice[p] * ProductProduced[p] for p in Products)\n    raw_material_cost = RawMaterialCost * RawMaterialPurchased\n    processing_cost = gp.quicksum(ProcessingCost[p] * ProductProduced[p] for p in Products)\n\n    model.setObjective(revenue - raw_material_cost - processing_cost, GRB.MAXIMIZE)\n\n    # Constraint 1: Labor hours constraint\n    labor_hours = (LaborHoursPerRawMaterial * RawMaterialPurchased +\n                   gp.quicksum(LaborHoursPerProduct[p] * ProductProduced[p] for p in Products))\n    model.addConstr(labor_hours <= MaxLaborHours, \"LaborHours\")\n\n    # Constraint 2: Raw material constraint\n    model.addConstr(RawMaterialPurchased <= MaxRawMaterial, \"RawMaterial\")\n\n    # Constraint 3: Product production constraint\n    model.addConstr(\n        gp.quicksum(ProductProduced[p] for p in Products) ==\n        gp.quicksum(ProductPerRawMaterial[p] * RawMaterialPurchased for p in Products),\n        \"ProductionBalance\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_product_manufacturing_optimization()\n    print(result)\n",
    "ground_truth":348500.0
  },
  {
    "task_id":"D037",
    "description":"AutoParts Ltd. manufactures three types of automotive components: Engine Block, Transmission, and Brake System. The company sources raw materials at a cost of $60 per unit. Each unit of raw material can be processed into 7 units of Engine Block and 3 units of Transmission. Processing one unit of raw material requires $8 in energy costs and 7 hours of machine time.  \n\nEngine Block can be used in three ways:  \n- Sold directly for $25 per unit.  \n- Processed into 1 unit of Transmission, requiring 4 hours of machine time and $5 in additional costs.  \n- Processed into 1 unit of Brake System, requiring 6 hours of machine time and $10 in additional costs.  \n\nTransmission can be used in two ways:  \n- Sold directly for $35 per unit.  \n- Processed into 1 unit of Brake System, requiring 5 hours of machine time and $12 in additional costs.  \n\nBrake System is sold for $45 per unit. The company has a maximum machine time capacity of 60,000 hours per year. Additionally, there is a contractual obligation to produce at least 4,000 units of Brake System annually. The maximum market demand for each component is as follows:  \n- Engine Block: 20,000 units  \n- Transmission: 15,000 units  \n- Brake System: 12,000 units  \n\nDetermine how AutoParts Ltd. can maximize its annual profit while meeting all constraints.",
    "formulation":"Set:\n1. ComponentType\nThe set of component types, \\( C = \\{1, 2, 3\\} \\)  # 1: Engine Block, 2: Transmission, 3: Brake System\n\nParameter:\n1. RawMaterialCost\n60\n2. ComponentPerRawMaterial\n[7, 3, 0]\n3. EnergyCostPerRawMaterial\n8\n4. MachineTimePerRawMaterial\n7\n5. SellingPrice\n[25, 35, 45]\n6. Engine2TransmissionCost\n5\n7. Engine2TransmissionMachineTime\n4\n8. Engine2BrakeSystemCost\n10\n9. Engine2BrakeSystemMachineTime\n6\n10. Transmission2BrakeSystemCost\n12\n11. Transmission2BrakeSystemMachineTime\n5\n12. MaxMachineTime\n60000\n13. MinBrakeSystemProduction\n4000\n14. MaxDemand\n[20000, 15000, 12000]\n\nDecision variable:\n1. RawMaterialPurchased\nInteger variable, \\( RawMaterialPurchased \\), the amount of raw material purchased in units.\n2. ComponentProducedfromRawMaterial\nInteger variable, \\( ComponentProducedfromRawMaterial[c] \\forall c \\in C \\), the amount of component \\( c \\) produced from raw material in units.\n3. Engine2TransmissionProduced\nInteger variable, \\( Engine2TransmissionProduced \\), the amount of Engine Block processed into Transmission in units.\n4. Engine2BrakeSystemProduced\nInteger variable, \\( Engine2BrakeSystemProduced \\), the amount of Engine Block processed into Brake System in units.\n5. Transmission2BrakeSystemProduced\nInteger variable, \\( Transmission2BrakeSystemProduced \\), the amount of Transmission processed into Brake System in units.\n6. ComponentSold\nInteger variable, \\( ComponentSold[c] \\forall c \\in C \\), the amount of component \\( c \\) sold in units.\n\nObjective:\n1. Maximize the total profit.\nmax: \\sum_{c \\in C} SellingPrice[c] * ComponentSold[c] - RawMaterialCost * RawMaterialPurchased - Engine2TransmissionCost * Engine2TransmissionProduced - Engine2BrakeSystemCost * Engine2BrakeSystemProduced - Transmission2BrakeSystemCost * Transmission2BrakeSystemProduced - EnergyCostPerRawMaterial * RawMaterialPurchased\n\nConstraint:\n1. Machine time constraint.\nMachineTimePerRawMaterial * RawMaterialPurchased + Engine2TransmissionMachineTime * Engine2TransmissionProduced + Engine2BrakeSystemMachineTime * Engine2BrakeSystemProduced + Transmission2BrakeSystemMachineTime * Transmission2BrakeSystemProduced \\leq MaxMachineTime\n2. Minimum Brake System production constraint.\nEngine2BrakeSystemProduced + Transmission2BrakeSystemProduced \\geq MinBrakeSystemProduction\n3. Demand constraint.\nComponentSold[c] \\leq MaxDemand[c] \\forall c \\in C\n4. Production constraint.\nComponentProducedfromRawMaterial[c] == ComponentPerRawMaterial[c] * RawMaterialPurchased \\forall c \\in C\n5. Production constraint - Engine Block.\nComponentSold[0] == ComponentProducedfromRawMaterial[0] -  Engine2TransmissionProduced - Engine2BrakeSystemProduced\n6. Production constraint - Transmission.\nComponentSold[1] == ComponentProducedfromRawMaterial[0] + Engine2TransmissionProduced - Transmission2BrakeSystemProduced\n7. Production constraint - Brake System.\nComponentSold[2] == ComponentProducedfromRawMaterial[0] + Engine2BrakeSystemProduced + Transmission2BrakeSystemProduced\n8. Non-negativity constraint.\nComponentProducedfromRawMaterial[c] \\geq 0 \\forall c \\in C\nComponentSold[c] \\geq 0 \\forall c \\in C\nRawMaterialPurchased \\geq 0\nEngine2TransmissionProduced \\geq 0\nEngine2BrakeSystemProduced \\geq 0\nTransmission2BrakeSystemProduced \\geq 0\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_component_manufacturing_optimization(\n    RawMaterialCost=60,\n    ComponentPerRawMaterial=[7, 3, 0],\n    EnergyCostPerRawMaterial=8,\n    MachineTimePerRawMaterial=7,\n    SellingPrice=[25, 35, 45],\n    Engine2TransmissionCost=5,\n    Engine2TransmissionMachineTime=4,\n    Engine2BrakeSystemCost=10,\n    Engine2BrakeSystemMachineTime=6,\n    Transmission2BrakeSystemCost=12,\n    Transmission2BrakeSystemMachineTime=5,\n    MaxMachineTime=60000,\n    MinBrakeSystemProduction=4000,\n    MaxDemand=[20000, 15000, 12000]\n):\n    \"\"\"\n    Models and solves the component manufacturing and processing optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Component Manufacturing and Processing Optimization\")\n\n    # Sets\n    Components = range(len(SellingPrice))\n\n    # Decision Variables\n    RawMaterialPurchased = model.addVar(vtype=GRB.INTEGER, name=\"RawMaterialPurchased\")\n    ComponentProducedfromRawMaterial = model.addVars(Components, vtype=GRB.INTEGER, name=\"ComponentProducedfromRawMaterial\")\n    Engine2TransmissionProduced = model.addVar(vtype=GRB.INTEGER, name=\"Engine2TransmissionProduced\")\n    Engine2BrakeSystemProduced = model.addVar(vtype=GRB.INTEGER, name=\"Engine2BrakeSystemProduced\")\n    Transmission2BrakeSystemProduced = model.addVar(vtype=GRB.INTEGER, name=\"Transmission2BrakeSystemProduced\")\n    ComponentSold = model.addVars(Components, vtype=GRB.INTEGER, name=\"ComponentSold\")\n\n    # Objective: Maximize total profit\n    revenue = gp.quicksum(SellingPrice[c] * ComponentSold[c] for c in Components)\n    raw_material_cost = (RawMaterialCost + EnergyCostPerRawMaterial) * RawMaterialPurchased\n    processing_cost = (Engine2TransmissionCost * Engine2TransmissionProduced +\n                       Engine2BrakeSystemCost * Engine2BrakeSystemProduced +\n                       Transmission2BrakeSystemCost * Transmission2BrakeSystemProduced)\n\n    model.setObjective(revenue - raw_material_cost - processing_cost, GRB.MAXIMIZE)\n\n    # Constraint 1: Machine time constraint\n    machine_time = (MachineTimePerRawMaterial * RawMaterialPurchased +\n                    Engine2TransmissionMachineTime * Engine2TransmissionProduced +\n                    Engine2BrakeSystemMachineTime * Engine2BrakeSystemProduced +\n                    Transmission2BrakeSystemMachineTime * Transmission2BrakeSystemProduced)\n    model.addConstr(machine_time <= MaxMachineTime, \"MachineTime\")\n\n    # Constraint 2: Minimum Brake System production constraint\n    model.addConstr(\n        Engine2BrakeSystemProduced + Transmission2BrakeSystemProduced >= MinBrakeSystemProduction,\n        \"MinBrakeSystemProduction\"\n    )\n\n    # Constraint 3: Demand constraint\n    for c in Components:\n        model.addConstr(ComponentSold[c] <= MaxDemand[c], f\"MaxDemand_{c}\")\n\n    # Constraint 4: Production constraint - components from raw material\n    for c in Components:\n        model.addConstr(\n            ComponentProducedfromRawMaterial[c] == ComponentPerRawMaterial[c] * RawMaterialPurchased,\n            f\"RawMaterialProduction_{c}\"\n        )\n\n    # Constraint 5: Production constraint - Engine Block\n    model.addConstr(\n        ComponentSold[0] == ComponentProducedfromRawMaterial[0] - Engine2TransmissionProduced - Engine2BrakeSystemProduced,\n        \"EngineBlockBalance\"\n    )\n\n    # Constraint 6: Production constraint - Transmission\n    model.addConstr(\n        ComponentSold[1] == ComponentProducedfromRawMaterial[1] + Engine2TransmissionProduced - Transmission2BrakeSystemProduced,\n        \"TransmissionBalance\"\n    )\n\n    # Constraint 7: Production constraint - Brake System\n    model.addConstr(\n        ComponentSold[2] == ComponentProducedfromRawMaterial[2] + Engine2BrakeSystemProduced + Transmission2BrakeSystemProduced,\n        \"BrakeSystemBalance\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_component_manufacturing_optimization()\n    print(result)\n",
    "ground_truth":851452.0
  },
  {
    "task_id":"D038",
    "description":"HealthSupply Co. manages a medical supply chain that must fulfill demand for two types of products, Vaccine X and Vaccine Y, over the next two quarters, with demands of 100 doses of Vaccine X and 200 doses of Vaccine Y in Quarter 1, and 300 doses of Vaccine X and 100 doses of Vaccine Y in Quarter 2. The company can produce a maximum of 1,500 doses per quarter, with each dose of Vaccine X requiring 4 liters of raw biochemical material and each dose of Vaccine Y requiring 3 liters. The cost of raw material is $300 per liter in Quarter 1 and $450 per liter in Quarter 2, with a maximum purchase limit of 2,500 liters per quarter, and material can only be used in the quarter it is purchased. At the start of Quarter 1, the company has an inventory of 200 doses of Vaccine X and 300 doses of Vaccine Y, and a storage cost of $100 per dose is assessed at the end of each quarter for remaining inventory. Additionally, the company must meet a regulatory requirement that the vaccines produced each quarter have an average efficacy rate of at least 90%, with Vaccine X having an efficacy rate of 85% and Vaccine Y having an efficacy rate of 95%. How to meet the demand and regulatory requirements at minimum cost, including raw material and storage costs.",
    "formulation":"Set:\n1. Product\nThe set of products, \\( P = \\{1, 2\\} \\)  # 1: Vaccine X, 2: Vaccine Y\n2. Quarter\nThe set of quarters, \\( Q = \\{1, 2\\} \\)  # 1: Quarter 1, 2: Quarter 2\n\nParameter:\n1. Demand\n[[100, 200], [300, 100]] # Demand for each product in each quarter\n2. MaxProductionPerQuarter\n[1500, 1500]\n3. RawMaterialCost\n[300, 450]\n4. RawMaterialPerProduct\n[4, 3]\n5. MaxRawMaterialPurchase\n[2500, 2500]\n6. InitialInventory\n[[200, 300], [0, 0]] # Initial inventory for each product in each quarter\n7. StorageCost\n[100, 100] # Storage cost per dose at the end of each quarter\n8. EfficacyRate\n[0.85, 0.95] # Efficacy rate for each product\n9. RegulatoryEfficacyRate\n0.90\n\nDecision variable:\n1. RawMaterialPurchased\nContinous variable, \\( RawMaterialPurchased[q] \\forall q \\in Q \\), the amount of raw material purchased in quarter \\( q \\) in liters.\n2. ProductProduced\nInteger variable, \\( ProductProduced[p][q] \\forall p \\in P, q \\in Q \\), the amount of product \\( p \\) produced in quarter \\( q \\) in doses.\n3. ProductStorage\nInteger variable, \\( ProductStorage[p][q] \\forall p \\in P, q \\in Q \\), the amount of product \\( p \\) stored at the end of quarter \\( q \\) in doses.\n\nObjective:\n1. Minimize the total cost.\nmin: \\sum_{q \\in Q} (RawMaterialCost[q] * RawMaterialPurchased[q] + StorageCost[q] * ProductStorage[p][q] \\forall p \\in P)\n\nConstraint:\n1. Demand constraint.\nProductProduced[p][1] + InitialInventory[p] - ProductStorage[p][1] \\geq Demand[p][1] \\forall p \\in P\nProductProduced[p][q] + ProductStorage[p][q-1] - ProductStorage[p][q] \\geq Demand[p][q] \\forall p \\in P, q \\in Q\/{1}\n2. Production capacity constraint.\n\\sum_{p \\in P} ProductProduced[p][q] \\leq MaxProductionPerQuarter[q] \\forall q \\in Q\n3. Raw material constraint.\n\\sum_{p \\in P} RawMaterialPerProduct[p] * ProductProduced[p][q] \\leq RawMaterialPurchased[q] \\forall q \\in Q\n4. Raw material purchase limit constraint.\nRawMaterialPurchased[q] \\leq MaxRawMaterialPurchase[q] \\forall q \\in Q\n5. Regulatory efficacy constraint.\n\\sum_{p \\in P} EfficacyRate[p] * ProductProduced[p][q] \\geq \\sum_{p \\in P} ProductProduced[p][q] * RegulatoryEfficacyRate \\forall q \\in Q\n6. Non-negativity constraint.\nProductProduced[p][q] \\geq 0 \\forall p \\in P, q \\in Q\nProductStorage[p][q] \\geq 0 \\forall p \\in P, q \\in Q\nRawMaterialPurchased[q] \\geq 0 \\forall q \\in Q\n\nType:\nMixed, Linear, Linear\nMILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_vaccine_production_optimization(\n    Demand=[[100, 200], [300, 100]],\n    MaxProductionPerQuarter=[1500, 1500],\n    RawMaterialCost=[300, 450],\n    RawMaterialPerProduct=[4, 3],\n    MaxRawMaterialPurchase=[2500, 2500],\n    InitialInventory=[200, 300],\n    StorageCost=[100, 100],\n    EfficacyRate=[0.85, 0.95],\n    RegulatoryEfficacyRate=0.90\n):\n    \"\"\"\n    Models and solves the vaccine production optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"HealthSupply_Vaccine_Production\")\n\n    # Sets\n    P = range(len(EfficacyRate))  # Products\n    Q = range(len(MaxProductionPerQuarter))  # Quarters\n\n    # Decision Variables\n    RawMaterialPurchased = model.addVars(Q, lb=0.0, name=\"RawMaterialPurchased\")\n    ProductProduced = model.addVars(P, Q, vtype=GRB.INTEGER, lb=0, name=\"ProductProduced\")\n    ProductStorage = model.addVars(P, Q, vtype=GRB.INTEGER, lb=0, name=\"ProductStorage\")\n\n    # Objective Function: Minimize total cost\n    raw_material_cost = gp.quicksum(RawMaterialCost[q] * RawMaterialPurchased[q] for q in Q)\n    storage_cost = gp.quicksum(StorageCost[q] * ProductStorage[p, q] for p in P for q in Q)\n    total_cost = raw_material_cost + storage_cost\n\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # Constraints\n    # 1. Demand constraints\n    for p in P:\n        # First quarter uses initial inventory\n        model.addConstr(\n            ProductProduced[p, 0] + InitialInventory[p] - ProductStorage[p, 0] >= Demand[0][p],\n            f\"Demand_P{p}_Q1\"\n        )\n\n    for p in P:\n        # Second quarter uses storage from first quarter\n        model.addConstr(\n            ProductProduced[p, 1] + ProductStorage[p, 0] - ProductStorage[p, 1] >= Demand[1][p],\n            f\"Demand_P{p}_Q2\"\n        )\n\n    # 2. Production capacity constraints\n    for q in Q:\n        model.addConstr(\n            gp.quicksum(ProductProduced[p, q] for p in P) <= MaxProductionPerQuarter[q],\n            f\"ProductionCapacity_Q{q+1}\"\n        )\n\n    # 3. Raw material constraints\n    for q in Q:\n        model.addConstr(\n            gp.quicksum(RawMaterialPerProduct[p] * ProductProduced[p, q] for p in P) <= RawMaterialPurchased[q],\n            f\"RawMaterial_Q{q+1}\"\n        )\n\n    # 4. Raw material purchase limit constraints\n    for q in Q:\n        model.addConstr(\n            RawMaterialPurchased[q] <= MaxRawMaterialPurchase[q],\n            f\"RawMaterialPurchaseLimit_Q{q+1}\"\n        )\n\n    # 5. Regulatory efficacy constraints\n    for q in Q:\n        total_produced = gp.quicksum(ProductProduced[p, q] for p in P)\n        weighted_efficacy = gp.quicksum(EfficacyRate[p] * ProductProduced[p, q] for p in P)\n\n        model.addConstr(\n            weighted_efficacy >= RegulatoryEfficacyRate * total_produced,\n            f\"RegulatoryEfficacy_Q{q+1}\"\n        )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_vaccine_production_optimization()\n    print(result)\n",
    "ground_truth":460000.0
  },
  {
    "task_id":"D039",
    "description":"SupplyChain Logistics Co. is responsible for distributing two types of products, Product A and Product B. The company needs to meet the market demand for these two products across four quarters of the year (Q1, Q2, Q3, Q4) while aiming to minimize the total annual operating costs, which include labor costs and inventory holding costs. The demand for Product A in the four quarters is 800, 600, 700, and 900 units, respectively; the demand for Product B in the four quarters is 500, 400, 600, and 300 units, respectively.Workers operate on a fixed rotation schedule: each worker works for three consecutive quarters and then takes one quarter off. To ensure that workers take their leave in the same quarter each year, workers are divided into four groups, taking leave in Q1, Q2, Q3, and Q4, respectively. The company must decide the number of workers in each group, and this number remains constant throughout the year. Each on-duty worker, in a working quarter, can only choose to handle one type of product: either a maximum of 60 units of Product A or a maximum of 40 units of Product B. They cannot split their capacity to handle both products within the same quarter. The wage for each worker per working quarter is $600, so the annual wage for each worker is $1800.At the end of each quarter, an inventory holding cost of $70 per unit is incurred for any remaining product (either A or B) in the warehouse. It is assumed that at the beginning of the first quarter of the first year, the initial inventory for both Product A and Product B is 0 units. To simplify the model, it is assumed that at the end of the fourth quarter each year, the inventory for both Product A and Product B must be 0 units.The company's optimization objective is: to determine the number of workers in each rotation group and how to assign on-duty workers to produce Product A and Product B each quarter, in order to meet all quarterly product demands and minimize the total annual operating costs (including the total wages for all registered workers and the total inventory holding costs incurred at the end of all quarters).",
    "formulation":"Set:\n1. Product\nThe set of products, \\( P = \\{1, 2\\} \\)  # 1: A, 2: B\n2. Quarter\nThe set of quarters, \\( Q = \\{1, 2, 3, 4\\} \\)\n3. WorkerGroup\nThe set of worker groups, \\( G = \\{1, 2, 3, 4\\} \\) \n\nParameter:\n1. HandleProductPerWorkerPerQuarter\n[60, 40]\n2. WorkerCostPerYear\n1800\n3. InventoryHoldingCost\n70\n4. Demand\n[[800, 600, 700, 900], [500, 400, 600, 300]]\n\nDecision variable:\n1. WorkersInGroup\nInteger variable, \\( WorkersInGroup[g] \\forall g \\in G \\), the number of workers in group \\( g \\).\n2. ProductProduced\nInteger variable, \\( ProductProduced[p][q] \\forall p \\in P, q \\in Q \\), the amount of product \\( p \\) produced in quarter \\( q \\).\n3. ProductStorage\nInteger variable, \\( ProductStorage[p][q] \\forall p \\in P, q \\in Q \\), the amount of product \\( p \\) stored at the end of quarter \\( q \\).\n4. WorkersOnDuty\nInteger variable, \\( WorkersOnDuty[g][p][q] \\forall g \\in G, p \\in P, q \\in Q \\), the number of workers in group \\( g \\) on duty for product \\( p \\) in quarter \\( q \\).\n\nObjective:\n1. Minimize the total cost.\nmin: \\sum_{g \\in G} (WorkersInGroup[g] * WorkerCostPerYear) + \\sum_{p \\in P, q \\in Q} (ProductStorage[p][q] * InventoryHoldingCost)\n\nConstraint:\n1. Demand constraint.\nProductProduced[p][1] - ProductStorage[p][1] \\geq Demand[p][1] \\forall p \\in P\nProductProduced[p][q] + ProductStorage[p][q-1] - ProductStorage[p][q] \\geq Demand[p][q] \\forall p \\in P, q \\in Q\/{1}\n2. Production handling constraint.\n\\sum_{g \\in G} WorkersOnDuty[g][p][q] * HandleProductPerWorkerPerQuarter[p] \\geq ProductProduced[p][q] \\forall p \\in P, q \\in Q\n3. Worker group constraint.\n\\sum_{p \\in P} WorkersOnDuty[g][p][q] \\leq WorkersInGroup[g] \\forall g \\in G, q \\in Q\n4. Worker off-duty constraint.\nWorkersOnDuty[g][p][g] = 0 \\forall g \\in G, p \\in P\n5. Inventory constraint.\nProductStorage[p][1] = 0 \\forall p \\in P\nProductStorage[p][4] = 0 \\forall p \\in P  # End of year inventory must be 0\n4. Non-negativity constraint.\nProductProduced[p][q] \\geq 0 \\forall p \\in P, q \\in Q\nProductStorage[p][q] \\geq 0 \\forall p \\in P, q \\in Q\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_workforce_planning_optimization(\n    HandleProductPerWorkerPerQuarter=[60, 40],\n    WorkerCostPerYear=1800,\n    InventoryHoldingCost=70,\n    Demand=[[800, 600, 700, 900], [500, 400, 600, 300]]\n):\n    \"\"\"\n    Models and solves the supply chain logistics and workforce planning problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"SupplyChain_Logistics_Workforce_Planning\")\n\n    # Sets\n    P = range(len(HandleProductPerWorkerPerQuarter))  # Products\n    Q = range(len(Demand[0]))  # Quarters\n    G = range(len(Demand[0]))  # Worker Groups\n\n    # Decision Variables\n    WorkersInGroup = model.addVars(G, vtype=GRB.INTEGER, lb=0, name=\"WorkersInGroup\")\n    ProductProduced = model.addVars(P, Q, vtype=GRB.INTEGER, lb=0, name=\"ProductProduced\")\n    ProductStorage = model.addVars(P, Q, vtype=GRB.INTEGER, lb=0, name=\"ProductStorage\")\n    WorkersOnDuty = model.addVars(G, P, Q, vtype=GRB.INTEGER, lb=0, name=\"WorkersOnDuty\")\n\n    # Objective Function: Minimize total cost\n    labor_cost = gp.quicksum(WorkersInGroup[g] * WorkerCostPerYear for g in G)\n    inventory_cost = gp.quicksum(ProductStorage[p, q] * InventoryHoldingCost for p in P for q in Q)\n    total_cost = labor_cost + inventory_cost\n\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # Constraints\n    # 1. Demand constraints\n    for p in P:\n        # First quarter (no previous inventory)\n        model.addConstr(\n            ProductProduced[p, 0] - ProductStorage[p, 0] >= Demand[p][0],\n            f\"Demand_P{p}_Q1\"\n        )\n\n        # Subsequent quarters\n        for q in range(1, 4):\n            model.addConstr(\n                ProductProduced[p, q] + ProductStorage[p, q - 1] - ProductStorage[p, q] >= Demand[p][q],\n                f\"Demand_P{p}_Q{q + 1}\"\n            )\n\n    # 2. Production handling constraints\n    for p in P:\n        for q in Q:\n            model.addConstr(\n                gp.quicksum(WorkersOnDuty[g, p, q] * HandleProductPerWorkerPerQuarter[p] for g in G) >= ProductProduced[p, q],\n                f\"Production_P{p}_Q{q + 1}\"\n            )\n\n    # 3. Worker group constraints\n    for g in G:\n        for q in Q:\n            # Workers in group g are off-duty in quarter (g+1)%4\n            if q == g:\n                # Workers in this group are on leave this quarter\n                for p in P:\n                    model.addConstr(WorkersOnDuty[g, p, q] == 0, f\"OffDuty_G{g + 1}_Q{q + 1}\")\n            else:\n                # Workers on duty can only handle one product type per quarter\n                model.addConstr(\n                    gp.quicksum(WorkersOnDuty[g, p, q] for p in P) <= WorkersInGroup[g],\n                    f\"WorkerCapacity_G{g + 1}_Q{q + 1}\"\n                )\n\n    # 4. End of year inventory must be zero\n    for p in P:\n        model.addConstr(ProductStorage[p, 3] == 0, f\"EndYearInventory_P{p}\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_workforce_planning_optimization()\n    print(result)\n",
    "ground_truth":59400.0
  },
  {
    "task_id":"D040",
    "description":"CraftBrew Inc. operates two breweries located in Portland and Asheville. The Portland brewery can produce up to 200,000 gallons of craft beer annually, while the Asheville brewery can produce up to 300,000 gallons. Once brewed, the beer is shipped to two distribution hubs: Seattle and Atlanta. Each distribution hub can handle up to 400,000 gallons per year. Due to differences in shipping and production costs, the profit (in dollars) per thousand gallons shipped depends on the brewery and the destination hub (see Table 1). CraftBrew Inc. is considering expanding the capacity of each brewery. Each thousand gallons of annual production capacity added will cost $1,000 for the Portland brewery and $1,500 for the Asheville brewery. How can CraftBrew Inc. maximize its profits, less expansion costs, over a three-year period?  \n\nTable 1:\n\n| Brewery   | Destination Hub | Profit per Thousand Gallons ($) |  \n|-----------|------------------|----------------------------------|  \n| Portland  | Seattle          | 500                              |  \n| Portland  | Atlanta          | 450                              |  \n| Asheville | Seattle          | 480                              |  \n| Asheville | Atlanta          | 520                              |",
    "formulation":"Set:\n1. Brewery\nThe set of breweries, \\( B = \\{1, 2\\} \\)  # 1: Portland, 2: Asheville\n2. DestinationHub\nThe set of destination hubs, \\( H = \\{1, 2\\} \\)  # 1: Seattle, 2: Atlanta\n3. Year\nThe set of years, \\( Y = \\{1, 2, 3\\} \\)\n\nParameter:\n1. ProductionCapacity\n[200000, 300000]  # in gallons\n2. ShippingCapacity\n[400000, 400000]  # in gallons\n3. ProfitPerThousandGallons\n[[500, 450], [480, 520]]  # in dollars per thousand gallons\n4. ExpansionCost\n[1000, 1500]  # in dollars per thousand gallons\n\nDecision variable:\n1. ProductionCapacityAdded\nContinous variable, \\( ProductionCapacityAdded[b] \\forall b \\in B \\), the amount of production capacity added for brewery \\( b \\) (in thousands of gallons).\n2. ProductionFromBrewery2Hub\nContinous variable, \\( ProductionFromBrewery2Hub[b][h][y] \\forall b \\in B, h \\in H, y \\in Y \\), the amount of product shipped from brewery \\( b \\) to hub \\( h \\) in year \\( y \\) (in thousands of gallons).\n\nObjective:\n1. Maximize the total profit.\nmax: \\sum_{b \\in B, h \\in H, y \\in Y} (ProductionFromBrewery2Hub[b][h][y] * ProfitPerThousandGallons[b][h]) - \\sum_{b \\in B} (ProductionCapacityAdded[b] * ExpansionCost[b])\n\nConstraint:\n1. Production capacity constraint.\n\\sum_{h \\in H} ProductionFromBrewery2Hub[b][h][y] \\leq (ProductionCapacity[b] + ProductionCapacityAdded[b]) \\forall b \\in B, y \\in Y\n2. Shipping capacity constraint.\n\\sum_{b \\in B} ProductionFromBrewery2Hub[b][h][y] \\leq ShippingCapacity[h] \\forall h \\in H, y \\in Y\n3. Non-negativity constraint.\nProductionCapacityAdded[b] \\geq 0 \\forall b \\in B\nProductionFromBrewery2Hub[b][h][y] \\geq 0 \\forall b \\in B, h \\in H, y \\in Y\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_brewery_optimization(\n    ProductionCapacity=[200, 300],\n    ShippingCapacity=[400, 400],\n    ProfitPerThousandGallons=[[500, 450], [480, 520]],\n    ExpansionCost=[1000, 1500]\n):\n    \"\"\"\n    Models and solves the brewery production and distribution optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Brewery_Production_Distribution_Optimization\")\n\n    # Sets\n    B = range(len(ProductionCapacity))  # Breweries\n    H = range(len(ShippingCapacity))  # Destination Hubs\n    Y = range(3)  # Years\n\n    # Decision Variables\n    ProductionCapacityAdded = model.addVars(B, lb=0.0, name=\"ProductionCapacityAdded\")\n    ProductionFromBrewery2Hub = model.addVars(B, H, Y, lb=0.0, name=\"ProductionFromBrewery2Hub\")\n\n    # Objective Function: Maximize total profit\n    profit = gp.quicksum(\n        ProductionFromBrewery2Hub[b, h, y] * ProfitPerThousandGallons[b][h]\n        for b in B for h in H for y in Y\n    )\n    expansion_costs = gp.quicksum(\n        ProductionCapacityAdded[b] * ExpansionCost[b]\n        for b in B\n    )\n    total_profit = profit - expansion_costs\n\n    model.setObjective(total_profit, GRB.MAXIMIZE)\n\n    # Constraints\n    # 1. Production capacity constraint\n    for b in B:\n        for y in Y:\n            model.addConstr(\n                gp.quicksum(ProductionFromBrewery2Hub[b, h, y] for h in H) <=\n                ProductionCapacity[b] + ProductionCapacityAdded[b],\n                f\"ProductionCapacity_B{b + 1}_Y{y + 1}\"\n            )\n\n    # 2. Shipping capacity constraint\n    for h in H:\n        for y in Y:\n            model.addConstr(\n                gp.quicksum(ProductionFromBrewery2Hub[b, h, y] for b in B) <= ShippingCapacity[h],\n                f\"ShippingCapacity_H{h + 1}_Y{y + 1}\"\n            )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_brewery_optimization()\n    print(result)\n",
    "ground_truth":903000.0
  },
  {
    "task_id":"D041",
    "description":"LogiFlow Solutions manages the distribution of two types of packages: Standard and Express. Each package must be transported entirely by air freight or entirely by ground shipping. A total of 150 cubic meters of air freight capacity and 210 cubic meters of ground shipping capacity are available. A Standard package requires either 17 cubic meters of air freight or 30 cubic meters of ground shipping, while an Express package requires either 5 cubic meters of air freight or 13 cubic meters of ground shipping. Each Standard package generates $40 in revenue, and each Express package generates $15 in revenue. How to maximize LogiFlow Solutions' total revenue from package distribution?",
    "formulation":"Set: \n1. Package\nThe set of packages, \\( P = \\{1, 2\\} \\)  # 1: Standard, 2: Express\n2. ShippingMethod\nThe set of shipping methods, \\( S = \\{1, 2\\} \\)  # 1: Air freight, 2: Ground shipping\n\nParameter:\n1. AirFreightCapacity\n150  # in cubic meters\n2. GroundShippingCapacity\n210  # in cubic meters\n3. AirFreightRequirement\n[17, 5]  # in cubic meters\n4. GroundShippingRequirement\n[30, 13]  # in cubic meters\n5. RevenuePerPackage\n[40, 15]  # in dollars\n\nDecision variable:\n1. PackagesShipped\nInteger variable, \\( PackagesShipped[p][s] \\forall p \\in P, s \\in S \\), the number of packages shipped for package type \\( p \\) using shipping method \\( s \\).\n\nObjective:\n1. Maximize the total revenue.\nmax: \\sum_{p \\in P, s \\in S} (PackagesShipped[p][s] * RevenuePerPackage[p])\n\nConstraint:\n1. Air freight capacity constraint.\n\\sum_{p \\in P} (PackagesShipped[p][1] * AirFreightRequirement[p]) \\leq AirFreightCapacity\n2. Ground shipping capacity constraint.\n\\sum_{p \\in P} (PackagesShipped[p][2] * GroundShippingRequirement[p]) \\leq GroundShippingCapacity\n3. Non-negativity constraint.\nPackagesShipped[p][s] \\geq 0 \\forall p \\in P, s \\in S\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_package_shipping_optimization(\n    AirFreightCapacity=150,\n    GroundShippingCapacity=210,\n    AirFreightRequirement=[17, 5],\n    GroundShippingRequirement=[30, 13],\n    RevenuePerPackage=[40, 15]\n):\n    \"\"\"\n    Models and solves the package shipping optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Package_Shipping_Optimization\")\n\n    # Sets\n    P = range(len(RevenuePerPackage))  # Package types\n    S = range(2)  # Shipping methods (0: Air freight, 1: Ground shipping)\n\n    # Decision Variables\n    PackagesShipped = model.addVars(P, S, vtype=GRB.INTEGER, lb=0, name=\"PackagesShipped\")\n\n    # Objective Function: Maximize total revenue\n    revenue = gp.quicksum(PackagesShipped[p, s] * RevenuePerPackage[p] for p in P for s in S)\n    model.setObjective(revenue, GRB.MAXIMIZE)\n\n    # Constraints\n    # 1. Air freight capacity constraint\n    model.addConstr(\n        gp.quicksum(PackagesShipped[p, 0] * AirFreightRequirement[p] for p in P) <= AirFreightCapacity,\n        \"AirFreightCapacity\"\n    )\n\n    # 2. Ground shipping capacity constraint\n    model.addConstr(\n        gp.quicksum(PackagesShipped[p, 1] * GroundShippingRequirement[p] for p in P) <= GroundShippingCapacity,\n        \"GroundShippingCapacity\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_package_shipping_optimization()\n    print(result)\n",
    "ground_truth":730.0
  },
  {
    "task_id":"D042",
    "description":"TransitLogix Co. offers two competing shipping services: Priority and Economy. The company aims to sell these services to two distinct customer segments: small businesses and large enterprises. The perceived value of each service by the customer segments is shown in the table below: \n\n| Customer Segment | Value of Priority Service ($) | Value of Economy Service ($) |  \n|-------------------|--------------------------------|-------------------------------|  \n| Small Businesses  | 120                            | 80                            |  \n| Large Enterprises | 90                             | 110                           |  \n\nEach customer will choose either Priority or Economy, but not both. If customers believe that the value of priority service exceeding its price is greater than or equal to the value of economic service exceeding its price, they will choose priority service. Similarly, If customers believe that the value of economic service exceeding its price is greater than or equal to the value of priority service exceeding its price, they will choose economic service. The small business segment has 1,000 potential customers, and the large enterprise segment has 1,500 potential customers. TransitLogix wants to set prices for each service to ensure that small businesses choose Priority and large enterprises choose Economy. And to maintain a clear differentiation and brand image, TransitLogix has decided that the price of the Priority service must be at least $15 higher than the price of the Economy service. How can TransitLogix maximize its total revenue from these two customer segments?",
    "formulation":"Set:\n1. Segment\nThe set of customer segments, \\( S = \\{1, 2\\} \\)  # 1: Small Businesses, 2: Large Enterprises\n2. Service\nThe set of services, \\( T = \\{1, 2\\} \\)  # 1: Priority, 2: Economy\n\nParameter:\n1. PriorityServiceValue\n[120, 90]  # in dollars\n2. EconomyServiceValue\n[80, 110]  # in dollars\n3. SmallBusinessPotential\n1000  # number of customers\n4. LargeEnterprisePotential\n1500  # number of customers\n\nDecision Variable:\n1. PriorityPrice\nContinous variable, \\( PriorityPrice \\) \n2. EconomyPrice\nContinous variable, \\( EconomyPrice \\)  \n\nObjective:\n1. Maximize the total revenue.\nmax: (SmallBusinessPotential * PriorityPrice) + (LargeEnterprisePotential * EconomyPrice)\n\nConstraint:\n1. Small business chooses Priority.\nPriorityServiceValue[1] - PriorityPrice \\geq EconomyServiceValue[1] - EconomyPrice\n2. Large enterprise chooses Economy.\nPriorityServiceValue[2] - PriorityPrice \\leq EconomyServiceValue[2] - EconomyPrice\n3. price difference constraint.\nPriorityPrice - EconomyPrice >= 15\n4. bound constraint.\nPriorityPrice >= 0\nEconomyPrice >= 0\nPriorityPrice <= PriorityServiceValue[1]\nEconomyPrice <= EconomyServiceValue[2]\n\nType:\nContinous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_pricing_optimization(\n    priority_service_value=[120, 90],\n    economy_service_value=[80, 110],\n    small_business_potential=1000,\n    large_enterprise_potential=1500\n):\n    \"\"\"\n    Models and solves the pricing optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"pricing_optimization\")\n\n    # Decision Variables\n    priority_price = model.addVar(name=\"PriorityPrice\", lb=0, ub=priority_service_value[0])\n    economy_price = model.addVar(name=\"EconomyPrice\", lb=0, ub=economy_service_value[1])\n\n    # Objective: Maximize total revenue\n    model.setObjective(\n        small_business_potential * priority_price + large_enterprise_potential * economy_price,\n        GRB.MAXIMIZE\n    )\n\n    # Constraint 1: Small business chooses Priority\n    model.addConstr(\n        priority_service_value[0] - priority_price >= economy_service_value[0] - economy_price,\n        \"small_business_preference\"\n    )\n\n    # Constraint 2: Large enterprise chooses Economy\n    model.addConstr(\n        priority_service_value[1] - priority_price <= economy_service_value[1] - economy_price,\n        \"large_enterprise_preference\"\n    )\n\n    # Constraint 3: Price of Priority service must be at least $15 higher than Economy service\n    model.addConstr(\n        priority_price - economy_price >= 15,\n        \"price_difference\"\n    )\n\n    # Solve the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_pricing_optimization()\n    print(result)\n",
    "ground_truth":277500.0
  },
  {
    "task_id":"D043",
    "description":"CargoLink Logistics operates two types of delivery vehicles: Type X and Type Y. New environmental regulations require that the average carbon emissions of all vehicles deployed over the next three years cannot exceed 40 grams per kilometer annually. Each Type X vehicle generates $25,000 in revenue, costs $18,000 to operate, and emits 70 grams of carbon per kilometer. Each Type Y vehicle generates $20,000 in revenue, costs $16,000 to operate, and emits 30 grams of carbon per kilometer. Due to fleet capacity constraints, CargoLink can deploy a maximum of 400 vehicles each year. The maximum number of each vehicle type that can be deployed annually is shown in the table below. For example, at most, 350 Type X vehicles can be deployed in year 3. How can CargoLink Logistics maximize its total profit over the next three years while complying with environmental regulations?\n\n| Year | Maximum Type X Vehicles | Maximum Type Y Vehicles |  \n|------|--------------------------|--------------------------|  \n| 1    | 300                      | 250                      |  \n| 2    | 320                      | 280                      |  \n| 3    | 350                      | 300                      |",
    "formulation":"Set:\n1. VehicleType\nThe set of vehicle types, \\( V = \\{1, 2\\} \\)  # 1: Type X, 2: Type Y\n2. Year\nThe set of years, \\( Y = \\{1, 2, 3\\} \\)  # 1: Year 1, 2: Year 2, 3: Year 3\n\nParameter:\n1. AvgCarbonEmissionLimit\n40  # in grams per kilometer\n2. RevenuePerVehicle\n[25000, 20000]  # in dollars\n3. OperatingCostPerVehicle\n[18000, 16000]  # in dollars\n4. CarbonEmissionPerVehicle\n[70, 30]  # in grams per kilometer\n5. MaxVehiclesPerYear\n[[300, 320, 350], [250, 280, 300]] \n6. MaxTotalVehicles\n400  # in vehicles\n\nDecision variable:\n1. VehiclesDeployed\nInteger variable, \\( VehiclesDeployed[v][y] \\forall v \\in V, y \\in Y \\), the number of vehicles of type \\( v \\) deployed in year \\( y \\).\n\nObjective:\n1. Maximize the total profit.\nmax: \\sum_{v \\in V, y \\in Y} (RevenuePerVehicle[v] * VehiclesDeployed[v][y] - OperatingCostPerVehicle[v] * VehiclesDeployed[v][y])\n\nConstraint:\n1. Carbon emissions constraint.\n\\sum_{v \\in V} (CarbonEmissionPerVehicle[v] * VehiclesDeployed[v][y]) \\leq AvgCarbonEmissionLimit * \\sum_{v \\in V} VehiclesDeployed[v][y] \\forall y \\in Y\n2. Fleet capacity constraint.\n\\sum_{v \\in V} VehiclesDeployed[v][y] \\leq MaxTotalVehicles \\forall y \\in Y\n3. Yearly vehicle limit constraint.\n\\sum_{v \\in V} VehiclesDeployed[v][y] \\leq MaxVehiclesPerYear[v][y] \\forall v \\in V, y \\in Y\n4. Non-negativity constraint.\nVehiclesDeployed[v][y] \\geq 0 \\forall v \\in V, y \\in Y\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_fleet_optimization(\n    avg_carbon_emission_limit=40,\n    revenue_per_vehicle=[25000, 20000],\n    operating_cost_per_vehicle=[18000, 16000],\n    carbon_emission_per_vehicle=[70, 30],\n    max_vehicles_per_year=[[300, 320, 350], [250, 280, 300]],\n    max_total_vehicles=400\n):\n    \"\"\"\n    Models and solves the fleet optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Fleet_Optimization\")\n\n    # Define sets\n    V = range(2)  # Vehicle types: 0=Type X, 1=Type Y\n    Y = range(3)  # Years: 0=Year 1, 1=Year 2, 2=Year 3\n\n    # Decision variables\n    vehicles_deployed = {}\n    for v in V:\n        for y in Y:\n            vehicles_deployed[v, y] = model.addVar(\n                vtype=GRB.INTEGER,\n                lb=0,\n                name=f\"VehiclesDeployed_{v}_{y}\"\n            )\n\n    # Objective function: Maximize total profit\n    profit = gp.quicksum(\n        (revenue_per_vehicle[v] - operating_cost_per_vehicle[v]) * vehicles_deployed[v, y]\n        for v in V for y in Y\n    )\n    model.setObjective(profit, GRB.MAXIMIZE)\n\n    # Constraint 1: Carbon emissions constraint\n    for y in Y:\n        total_vehicles = gp.quicksum(vehicles_deployed[v, y] for v in V)\n        total_emissions = gp.quicksum(carbon_emission_per_vehicle[v] * vehicles_deployed[v, y] for v in V)\n        model.addConstr(\n            total_emissions <= avg_carbon_emission_limit * total_vehicles,\n            name=f\"CarbonEmissions_Year_{y}\"\n        )\n\n    # Constraint 2: Fleet capacity constraint\n    for y in Y:\n        model.addConstr(\n            gp.quicksum(vehicles_deployed[v, y] for v in V) <= max_total_vehicles,\n            name=f\"FleetCapacity_Year_{y}\"\n        )\n\n    # Constraint 3: Yearly vehicle limit constraint\n    for v in V:\n        for y in Y:\n            model.addConstr(\n                vehicles_deployed[v, y] <= max_vehicles_per_year[v][y],\n                name=f\"YearlyVehicleLimit_Type_{v}_Year_{y}\"\n            )\n\n    # Solve the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_fleet_optimization()\n    print(result)\n",
    "ground_truth":5252000.0
  },
  {
    "task_id":"D044",
    "description":"You are in charge of GreenTech Manufacturing, a company that produces eco-friendly packaging materials from recycled paper. The company produces two types of packaging: Premium and Standard. Premium packaging sells for $15 per ton and must have an average quality score of at least 9. Standard packaging sells for $8 per ton and must have an average quality score of at least 7. The maximum demand is 2,500 tons of Premium packaging and 800 tons of Standard packaging per month. \n\nRecycled paper can be processed using one of three methods. The yield and cost per ton for each method are shown in the table below. For example, processing one ton of recycled paper using Method 1 costs $4.20 and yields 0.3 tons of quality score 6, 0.4 tons of quality score 8, and 0.3 tons of quality score 10. These costs include the expenses of acquiring the recycled paper. Before being converted into packaging materials, quality scores 6 and 8 can be enhanced through a refinement process. For $1.20 per ton, one ton of quality score 6 can be upgraded to quality score 8. For $1.80 per ton, one ton of quality score 8 can be upgraded to quality score 10. How can GreenTech Manufacturing maximize its monthly profit while meeting quality and demand requirements?\n\n| Processing Method | Cost per Ton ($) | Yield (Quality 6) | Yield (Quality 8) | Yield (Quality 10) |  \n|--------------------|-------------------|--------------------|--------------------|---------------------|  \n| Method 1           | 4.20              | 0.3                | 0.4                | 0.3                 |  \n| Method 2           | 3.80              | 0.5                | 0.3                | 0.2                 |  \n| Method 3           | 4.50              | 0.2                | 0.5                | 0.3                 |",
    "formulation":"Set:\n1. Packaging\nThe set of packaging types, \\( P = \\{1, 2\\} \\)  # 1: Premium, 2: Standard\n2. Method\nThe set of production methods, \\( M = \\{1, 2, 3\\} \\)  \n3. YieldQuality\nThe set of quality scores, \\( Q = \\{1, 2, 3\\} \\) # 1: Quality 6, 2: Quality 8, 3: Quality 10\n\nParameter:\n1. CostPerTonPerMethod\n[4.20, 3.80, 4.50]  # in dollars\n2. YieldPerMethod\n[[0.3, 0.4, 0.3], [0.5, 0.3, 0.2], [0.2, 0.5, 0.3]]  # yield of quality scores per method\n3. UpgradeCost\n[1.20, 1.80]  # cost to upgrade quality scores 6 to 8 and 8 to 10 in dollars\n4. PricePerTon\n[15, 8]  # price per ton for Premium and Standard packaging in dollars\n5. MinQualityScore\n[9, 7]  # minimum quality score for Premium and Standard packaging\n6. MaxDemand\n[2500, 800]  # maximum demand for Premium and Standard packaging in tons\n\nDecision variable:\n1. ProcessingAmount\nContinuous variable, \\( ProcessingAmount[m] \\forall m \\in M \\), the amount of recycled paper processed using method \\( m \\) in tons.\n2. Quality6UpgradeAmount\nContinuous variable, \\( Quality6UpgradeAmount \\), the amount of quality score 6 upgraded to quality score 8 in tons.\n3. Quality8UpgradeAmount\nContinuous variable, \\( Quality8UpgradeAmount \\), the amount of quality score 8 upgraded to quality score 10 in tons.\n4. PackagingProducedPerQuality\nContinuous variable, \\( PackagingProduced[p][q] \\forall p \\in P, q \\in Q \\), the amount of packaging produced of type \\( p \\) with quality score \\( q \\) in tons.\n\nObjective:\n1. Maximize the total profit.\nmax: \\sum_{p \\in P, q \\in Q} (PricePerTon[p] * PackagingProduced[p][q]) - \\sum_{m \\in M} (CostPerTonPerMethod[m] * ProcessingAmount[m]) - UpgradeCost[0] * Quality6UpgradeAmount - UpgradeCost[1] * Quality8UpgradeAmount\n\nConstraint:\n1. Quality score constraint for packaging.\n\\sum_{q \\in Q} (q * PackagingProduced[p][q]) \\geq MinQualityScore[p] * \\sum_{q \\in Q} PackagingProduced[p][q] \\forall p \\in P\n2. Demand constraint for packaging.\n\\sum_{q \\in Q} PackagingProduced[p][q] \\leq MaxDemand[p] \\forall p \\in P\n3. Yield constraint for quality scores.\n\\sum_{m \\in M} (YieldPerMethod[m][0] * ProcessingAmount[m]) - Quality6UpgradeAmount \\geq \\sum_{p \\in P} PackagingProduced[p][1] \\quad \\text{(Quality 6)}\n\\sum_{m \\in M} (YieldPerMethod[m][1] * ProcessingAmount[m]) + Quality6UpgradeAmount - Quality8UpgradeAmount \\geq \\sum_{p \\in P} PackagingProduced[p][2] \\quad \\text{(Quality 8)}\n\\sum_{m \\in M} (YieldPerMethod[m][2] * ProcessingAmount[m]) + Quality8UpgradeAmount \\geq \\sum_{p \\in P} PackagingProduced[p][3] \\quad \\text{(Quality 10)}\n4. Non-negativity constraint.\nProcessingAmount[m] \\geq 0 \\forall m \\in M\nPackagingProduced[p][q] \\geq 0 \\forall p \\in P, q \\in Q\nQuality6UpgradeAmount \\geq 0\nQuality8UpgradeAmount \\geq 0\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_greentech_manufacturing(\n    cost_per_ton_method={\"Method1\": 4.20, \"Method2\": 3.80, \"Method3\": 4.50},\n    yield_per_method={\n        \"Method1\": {\"Q6\": 0.3, \"Q8\": 0.4, \"Q10\": 0.3},\n        \"Method2\": {\"Q6\": 0.5, \"Q8\": 0.3, \"Q10\": 0.2},\n        \"Method3\": {\"Q6\": 0.2, \"Q8\": 0.5, \"Q10\": 0.3}\n    },\n    actual_quality_values={\"Q6\": 6, \"Q8\": 8, \"Q10\": 10},\n    upgrade_cost={\"Q6_to_Q8\": 1.20, \"Q8_to_Q10\": 1.80},\n    price_per_ton={\"Premium\": 15, \"Standard\": 8},\n    min_quality_score_req={\"Premium\": 9, \"Standard\": 7},\n    max_demand={\"Premium\": 2500, \"Standard\": 800}\n):\n    \"\"\"\n    Models and solves the GreenTech Manufacturing problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"GreenTechManufacturing\")\n\n    # --- Sets ---\n    packaging_types = [\"Premium\", \"Standard\"]\n    methods = [\"Method1\", \"Method2\", \"Method3\"]\n    quality_labels = [\"Q6\", \"Q8\", \"Q10\"]\n\n    # --- Decision Variables ---\n    processing_amount = model.addVars(methods, name=\"ProcessingAmount\", lb=0)\n    quality6_upgrade_amount = model.addVar(name=\"Quality6UpgradeAmount\", lb=0)\n    quality8_upgrade_amount = model.addVar(name=\"Quality8UpgradeAmount\", lb=0)\n    packaging_produced = model.addVars(packaging_types, quality_labels, name=\"PackagingProduced\", lb=0)\n\n    # --- Objective Function: Maximize Total Profit ---\n    total_revenue = gp.quicksum(price_per_ton[p] * packaging_produced.sum(p, '*') for p in packaging_types)\n    total_processing_cost = gp.quicksum(cost_per_ton_method[m] * processing_amount[m] for m in methods)\n    total_upgrade_cost = (upgrade_cost[\"Q6_to_Q8\"] * quality6_upgrade_amount +\n                          upgrade_cost[\"Q8_to_Q10\"] * quality8_upgrade_amount)\n    model.setObjective(total_revenue - total_processing_cost - total_upgrade_cost, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    for p in packaging_types:\n        weighted_quality_sum = gp.quicksum(actual_quality_values[q_label] * packaging_produced[p, q_label]\n                                           for q_label in quality_labels)\n        total_produced_p = packaging_produced.sum(p, '*')\n        model.addConstr(weighted_quality_sum >= min_quality_score_req[p] * total_produced_p,\n                        name=f\"QualityScore_{p}\")\n\n    for p in packaging_types:\n        model.addConstr(packaging_produced.sum(p, '*') <= max_demand[p], name=f\"Demand_{p}\")\n\n    produced_q6_material = gp.quicksum(yield_per_method[m][\"Q6\"] * processing_amount[m] for m in methods)\n    used_as_q6_in_packaging = gp.quicksum(packaging_produced[p, \"Q6\"] for p in packaging_types)\n    model.addConstr(produced_q6_material - quality6_upgrade_amount >= used_as_q6_in_packaging, name=\"Balance_Q6\")\n\n    produced_q8_material_native = gp.quicksum(yield_per_method[m][\"Q8\"] * processing_amount[m] for m in methods)\n    total_available_q8_material = produced_q8_material_native + quality6_upgrade_amount\n    used_as_q8_in_packaging = gp.quicksum(packaging_produced[p, \"Q8\"] for p in packaging_types)\n    model.addConstr(total_available_q8_material - quality8_upgrade_amount >= used_as_q8_in_packaging, name=\"Balance_Q8\")\n\n    produced_q10_material_native = gp.quicksum(yield_per_method[m][\"Q10\"] * processing_amount[m] for m in methods)\n    total_available_q10_material = produced_q10_material_native + quality8_upgrade_amount\n    used_as_q10_in_packaging = gp.quicksum(packaging_produced[p, \"Q10\"] for p in packaging_types)\n    model.addConstr(total_available_q10_material >= used_as_q10_in_packaging, name=\"Balance_Q10\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == '__main__':\n    result = solve_greentech_manufacturing()\n    print(result)\n",
    "ground_truth":28864.0
  },
  {
    "task_id":"D045",
    "description":"At the start of month 1, SupplyChain Dynamics has $50,000 in available funds. At the beginning of months 1, 2, 3, and 4, the company receives specific revenues from its logistics operations, after which it must pay operational expenses(see table below). Any remaining funds can be allocated to short-term investments with the following options (Interest is earned after paying operational expenses):  \n- Invest for one month at an interest rate of 0.2% per month.  \n- Invest for two months at an interest rate of 0.8% per month.  \n- Invest for three months at an interest rate of 1.5% per month.  \n- Invest for four months at an interest rate of 3% per month.  \n\nHow can SupplyChain Dynamics allocate its funds to maximize the cash on hand at the beginning of month 5 while meeting its operational obligations?\n\n| Month | Revenue ($) | Operational Expenses ($) |  \n|-------|-------------|---------------------------|  \n| 1     | 20,000      | 15,000                    |  \n| 2     | 25,000      | 35,000                    |  \n| 3     | 30,000      | 22,000                    |  \n| 4     | 35,000      | 28,000                    |",
    "formulation":"Set:\n1. MonthsInvest:\nThe set of months when investment decisions can be made.\nT_I = \\{1, 2, 3, 4\\}\n2. MonthsBalance:\nThe set of months for which end-of-month uninvested cash balance is tracked.\nT_B = \\{1, 2, 3, 4\\}\n3. InvestmentDurations:\nThe set of possible investment durations in months.\nD = \\{1, 2, 3, 4\\}  # representing 1-month, 2-month, 3-month, and 4-month investment options respectively.\n\nParameter:\n1. InitialFunds:\n# The amount of cash available at the start of month 1.\n 50000\n2. Revenue:\n[20000, 25000, 30000, 35000]  # in dollars for months 1, 2, 3, and 4 respectively.\n3. OperationalExpenses:\nThe operational expenses paid at the beginning of month $t$, for $t \\in T_I$.\n[15000, 35000, 22000, 28000]  # in dollars for months 1, 2, 3, and 4 respectively.\n4. MonthlyInterestRate:\n[0.002, 0.008, 0.015, 0.030]  # in dollars for months 1, 2, 3, and 4 respectively.\n# The return factor for an investment of duration $d$ is $(1 + d \\times \\text{MIR}[d])$.\n\nDecision Variable:\n1. InvestAmount:\nContinuous variable, $X_{t,d} \\ge 0$, representing the amount of money invested at the beginning of month $t$ for a duration of $d$ months, for all $t \\in T_I$ and $d \\in D$ such that $t+d \\le 5$.\n2. CashOnHand:\nContinuous variable, $C_t \\ge 0$, representing the uninvested cash held at the end of month $t$, carried over to the start of month $t+1$.\nDefined for $t \\in T_B$. (i.e., $C_1, C_2, C_3, C_4$)\n\nObjective:\n1.  Maximize the total cash on hand at the beginning of month 5.\nThis includes cash carried over from the end of month 4 and all investments maturing at the start of month 5.\nmax:\n$Z = C_4 + \\sum_{\\substack{t \\in T_I, d \\in D \\\\ t+d=5}} X_{t,d} (1 + d \\times \\text{MIR}[d])$\n\nConstraint:\n1. Cash Balance Constraint:\nFor each month $t \\in T_I$:\nThe funds available at the beginning of month $t$ (after receiving revenue, paying expenses, and accounting for maturing investments and cash from the previous month) must equal the funds allocated in month $t$ (new investments plus cash carried over).\n    - If $t=1$:\n        $\\text{InitialFunds} + \\text{Rev}[1] - \\text{Exp}[1] = \\sum_{\\substack{d \\in D \\\\ 1+d \\le 5}} X_{1,d} + C_1$\n\n    - If $t \\in T_I \\text{ and } t > 1$:\n        $C_{t-1} + \\sum_{\\substack{d' \\in D \\\\ t-d' \\ge 1}} X_{t-d', d'} (1 + d' \\times \\text{MIR}[d']) + \\text{Rev}[t] - \\text{Exp}[t] = \\sum_{\\substack{d \\in D \\\\ t+d \\le 5}} X_{t,d} + C_t$\n\n2. Non-negativity Constraint:\nAll decision variables must be non-negative.\n$X_{t,d} \\ge 0$ for all defined $t,d$.\n$C_t \\ge 0$ for $t \\in T_B$.\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_fund_allocation(\n    initial_funds=50000.0,\n    revenues={1: 20000.0, 2: 25000.0, 3: 30000.0, 4: 35000.0},\n    expenses={1: 15000.0, 2: 35000.0, 3: 22000.0, 4: 28000.0},\n    monthly_interest_rates={\n        1: 0.002,\n        2: 0.008,\n        3: 0.015,\n        4: 0.030\n    }\n):\n    \"\"\"\n    Solves the SupplyChain Dynamics fund allocation problem.\n    \"\"\"\n    try:\n        # --- 1. Model Data ---\n        months_invest = [1, 2, 3, 4]\n        months_balance = [1, 2, 3, 4]\n        investment_durations = [1, 2, 3, 4]\n\n        # --- 2. Create Gurobi Model ---\n        model = gp.Model(\"SupplyChainFundAllocation\")\n        model.Params.LogToConsole = 0\n\n        # --- 3. Decision Variables ---\n        X = model.addVars([(t, d) for t in months_invest for d in investment_durations if t + d <= 5],\n                          name=\"InvestAmount\", lb=0.0, vtype=GRB.CONTINUOUS)\n        C = model.addVars(months_balance, name=\"CashOnHandEndOfMonth\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- 4. Objective Function ---\n        cash_at_month_5_start = C[4] + gp.quicksum(\n            X[t, d] * (1 + d * monthly_interest_rates[d])\n            for t in months_invest for d in investment_durations if (t, d) in X and t + d == 5)\n        model.setObjective(cash_at_month_5_start, GRB.MAXIMIZE)\n\n        # --- 5. Constraints ---\n        for t in months_invest:\n            if t == 1:\n                funds_in = initial_funds + revenues[t] - expenses[t]\n            else:\n                cash_from_last_month = C[t - 1]\n                maturing_investments_value = gp.quicksum(\n                    X[t_invest, d_invest] * (1 + d_invest * monthly_interest_rates[d_invest])\n                    for t_invest in months_invest for d_invest in investment_durations\n                    if (t_invest, d_invest) in X and t_invest + d_invest == t)\n                funds_in = cash_from_last_month + maturing_investments_value + revenues[t] - expenses[t]\n\n            new_investments_made_this_month = gp.quicksum(X[t, d] for d in investment_durations if (t, d) in X)\n            cash_carried_over = C[t]\n            model.addConstr(funds_in == new_investments_made_this_month + cash_carried_over, name=f\"CashBalance_Month{t}\")\n            if t == 1:\n                model.addConstr(expenses[t] <= initial_funds + revenues[t], name=f\"Expenses_Month{t}\")\n            else:\n                model.addConstr(expenses[t] <= C[t - 1] + revenues[t], name=f\"Expenses_Month{t}\")\n\n        # --- 6. Solve Model ---\n        model.optimize()\n\n        # --- 7. Return Results ---\n        if model.Status == GRB.OPTIMAL:\n            return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n        else:\n            return {\"status\": f\"{model.Status}\"}\n\n    except gp.GurobiError as e:\n        return {\"status\": f\"Gurobi error: {e}\"}\n    except Exception as e:\n        return {\"status\": f\"An unexpected error occurred: {e}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_fund_allocation()\n    print(result)\n",
    "ground_truth":65542.0
  },
  {
    "task_id":"D046",
    "description":"Warehouse 24 operates around the clock to fulfill online orders. Workers are scheduled in two consecutive 6-hour shifts and are paid $12 per hour. The possible shifts are as follows: midnight–6 A.M., 6 A.M.–noon, noon–6 P.M., and 6 P.M.–midnight. During each shift, the following numbers of orders arrive: midnight–6 A.M., 150; 6 A.M.–noon, 250; noon–6 P.M., 400; 6 P.M.–midnight, 300. Each worker can process up to 60 orders per shift. To account for customer dissatisfaction due to delayed orders, any order that remains unprocessed at the end of a shift incurs a penalty of $1. The warehouse ensures that all orders received by midnight are processed by the start of the next day, so the midnight–6 A.M. shift begins with no pending orders. How can Warehouse 24 minimize the total cost of labor and customer dissatisfaction penalties while meeting its order processing requirements?\n\n| Shift              | Orders Received |  \n|--------------------|-----------------|  \n| Midnight–6 A.M.    | 150             |  \n| 6 A.M.–Noon        | 250             |  \n| Noon–6 P.M.        | 400             |  \n| 6 P.M.–Midnight    | 300             |",
    "formulation":"Set:\n1. Shift\nThe set of shifts, \\( S = \\{1, 2, 3, 4\\} \\)  # 1: Midnight–6 A.M., 2: 6 A.M.–Noon, 3: Noon–6 P.M., 4: 6 P.M.–Midnight\n\nParameter:\n1. OrdersReceived\n[150, 250, 400, 300]  # number of orders received in each shift\n2. OrdersPerWorkerPerShift\n60  # number of orders each worker can process in a shift\n3. WagePerHour\n12  # wage per hour for each worker in dollars\n4. ShiftDuration\n6  # duration of each shift in hours\n5. PenaltyPerUnprocessedOrder\n1  # penalty for each unprocessed order in dollars\n\nDecision variable:\n1. WorkersScheduled\nInteger variable, \\( WorkersScheduled[s] \\forall s \\in S \\), the number of workers scheduled for shift \\( s \\).\n2. OrdersProcessed\nInteger variable, \\( OrdersProcessed[s] \\forall s \\in S \\), the number of orders processed during shift \\( s \\).\n3. UnprocessedOrders\nInteger variable, \\( UnprocessedOrders[s] \\forall s \\in S \\), the number of unprocessed orders at the end of shift \\( s \\).\n\nObjective:\n1. Minimize the total cost of labor and penalties.\nmin: \\sum_{s \\in S} (WagePerHour * ShiftDuration * WorkersScheduled[s]) + \\sum_{s \\in S} (PenaltyPerUnprocessedOrder * (OrdersReceived[s]+UnprocessedOrders[s-1] - OrdersProcessed[s])) \nwhere \\( UnprocessedOrders[1] = OrdersReceived[1] - OrdersProcessed[1] \\) for the first shift, and \\( UnprocessedOrders[s] = OrdersReceived[s] + UnprocessedOrders[s-1] - OrdersProcessed[s] \\) for subsequent shifts.\n\nConstraint:\n1. Order processing constraint.\nOrdersProcessed[s] \\leq WorkersScheduled[s] * OrdersPerWorkerPerShift \\forall s \\in S\n2. Unprocessed orders constraint.\nUnprocessedOrders[s] = OrdersReceived[s] + UnprocessedOrders[s-1] - OrdersProcessed[s] \\forall s \\in S, s > 1\nUnprocessedOrders[1] = OrdersReceived[1] - OrdersProcessed[1]  # for the first shift, no previous unprocessed orders\n3. Non-negativity constraint.\nWorkersScheduled[s] \\geq 0 \\forall s \\in S\nOrdersProcessed[s] \\geq 0 \\forall s \\in S\nUnprocessedOrders[s] \\geq 0 \\forall s \\in S\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_warehouse_scheduling(\n    orders_received={'midnight_6am': 150, '6am_noon': 250, 'noon_6pm': 400, '6pm_midnight': 300},\n    hourly_wage=12,\n    shift_hours=6,\n    orders_per_worker=60,\n    penalty_per_unprocessed_order=1\n):\n    \"\"\"\n    Models and solves the warehouse scheduling problem.\n    \"\"\"\n    model = gp.Model(\"WarehouseScheduling\")\n    model.setParam('OutputFlag', 0)\n\n    # --- Parameters ---\n    shifts = ['midnight_6am', '6am_noon', 'noon_6pm', '6pm_midnight']\n    shift_wage = hourly_wage * shift_hours\n\n    # --- Decision Variables ---\n    workers = model.addVars(shifts, name=\"Workers\", vtype=GRB.INTEGER, lb=0)\n    orders_processed = model.addVars(shifts, name=\"OrdersProcessed\", vtype=GRB.CONTINUOUS, lb=0)\n    unprocessed = model.addVars(shifts, name=\"UnprocessedOrders\", vtype=GRB.CONTINUOUS, lb=0)\n\n    # --- Objective Function ---\n    total_cost = gp.LinExpr()\n    for shift in shifts:\n        total_cost += workers[shift] * shift_wage\n        total_cost += unprocessed[shift] * penalty_per_unprocessed_order\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    for shift in shifts:\n        model.addConstr(orders_processed[shift] <= workers[shift] * orders_per_worker,\n                        name=f\"ProcessingCapacity_{shift}\")\n\n    shift_order = ['midnight_6am', '6am_noon', 'noon_6pm', '6pm_midnight']\n    for i, shift in enumerate(shift_order):\n        if shift == 'midnight_6am':\n            model.addConstr(orders_processed[shift] + unprocessed[shift] == orders_received[shift],\n                           name=f\"OrderBalance_{shift}\")\n        else:\n            prev_shift = shift_order[i-1]\n            model.addConstr(orders_processed[shift] + unprocessed[shift] ==\n                           orders_received[shift] + unprocessed[prev_shift],\n                           name=f\"OrderBalance_{shift}\")\n\n    model.addConstr(unprocessed['6pm_midnight'] == 0, name=\"AllOrdersProcessedByMidnight\")\n\n    # --- Solve ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == '__main__':\n    result = solve_warehouse_scheduling()\n    print(result)",
    "ground_truth":1378.0
  },
  {
    "task_id":"D047",
    "description":"The operations manager of QuickShip Logistics is trying to determine the number of warehouse supervisors needed to manage the company's distribution operations throughout the year. The estimated number of operational hours required each month is as follows:  \n\n| Month     | Operational Hours Needed |  \n|-----------|--------------------------|  \n| January   | 600                      |  \n| February  | 450                      |  \n| March     | 350                      |  \n| April     | 800                      |  \n| May       | 1,000                    |  \n| June      | 450                      |  \n| July      | 350                      |  \n| August    | 600                      |  \n| September | 450                      |  \n| October   | 350                      |  \n| November  | 250                      |  \n| December  | 150                      |  \n\nQuickShip Logistics aims to determine the optimal number of full-time warehouse supervisors to employ for the entire year, with the primary goal of minimizing total annual labor costs. These costs are composed of fixed monthly salaries of $5,000 for each supervisor (who are employed for all 12 months) and any overtime expenses incurred to meet fluctuating monthly operational hour demands. The company must ensure all operational tasks for each month are completed within that month, and all annual tasks are finalized by the end of December. \n\nEach of the N supervisors, when not taking their mandatory one-month annual paid vacation, can provide up to 160 standard operational hours monthly. To cover demands exceeding this standard capacity, these non-vacationing supervisors can work up to an additional 40 hours of overtime each per month, with overtime labor paid at a rate of $45 per hour. How can QuickShip Logistics minimize employment costs?",
    "formulation":"Set:\n1. Month\nThe set of months, \\( M = \\{1, 2, \\ldots, 12\\} \\)  # 1: January, 2: February, ..., 12: December\n\nParameter:\n1. OperationalHoursNeeded\n[600, 450, 350, 800, 1000, 450, 350, 600, 450, 350, 250, 150]  # operational hours needed for each month\n2. NormalHoursPerSupervisorPerMonth\n160  # hours each supervisor can handle per month\n3. OvertimeHoursPerSupervisorPerMonth\n40  # additional hours each supervisor can work per month as overtime\n4. SupervisorsVacationMonths\n1\n5. FixedSalaryPerSupervisorPerMonth\n5000  # fixed monthly salary for each supervisor\n6. OvertimeRatePerHour\n45  # overtime pay rate per hour\n\nDecision variable:\n1. SupervisorsNeeded\nInteger variable, \\( SupervisorsNeeded \\), the number of warehouse supervisors needed.\n2. WorkSupervisorPerMonth\nInteger variable, \\( WorkSupervisorPerMonth[m] \\forall m \\in M \\), the number of hours worked by supervisors in month \\( m \\).\n3. OvertimeHoursPerMonth\nInteger variable, \\( OvertimeHoursPerMonth[m] \\forall m \\in M \\), the total overtime hours worked by supervisors in month \\( m \\).\n\nObjective:\n1. Minimize the total cost.\nmin: FixedSalaryPerSupervisorPerMonth \\times SupervisorsNeeded \\times 12 + \\sum_{m \\in M} (OvertimeRatePerHour \\times OvertimeHoursPerMonth[m])\n\nConstraint:\n1. Operational hours constraint.\nWorkSupervisorPerMonth[m] \\times NormalHoursPerSupervisorPerMonth + OvertimeHoursPerMonth[m] \\geq OperationalHoursNeeded[m] \\forall m \\in M\n2. Vacation constraint.\n\\sum_{m \\in M} WorkSupervisorPerMonth[m] = (12 - SupervisorsVacationMonths) \\times SupervisorsNeeded\n3. Supervisors number constraint.\nWorkSupervisorPerMonth[m] \\leq SupervisorsNeeded \\forall m \\in M\n4. Overtime hours constraint.\nOvertimeHoursPerMonth[m] \\leq WorkSupervisorPerMonth[m] \\times OvertimeHoursPerSupervisorPerMonth \\forall m \\in M\n5. Non-negativity constraint.\nSupervisorsNeeded \\geq 0\nWorkSupervisorPerMonth[m] \\geq 0 \\forall m \\in M\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_supervisor_scheduling(\n    operational_hours_needed={\n        1: 600, 2: 450, 3: 350, 4: 800, 5: 1000, 6: 450,\n        7: 350, 8: 600, 9: 450, 10: 350, 11: 250, 12: 150\n    },\n    normal_hours_per_supervisor=160,\n    overtime_hours_per_supervisor=40,\n    supervisors_vacation_months=1,\n    fixed_salary=5000,\n    overtime_rate=45\n):\n    \"\"\"\n    Models and solves the supervisor scheduling problem.\n    \"\"\"\n    model = gp.Model(\"WarehouseSupervisors\")\n    model.setParam('OutputFlag', 0)\n\n    # --- Parameters ---\n    months = range(1, 13)\n\n    # --- Decision Variables ---\n    supervisors_needed = model.addVar(vtype=GRB.INTEGER, name=\"SupervisorsNeeded\")\n    work_supervisor_per_month = model.addVars(months, vtype=GRB.INTEGER, name=\"WorkSupervisorPerMonth\")\n    overtime_hours_per_month = model.addVars(months, vtype=GRB.INTEGER, name=\"OvertimeHoursPerMonth\")\n\n    # --- Objective Function ---\n    total_cost = fixed_salary * supervisors_needed * 12\n    for m in months:\n        total_cost += overtime_rate * overtime_hours_per_month[m]\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    for m in months:\n        model.addConstr(\n            work_supervisor_per_month[m] * normal_hours_per_supervisor +\n            overtime_hours_per_month[m] >= operational_hours_needed[m],\n            name=f\"OperationalHoursNeeded_{m}\"\n        )\n\n    model.addConstr(\n        gp.quicksum(work_supervisor_per_month[m] for m in months) ==\n        (12 - supervisors_vacation_months) * supervisors_needed,\n        name=\"VacationConstraint\"\n    )\n\n    for m in months:\n        model.addConstr(\n            work_supervisor_per_month[m] <= supervisors_needed,\n            name=f\"SupervisorsNumberConstraint_{m}\"\n        )\n\n    for m in months:\n        model.addConstr(\n            overtime_hours_per_month[m] <= work_supervisor_per_month[m] * overtime_hours_per_supervisor,\n            name=f\"OvertimeLimit_{m}\"\n        )\n\n    # --- Solve ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == '__main__':\n    result = solve_supervisor_scheduling()\n    print(result)",
    "ground_truth":309000.0
  },
  {
    "task_id":"D048",
    "description":"LogiTech’s main distribution center is organized into two key areas: a packaging area located at coordinates (0, 0) and a loading dock located at coordinates (800, 600) (distances are in meters). The company must determine where to locate a sorting facility and a storage facility to minimize the daily cost of moving goods through the center. All movement within the distribution center is restricted to either east–west or north–south directions.  \n\nThe number of daily trips between the areas are as follows:  \n\n| From\/To          | Packaging Area | Loading Dock | Sorting Facility | Storage Facility |  \n|-------------------|----------------|--------------|-------------------|------------------|  \n| Packaging Area    | -              | 20           | 15                | 10               |  \n| Loading Dock      | 20             | -            | 25                | 30               |  \n| Sorting Facility  | 15             | 25           | -                 | 40               |  \n| Storage Facility  | 10             | 30           | 40                | -                |  \n\nThe cost of moving goods is $0.50 per meter per trip. The sorting facility and storage facility must be located within the boundaries of the distribution center, which spans from (0, 0) to (1000, 1000). And any two areas among the four areas are at least 100 units apart.\n\nHow should LogiTech locate the sorting and storage facilities to minimize daily transportation costs?",
    "formulation":"Set:\n1. Area\nThe set of areas, \\( A = \\{1, 2, 3, 4\\} \\)  # 1: Packaging Area, 2: Loading Dock, 3: Sorting Facility, 4: Storage Facility\n\nParameter:\n1. PackagingAreaCoordinates\n(0, 0)  # coordinates of the Packaging Area\n2. LoadingDockCoordinates\n(800, 600)  # coordinates of the Loading Dock\n3. DistanceBetweenPackagingAndLoading\n1400\n4. DailyTrips\n[[0, 20, 15, 10], [20, 0, 25, 30], [15, 25, 0, 40], [10, 30, 40, 0]]  # daily trips between areas\n5. CostPerMeterPerTrip\n0.50  # cost of moving goods per meter per trip\n6. DistributionCenterBoundaries\n(0, 0, 800, 600)  # boundaries of the distribution center (x_min, y_min, x_max, y_max)\n7. MinimalDistance\n100  # minimal distance between two areas in meters\n\nDecision variable:\n1. DistanceBetweenSortingAndStorage\nContinuous variable, \\( DistanceBetweenSortingAndStorage \\), the distance between the Sorting Facility and Storage Facility in meters.\n2. DistanceBetweenSortingAndPackaging\nContinuous variable, \\( DistanceBetweenSortingAndPackaging \\), the distance between the Sorting Facility and Packaging Area in meters.\n3. DistanceBetweenSortingAndLoading\nContinuous variable, \\( DistanceBetweenSortingAndLoading \\), the distance between the Sorting Facility and Loading Dock in meters.\n4. DistanceBetweenStorageAndPackaging\nContinuous variable, \\( DistanceBetweenStorageAndPackaging \\), the distance between the Storage Facility and Packaging Area in meters.\n5. DistanceBetweenStorageAndLoading\nContinuous variable, \\( DistanceBetweenStorageAndLoading \\), the distance between the Storage Facility and Loading Dock in meters.\n\nObjective:\n1. Minimize the total daily transportation cost.\nmin: [(DailyTrips[1][2]+DailyTrips[2][1])*DistanceBetweenPackagingAndLoading + \n       (DailyTrips[1][3]+DailyTrips[3][1])*DistanceBetweenSortingAndPackaging + \n       (DailyTrips[1][4]+DailyTrips[4][1])*DistanceBetweenStorageAndPackaging + \n       (DailyTrips[2][3]+DailyTrips[3][2])*DistanceBetweenSortingAndLoading + \n       (DailyTrips[2][4]+DailyTrips[4][2])*DistanceBetweenStorageAndLoading + \n       (DailyTrips[3][4]+DailyTrips[4][3])*DistanceBetweenSortingAndStorage] * CostPerMeterPerTrip\n\nConstraint:\n1. DistanceRelationships\nDistanceBetweenSortingAndLoading + DistanceBetweenSortingAndPackaging == DistanceBetweenPackagingAndLoading\nDistanceBetweenStorageAndPackaging + DistanceBetweenStorageAndLoading == DistanceBetweenPackagingAndLoading\nDistanceBetweenSortingAndStorage <= DistanceBetweenPackagingAndLoading\n2. MinimalDistanceConstraint\nDistanceBetweenSortingAndStorage >= MinimalDistance\nDistanceBetweenSortingAndLoading >= MinimalDistance\nDistanceBetweenSortingAndPackaging >= MinimalDistance\nDistanceBetweenStorageAndLoading >= MinimalDistance\nDistanceBetweenStorageAndPackaging >= MinimalDistance\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_logistics_optimization(\n    distance_packaging_loading=1400.0,\n    daily_trips=[\n        [0, 20, 15, 10],\n        [20, 0, 25, 30],\n        [15, 25, 0, 40],\n        [10, 30, 40, 0]\n    ],\n    cost_per_meter_per_trip=0.50,\n    minimal_distance=100.0\n):\n    \"\"\"\n    Solves the logistics optimization problem.\n    \"\"\"\n    try:\n        # --- Create a new model ---\n        model = gp.Model(\"LogisticsOptimization\")\n\n        # --- Decision Variables ---\n        d_S_St = model.addVar(lb=minimal_distance, name=\"DistanceBetweenSortingAndStorage\")\n        d_S_Pk = model.addVar(lb=minimal_distance, name=\"DistanceBetweenSortingAndPackaging\")\n        d_S_L = model.addVar(lb=minimal_distance, name=\"DistanceBetweenSortingAndLoading\")\n        d_St_Pk = model.addVar(lb=minimal_distance, name=\"DistanceBetweenStorageAndPackaging\")\n        d_St_L = model.addVar(lb=minimal_distance, name=\"DistanceBetweenStorageAndLoading\")\n\n        # --- Objective Function ---\n        cost_Pk_L = (daily_trips[0][1] + daily_trips[1][0]) * distance_packaging_loading\n        cost_Pk_S = (daily_trips[0][2] + daily_trips[2][0]) * d_S_Pk\n        cost_Pk_St = (daily_trips[0][3] + daily_trips[3][0]) * d_St_Pk\n        cost_L_S = (daily_trips[1][2] + daily_trips[2][1]) * d_S_L\n        cost_L_St = (daily_trips[1][3] + daily_trips[3][1]) * d_St_L\n        cost_S_St = (daily_trips[2][3] + daily_trips[3][2]) * d_S_St\n        total_transport_cost_before_factor = cost_Pk_L + cost_Pk_S + cost_Pk_St + cost_L_S + cost_L_St + cost_S_St\n        model.setObjective(total_transport_cost_before_factor * cost_per_meter_per_trip, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        model.addConstr(d_S_L + d_S_Pk == distance_packaging_loading, \"Collinearity_Sorting\")\n        model.addConstr(d_St_Pk + d_St_L == distance_packaging_loading, \"Collinearity_Storage\")\n        model.addConstr(d_S_St <= distance_packaging_loading, \"MaxDist_SortingStorage\")\n\n        # --- Optimize model ---\n        model.optimize()\n\n        # --- Return solution ---\n        if model.status == GRB.OPTIMAL:\n            return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n        else:\n            return {\"status\": f\"{model.status}\"}\n\n    except gp.GurobiError as e:\n        return {\"status\": f\"Gurobi error: {e}\"}\n    except Exception as e:\n        return {\"status\": f\"An unexpected error occurred: {e}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_logistics_optimization()\n    print(result)\n",
    "ground_truth":70000.0
  },
  {
    "task_id":"D049",
    "description":"A delivery company is using a drone to make a series of urgent deliveries to 6 specific customer locations (C1 to C6) within a dense urban area. The drone must start from its depot, visit each of the 6 customer locations exactly once to drop off a package, and then return to the depot. The company has calculated the flight time (in minutes) between all pairs of locations (depot and customer sites), considering air-traffic restrictions and optimal flight paths.\n\nFlight Time Matrix (Minutes - Symmetric):\n\n|        | Depot | C1    | C2    | C3    | C4    | C5    | C6    |\n| :----- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |\n| Depot  | -     | 8     | 12    | 15    | 7     | 10    | 14    |\n|   C1   | 8     | -     | 5     | 11    | 6     | 9     | 13    |\n|   C2   | 12    | 5     | -     | 7     | 10    | 4     | 8     |\n|   C3   | 15    | 11    | 7     | -     | 9     | 6     | 5     |\n|   C4   | 7     | 6     | 10    | 9     | -     | 3     | 11    |\n|   C5   | 10    | 9     | 4     | 6     | 3     | -     | 7     |\n|   C6   | 14    | 13    | 8     | 5     | 11    | 7     | -     |",
    "formulation":"Set:\n1. CustomerLocation \nThe set of customer locations, \\( C = \\{C1, C2, C3, C4, C5, C6\\} \\) \n2. Location\nThe set of locations, \\( L = \\{Depot\\} \\cup C \\)\n\nParameter:\n1. FlightTime\n[[0, 8, 12, 15, 7, 10, 14], \n [8, 0, 5, 11, 6, 9, 13], \n [12, 5, 0, 7, 10, 4, 8], \n [15, 11, 7, 0, 9, 6, 5], \n [7, 6, 10, 9, 0, 3, 11], \n [10, 9, 4, 6, 3, 0, 7], \n [14, 13, 8, 5, 11, 7, 0]] # flight time in minutes between locations\n\nDecision variable:\n1. Route\nBinary variable, \\( Route[i][j] \\) for \\( i, j \\in L \\), where \\( Route[i][j] = 1 \\) if the drone travels directly from location \\( i \\) to location \\( j \\), and 0 otherwise.\n\nObjective:\n1. Minimize the total flight time.\nmin: \\sum_{i \\in L, j \\in L} (FlightTime[i][j] * Route[i][j])\n\nConstraint:\n1. Each customer location must be visited exactly once. \n\\sum_{i \\in L} Route[i][j] = 1 \\forall j \\in C \n2. The drone must start from and return to the depot after visiting all customer locations.\n\\sum_{j \\in C} Route[Depot][j] = 1\n\\sum_{i \\in C} Route[i][Depot] = 1\n3. Subtour elimination constraints (to prevent subtours).\n\\sum_{i \\in C} Route[i][j] - \\sum_{k \\in C} Route[j][k] = 0 \\forall j \\in C, j \\neq Depot\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_drone_tsp(\n    flight_times_input=[\n        [0, 8, 12, 15, 7, 10, 14],\n        [8, 0, 5, 11, 6, 9, 13],\n        [12, 5, 0, 7, 10, 4, 8],\n        [15, 11, 7, 0, 9, 6, 5],\n        [7, 6, 10, 9, 0, 3, 11],\n        [10, 9, 4, 6, 3, 0, 7],\n        [14, 13, 8, 5, 11, 7, 0]\n    ]\n):\n    \"\"\"\n    Solves the Drone Traveling Salesperson Problem (TSP).\n    \"\"\"\n    try:\n        # --- Parameters ---\n        customer_locations_set = {\"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\"}\n        depot_name = \"Depot\"\n        location_names = [depot_name] + sorted(list(customer_locations_set))\n        num_total_locations = len(location_names)\n        depot_index = 0\n        customer_indices = list(range(1, num_total_locations))\n\n        flight_time_matrix = {\n            (i, j): flight_times_input[i][j]\n            for i in range(num_total_locations)\n            for j in range(num_total_locations)\n        }\n\n        # --- Create a new model ---\n        model = gp.Model(\"DroneTSP\")\n\n        # --- Decision Variables ---\n        arcs = [(i, j) for i in range(num_total_locations) for j in range(num_total_locations) if i != j]\n        x = model.addVars(arcs, vtype=GRB.BINARY, name=\"Route\")\n\n        # --- Objective Function ---\n        model.setObjective(gp.quicksum(flight_time_matrix[i, j] * x[i, j] for i, j in arcs), GRB.MINIMIZE)\n\n        # --- Constraints ---\n        model.addConstr(gp.quicksum(x[depot_index, j] for j in customer_indices) == 1, \"LeaveDepot\")\n        model.addConstr(gp.quicksum(x[i, depot_index] for i in customer_indices) == 1, \"ReturnToDepot\")\n\n        for j in customer_indices:\n            model.addConstr(gp.quicksum(x[i, j] for i in range(num_total_locations) if i != j) == 1, f\"EnterCustomer_{j}\")\n\n        for i in customer_indices:\n            model.addConstr(gp.quicksum(x[i, j] for j in range(num_total_locations) if i != j) == 1, f\"LeaveCustomer_{i}\")\n\n        num_customers = len(customer_indices)\n        u = model.addVars(customer_indices, lb=1.0, ub=float(num_customers), vtype=GRB.CONTINUOUS, name=\"u\")\n\n        for i in customer_indices:\n            for j in customer_indices:\n                if i != j:\n                    model.addConstr(u[i] - u[j] + num_customers * x[i, j] <= num_customers - 1, f\"MTZ_{i}_{j}\")\n\n        # --- Optimize model ---\n        model.optimize()\n\n        # --- Return solution ---\n        if model.status == GRB.OPTIMAL:\n            return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n        else:\n            return {\"status\": f\"{model.status}\"}\n\n    except gp.GurobiError as e:\n        return {\"status\": f\"Gurobi error: {e}\"}\n    except Exception as e:\n        return {\"status\": f\"An unexpected error occurred: {e}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_drone_tsp()\n    print(result)\n",
    "ground_truth":42.0
  },
  {
    "task_id":"D050",
    "description":"An assembly line needs to produce a product with 10 tasks. The cycle time is 66 time units. The tasks, their durations, and precedence relationships are given in the following table:\n\nTask | Duration | Predecessors\n-----|----------|-------------\n1    | 36       | -\n2    | 36       | 1\n3    | 30       | -\n4    | 30       | 3\n5    | 24       | 1,4\n6    | 30       | 5\n7    | 24       | 2\n8    | 12       | 6,7\n9    | 54       | 8\n10   | 12       | 9\n\nThe problem requires assigning these tasks to workstations while respecting the precedence relationships and cycle time constraint, with the objective of minimizing the number of workstations needed. Each task must be assigned to exactly one workstation, and the total duration of tasks assigned to any workstation cannot exceed the cycle time of 66 units.",
    "formulation":"Set:\n1. Tasks\nThe set of all tasks, \\( T = \\{1, 2, ..., 10\\} \\)\n2. Workstations\nThe set of potential workstations, \\( W = \\{1, 2, ..., 7\\} \\) (upper bound estimated)\n\nParameter:\n1. TaskDuration\nDuration of each task \\( t \\), \\( d_t \\): [36, 36, 30, 30, 24, 30, 24, 12, 54, 12]\n2. CycleTime\nMaximum allowed time per workstation, \\( C = 66 \\)\n3. Precedence\nSet of direct precedence pairs \\( (i,j) \\) where task \\( i \\) must precede task \\( j \\): \n{(1,2), (1,5), (2,7), (3,4), (4,5), (5,6), (6,8), (7,8), (8,9), (9,10)}\n4. StationInterval\nFor each task \\( t \\), the range of possible workstations \\( I_t \\) it can be assigned to, calculated based on earliest and latest possible stations considering precedence and cycle time\n\nDecision variable:\n1. TaskAssignment\nBinary variable \\( x_{tw} \\in \\{0, 1\\} \\) for all \\( t \\in T, w \\in W \\), where \\( x_{tw} = 1 \\) if task \\( t \\) is assigned to workstation \\( w \\), and 0 otherwise\n2. StationUsed\nBinary variable \\( y_w \\in \\{0, 1\\} \\) for all \\( w \\in W \\), where \\( y_w = 1 \\) if workstation \\( w \\) is used, and 0 otherwise\n\nObjective:\nMinimize the number of workstations used\nmin: \\(\\sum_{w \\in W} y_w\\)\n\nConstraint:\n1. Each task must be assigned to exactly one workstation within its feasible interval\n\\(\\sum_{w \\in I_t} x_{tw} = 1, \\forall t \\in T\\)\n2. The total duration of tasks assigned to each workstation cannot exceed cycle time\n\\(\\sum_{t \\in T} d_t \\cdot x_{tw} \\leq C \\cdot y_w, \\forall w \\in W\\)\n3. Workstations must be used in sequence (if station w+1 is used, station w must be used)\n\\(y_{w+1} \\leq y_w, \\forall w \\in \\{1,...,6\\}\\)\n4. Precedence relationships must be maintained\n\\(\\sum_{w \\in W} w \\cdot x_{iw} \\leq \\sum_{w \\in W} w \\cdot x_{jw}, \\forall (i,j) \\in Precedence\\)\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_assembly_line_balancing(\n    tasks=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n    duration={\n        1: 36, 2: 36, 3: 30, 4: 30, 5: 24,\n        6: 30, 7: 24, 8: 12, 9: 54, 10: 12\n    },\n    precedence=[(1, 2), (1, 5), (2, 7), (3, 4), (4, 5), (5, 6), (6, 8),\n                (7, 8), (8, 9), (9, 10)],\n    cycle_time=66,\n    max_stations=7\n):\n    \"\"\"Solve the assembly line balancing problem using Gurobi.\"\"\"\n    # Create a new model\n    model = gp.Model(\"AssemblyLineBalancing\")\n\n    workstations = range(1, max_stations + 1)\n\n    # --- Decision Variables ---\n    x = model.addVars(tasks, workstations, vtype=GRB.BINARY, name=\"x\")\n    y = model.addVars(workstations, vtype=GRB.BINARY, name=\"y\")\n\n    # --- Objective Function ---\n    model.setObjective(y.sum(), GRB.MINIMIZE)\n\n    # --- Constraints ---\n    model.addConstrs((x.sum(t, '*') == 1 for t in tasks), name=\"TaskAssignment\")\n    model.addConstrs((gp.quicksum(duration[t] * x[t, w] for t in tasks) <= cycle_time * y[w]\n                      for w in workstations), name=\"CycleTime\")\n    model.addConstrs((y[w + 1] <= y[w] for w in workstations if w < max_stations),\n                     name=\"StationSequence\")\n    for (i, j) in precedence:\n        model.addConstr(gp.quicksum(w * x[i, w] for w in workstations)\n                        <= gp.quicksum(w * x[j, w] for w in workstations),\n                        name=f\"Precedence_{i}_{j}\")\n\n    # --- Solve the Model ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_assembly_line_balancing()\n    print(result)\n",
    "ground_truth":5.0
  },
  {
    "task_id":"D051",
    "description":"Problem Description:\nA city needs to place emergency response facilities to ensure that every residential area can be reached within 10 minutes. There are 5 potential facility locations (F1-F5) and 8 residential areas (R1-R8). The travel time (in minutes) between each facility location and residential area is given in the following table:\n\n| Facility\\Residential | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 |\n|----------------------|----|----|----|----|----|----|----|----|\n| F1                   | 8  | 12 | 9  | 15 | 7  | 11 | 14 | 6  |\n| F2                   | 10 | 8  | 13 | 7  | 9  | 12 | 5  | 11 |\n| F3                   | 14 | 6  | 10 | 8  | 12 | 7  | 9  | 13 |\n| F4                   | 7  | 11 | 14 | 6  | 8  | 10 | 12 | 9  |\n| F5                   | 9  | 13 | 7  | 11 | 6  | 14 | 8  | 10 |\n\nThe goal is to select the minimum number of facilities such that every residential area is covered (reachable within 10 minutes) by at least one selected facility.",
    "formulation":"Set:\n1. Facilities\nThe set of potential facility locations, \\( F = \\{F1, F2, F3, F4, F5\\} \\)\n2. Residentials\nThe set of residential areas, \\( R = \\{R1, R2, R3, R4, R5, R6, R7, R8\\} \\)\n\nParameter:\n1. Coverage\nBinary parameter \\( a_{fr} \\in \\{0, 1\\} \\) for all \\( f \\in F, r \\in R \\), where \\( a_{fr} = 1 \\) if facility \\( f \\) can cover residential \\( r \\) within 10 minutes, and \\( a_{fr} = 0 \\) otherwise. This is derived from the travel time table (e.g., \\( a_{F1,R1} = 1 \\) since 8 ≤ 10, but \\( a_{F1,R2} = 0 \\) since 12 > 10).\n\nDecision variable:\n1. FacilitySelected\nBinary variable \\( x_f \\in \\{0, 1\\} \\) for all \\( f \\in F \\), where \\( x_f = 1 \\) if facility \\( f \\) is selected, and \\( x_f = 0 \\) otherwise\n\nObjective:\nThe minimum number of facilities to select\nmin: \\sum_{f\\in F}x_f\n\nConstraint:\n1. Each residential area must be covered by at least one selected facility\n\\sum_{f\\in F}a_{fr} \\cdot x_f \\geq 1, \\forall r \\in R\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_facility_location(\n    facilities=['F1', 'F2', 'F3', 'F4', 'F5'],\n    residentials=['R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8'],\n    travel_time={\n        'F1': [8, 12, 9, 15, 7, 11, 14, 6],\n        'F2': [10, 8, 13, 7, 9, 12, 5, 11],\n        'F3': [14, 6, 10, 8, 12, 7, 9, 13],\n        'F4': [7, 11, 14, 6, 8, 10, 12, 9],\n        'F5': [9, 13, 7, 11, 6, 14, 8, 10]\n    }\n):\n    \"\"\"\n    Solves the facility location problem.\n    \"\"\"\n    # Create coverage parameter a_fr (1 if travel time <=10, 0 otherwise)\n    coverage = {}\n    for f in facilities:\n        for i, r in enumerate(residentials):\n            coverage[(f, r)] = 1 if travel_time[f][i] <= 10 else 0\n\n    # Create model\n    model = gp.Model(\"Facility_Location\")\n\n    # Decision variables: x_f (whether facility f is selected)\n    x = model.addVars(facilities, vtype=GRB.BINARY, name=\"Select\")\n\n    # Objective: minimize number of selected facilities\n    model.setObjective(gp.quicksum(x[f] for f in facilities), GRB.MINIMIZE)\n\n    # Constraints: each residential area must be covered by at least one selected facility\n    for r in residentials:\n        model.addConstr(gp.quicksum(coverage[(f, r)] * x[f] for f in facilities) >= 1,\n                        f\"Cover_{r}\")\n\n    # Solve the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_facility_location()\n    print(result)",
    "ground_truth":2.0
  },
  {
    "task_id":"D052",
    "description":"A retail chain wants to open warehouses in 3 potential locations to serve 5 customer zones. The distances (in km) between each potential warehouse location and customer zone are given in the table below. The goal is to select exactly 2 warehouse locations that minimize the total distance between each customer zone and its nearest warehouse. \n\nCustomer Zones: {C1, C2, C3, C4, C5}\nPotential Warehouse Locations: {W1, W2, W3}\n\nDistance Matrix (km):\n|       | C1 | C2 | C3 | C4 | C5 |\n|-------|----|----|----|----|----|\n|W1     | 10 | 15 | 12 | 8  | 20 |\n|W2     | 8  | 10 | 15 | 12 | 18 |\n|W3     | 12 | 8  | 10 | 15 | 12 |",
    "formulation":"Set:\n1. CustomerZones\nThe set of customer zones, \\( C = \\{C1, C2, C3, C4, C5\\} \\)\n2. WarehouseLocations\nThe set of potential warehouse locations, \\( W = \\{W1, W2, W3\\} \\)\n\nParameter:\n1. DistanceMatrix\nThe distance between warehouse location \\( w \\in W \\) and customer zone \\( c \\in C \\), denoted as \\( d_{wc} \\)\nValues: \nd(W1,C1)=10, d(W1,C2)=15, ..., d(W3,C5)=12 (from the distance matrix above)\n2. p\nThe number of warehouses to be opened, p=2\n\nDecision variable:\n1. WarehouseOpen\nBinary variable \\( y_w \\in \\{0, 1\\} \\) for all \\( w \\in W \\), where \\( y_w = 1 \\) if warehouse \\( w \\) is opened, and \\( y_w = 0 \\) otherwise\n2. Assignment\nBinary variable \\( x_{wc} \\in \\{0, 1\\} \\) for all \\( w \\in W, c \\in C \\), where \\( x_{wc} = 1 \\) if customer zone \\( c \\) is assigned to warehouse \\( w \\), and \\( x_{wc} = 0 \\) otherwise\n\nObjective:\nMinimize the total distance between each customer zone and its assigned warehouse\nmin: \\( \\sum_{w \\in W} \\sum_{c \\in C} d_{wc} \\cdot x_{wc} \\)\n\nConstraint:\n1. Exactly p warehouses must be opened\n\\( \\sum_{w \\in W} y_w = p \\)\n2. Each customer zone must be assigned to exactly one warehouse\n\\( \\sum_{w \\in W} x_{wc} = 1, \\forall c \\in C \\)\n3. A customer zone can only be assigned to an opened warehouse\n\\( x_{wc} \\leq y_w, \\forall w \\in W, \\forall c \\in C \\)\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_warehouse_location(\n    CustomerZones=['C1', 'C2', 'C3', 'C4', 'C5'],\n    WarehouseLocations=['W1', 'W2', 'W3'],\n    DistanceMatrix={\n        'W1': {'C1': 10, 'C2': 15, 'C3': 12, 'C4': 8, 'C5': 20},\n        'W2': {'C1': 8, 'C2': 10, 'C3': 15, 'C4': 12, 'C5': 18},\n        'W3': {'C1': 12, 'C2': 8, 'C3': 10, 'C4': 15, 'C5': 12}\n    },\n    p=2\n):\n    \"\"\"Solve the warehouse location selection problem using Gurobi.\"\"\"\n    # Create a new model\n    model = gp.Model(\"WarehouseLocation\")\n\n    # Decision variables\n    y = model.addVars(WarehouseLocations, vtype=GRB.BINARY, name=\"Open\")\n    x = model.addVars(WarehouseLocations, CustomerZones, vtype=GRB.BINARY, name=\"Assign\")\n\n    # Objective: Minimize total distance\n    model.setObjective(\n        gp.quicksum(DistanceMatrix[w][c] * x[w, c] for w in WarehouseLocations for c in CustomerZones),\n        GRB.MINIMIZE\n    )\n\n    # Constraints\n    model.addConstr(gp.quicksum(y[w] for w in WarehouseLocations) == p, \"Open_p_warehouses\")\n    for c in CustomerZones:\n        model.addConstr(gp.quicksum(x[w, c] for w in WarehouseLocations) == 1, f\"Assign_one_warehouse_{c}\")\n    for w in WarehouseLocations:\n        for c in CustomerZones:\n            model.addConstr(x[w, c] <= y[w], f\"Assign_only_if_open_{w}_{c}\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_warehouse_location()\n    print(result)",
    "ground_truth":48.0
  },
  {
    "task_id":"D053",
    "description":"A large-scale logistics company specializes in transporting a wide variety of perishable goods from a central distribution hub to several supermarket chains. The company uses a fleet of advanced refrigerated trucks, and for a specific delivery route, one truck needs to be loaded. Each truck has strict capacity limits in four dimensions: a maximum weight of 12 tons, a total volume of 35 m³, a refrigeration power output of 40 kW, and a total cool-down time budget of 100 hours (a proxy for the energy and time required to bring goods to their optimal temperature and maintain it).\n\nThe goods are classified into 10 distinct categories. For each category, the company can choose from 5 different variants, each sourced from a different supplier and having unique characteristics. The company must select exactly one variant from each of the 10 categories to be included in the shipment with the primary goal to maximize the total profit.\n\nFurthermore, there are two special conditions for this delivery:\n1.  Product Synergy: If Variant B of Fruits (Category 1) and Variant C of Baked Goods (Category 6) are shipped together, a special packaging collaboration creates an additional bonus profit of $150.\n2.  Product Conflict: Due to the high risk of cross-contamination, shipping Variant A of Seafood (Category 5) and Variant A of Dairy (Category 3) together is forbidden.\n\nThe complete data for all available goods is as follows:\n\n| Category | Variant | Weight (t) | Volume (m³) | Power (kW) | Cool-Down (hr) | Profit ($) |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| **1: Fruits** | A | 1.1 | 2.8 | 2.0 | 8.0 | 210 |\n| | B | 1.3 | 3.2 | 2.5 | 10.0 | 290 |\n| | C | 0.9 | 2.4 | 1.8 | 7.0 | 190 |\n| | D | 1.4 | 3.5 | 2.8 | 11.0 | 320 |\n| | E | 1.0 | 2.6 | 1.9 | 7.5 | 200 |\n| **2: Vegetables** | A | 0.8 | 2.0 | 1.0 | 5.0 | 160 |\n| | B | 1.0 | 2.5 | 1.5 | 6.0 | 230 |\n| | C | 0.7 | 1.8 | 0.9 | 4.5 | 140 |\n| | D | 1.2 | 2.8 | 1.8 | 7.0 | 260 |\n| | E | 0.9 | 2.2 | 1.2 | 5.5 | 190 |\n| **3: Dairy** | A | 1.5 | 4.5 | 4.2 | 12.0 | 360 |\n| | B | 1.3 | 4.0 | 3.5 | 10.0 | 310 |\n| | C | 1.7 | 5.0 | 4.8 | 14.0 | 420 |\n| | D | 1.4 | 4.2 | 3.8 | 11.0 | 340 |\n| | E | 1.6 | 4.8 | 4.5 | 13.0 | 400 |\n| **4: Meat** | A | 1.9 | 4.0 | 6.5 | 15.0 | 520 |\n| | B | 1.6 | 3.5 | 5.5 | 13.0 | 460 |\n| | C | 2.1 | 4.5 | 7.2 | 17.0 | 580 |\n| | D | 1.8 | 3.8 | 6.0 | 14.0 | 500 |\n| | E | 2.2 | 4.8 | 7.5 | 18.0 | 600 |\n| **5: Seafood** | A | 1.4 | 3.0 | 8.0 | 16.0 | 480 |\n| | B | 1.2 | 2.8 | 7.0 | 14.0 | 430 |\n| | C | 1.6 | 3.5 | 9.0 | 18.0 | 550 |\n| | D | 1.3 | 2.9 | 7.5 | 15.0 | 450 |\n| | E | 1.7 | 3.8 | 9.5 | 19.0 | 590 |\n| **6: Baked Goods**| A | 0.5 | 1.5 | 0.5 | 2.0 | 90 |\n| | B | 0.7 | 2.0 | 0.8 | 3.0 | 140 |\n| | C | 0.6 | 1.8 | 0.6 | 2.5 | 120 |\n| | D | 0.8 | 2.2 | 1.0 | 3.5 | 160 |\n| | E | 0.4 | 1.2 | 0.4 | 1.5 | 80 |\n| **7: Beverages** | A | 1.8 | 3.0 | 1.5 | 4.0 | 250 |\n| | B | 2.0 | 3.5 | 1.8 | 5.0 | 290 |\n| | C | 1.6 | 2.8 | 1.4 | 3.5 | 220 |\n| | D | 2.2 | 3.8 | 2.0 | 6.0 | 330 |\n| | E | 1.7 | 2.9 | 1.6 | 4.5 | 240 |\n| **8: Frozen** | A | 2.0 | 5.0 | 8.0 | 20.0 | 500 |\n| | B | 1.8 | 4.5 | 7.0 | 18.0 | 450 |\n| | C | 2.3 | 5.5 | 9.0 | 22.0 | 580 |\n| | D | 2.1 | 5.2 | 8.5 | 21.0 | 540 |\n| | E | 2.5 | 6.0 | 9.8 | 24.0 | 620 |\n| **9: Deli Meats** | A | 0.9 | 2.0 | 3.0 | 6.0 | 180 |\n| | B | 1.1 | 2.5 | 3.5 | 7.0 | 240 |\n| | C | 0.8 | 1.8 | 2.8 | 5.5 | 160 |\n| | D | 1.2 | 2.8 | 4.0 | 8.0 | 270 |\n| | E | 1.0 | 2.2 | 3.2 | 6.5 | 210 |\n| **10: Prepared** | A | 1.3 | 3.0 | 4.0 | 9.0 | 300 |\n| | B | 1.5 | 3.5 | 4.5 | 10.0 | 350 |\n| | C | 1.2 | 2.8 | 3.8 | 8.0 | 280 |\n| | D | 1.6 | 3.8 | 5.0 | 11.0 | 380 |\n| | E | 1.4 | 3.2 | 4.2 | 9.5 | 330 |",
    "formulation":"Sets:\n1.  Categories C: The set of product categories, C = {1, 2, ..., 10}.\n2.  Variants Vc: The set of variants for each category c in C, Vc = {A, B, C, D, E}.\n\nParameters:\n1.  Resource Limits:\n    WeightLimit = 12 (tons)\n    VolumeLimit = 35 (m³)\n    PowerLimit = 40 (kW)\n    TimeLimit = 100 (hours)\n2.  Product Data: For each c in C, v in Vc:\n    Weight_cv: Weight of variant v in category c.\n    Volume_cv: Volume of variant v in category c.\n    Power_cv: Power consumption of variant v in category c.\n    Time_cv: Cool-down time for variant v in category c.\n    Profit_cv: Profit of variant v in category c.\n3.  Synergy Bonus:\n    BonusProfit = 150\n\nDecision Variables:\n1.  Primary Selection x_cv: A binary variable, where x_cv = 1 if variant v from category c is selected, and 0 otherwise.\n2.  Synergy Indicator y: A binary variable, where y = 1 if the specific synergistic combination of products is selected, and 0 otherwise.\n\nObjective Function:\nMaximize the total profit, which includes the base profit from all selected items plus any synergy bonuses.\n\nMaximize Z = ( sum_{c in C} sum_{v in Vc} Profit_cv * x_cv ) + (BonusProfit * y)\n\nConstraints:\n1.  Unique Selection per Category: Exactly one variant must be chosen from each category.\n    sum_{v in Vc} x_cv = 1, for all c in C\n2.  Weight Capacity: The total weight of selected variants must not exceed the truck's limit.\n    sum_{c in C} sum_{v in Vc} Weight_cv * x_cv <= WeightLimit\n3.  Volume Capacity: The total volume of selected variants must not exceed the truck's limit.\n    sum_{c in C} sum_{v in Vc} Volume_cv * x_cv <= VolumeLimit\n4.  Power Capacity: The total refrigeration power required must not exceed the truck's limit.\n    sum_{c in C} sum_{v in Vc} Power_cv * x_cv <= PowerLimit\n5.  Cool-Down Time Capacity: The total cool-down time required must not exceed the truck's budget.\n    sum_{c in C} sum_{v in Vc} Time_cv * x_cv <= TimeLimit\n6.  Product Synergy: The synergy bonus variable y can only be 1 if both Fruit Variant B (1,B) and Baked Good Variant C (6,C) are selected.\n    x_{1,B} + x_{6,C} - 2y >= 0\n    y <= x_{1,B}\n    y <= x_{6,C}\n7.  Product Conflict: The combination of Seafood Variant A (5,A) and Dairy Variant A (3,A) is forbidden.\n    x_{5,A} + x_{3,A} <= 1\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_large_scale_transport_problem(\n    categories={\n        1: \"Fruits\", 2: \"Vegetables\", 3: \"Dairy\", 4: \"Meat\", 5: \"Seafood\",\n        6: \"Baked Goods\", 7: \"Beverages\", 8: \"Frozen\", 9: \"Deli Meats\", 10: \"Prepared\"\n    },\n    variants=['A', 'B', 'C', 'D', 'E'],\n    weight_limit=12.0,\n    volume_limit=35.0,\n    power_limit=40.0,\n    time_limit=100.0,\n    bonus_profit=150,\n    data={\n        1: {'A': [1.1, 2.8, 2.0, 8, 210], 'B': [1.3, 3.2, 2.5, 10, 290], 'C': [0.9, 2.4, 1.8, 7, 190], 'D': [1.4, 3.5, 2.8, 11, 320], 'E': [1.0, 2.6, 1.9, 7.5, 200]},\n        2: {'A': [0.8, 2.0, 1.0, 5, 160], 'B': [1.0, 2.5, 1.5, 6, 230], 'C': [0.7, 1.8, 0.9, 4.5, 140], 'D': [1.2, 2.8, 1.8, 7, 260], 'E': [0.9, 2.2, 1.2, 5.5, 190]},\n        3: {'A': [1.5, 4.5, 4.2, 12, 360], 'B': [1.3, 4.0, 3.5, 10, 310], 'C': [1.7, 5.0, 4.8, 14, 420], 'D': [1.4, 4.2, 3.8, 11, 340], 'E': [1.6, 4.8, 4.5, 13, 400]},\n        4: {'A': [1.9, 4.0, 6.5, 15, 520], 'B': [1.6, 3.5, 5.5, 13, 460], 'C': [2.1, 4.5, 7.2, 17, 580], 'D': [1.8, 3.8, 6.0, 14, 500], 'E': [2.2, 4.8, 7.5, 18, 600]},\n        5: {'A': [1.4, 3.0, 8.0, 16, 480], 'B': [1.2, 2.8, 7.0, 14, 430], 'C': [1.6, 3.5, 9.0, 18, 550], 'D': [1.3, 2.9, 7.5, 15, 450], 'E': [1.7, 3.8, 9.5, 19, 590]},\n        6: {'A': [0.5, 1.5, 0.5, 2, 90], 'B': [0.7, 2.0, 0.8, 3, 140], 'C': [0.6, 1.8, 0.6, 2.5, 120], 'D': [0.8, 2.2, 1.0, 3.5, 160], 'E': [0.4, 1.2, 0.4, 1.5, 80]},\n        7: {'A': [1.8, 3.0, 1.5, 4, 250], 'B': [2.0, 3.5, 1.8, 5, 290], 'C': [1.6, 2.8, 1.4, 3.5, 220], 'D': [2.2, 3.8, 2.0, 6, 330], 'E': [1.7, 2.9, 1.6, 4.5, 240]},\n        8: {'A': [2.0, 5.0, 8.0, 20, 500], 'B': [1.8, 4.5, 7.0, 18, 450], 'C': [2.3, 5.5, 9.0, 22, 580], 'D': [2.1, 5.2, 8.5, 21, 540], 'E': [2.5, 6.0, 9.8, 24, 620]},\n        9: {'A': [0.9, 2.0, 3.0, 6, 180], 'B': [1.1, 2.5, 3.5, 7, 240], 'C': [0.8, 1.8, 2.8, 5.5, 160], 'D': [1.2, 2.8, 4.0, 8, 270], 'E': [1.0, 2.2, 3.2, 6.5, 210]},\n        10: {'A': [1.3, 3.0, 4.0, 9, 300], 'B': [1.5, 3.5, 4.5, 10, 350], 'C': [1.2, 2.8, 3.8, 8, 280], 'D': [1.6, 3.8, 5.0, 11, 380], 'E': [1.4, 3.2, 4.2, 9.5, 330]}\n    }\n):\n    \"\"\"\n    Solves the large-scale, multi-constraint perishable goods\n    transportation problem using Gurobi.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"LargeScalePerishableTransport\")\n\n    # --- Decision Variables ---\n    x = model.addVars(data.keys(), variants, vtype=GRB.BINARY, name=\"x\")\n    y = model.addVar(vtype=GRB.BINARY, name=\"SynergyBonus\")\n\n    # --- Objective Function ---\n    base_profit = gp.quicksum(data[c][v][4] * x[c, v] for c in data for v in variants)\n    total_profit = base_profit + (bonus_profit * y)\n    model.setObjective(total_profit, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    for c in data:\n        model.addConstr(gp.quicksum(x[c, v] for v in variants) == 1, name=f\"SelectOne_{c}\")\n\n    model.addConstr(gp.quicksum(data[c][v][0] * x[c, v] for c in data for v in variants) <= weight_limit, \"WeightLimit\")\n    model.addConstr(gp.quicksum(data[c][v][1] * x[c, v] for c in data for v in variants) <= volume_limit, \"VolumeLimit\")\n    model.addConstr(gp.quicksum(data[c][v][2] * x[c, v] for c in data for v in variants) <= power_limit, \"PowerLimit\")\n    model.addConstr(gp.quicksum(data[c][v][3] * x[c, v] for c in data for v in variants) <= time_limit, \"TimeLimit\")\n\n    model.addConstr(y <= x[1, 'B'], \"SynergyCheck1\")\n    model.addConstr(y <= x[6, 'C'], \"SynergyCheck2\")\n    model.addConstr(y >= x[1, 'B'] + x[6, 'C'] - 1, \"SynergyActivation\")\n\n    model.addConstr(x[5, 'A'] + x[3, 'A'] <= 1, \"ProductConflict\")\n\n    # --- Solve ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_large_scale_transport_problem()\n    print(result)\n",
    "ground_truth":2880.0
  },
  {
    "task_id":"D054",
    "description":"A logistics company needs to optimize the loading of 5 different types of cargo items (A, B, C, D, E) onto a single truck with a maximum weight capacity of 2000 kg. Each item has a base profit value and weight, but certain item combinations generate additional synergy profits when transported together (e.g., perishable items with refrigeration equipment). The item characteristics and synergy matrix are given below:\n\nItem Data:\n| Item | Weight (kg) | Base Profit ($) |\n|------|------------|----------------|\n| A    | 400        | 120            |\n| B    | 600        | 180            |\n| C    | 300        | 90             |\n| D    | 500        | 150            |\n| E    | 700        | 210            |\n\nSynergy Profit Matrix ($):\n|   | A  | B  | C  | D  | E  |\n|---|---|---|---|---|---|\n| A | 0  | 25 | 15 | 0  | -10|\n| B | 25 | 0  | 30 | 20 | 0  |\n| C | 15 | 30 | 0  | 10 | 5  |\n| D | 0  | 20 | 10 | 0  | 15 |\n| E |-10 | 0  | 5  | 15 | 0  |\n\nNegative values indicate incompatibility costs (e.g., item A and E require separate storage space).",
    "formulation":"Set:\n1. Items\nThe set of cargo items, \\( I = \\{A, B, C, D, E\\} \\)\n\nParameter:\n1. Weight\nThe weight of each item \\( w_i \\) where \\( i \\in I \\):\n\\( w = \\{A:400, B:600, C:300, D:500, E:700\\} \\)\n2. BaseProfit\nThe base profit of each item \\( c_i \\) where \\( i \\in I \\):\n\\( c = \\{A:120, B:180, C:90, D:150, E:210\\} \\)\n3. Synergy\nThe synergy profit matrix \\( Q_{ij} \\) for all \\( i,j \\in I \\) (as shown in the table)\n4. Capacity\nThe truck's maximum weight capacity \\( W = 2000 \\)\n\nDecision variable:\n1. Selection\nBinary variable \\( x_i \\in \\{0, 1\\} \\) for all \\( i \\in I \\), where \\( x_i = 1 \\) if item \\( i \\) is selected, and \\( x_i = 0 \\) otherwise\n\nObjective:\nMaximize total profit including base and synergy values\nmax: \\( \\sum_{i \\in I} \\sum_{j \\in I} Q_{ij} x_i x_j + \\sum_{i \\in I} c_i x_i \\)\n\nConstraint:\n1. Weight capacity limit\n\\( \\sum_{i \\in I} w_i x_i \\leq W \\)\n\nType:\nBinary, Quadratic, Linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_logistics_knapsack(\n    items=['A', 'B', 'C', 'D', 'E'],\n    weights={'A': 400, 'B': 600, 'C': 300, 'D': 500, 'E': 700},\n    base_profits={'A': 120, 'B': 180, 'C': 90, 'D': 150, 'E': 210},\n    synergy={\n        'A': {'A': 0, 'B': 25, 'C': 15, 'D': 0, 'E': -10},\n        'B': {'A': 25, 'B': 0, 'C': 30, 'D': 20, 'E': 0},\n        'C': {'A': 15, 'B': 30, 'C': 0, 'D': 10, 'E': 5},\n        'D': {'A': 0, 'B': 20, 'C': 10, 'D': 0, 'E': 15},\n        'E': {'A': -10, 'B': 0, 'C': 5, 'D': 15, 'E': 0}\n    },\n    truck_capacity=2000\n):\n    \"\"\"\n    Solves the logistics knapsack problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Logistics_Knapsack\")\n\n    # Create binary decision variables for each item\n    x = model.addVars(items, vtype=GRB.BINARY, name=\"select\")\n\n    # Set objective: maximize total profit (base + synergy)\n    base_profit = gp.quicksum(base_profits[i] * x[i] for i in items)\n    synergy_profit = gp.quicksum(synergy[i][j] * x[i] * x[j] for i in items for j in items if i <= j)\n    model.setObjective(base_profit + synergy_profit, GRB.MAXIMIZE)\n\n    # Add weight capacity constraint\n    model.addConstr(gp.quicksum(weights[i] * x[i] for i in items) <= truck_capacity, \"weight_limit\")\n\n    # Optimize model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_logistics_knapsack()\n    print(result)\n",
    "ground_truth":665.0
  },
  {
    "task_id":"D055",
    "description":"A bus company needs to schedule departures for a specific route during the morning peak hours (7:00 AM to 9:00 AM) to minimize the total passenger waiting time. Each bus has a minimum departure interval of 5 minutes and a maximum departure interval of 10 minutes, with a round-trip time of 30 minutes including stops. The company has a maximum of 5 buses available for scheduling. Passengers arrive at the station uniformly at a constant rate during the morning rush hour. The objective is to determine the optimal departure schedule by formulating an integer programming model that minimizes the total passenger waiting time while satisfying the given constraints.",
    "formulation":"Set:\n1. TimeSlots\nThe set of departure times in minutes from 6:00 AM to 9:00 AM, \\( T = \\{StartTime, 1, 2, \\dots, EndTime\\} \\)\n\nParameter:\n1. StartTime\n0\n2. EndTime\n180\n3. MinimumDepartureInterval\n5\n4. MaximumDepartureInterval\n15\n5. RoundtripTime\n40\n6. MaximumBuses\n8\n7. PassengerArrivalRate\n30\n\nDecision variable:\n1. Departures\nBinary variable \\( x_t \\in \\{0, 1\\} \\) for all \\( t \\in T \\), where \\( x_t = 1 \\) if there is a departure at time \\( t \\), and \\( x_t = 0 \\) otherwise.\n\nObjective:\nThe total passenger waiting time\nmin: \\sum_{s\\in T}\\sum_{t\\in T,s>t}(s-t)^2\\cdot x_t\\cdot x_s\n\nConstraint:\n1. Minimum Departure Interval: The interval between consecutive departures must be at least 5 minutes\n\\sum_{i=t}^{t+MinimumDepartureInterval-1} x_t \\leq 1, \\forall t \\in T \\text{ such that } t+MinimumDepartureInterval-1 \\leq EndTime\n\n2. Maximum Departure Interval: The interval between consecutive departures must be at most 15 minutes\n\\sum_{s=t+MinimumDepartureInterval}^{t+MaximumDepartureInterval-1} x_s, \\forall t \\in T \\text{ such that } t+MaximumDepartureInterval-1 \\leq EndTime\n\n3. Maximum departure times\n\\sum_{t\\in T}x_t \\leq (\\left\\lfloor\\frac{EndTime-StartTime}{RoundtripTime}\\right\\rfloor+1)MaximumBuses\n\nx_{StartTime} = 1\nx_{EndTime} = 1\n\n\nType:\nBinary, Quadratic, Linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_bus_scheduling(\n    StartTime=0,\n    EndTime=120,\n    MinimumDepartureInterval=5,\n    MaximumDepartureInterval=10,\n    RoundtripTime=30,\n    MaximumBuses=5\n):\n    \"\"\"\n    Solves the bus scheduling problem to minimize passenger waiting time.\n    \"\"\"\n    # --- Sets ---\n    TimeSlots = range(StartTime, EndTime + 1)\n\n    # --- Model Initialization ---\n    model = gp.Model(\"BusScheduling\")\n\n    # --- Decision Variables ---\n    Departures = model.addVars(TimeSlots, vtype=GRB.BINARY, name=\"Departures\")\n\n    # --- Objective Function ---\n    obj = gp.quicksum(\n        (s - t)**2 * Departures[t] * Departures[s]\n        for t in TimeSlots for s in TimeSlots if s > t\n    )\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Min departure interval\n    for t in TimeSlots:\n        if t + MinimumDepartureInterval - 1 <= EndTime:\n            model.addConstr(\n                gp.quicksum(Departures[i] for i in range(t, t + MinimumDepartureInterval)) <= 1\n            )\n\n    # Max departure interval\n    for t in TimeSlots:\n        if t + MaximumDepartureInterval - 1 <= EndTime:\n            model.addConstr(\n                Departures[t] <= gp.quicksum(\n                    Departures[s] for s in range(t + MinimumDepartureInterval, t + MaximumDepartureInterval)\n                )\n            )\n\n    # Max number of departures\n    max_departures = ((EndTime - StartTime) \/\/ RoundtripTime + 1) * MaximumBuses\n    model.addConstr(gp.quicksum(Departures[t] for t in TimeSlots) <= max_departures)\n\n    # Fixed departures at start and end\n    model.addConstr(Departures[StartTime] == 1)\n    model.addConstr(Departures[EndTime] == 1)\n\n    # --- Optimize the model ---\n    model.optimize()\n\n    # --- Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_bus_scheduling()\n    print(result)\n",
    "ground_truth":296730.0
  },
  {
    "task_id":"D056",
    "description":"A logistics company needs to optimize its warehouse storage by selecting a subset of products to store that maximizes profit while considering space constraints and product compatibility. The warehouse has a total capacity of 500 cubic meters. There are 8 products available, each with a specific volume, profit, and compatibility restrictions (some products cannot be stored together due to safety or regulatory reasons). The products and their attributes are as follows:\n\n| Product ID | Volume (m³) | Profit ($) | Incompatible Products |\n|------------|-------------|------------|------------------------|\n| 1          | 80          | 1200       | 3, 5                   |\n| 2          | 60          | 900        | 4                      |\n| 3          | 40          | 700        | 1, 6                   |\n| 4          | 70          | 1100       | 2, 7                   |\n| 5          | 50          | 800        | 1                      |\n| 6          | 30          | 500        | 3                      |\n| 7          | 90          | 1300       | 4                      |\n| 8          | 20          | 300        | None                   |",
    "formulation":"Set:\n1. Products\nThe set of available products, \\( P = \\{1, 2, 3, 4, 5, 6, 7, 8\\} \\)\n\nParameter:\n1. WarehouseCapacity\n500\n2. Volume\n[80, 60, 40, 70, 50, 30, 90, 20]\n3. Profit\n[1200, 900, 700, 1100, 800, 500, 1300, 300]\n4. IncompatiblePairs\n{(1,3), (1,5), (2,4), (3,1), (3,6), (4,2), (4,7), (5,1), (6,3), (7,4)}\n\nDecision variable:\n1. ProductSelected\nBinary variable \\( x_p \\in \\{0, 1\\} \\) for all \\( p \\in P \\), where \\( x_p = 1 \\) if product \\( p \\) is selected for storage, and \\( x_p = 0 \\) otherwise\n\nObjective:\nMaximize total profit from selected products\nmax: \\sum_{p\\in P}Profit_p \\cdot x_p\n\nConstraint:\n1. Total volume of selected products must not exceed warehouse capacity\n\\sum_{p\\in P}Volume_p \\cdot x_p \\leq WarehouseCapacity\n2. Incompatible products cannot be selected together\nx_p + x_q \\leq 1, \\forall (p,q) \\in IncompatiblePairs\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_warehouse_optimization(\n    products=[1, 2, 3, 4, 5, 6, 7, 8],\n    volume={1: 80, 2: 60, 3: 40, 4: 70, 5: 50, 6: 30, 7: 90, 8: 20},\n    profit={\n        1: 1200,\n        2: 900,\n        3: 700,\n        4: 1100,\n        5: 800,\n        6: 500,\n        7: 1300,\n        8: 300\n    },\n    warehouse_capacity=500,\n    incompatible_pairs=[(1, 3), (1, 5), (2, 4), (3, 1), (3, 6), (4, 2),\n                        (4, 7), (5, 1), (6, 3), (7, 4)]\n):\n    \"\"\"\n    Solves the warehouse storage optimization problem.\n    \"\"\"\n    model = gp.Model(\"Warehouse_Storage_Optimization\")\n\n    # Decision Variables\n    x = model.addVars(products, vtype=GRB.BINARY, name=\"select\")\n\n    # Objective Function\n    model.setObjective(gp.quicksum(profit[p] * x[p] for p in products),\n                       GRB.MAXIMIZE)\n\n    # Constraints\n    model.addConstr(\n        gp.quicksum(volume[p] * x[p] for p in products) <= warehouse_capacity,\n        \"Capacity\")\n\n    for (p, q) in incompatible_pairs:\n        model.addConstr(x[p] + x[q] <= 1, f\"Incompatible_{p}_{q}\")\n\n    # Solve the Model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_warehouse_optimization()\n    print(result)\n",
    "ground_truth":4200.0
  },
  {
    "task_id":"D057",
    "description":"A logistics company needs to pack 12 rectangular parcels into a shipping container with fixed width of 100 cm and variable height. The parcels have different dimensions and must be placed orthogonally (no rotations allowed). The goal is to arrange all parcels within the container while minimizing the total height used. The parcels have the following dimensions (width × height in cm):\n1. 30×40, 2. 25×35, 3. 40×20, 4. 15×25, 5. 35×30, 6. 20×15, 7. 25×20, 8. 30×25, 9. 15×10, 10. 20×30, 11. 10×15, 12. 25×10. Parcels cannot overlap and must be completely contained within the container's width. The container has unlimited height capacity, but the objective is to minimize the used height.",
    "formulation":"Set:\n1. Parcels\nThe set of parcels, \\( P = \\{1, 2, ..., 12\\} \\)\n\nParameter:\n1. ContainerWidth\n100 (cm)\n2. ParcelWidths\n[30, 25, 40, 15, 35, 20, 25, 30, 15, 20, 10, 25] (cm)\n3. ParcelHeights\n[40, 35, 20, 25, 30, 15, 20, 25, 10, 30, 15, 10] (cm)\n4. M (Large constant)\n1000 (sufficiently large number for big-M constraints)\n\nDecision variable:\n1. x_p\nContinuous variable \\( x_p \\geq 0 \\) for all \\( p \\in P \\), x-coordinate of bottom-left corner of parcel p\n2. y_p\nContinuous variable \\( y_p \\geq 0 \\) for all \\( p \\in P \\), y-coordinate of bottom-left corner of parcel p\n3. a_{pq}\nBinary variable for all \\( p,q \\in P, p < q \\), indicating relative positioning:\n   - \\( a_{pq} = 1 \\) if parcel p is to the left of q\n   - \\( a_{pq} = 0 \\) otherwise\n4. b_{pq}\nBinary variable for all \\( p,q \\in P, p < q \\), indicating relative positioning:\n   - \\( b_{pq} = 1 \\) if parcel p is below q\n   - \\( b_{pq} = 0 \\) otherwise\n5. H\nContinuous variable \\( H \\geq 0 \\), representing total container height\n\nObjective:\nMinimize the total height of the container\nmin: H\n\nConstraint:\n1. Parcels must fit within container width\n\\( x_p + \\text{ParcelWidths}_p \\leq \\text{ContainerWidth}, \\forall p \\in P \\)\n2. Parcels must fit within container height\n\\( y_p + \\text{ParcelHeights}_p \\leq H, \\forall p \\in P \\)\n3. Non-overlapping constraints (for all \\( p,q \\in P, p < q \\)):\n   \\( x_p + \\text{ParcelWidths}_p \\leq x_q + M(1-a_{pq}) \\)\n   \\( x_q + \\text{ParcelWidths}_q \\leq x_p + M(1-a_{qp}) \\)\n   \\( y_p + \\text{ParcelHeights}_p \\leq y_q + M(1-b_{pq}) \\)\n   \\( y_q + \\text{ParcelHeights}_q \\leq y_p + M(1-b_{qp}) \\)\n   \\( a_{pq} + a_{qp} + b_{pq} + b_{qp} \\geq 1 \\)\n4. Height calculation\n\\( H \\geq y_p + \\text{ParcelHeights}_p, \\forall p \\in P \\)\n\nType:\nMixed, Linear, Linear\nMILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_container_packing(\n    parcels=list(range(12)),\n    parcel_widths=[30, 25, 40, 15, 35, 20, 25, 30, 15, 20, 10, 25],\n    parcel_heights=[40, 35, 20, 25, 30, 15, 20, 25, 10, 30, 15, 10],\n    container_width=100,\n    M=1000\n):\n    \"\"\"Solve the rectangular packing problem to minimize container height.\"\"\"\n    model = gp.Model(\"ContainerPacking\")\n\n    # Create variables\n    x = model.addVars(parcels, lb=0, name=\"x\")\n    y = model.addVars(parcels, lb=0, name=\"y\")\n    a = model.addVars(parcels, parcels, vtype=GRB.BINARY, name=\"a\")\n    b = model.addVars(parcels, parcels, vtype=GRB.BINARY, name=\"b\")\n    H = model.addVar(lb=0, name=\"H\")\n\n    # Set objective\n    model.setObjective(H, GRB.MINIMIZE)\n\n    # Add constraints\n    model.addConstrs(\n        (x[p] + parcel_widths[p] <= container_width for p in parcels),\n        name=\"width_constraint\")\n\n    for p in parcels:\n        for q in parcels:\n            if p < q:\n                model.addConstr(x[p] + parcel_widths[p] <= x[q] + M * (1 - a[p, q]))\n                model.addConstr(x[q] + parcel_widths[q] <= x[p] + M * (1 - a[q, p]))\n                model.addConstr(y[p] + parcel_heights[p] <= y[q] + M * (1 - b[p, q]))\n                model.addConstr(y[q] + parcel_heights[q] <= y[p] + M * (1 - b[q, p]))\n                model.addConstr(a[p, q] + a[q, p] + b[p, q] + b[q, p] >= 1)\n\n    model.addConstrs((H >= y[p] + parcel_heights[p] for p in parcels),\n                     name=\"height_calculation\")\n\n    # Optimize model\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": H.X}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_container_packing()\n    print(result)\n",
    "ground_truth":75.0
  },
  {
    "task_id":"D058",
    "description":"A logistics company needs to pack 6 heavy cylindrical containers into a specialized truck bed. The truck bed has a fixed width of 2.5 meters, and the company wants to find the minimum possible length required to fit all containers. The diameters of the 6 containers (in meters) are: [1.2, 1.1, 1.0, 0.9, 0.8, 0.7].\n\nThe containers must be placed flat on the truck bed according to the following rules:\n1.  Each container must be fully contained within the truck bed's boundaries.\n2.  No two containers can overlap.\n3.  The goal is to find an arrangement that minimizes the total length of the truck bed used.\n\nThe position of each container is determined by the (x, y) coordinates of its center. The x-axis runs along the length of the truck, and the y-axis runs along its fixed width.",
    "formulation":"# Set\n# C: The set of containers to be packed.\nSet:\n1. Containers\nThe set of containers, \\( C = \\{1, 2, 3, 4, 5, 6\\} \\)\n\n# Parameter\n# TruckWidth: The fixed width of the truck bed in meters.\n# Diameter_c: The diameter of container c.\n# Radius_c: The radius of container c, calculated as Diameter_c \/ 2.\nParameter:\n1. TruckWidth\n2.5 (meters)\n2. Diameters\nThe diameter of each container \\( c \\in C \\) (meters): [1.2, 1.1, 1.0, 0.9, 0.8, 0.7]\n3. Radii\nThe radius of each container \\( c \\in C \\) (meters): [0.6, 0.55, 0.5, 0.45, 0.4, 0.35]\n\n# Decision variable\n# x_c, y_c: The continuous variables representing the center coordinates of container c.\n# L: A continuous variable representing the required length of the truck bed.\nDecision variable:\n1. x_c\nContinuous variable \\( x_c \\geq 0 \\) for all \\( c \\in C \\), representing the x-coordinate (length dimension) of container \\( c \\)'s center.\n2. y_c\nContinuous variable \\( y_c \\geq 0 \\) for all \\( c \\in C \\), representing the y-coordinate (width dimension) of container \\( c \\)'s center.\n3. L\nContinuous variable \\( L \\geq 0 \\), representing the required length of the truck bed.\n\n# Objective\n# Minimize the required length of the truck bed.\nObjective:\nMinimize the truck length\nmin: \\( L \\)\n\n# Constraint\n# 1. Containers must fit within the truck width (respecting boundaries).\n# 2. Containers must fit within the required truck length (respecting boundaries).\n# 3. No two containers i and j can overlap. This is enforced by ensuring the distance between\n#    their centers is at least the sum of their radii.\nConstraint:\n1. Width Boundary\n\\( y_c + \\text{Radius}_c \\leq \\text{TruckWidth}, \\quad \\forall c \\in C \\)\n\\( y_c \\geq \\text{Radius}_c, \\quad \\forall c \\in C \\)\n2. Length Boundary\n\\( x_c + \\text{Radius}_c \\leq L, \\quad \\forall c \\in C \\)\n\\( x_c \\geq \\text{Radius}_c, \\quad \\forall c \\in C \\)\n3. Non-Overlapping\n\\( (x_i - x_j)^2 + (y_i - y_j)^2 \\geq (\\text{Radius}_i + \\text{Radius}_j)^2, \\quad \\forall i, j \\in C, i < j \\)\n\n# Type\n# The problem has continuous variables. The non-overlapping constraint is a non-convex\n# quadratic constraint, making this a Non-Convex Quadratically Constrained Program (QCQP),\n# a specific type of Nonlinear Program (NLP).\nType:\nContinuous, Quadratic, Non-linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_nonlinear_container_packing(\n    container_ids=list(range(6)),\n    diameters={0: 1.2, 1: 1.1, 2: 1.0, 3: 0.9, 4: 0.8, 5: 0.7},\n    truck_width=2.5,\n    time_limit=60\n):\n    \"\"\"\n    Solves a non-linear container packing problem for a reduced number of containers.\n    This model is a Non-Convex Quadratically Constrained Program (QCQP).\n    \"\"\"\n    radii = {c: d \/ 2 for c, d in diameters.items()}\n\n    model = gp.Model(\"NonlinearContainerPacking\")\n\n    x = model.addVars(container_ids, name=\"x_coord\", lb=0.0)\n    y = model.addVars(container_ids, name=\"y_coord\", lb=0.0)\n    L = model.addVar(name=\"TruckLength\", lb=0.0)\n\n    model.setObjective(L, GRB.MINIMIZE)\n\n    for c in container_ids:\n        model.addConstr(y[c] - radii[c] >= 0, name=f\"width_lower_{c}\")\n        model.addConstr(y[c] + radii[c] <= truck_width, name=f\"width_upper_{c}\")\n        model.addConstr(x[c] - radii[c] >= 0, name=f\"length_lower_{c}\")\n        model.addConstr(x[c] + radii[c] <= L, name=f\"length_upper_{c}\")\n\n    for i in container_ids:\n        for j in container_ids:\n            if i < j:\n                model.addQConstr(\n                    (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) >= (radii[i] + radii[j])**2,\n                    name=f\"no_overlap_{i}_{j}\"\n                )\n\n    model.Params.NonConvex = 2\n    model.Params.TimeLimit = time_limit\n    \n    model.optimize()\n\n    if model.Status == GRB.OPTIMAL or model.Status == GRB.TIME_LIMIT:\n        return {\"status\": \"optimal\", \"obj\": L.X}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_nonlinear_container_packing()\n    print(result)\n",
    "ground_truth":2.373934757
  },
  {
    "task_id":"D059",
    "description":"A logistics company operates a two-echelon distribution network with 1 central depot (D), 3 intermediate warehouses (W1, W2, W3), and 15 customers (C1-C15). The depot has 3 trucks with a capacity of 50 units each for first-level transport. Each warehouse has an allocation of 2 smaller vehicles with a capacity of 20 units each for second-level delivery.\n\nThe goal is to assign customers to warehouses and plan optimal delivery routes for all vehicles to minimize the total distance traveled, subject to the following constraints:\n- Each customer must be served by exactly one van.\n- Each van must start and end its tour at its assigned warehouse.\n- The total demand on any vehicle's route cannot exceed its capacity.\n- The total demand flowing through an opened warehouse cannot exceed the capacity of the truck serving it.\n\n**Distances (km):**\n- **Depot to Warehouses:** Depot-W1: 30, Depot-W2: 40, Depot-W3: 35.\n- **Between Warehouses:** W1-W2: 25, W1-W3: 20, W2-W3: 30.\n- **Between Customers:** A full distance matrix is provided for travel between any two customers as follows:\n\n| | C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 | C11 | C12 | C13 | C14 | C15 |\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n| C1 | 0 | 15 | 24 | 11 | 20 | 9 | 20 | 11 | 5 | 18 | 15 | 24 | 12 | 10 | 10 |\n| C2 | 15 | 0 | 18 | 21 | 13 | 12 | 5 | 12 | 15 | 24 | 18 | 11 | 22 | 19 | 13 |\n| C3 | 24 | 18 | 0 | 6 | 13 | 11 | 24 | 11 | 13 | 10 | 11 | 18 | 19 | 13 | 11 |\n| C4 | 11 | 21 | 6 | 0 | 11 | 16 | 12 | 18 | 11 | 19 | 10 | 11 | 14 | 19 | 10 |\n| C5 | 20 | 13 | 13 | 11 | 0 | 14 | 24 | 10 | 16 | 21 | 16 | 11 | 14 | 17 | 15 |\n| C6 | 9 | 12 | 11 | 16 | 14 | 0 | 19 | 18 | 23 | 19 | 18 | 10 | 15 | 11 | 12 |\n| C7 | 20 | 5 | 24 | 12 | 24 | 19 | 0 | 16 | 11 | 17 | 12 | 17 | 13 | 17 | 12 |\n| C8 | 11 | 12 | 11 | 18 | 10 | 18 | 16 | 0 | 18 | 13 | 12 | 17 | 18 | 13 | 16 |\n| C9 | 5 | 15 | 13 | 11 | 16 | 23 | 11 | 18 | 0 | 13 | 24 | 21 | 18 | 18 | 11 |\n| C10 | 18 | 24 | 10 | 19 | 21 | 19 | 17 | 13 | 13 | 0 | 12 | 22 | 12 | 19 | 17 |\n| C11 | 15 | 18 | 11 | 10 | 16 | 18 | 12 | 12 | 24 | 12 | 0 | 16 | 18 | 15 | 13 |\n| C12 | 24 | 11 | 18 | 11 | 11 | 10 | 17 | 17 | 21 | 22 | 16 | 0 | 19 | 19 | 13 |\n| C13 | 12 | 22 | 19 | 14 | 14 | 15 | 13 | 18 | 18 | 12 | 18 | 19 | 0 | 13 | 18 |\n| C14 | 10 | 19 | 13 | 19 | 17 | 11 | 17 | 13 | 18 | 19 | 15 | 19 | 13 | 0 | 18 |\n| C15 | 10 | 13 | 11 | 10 | 15 | 12 | 12 | 16 | 11 | 17 | 13 | 13 | 18 | 18 | 0 |\n\n- **Warehouses to Customers:** The specific distances are defined as follows:\n\n| From | To | Dist | | From | To | Dist | | From | To | Dist |\n| :--- | :--- | :--- |-|:--- | :--- | :--- |-|:--- | :--- | :--- |\n| W1   | C1   | 12   | | W2   | C1   | 28   | | W3   | C1   | 18   |\n| W1   | C2   | 8    | | W2   | C2   | 22   | | W3   | C2   | 25   |\n| W1   | C3   | 15   | | W2   | C3   | 10   | | W3   | C3   | 9    |\n| W1   | C4   | 11   | | W2   | C4   | 14   | | W3   | C4   | 19   |\n| W1   | C5   | 7    | | W2   | C5   | 18   | | W3   | C5   | 24   |\n| W1   | C6   | 14   | | W2   | C6   | 9    | | W3   | C6   | 16   |\n| W1   | C7   | 10   | | W2   | C7   | 13   | | W3   | C7   | 12   |\n| W1   | C8   | 9    | | W2   | C8   | 17   | | W3   | C8   | 21   |\n| W1   | C9   | 13   | | W2   | C9   | 11   | | W3   | C9   | 7    |\n| W1   | C10  | 6    | | W2   | C10  | 20   | | W3   | C10  | 23   |\n| W1   | C11  | 14   | | W2   | C11  | 7    | | W3   | C11  | 10   |\n| W1   | C12  | 9    | | W2   | C12  | 16   | | W3   | C12  | 17   |\n| W1   | C13  | 11   | | W2   | C13  | 19   | | W3   | C13  | 22   |\n| W1   | C14  | 7    | | W2   | C14  | 12   | | W3   | C14  | 14   |\n| W1   | C15  | 13   | | W2   | C15  | 15   | | W3   | C15  | 8    |\n\n**Demands (units):**\n- C1:4, C2:7, C3:5, C4:6, C5:3, C6:8, C7:5, C8:6, C9:4, C10:7, C11:5, C12:6, C13:3, C14:8, C15:5.",
    "formulation":"Sets:\n1.  W: Set of potential warehouse locations. W = {W1, W2, W3}\n2.  C: Set of customers. C = {C1, C2, ..., C15}\n3.  N: Set of all nodes for routing, N = W U C.\n4.  K: Set of available vans at each warehouse. K = {1, 2}\n\nParameters:\n1.  demand_i: Demand of customer i, for i in C.\n2.  dist_ij: Distance between node i and node j, for i, j in N. This combines customer-customer, warehouse-customer, and depot-warehouse distances.\n3.  CAP_TRUCK: Capacity of a single truck from the depot (50 units).\n4.  CAP_VAN: Capacity of a single van from a warehouse (20 units).\n5.  NUM_VANS: Number of vans available at each warehouse (2).\n\nDecision Variables:\n1.  y_w: Binary variable. y_w = 1 if warehouse w is used, 0 otherwise. For w in W.\n2.  z_iw: Binary variable. z_iw = 1 if customer i is assigned to warehouse w, 0 otherwise. For i in C, w in W.\n3.  x_ijkw: Binary variable. x_ijkw = 1 if van k from warehouse w travels from node i to node j, 0 otherwise. For i, j in N, w in W, k in K.\n4.  u_ikw: Continuous variable for subtour elimination (MTZ formulation). Represents the load accumulated by van k from warehouse w after visiting customer i. For i in C, w in W, k in K.\n\nObjective Function:\nMinimize the total distance traveled in both echelons.\n1.  First-echelon distance: Cost of round trips from the depot to each opened warehouse.\n2.  Second-echelon distance: Cost of all van routes from warehouses to customers.\n\nMinimize Z = sum_{w in W} (2 * dist_depot_w * y_w) + sum_{i in N} sum_{j in N} sum_{w in W} sum_{k in K} (dist_ij * x_ijkw)\n\nConstraints:\n1.  Warehouse Activation: A customer can only be assigned to a warehouse if that warehouse is active (used).\n    forall i in C, w in W:\n    z_iw <= y_w\n\n2.  Customer Assignment: Each customer must be assigned to exactly one warehouse.\n    forall i in C:\n    sum_{w in W} z_iw = 1\n\n3.  Warehouse Capacity: The total demand of customers assigned to a warehouse cannot exceed the truck capacity.\n    forall w in W:\n    sum_{i in C} (demand_i * z_iw) <= CAP_TRUCK * y_w\n\n4.  Van Assignment: If a customer is assigned to a warehouse, it must be visited by exactly one van from that warehouse.\n    forall i in C, w in W:\n    sum_{k in K} sum_{j in N, j != i} x_ijwk = z_iw\n\n5.  Flow Conservation: Each van that enters a customer node must also leave it.\n    forall i in C, w in W, k in K:\n    sum_{j in N, j != i} x_jiwk - sum_{j in N, j != i} x_ijwk = 0\n\n6.  Route Start: Each van used must depart from its assigned warehouse.\n    forall w in W, k in K:\n    sum_{j in C} x_w,j,k,w <= 1\n\n7.  Route End: Each van used must return to its assigned warehouse.\n    forall w in W, k in K:\n    sum_{i in C} x_i,w,k,w <= 1\n\n8.  Start-End Equality: A van only returns to the warehouse if it departed from it.\n    forall w in W, k in K:\n    sum_{j in C} x_w,j,k,w = sum_{i in C} x_i,w,k,w\n\n9.  Van Capacity: The total demand served by any single van cannot exceed its capacity.\n    forall w in W, k in K:\n    sum_{i in C} (demand_i * sum_{j in N, j != i} x_ijwk) <= CAP_VAN\n\n10. Subtour Elimination (MTZ): Prevents routes that do not include the warehouse.\n    forall i in C, j in C (i != j), w in W, k in K:\n    u_ikw - u_jkw + demand_i <= (CAP_VAN + demand_i) * (1 - x_ijkw)\n\n11. Load Bounds: Defines the bounds for the load variables.\n    forall i in C, w in W, k in K:\n    demand_i * sum_{j in N, j != i} x_ijwk <= u_ikw <= CAP_VAN * sum_{j in N, j != i} x_ijwk\n\nType:\nMixed, Linear, Linear\nMILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich.panel import Panel\nimport numpy as np\n\ndef solve_two_echelon_vrp():\n    \"\"\"\n    Solves a model for the Two-Echelon Vehicle Routing Problem.\n    This version correctly incorporates all constraints from the problem description,\n    with comments and output in English.\n    \"\"\"\n    console = Console()\n    console.print(Panel(\"[bold blue]Enhanced Two-Echelon VRP Solver[\/bold blue]\"))\n\n    # ========== 1. Data Preparation ==========\n    # --- Define sets ---\n    depot = 'D0'\n    warehouses = ['W1', 'W2', 'W3']\n    customers = [f'C{i}' for i in range(1, 16)]\n    nodes = warehouses + customers  # All nodes for the second-echelon VRP\n    \n    # --- Define vehicle counts and capacities ---\n    num_trucks = 3\n    num_vans_per_warehouse = 2\n    # Total number of vans available in the fleet\n    all_vans = [f'V{i}' for i in range(1, len(warehouses) * num_vans_per_warehouse + 1)]\n\n    truck_capacity = 50\n    van_capacity = 20\n    \n    # --- Customer demands ---\n    demands = {\n        'C1':4, 'C2':7, 'C3':5, 'C4':6, 'C5':3, 'C6':8, 'C7':5, 'C8':6, \n        'C9':4, 'C10':7, 'C11':5, 'C12':6, 'C13':3, 'C14':8, 'C15':5\n    }\n\n    # --- Distance Matrix ---\n    # Note: The problem provides D-W, W-W, and W-C distances, but not C-C (customer-to-customer).\n    # We use a fixed random seed to generate C-C distances for reproducibility.\n    dist = {}\n    \n    # Echelon 1: Depot to Warehouses\n    dist.update({ (depot, 'W1'): 30, ('W1', depot): 30, (depot, 'W2'): 40, ('W2', depot): 40, (depot, 'W3'): 35, ('W3', depot): 35 })\n    \n    # Distances between warehouses (loaded for completeness, though not used in routes)\n    dist.update({ ('W1', 'W2'): 25, ('W2', 'W1'): 25, ('W1', 'W3'): 20, ('W3', 'W1'): 20, ('W2', 'W3'): 30, ('W3', 'W2'): 30 })\n\n    # Echelon 2: Warehouses to Customers\n    wc_dist_data = {\n        'W1': [12, 8, 15, 11, 7, 14, 10, 9, 13, 6, 14, 9, 11, 7, 13],\n        'W2': [28, 22, 10, 14, 18, 9, 13, 17, 11, 20, 7, 16, 19, 12, 15],\n        'W3': [18, 25, 9, 19, 24, 16, 12, 21, 7, 23, 10, 17, 22, 14, 8]\n    }\n    for w_idx, w in enumerate(warehouses):\n        for c_idx, c in enumerate(customers):\n            d = wc_dist_data[w][c_idx]\n            dist[w, c] = d\n            dist[c, w] = d # Distances are symmetric\n\n    # Echelon 2: Customer to Customer (generated with a fixed seed)\n    np.random.seed(42)\n    for i in range(len(customers)):\n        for j in range(i, len(customers)):\n            c1, c2 = customers[i], customers[j]\n            if i == j:\n                dist[c1, c2] = 0\n            else:\n                d = np.random.randint(5, 25)\n                dist[c1, c2] = d\n                dist[c2, c1] = d\n\n    # ========== 2. Model Creation ==========\n    model = gp.Model(\"Fully_Constrained_2E_VRP\")\n\n    # ========== 3. Decision Variables ==========\n    z = model.addVars(warehouses, vtype=GRB.BINARY, name=\"warehouse_open\")\n    y = model.addVars(customers, all_vans, vtype=GRB.BINARY, name=\"customer_served_by_van\")\n    assign_vw = model.addVars(all_vans, warehouses, vtype=GRB.BINARY, name=\"van_at_warehouse\")\n    x = model.addVars(nodes, nodes, all_vans, vtype=GRB.BINARY, name=\"van_route\")\n    \n    # ========== 4. Objective Function ==========\n    first_echelon_cost = gp.quicksum(2 * dist[depot, w] * z[w] for w in warehouses)\n    second_echelon_cost = gp.quicksum(dist[i, j] * x[i, j, v] for i in nodes for j in nodes for v in all_vans if i != j)\n    model.setObjective(first_echelon_cost + second_echelon_cost, GRB.MINIMIZE)\n\n    # ========== 5. Constraints ==========\n    # --- Assignment Constraints ---\n    model.addConstrs((y.sum(c, '*') == 1 for c in customers), \"C1_customer_one_van\")\n    model.addConstrs((assign_vw.sum(v, '*') <= 1 for v in all_vans), \"C2a_van_one_warehouse\")\n    model.addConstrs((assign_vw[v, w] <= z[w] for v in all_vans for w in warehouses), \"C2b_van_assign_to_open_wh\")\n\n    # --- Warehouse Vehicle Limit Constraint (NEW) ---\n    model.addConstrs((assign_vw.sum('*', w) <= num_vans_per_warehouse for w in warehouses), \"C3_warehouse_van_limit\")\n    \n    # --- Truck Fleet Size Constraint (NEW) ---\n    model.addConstr(z.sum() <= num_trucks, \"C4_truck_fleet_size\")\n    \n    # --- Capacity Constraints ---\n    model.addConstrs((gp.quicksum(demands[c] * y[c, v] for c in customers) <= van_capacity for v in all_vans), \"C5a_van_capacity\")\n    for w in warehouses:\n        total_demand_at_wh = gp.quicksum(demands[c] * y[c, v] * assign_vw[v, w] for c in customers for v in all_vans)\n        model.addConstr(total_demand_at_wh <= truck_capacity * z[w], f\"C5b_truck_capacity_{w}\")\n    \n    # --- Routing & Linking Constraints ---\n    model.addConstrs((gp.quicksum(x[i, c, v] for i in nodes if i != c) == y[c, v] for c in customers for v in all_vans), \"C6a_link_visit_in\")\n    model.addConstrs((gp.quicksum(x[c, j, v] for j in nodes if j != c) == y[c, v] for c in customers for v in all_vans), \"C6b_link_visit_out\")\n    \n    for v in all_vans:\n        # A van must depart from its assigned warehouse\n        model.addConstrs((gp.quicksum(x[w, j, v] for j in customers) <= assign_vw[v, w] for w in warehouses), f\"C7a_van_departs_from_assigned_wh_{v}\")\n        # Each van can start at most one tour\n        model.addConstr(gp.quicksum(x[w, j, v] for w in warehouses for j in customers) <= 1, f\"C7b_van_departs_once_{v}\")\n        # The van must return to the same warehouse it departed from\n        model.addConstr(gp.quicksum(x[w, j, v] for w in warehouses for j in customers) == \n                        gp.quicksum(x[i, w, v] for w in warehouses for i in customers), f\"C7c_van_returns_{v}\")\n        \n    # --- Subtour Elimination Constraints (MTZ) ---\n    u = model.addVars(customers, all_vans, vtype=GRB.CONTINUOUS, name=\"subtour_elim_u\")\n    for v in all_vans:\n        for i in customers:\n            model.addConstr(u[i, v] <= van_capacity, f\"C8a_u_upper_bound_{i}_{v}\")\n            model.addConstr(u[i, v] >= demands[i] * y[i, v], f\"C8b_u_lower_bound_{i}_{v}\")\n            for j in customers:\n                if i != j:\n                    model.addConstr(u[i, v] - u[j, v] + van_capacity * x[i, j, v] <= van_capacity - demands[j] * y[j,v], f\"C8c_subtour_elim_{i}_{j}_{v}\")\n\n    # ========== 6. Solve ==========\n    model.Params.MIPGap = 0.01   # Set a 1% optimality gap tolerance\n    model.optimize()\n\n    # ========== 7. Display Results ==========\n    if model.Status == GRB.OPTIMAL or (model.Status == GRB.TIME_LIMIT and model.SolCount > 0):\n        status = \"Optimal Solution Found\" if model.Status == GRB.OPTIMAL else f\"Time Limit Reached - Best Solution Found\"\n        console.print(Panel(f\"[bold green]{status}!\\nMinimized Total Distance: {model.ObjVal:.2f} km[\/bold green]\"))\n\n        open_hubs = [w for w in warehouses if z[w].X > 0.5]\n        console.print(f\"\\n[bold]Opened Warehouses:[\/bold] {', '.join(open_hubs) or 'None'}\")\n\n        route_table = Table(title=\"[bold]Vehicle Routes and Load Details[\/bold]\")\n        route_table.add_column(\"Vehicle\", style=\"cyan\", justify=\"center\")\n        route_table.add_column(\"Type\", style=\"yellow\", justify=\"center\")\n        route_table.add_column(\"Route\", style=\"magenta\", width=60)\n        route_table.add_column(\"Load\/Capacity\", style=\"green\", justify=\"right\")\n        route_table.add_column(\"Distance (km)\", style=\"red\", justify=\"right\")\n\n        for w in open_hubs:\n            wh_demand = sum(demands[c] * y[c,v].X * assign_vw[v,w].X for c in customers for v in all_vans)\n            route_table.add_row(f\"Truck (for {w})\", \"Echelon 1\", f\"{depot} -> {w} -> {depot}\", f\"{wh_demand:.0f}\/{truck_capacity}\", f\"{2*dist[depot, w]:.1f}\")\n        \n        for v in all_vans:\n            for w in warehouses:\n                if assign_vw[v, w].X > 0.5:\n                    tour_edges = [(i, j) for i in nodes for j in nodes if i != j and x[i, j, v].X > 0.5]\n                    if not tour_edges: continue\n                    \n                    # Reconstruct the tour starting from the warehouse\n                    tour = [w]\n                    current_node = w\n                    \n                    while True:\n                        found_next = False\n                        for i, j in tour_edges:\n                            if i == current_node and j not in tour:\n                                tour.append(j)\n                                current_node = j\n                                found_next = True\n                                break\n                        if not found_next:\n                            break # All connected edges have been added\n                    \n                    if tour[-1] != w: tour.append(w) # Ensure the tour is closed\n\n                    route_str = \" -> \".join(tour)\n                    route_load = sum(demands.get(c, 0) for c in tour if c in customers)\n                    route_dist = sum(dist.get((i, j), 0) for i, j in tour_edges)\n                    route_table.add_row(v, \"Echelon 2\", route_str, f\"{route_load}\/{van_capacity}\", f\"{route_dist:.1f}\")\n        console.print(route_table)\n    else:\n        console.print(f\"[bold red]No feasible solution found. Gurobi Status Code: {model.Status}[\/bold red]\")\n\nif __name__ == \"__main__\":\n    solve_two_echelon_vrp()\n",
    "ground_truth":275.0
  },
  {
    "task_id":"D060",
    "description":"A regional logistics company needs to optimize its cargo transportation network involving 3 supply points (S1, S2, S3), 2 transshipment hubs (H1, H2), and 4 demand points (D1, D2, D3, D4). The supply capacities are 200, 150, and 180 units respectively. Demand requirements are 120, 90, 110, and 130 units respectively. Transportation costs (per unit) between nodes are: S1-H1=5, S1-H2=7, S2-H1=6, S2-H2=8, S3-H1=4, S3-H2=5, H1-D1=3, H1-D2=4, H1-D3=5, H1-D4=6, H2-D1=4, H2-D2=3, H2-D3=6, H2-D4=5. All routes have unlimited capacity. The objective is to minimize total transportation costs while meeting all supply and demand constraints.",
    "formulation":"Set:\n1. SupplyNodes\nThe set of supply nodes, \\( S = \\{S1, S2, S3\\} \\)\n2. HubNodes\nThe set of transshipment hubs, \\( H = \\{H1, H2\\} \\)\n3. DemandNodes\nThe set of demand nodes, \\( D = \\{D1, D2, D3, D4\\} \\)\n\nParameter:\n1. SupplyCapacity\n\\( [200, 150, 180] \\) units for \\( S1, S2, S3 \\) respectively\n2. DemandRequirement\n\\( [120, 90, 110, 130] \\) units for \\( D1, D2, D3, D4 \\) respectively\n3. TransportationCost\nCost matrix \\( c_{ij} \\) where \\( i \\in S \\cup H, j \\in H \\cup D \\):\n- \\( c_{S1,H1}=5 \\), \\( c_{S1,H2}=7 \\)\n-S \\( c_{S2,H1}=6 \\), \\( c_{S2,H2}=8 \\)\n- \\( c_{S3,H1}=4 \\), \\( c_{S3,H2}=5 \\)\n- \\( c_{H1,D1}=3 \\), \\( c_{H1,D2}=4 \\), \\( c_{H1,D3}=5 \\), \\( c_{H1,D4}=6 \\)\n- \\( c_{H2,D1}=4 \\), \\( c_{H2,D2}=3 \\), \\( c_{H2,D3}=6 \\), \\( c_{H2,D4}=5 \\)\n\nDecision variable:\n1. FlowAmount\ncontinuous variable \\( x_{ij} \\geq 0 \\) representing the flow from node \\( i \\) to node \\( j \\), where \\( i \\in S \\cup H, j \\in H \\cup D \\)\n\nObjective:\nMinimize total transportation cost\nmin: \\( \\sum_{i \\in S} \\sum_{j \\in H} c_{ij}x_{ij} + \\sum_{i \\in H} \\sum_{j \\in D} c_{ij}x_{ij} \\)\n\nConstraint:\n1. Supply constraints: Outflow from each supply node cannot exceed its capacity\n\\( \\sum_{j \\in H} x_{ij} \\leq SupplyCapacity_i, \\forall i \\in S \\)\n2. Hub balance: Inflow equals outflow at each hub\n\\( \\sum_{i \\in S} x_{ih} = \\sum_{j \\in D} x_{hj}, \\forall h \\in H \\)\n3. Demand constraints: Inflow to each demand node must meet its requirement\n\\( \\sum_{i \\in H} x_{ij} = DemandRequirement_j, \\forall j \\in D \\)\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_transportation_problem(\n    supply_nodes=['S1', 'S2', 'S3'],\n    hub_nodes=['H1', 'H2'],\n    demand_nodes=['D1', 'D2', 'D3', 'D4'],\n    supply_capacity={'S1': 200, 'S2': 150, 'S3': 180},\n    demand_requirement={'D1': 120, 'D2': 90, 'D3': 110, 'D4': 130},\n    transport_cost={\n        ('S1', 'H1'): 5, ('S1', 'H2'): 7,\n        ('S2', 'H1'): 6, ('S2', 'H2'): 8,\n        ('S3', 'H1'): 4, ('S3', 'H2'): 5,\n        ('H1', 'D1'): 3, ('H1', 'D2'): 4, ('H1', 'D3'): 5, ('H1', 'D4'): 6,\n        ('H2', 'D1'): 4, ('H2', 'D2'): 3, ('H2', 'D3'): 6, ('H2', 'D4'): 5,\n    }\n):\n    \"\"\"Solve the cargo transportation network optimization problem.\"\"\"\n    model = gp.Model(\"CargoTransportation\")\n\n    flow = model.addVars(transport_cost.keys(), lb=0, vtype=GRB.CONTINUOUS, name=\"flow\")\n\n    model.setObjective(\n        gp.quicksum(flow[i, j] * transport_cost[i, j] for i, j in transport_cost.keys()),\n        GRB.MINIMIZE\n    )\n\n    for s in supply_nodes:\n        model.addConstr(gp.quicksum(flow[s, h] for h in hub_nodes) <= supply_capacity[s])\n\n    for h in hub_nodes:\n        model.addConstr(\n            gp.quicksum(flow[s, h] for s in supply_nodes) == gp.quicksum(flow[h, d] for d in demand_nodes)\n        )\n\n    for d in demand_nodes:\n        model.addConstr(gp.quicksum(flow[h, d] for h in hub_nodes) == demand_requirement[d])\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_transportation_problem()\n    print(result)",
    "ground_truth":4190.0
  },
  {
    "task_id":"D061",
    "description":"A regional beverage distributor needs to design an optimal delivery network from their central warehouse (node 0) to 8 retail stores (nodes 1-8). The road network between locations has the following distances (in km): [(0,1)=12, (0,2)=8, (1,2)=5, (1,3)=9, (2,4)=7, (3,4)=6, (3,5)=11, (4,6)=10, (5,6)=4, (5,7)=8, (6,8)=7, (7,8)=6]. Each delivery truck has a capacity of serving maximum 3 stores (including transfers). The company wants to minimize total travel distance while ensuring no truck serves more than 3 nodes in its subtree. The warehouse must be connected to all stores through a single network without cycles.",
    "formulation":"Set\nN: The set of all locations (nodes), where 0 is the warehouse.\nE: The set of all possible connections (edges) between nodes.\n\nParameter\nd_ij: The distance of the edge between node i and j.\nC: The capacity of a truck (max number of stores in a subtree).\nq_i: The demand at each node (1 for each store, 0 for the warehouse).\n\nDecision variable\nx_ij: Binary, 1 if the edge (i,j) is selected for the tree.\nf_ij: Continuous, represents the amount of \"flow\" on the edge from i to j.\n\nObjective\n# Minimize the total distance of the selected edges.\nmin: ( \\sum_{(i,j) \\in E} d_{ij} \\cdot x_{ij} )\n\nConstraint\n1. Spanning Tree Structure: Exactly |N|-1 edges must be selected.\n   \\sum_{(i,j) \\in E} x_{ij} = |N| - 1\n2. Flow Balance: For each node, the flow coming in must equal the flow going out plus that node's own demand. This ensures connectivity and prevents cycles.\n   \\sum_{j:(j,i) \\in E} f_{ji} - \\sum_{j:(i,j) \\in E} f_{ij} = q_i,  \\forall i \\in N\n3. Flow-Edge Link: Flow can only pass through an edge if that edge is selected. The flow represents the number of nodes being served, so its maximum value is |N|-1.\n   f_{ij} <= (|N| - 1) \\cdot x_{ij},  \\forall (i,j) \\in E\n   f_{ji} <= (|N| - 1) \\cdot x_{ji},  \\forall (i,j) \\in E\n4. Capacity Constraint: The flow on any edge cannot exceed the truck's capacity. This effectively limits the size of the subtree.\n   f_{ij} + f_{ji} \\leq C \\cdot x_{ij},  \\forall (i,j) \\in E, i,j \\neq 0\n\nType:\nMixed, Linear, Linear\nMILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport itertools\n\n\ndef solve_capacitated_mst(\n    nodes=list(range(9)),\n    warehouse=0,\n    distances_data=None,\n    capacity=3,\n    time_limit=60\n):\n    \"\"\"\n    Solves the capacitated minimal spanning tree problem using a\n    single-commodity flow formulation.\n    \"\"\"\n    if distances_data is None:\n        distances = {\n            (0, 1): 12, (0, 2): 8, (1, 2): 5, (1, 3): 9, (2, 4): 7, (3, 4): 6,\n            (3, 5): 11, (4, 6): 10, (5, 6): 4, (5, 7): 8, (6, 8): 7, (7, 8): 6\n        }\n        for i, j in distances.copy():\n            distances[j, i] = distances[i, j]\n    else:\n        distances = distances_data\n\n    stores = [n for n in nodes if n != warehouse]\n    demands = {n: 1 if n in stores else -(len(stores)) for n in nodes}\n\n    model = gp.Model(\"Corrected_CMST\")\n\n    x = model.addVars(distances.keys(), vtype=GRB.BINARY, name=\"edge_selected\")\n    f = model.addVars(distances.keys(), vtype=GRB.CONTINUOUS, name=\"flow\")\n\n    model.setObjective(\n        gp.quicksum(distances[i, j] * x[i, j] for i, j in distances if i < j),\n        GRB.MINIMIZE\n    )\n\n    model.addConstr(x.sum('*', '*') \/ 2 == len(nodes) - 1, \"num_edges\")\n\n    for i in nodes:\n        in_flow = gp.quicksum(f[j, i] for j in nodes if (j, i) in distances)\n        out_flow = gp.quicksum(f[i, j] for j in nodes if (i, j) in distances)\n        model.addConstr(in_flow - out_flow == demands[i], f\"flow_balance_{i}\")\n\n    for i, j in distances:\n        model.addConstr(f[i, j] <= (len(nodes) - 1) * x[i, j], f\"flow_link_{i}_{j}\")\n\n    for i, j in distances:\n        if i != warehouse and j != warehouse:\n            model.addConstr(f[i, j] + f[j, i] <= capacity * x[i, j], f\"capacity_{i}_{j}\")\n\n    model.Params.TimeLimit = time_limit\n    model.optimize()\n\n    if model.Status == GRB.OPTIMAL or model.Status == GRB.TIME_LIMIT:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_capacitated_mst()\n    print(result)\n",
    "ground_truth":72.0
  },
  {
    "task_id":"D062",
    "description":"A logistics company needs to schedule deliveries for 8 customer orders using 3 available trucks. Each order has a specific processing time (hours) and must be assigned to exactly one truck. Some orders require multiple visits to the same truck (reentrant processing) due to intermediate handling requirements. The trucks have different capacities (maximum total processing time they can handle) and operating costs per hour. The objective is to minimize the total operating cost while ensuring no truck exceeds its capacity and all orders are completed. \n\nOrder details:\n- Order processing times: [4, 5, 3, 6, 2, 5, 4, 3]\n- Reentrant requirements: Orders 2 and 5 must be processed twice by their assigned truck\n- Truck capacities: [15, 18, 12] hours\n- Truck operating costs: [30, 25, 35] per hour",
    "formulation":"Set:\n1. Orders\nThe set of Orders, \\( O = \\{1, 2, ..., 8\\} \\)\n2. Trucks\nThe set of Trucks, \\( T = \\{1, 2, 3\\} \\)\n\nParameter:\n1. ProcessingTime\n[4, 5, 3, 6, 2, 5, 4, 3] (hours for each order)\n2. ReentrantFactor\n[1, 2, 1, 1, 2, 1, 1, 1] (number of times each order must be processed)\n3. TruckCapacity\n[15, 18, 12] (maximum total processing hours per truck)\n4. OperatingCost\n[30, 25, 35] (cost per hour for each truck)\n\nDecision variable:\n1. Assignment\nBinary variable \\( x_{ot} \\in \\{0, 1\\} \\) for all \\( o \\in O, t \\in T \\), where \\( x_{ot} = 1 \\) if order \\( o \\) is assigned to truck \\( t \\), and \\( x_{ot} = 0 \\) otherwise\n2. TruckUsed\nBinary variable \\( y_t \\in \\{0, 1\\} \\) for all \\( t \\in T \\), where \\( y_t = 1 \\) if truck \\( t \\) is used, and \\( y_t = 0 \\) otherwise\n\nObjective:\nMinimize total operating cost\nmin: \\sum_{t\\in T} \\left( \\sum_{o\\in O} ProcessingTime_o \\cdot ReentrantFactor_o \\cdot x_{ot} \\right) \\cdot OperatingCost_t\n\nConstraint:\n1. Each order must be assigned to exactly one truck\n\\sum_{t\\in T}x_{ot} = 1, \\forall o \\in O\n2. Total processing time on each truck must not exceed its capacity\n\\sum_{o\\in O} ProcessingTime_o \\cdot ReentrantFactor_o \\cdot x_{ot} \\leq TruckCapacity_t, \\forall t \\in T\n3. Truck usage indicator\n\\sum_{o\\in O}x_{ot} \\leq M \\cdot y_t, \\forall t \\in T (where M is a large constant)\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_logistics_problem(\n    orders=list(range(1, 9)),\n    trucks=list(range(1, 4)),\n    processing_time=[4, 5, 3, 6, 2, 5, 4, 3],\n    reentrant_factor=[1, 2, 1, 1, 2, 1, 1, 1],\n    truck_capacity=[15, 18, 12],\n    operating_cost=[30, 25, 35]\n):\n    \"\"\"Solve the truck scheduling problem with reentrant processing requirements.\"\"\"\n    model = gp.Model(\"LogisticsScheduling\")\n\n    x = model.addVars(orders, trucks, vtype=GRB.BINARY, name=\"Assign\")\n    y = model.addVars(trucks, vtype=GRB.BINARY, name=\"TruckUsed\")\n\n    model.setObjective(\n        gp.quicksum(\n            gp.quicksum(\n                processing_time[o - 1] * reentrant_factor[o - 1] * x[o, t] * operating_cost[t - 1]\n                for o in orders\n            )\n            for t in trucks\n        ),\n        GRB.MINIMIZE\n    )\n\n    model.addConstrs((gp.quicksum(x[o, t] for t in trucks) == 1 for o in orders))\n\n    model.addConstrs(\n        (gp.quicksum(\n            processing_time[o - 1] * reentrant_factor[o - 1] * x[o, t]\n            for o in orders\n        ) <= truck_capacity[t - 1]\n        for t in trucks),\n        name=\"Capacity\"\n    )\n\n    M = len(orders)\n    model.addConstrs((gp.quicksum(x[o, t] for o in orders) <= M * y[t] for t in trucks))\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_logistics_problem()\n    print(result)\n",
    "ground_truth":1110.0
  },
  {
    "task_id":"D063",
    "description":"A logistics company needs to optimize the delivery of three types of drinks (Cola, Juice, and Mineral Water) from two production facilities (P1 and P2) to three retail stores (S1, S2, S3) via a transportation network with 5 intermediate nodes (N1-N5). The directed arcs between nodes have capacity limits (in pallets) and unit transportation costs ($\/pallet).\n\nThe network connections, capacities, and costs are as follows:\n- P1→N1 (Capacity: 80, Cost: 2)\n- P1→N2 (Capacity: 60, Cost: 3)\n- P2→N3 (Capacity: 90, Cost: 2)\n- N1→N3 (Capacity: 50, Cost: 1)\n- N2→N4 (Capacity: 70, Cost: 2)\n- N3→N5 (Capacity: 100, Cost: 3)\n- N4→S1 (Capacity: ∞, Cost: 1)\n- N4→S2 (Capacity: ∞, Cost: 2)\n- N5→S2 (Capacity: ∞, Cost: 1)\n- N5→S3 (Capacity: ∞, Cost: 2)\n\nThe demand requirements are: Cola (S1:30, S2:20, S3:10), Juice (S1:15, S2:25, S3:5), Water (S1:10, S2:15, S3:20). Production capacities are P1 (Cola:40, Juice:30, Water:20) and P2 (Cola:30, Juice:25, Water:40). The goal is to satisfy all demands while minimizing total transportation costs.",
    "formulation":"Set:\n1. Nodes\nThe set of all nodes \\( V = \\{P1, P2, N1, N2, N3, N4, N5, S1, S2, S3\\} \\)\n2. Arcs\nThe set of directed arcs \\( A \\), defined by the connections in problem description\n3. Commodities\nThe set of beverage types \\( K = \\{Cola, Juice, Water\\} \\)\n\nParameter:\n1. Capacity\n\\( u_{ij} \\): Arc capacity from node i to j (values given in problem description, with N3->N5 capacity corrected to 100)\n2. Cost\n\\( c_{ij} \\): Unit transportation cost on arc (i,j).\n3. Demand\n\\( d_j^k \\): Demand for commodity k at store j (values given)\n4. Supply\n\\( s_i^k \\): Maximum supply capacity of commodity k at production facility i (values given)\n\nDecision variable:\n1. Flow\n\\( x_{ij}^k \\geq 0 \\): Flow amount of commodity k on arc (i,j)\n\nObjective:\nMinimize total transportation cost\nmin: \\( \\sum_{k\\in K} \\sum_{(i,j)\\in A} c_{ij} x_{ij}^k \\)\n\nConstraint:\n1. Flow conservation\n   Net outflow from production nodes must be less than or equal to supply capacity.\n   \\( \\sum_{j:(i,j)\\in A} x_{ij}^k - \\sum_{j:(j,i)\\in A} x_{ji}^k \\leq s_i^k \\) for production nodes\n   \\( \\sum_{j:(i,j)\\in A} x_{ij}^k - \\sum_{j:(j,i)\\in A} x_{ji}^k = -d_i^k \\) for store nodes (demand must be met exactly)\n   \\( \\sum_{j:(i,j)\\in A} x_{ij}^k - \\sum_{j:(j,i)\\in A} x_{ji}^k = 0 \\) for intermediate nodes\n2. Capacity constraint\n   \\( \\sum_{k\\in K} x_{ij}^k \\leq u_{ij} \\) for all (i,j) ∈ A\n3. Non-negativity\n   \\( x_{ij}^k \\geq 0 \\) for all (i,j) ∈ A, k ∈ K\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_beverage_distribution(\n    nodes=['P1', 'P2', 'N1', 'N2', 'N3', 'N4', 'N5', 'S1', 'S2', 'S3'],\n    commodities=['Cola', 'Juice', 'Water'],\n    arcs_data=[\n        ('P1', 'N1', 80, 2), ('P1', 'N2', 60, 3), ('P2', 'N3', 90, 2),\n        ('N1', 'N3', 50, 1), ('N2', 'N4', 70, 2), ('N3', 'N5', 100, 3),\n        ('N4', 'S1', float('inf'), 1), ('N4', 'S2', float('inf'), 2),\n        ('N5', 'S2', float('inf'), 1), ('N5', 'S3', float('inf'), 2)\n    ],\n    demand={\n        'S1': {'Cola': 30, 'Juice': 15, 'Water': 10},\n        'S2': {'Cola': 20, 'Juice': 25, 'Water': 15},\n        'S3': {'Cola': 10, 'Juice': 5, 'Water': 20}\n    },\n    supply={\n        'P1': {'Cola': 40, 'Juice': 30, 'Water': 20},\n        'P2': {'Cola': 30, 'Juice': 25, 'Water': 40}\n    }\n):\n    \"\"\"Solve the beverage distribution optimization problem using Gurobi.\"\"\"\n    model = gp.Model(\"BeverageDistribution\")\n\n    arcs, capacity, cost = gp.multidict({\n        (i, j): [cap, c] for (i, j, cap, c) in arcs_data\n    })\n\n    flow = model.addVars(arcs, commodities, lb=0, name=\"flow\")\n\n    model.setObjective(\n        gp.quicksum(cost[i, j] * flow[i, j, k] for i, j in arcs for k in commodities),\n        GRB.MINIMIZE\n    )\n\n    production_nodes = supply.keys()\n    demand_nodes = demand.keys()\n\n    for node in nodes:\n        for k in commodities:\n            net_flow = (flow.sum(node, '*', k) - flow.sum('*', node, k))\n            if node in production_nodes:\n                model.addConstr(net_flow <= supply[node].get(k, 0))\n            elif node in demand_nodes:\n                model.addConstr(net_flow == -demand[node].get(k, 0))\n            else:\n                model.addConstr(net_flow == 0)\n\n    for i, j in arcs:\n        if capacity[i, j] != float('inf'):\n            model.addConstr(gp.quicksum(flow[i, j, k] for k in commodities) <= capacity[i, j])\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_beverage_distribution()\n    print(result)\n",
    "ground_truth":940.0
  },
  {
    "task_id":"D064",
    "description":"A logistics company needs to deliver goods to 15 customers over a 5-day workweek (Monday to Friday). Each customer has specific delivery frequency requirements: 3 customers require daily deliveries, 5 require deliveries every other day, and 7 require weekly deliveries. The company has 3 available vehicles, each with a capacity of 200 units. The distances between customers and the depot are given in the following matrix (in km):\n\nDistance Table (depot = 0, customers = 1-15):\n\n| From\\To | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |\n|---------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n|   0     | 0   | 12  | 18  | 9   | 15  | 22  | 7   | 14  | 20  | 11  | 16  | 8   | 13  | 19  | 10  | 17  |\n|   1     | 12  | 0   | 6   | 15  | 21  | 8   | 17  | 23  | 10  | 19  | 4   | 16  | 5   | 11  | 18  | 7   |\n|   2     | 18  | 6   | 0   | 21  | 3   | 14  | 9   | 15  | 12  | 5   | 10  | 7   | 13  | 8   | 4   | 11  |\n|   3     | 9   | 15  | 21  | 0   | 18  | 11  | 16  | 22  | 7   | 14  | 20  | 3   | 19  | 10  | 17  | 6   |\n|   4     | 15  | 21  | 3   | 18  | 0   | 17  | 12  | 8   | 15  | 10  | 7   | 13  | 4   | 9   | 14  | 11  |\n|   5     | 22  | 8   | 14  | 11  | 17  | 0   | 19  | 5   | 12  | 7   | 14  | 10  | 17  | 6   | 13  | 8   |\n|   6     | 7   | 17  | 9   | 16  | 12  | 19  | 0   | 14  | 21  | 8   | 15  | 11  | 18  | 5   | 12  | 9   |\n|   7     | 14  | 23  | 15  | 22  | 8   | 5   | 14  | 0   | 17  | 12  | 9   | 15  | 6   | 11  | 16  | 13  |\n|   8     | 20  | 10  | 12  | 7   | 15  | 12  | 21  | 17  | 0   | 13  | 18  | 4   | 19  | 14  | 9   | 16  |\n|   9     | 11  | 19  | 5   | 14  | 10  | 7   | 8   | 12  | 13  | 0   | 15  | 11  | 6   | 17  | 12  | 9   |\n|   10    | 16  | 4   | 10  | 20  | 7   | 14  | 15  | 9   | 18  | 15  | 0   | 17  | 8   | 13  | 18  | 5   |\n|   11    | 8   | 16  | 7   | 3   | 13  | 10  | 11  | 15  | 4   | 11  | 17  | 0   | 14  | 9   | 16  | 7   |\n|   12    | 13  | 5   | 13  | 19  | 4   | 17  | 18  | 6   | 19  | 6   | 8   | 14  | 0   | 15  | 10  | 17  |\n|   13    | 19  | 11  | 8   | 10  | 9   | 6   | 5   | 11  | 14  | 17  | 13  | 9   | 15  | 0   | 7   | 12  |\n|   14    | 10  | 18  | 4   | 17  | 14  | 13  | 12  | 16  | 9   | 12  | 18  | 16  | 10  | 7   | 0   | 11  |\n|   15    | 17  | 7   | 11  | 6   | 11  | 8   | 9   | 13  | 16  | 9   | 5   | 7   | 17  | 12  | 11  | 0   |\n\nEach customer's daily demand (in units) is: [25, 30, 20, 15, 35, 40, 18, 22, 28, 32, 19, 21, 26, 24, 23]. The objective is to plan vehicle routes for each day of the week to satisfy all delivery requirements while minimizing total distance traveled.",
    "formulation":"Mathematical Model (for a Single-Day VRP)\nThis mathematical model describes the optimization problem solved for each single day of the week. Let d be the current day.\n\nSet\n1. Customers (for the day)\n   The set of customers requiring a visit on day d, C_d (a subset of {1, ..., 15}).\n2. Nodes (for the day)\n   The set of all locations to be considered on day d, N_d = {0} U C_d, where 0 is the depot.\n3. Vehicles\n   The set of available vehicles, V = {1, 2, 3}.\n\nParameter\n1. Distance\n   A distance matrix dist_ij between any two nodes i, j in N_d.\n2. Demand\n   The demand q_c for each customer c in C_d.\n3. VehicleCapacity\n   The capacity of each vehicle, Q = 200.\n\nDecision variable\n1. Route\n   Binary variable x_ijv in {0, 1}, which equals 1 if vehicle v travels directly from node i to node j.\n2. Subtour Elimination Variable\n   Continuous variable u_i >= 0 for each customer i in C_d, used for the MTZ formulation.\n\nObjective\nMinimize the total distance traveled by all vehicles on day d.\nmin: sum over i in N_d, j in N_d, v in V of (dist_ij * x_ijv)\n\nConstraint\n1. Customer Visitation\n   Each customer required to be visited on day d is visited by exactly one arc of one vehicle.\n   sum over i in N_d, v in V of x_icv = 1, for all c in C_d\n\n2. Vehicle Departure\n   Each vehicle leaves the depot at most once (allowing some vehicles to remain unused).\n   sum over j in C_d of x_0jv <= 1, for all v in V\n\n3. Flow Conservation\n   If a vehicle enters a customer node, it must also leave it.\n   sum over i in N_d of x_icv - sum over j in N_d of x_cjv = 0, for all c in C_d, v in V\n\n4. Vehicle Return\n   If a vehicle leaves the depot, it must return to the depot.\n   sum over j in C_d of x_0jv = sum over i in C_d of x_i0v, for all v in V\n\n5. Capacity Constraint\n   The total demand of all customers on a single vehicle's route cannot exceed the vehicle's capacity.\n   sum over c in C_d of q_c * (sum over i in N_d of x_icv) <= Q, for all v in V\n\n6. Subtour Elimination (MTZ Formulation)\n   Prevents disconnected loops by enforcing a load\/sequence order.\n   u_i - u_j + Q * (sum over v in V of x_ijv) <= Q - q_j, for all i, j in C_d, i != j\n   q_i <= u_i <= Q, for all i in C_d\n\nType\nMixed, Linear, Linear.\nMILP",
    "correct_program":"import math\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport numpy as np\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich.panel import Panel\n\n\ndef solve_daily_vrp(day, required_customers, demands, vehicle_capacity,\n                    num_vehicles, all_nodes, distance_matrix):\n    \"\"\"\n    Solves a single-day Capacitated VRP for a given set of customers\n    using a standard and robust flow-based formulation.\n    \"\"\"\n\n    # The nodes for today's problem include the depot and only the customers that need a visit.\n    daily_nodes = [0] + required_customers\n\n    model = gp.Model(f\"VRP_Day_{day}\")\n\n    # --- Decision Variables ---\n    # x[i, j, v]: 1 if vehicle v travels from node i to j.\n    # We create arcs only between the nodes relevant for the day.\n    vehicles = list(range(1, num_vehicles + 1))\n    arcs = [(i, j, v) for i in daily_nodes for j in daily_nodes\n            for v in vehicles if i != j]\n    x = model.addVars(arcs, vtype=GRB.BINARY, name=\"x\")\n\n    # --- Objective Function ---\n    # Minimize the total distance traveled for the day.\n    model.setObjective(\n        gp.quicksum(distance_matrix[i, j] * x[i, j, v] for i, j, v in arcs),\n        GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # 1. Each required customer for the day is visited exactly once by some vehicle.\n    model.addConstrs((gp.quicksum(x[i, c, v] for i in daily_nodes\n                                  for v in vehicles if i != c) == 1\n                      for c in required_customers),\n                     name=\"visit_customer\")\n\n    # 2. Each vehicle leaves the depot at most once.\n    model.addConstrs((gp.quicksum(x[0, j, v] for j in required_customers) <= 1\n                      for v in vehicles),\n                     name=\"leave_depot\")\n\n    # 3. Flow conservation: if a vehicle enters a customer node, it must leave it.\n    model.addConstrs((gp.quicksum(x[i, c, v] for i in daily_nodes if i != c)\n                      == gp.quicksum(x[c, j, v] for j in daily_nodes if j != c)\n                      for c in required_customers for v in vehicles),\n                     name=\"flow_conservation\")\n\n    # 4. Vehicle capacity constraint.\n    model.addConstrs(\n        (gp.quicksum(demands[c] * gp.quicksum(x[i, c, v]\n                                              for i in daily_nodes if i != c)\n                     for c in required_customers) <= vehicle_capacity\n         for v in vehicles),\n        name=\"capacity\")\n\n    # 5. Subtour Elimination (MTZ formulation).\n    u = model.addVars(daily_nodes, vtype=GRB.CONTINUOUS)\n    for i in required_customers:\n        model.addConstr(u[i] >= demands[i])\n        model.addConstr(u[i] <= vehicle_capacity)\n        for j in required_customers:\n            if i != j:\n                model.addConstr(\n                    u[i] - u[j] +\n                    vehicle_capacity * gp.quicksum(x[i, j, v]\n                                                   for v in vehicles)\n                    <= vehicle_capacity - demands[j], f\"subtour_{i}_{j}\")\n\n    # --- Solve This Day's Model ---\n    model.Params.LogToConsole = 0  # Suppress solver output for daily runs\n    model.optimize()\n\n    # --- Extract and Return Results ---\n    if model.Status == GRB.OPTIMAL:\n        routes = []\n        for v in vehicles:\n            # Check if this vehicle is used by seeing if it leaves the depot\n            if gp.quicksum(x[0, j, v]\n                           for j in required_customers).getValue() > 0.5:\n                # Reconstruct the tour for this vehicle\n                tour = [0]\n                current_node = 0\n                while True:\n                    found_next = False\n                    for j in daily_nodes:\n                        if j != current_node and x[current_node, j, v].X > 0.5:\n                            if j == 0:  # Returned to depot\n                                break\n                            tour.append(j)\n                            current_node = j\n                            found_next = True\n                            break\n                    if not found_next:\n                        tour.append(0)  # Final return to depot\n                        break\n                routes.append({'vehicle': v, 'route': tour})\n        return model.ObjVal, routes\n    return float('inf'), []\n\n\ndef solve_weekly_delivery_routing():\n    \"\"\"Main function to set up and solve the weekly routing problem day-by-day.\"\"\"\n    console = Console()\n    console.print(\n        Panel(\n            \"[bold blue]Weekly Delivery Routing Optimizer (Day-by-Day Approach)[\/bold blue]\"\n        ))\n\n    # ========== Problem Data ==========\n    days = list(range(1, 6))\n    customers = list(range(1, 16))\n    vehicles = list(range(1, 4))\n    depot = 0\n    all_nodes = [depot] + customers\n    vehicle_capacity = 200\n\n    dist_matrix = np.array(\n        [[0, 12, 18, 9, 15, 22, 7, 14, 20, 11, 16, 8, 13, 19, 10, 17],\n         [12, 0, 6, 15, 21, 8, 17, 23, 10, 19, 4, 16, 5, 11, 18, 7],\n         [18, 6, 0, 21, 3, 14, 9, 15, 12, 5, 10, 7, 13, 8, 4, 11],\n         [9, 15, 21, 0, 18, 11, 16, 22, 7, 14, 20, 3, 19, 10, 17, 6],\n         [15, 21, 3, 18, 0, 17, 12, 8, 15, 10, 7, 13, 4, 9, 14, 11],\n         [22, 8, 14, 11, 17, 0, 19, 5, 12, 7, 14, 10, 17, 6, 13, 8],\n         [7, 17, 9, 16, 12, 19, 0, 14, 21, 8, 15, 11, 18, 5, 12, 9],\n         [14, 23, 15, 22, 8, 5, 14, 0, 17, 12, 9, 15, 6, 11, 16, 13],\n         [20, 10, 12, 7, 15, 12, 21, 17, 0, 13, 18, 4, 19, 14, 9, 16],\n         [11, 19, 5, 14, 10, 7, 8, 12, 13, 0, 15, 11, 6, 17, 12, 9],\n         [16, 4, 10, 20, 7, 14, 15, 9, 18, 15, 0, 17, 8, 13, 18, 5],\n         [8, 16, 7, 3, 13, 10, 11, 15, 4, 11, 17, 0, 14, 9, 16, 7],\n         [13, 5, 13, 19, 4, 17, 18, 6, 19, 6, 8, 14, 0, 15, 10, 17],\n         [19, 11, 8, 10, 9, 6, 5, 11, 14, 17, 13, 9, 15, 0, 7, 12],\n         [10, 18, 4, 17, 14, 13, 12, 16, 9, 12, 18, 16, 10, 7, 0, 11],\n         [17, 7, 11, 6, 11, 8, 9, 13, 16, 9, 5, 7, 17, 12, 11, 0]])\n    demands = {\n        c: val\n        for c, val in enumerate(\n            [25, 30, 20, 15, 35, 40, 18, 22, 28, 32, 19, 21, 26, 24, 23], 1)\n    }\n\n    # Define which customers to visit on each day based on frequency\n    customers_by_day = {d: [] for d in days}\n    frequency_map = {\n        c: 1 if c <= 3 else (2 if c <= 8 else 3)\n        for c in customers\n    }  # Daily, Every Other, Weekly\n    for c in customers:\n        if frequency_map[c] == 1:  # Daily\n            for d in days:\n                customers_by_day[d].append(c)\n        elif frequency_map[c] == 2:  # Every other day (Mon, Wed, Fri)\n            customers_by_day[1].append(c)\n            customers_by_day[3].append(c)\n            customers_by_day[5].append(c)\n        else:  # Weekly (Wednesday)\n            customers_by_day[3].append(c)\n\n    # ========== Solve and Display Results ==========\n    total_weekly_distance = 0\n    results_table = Table(title=\"Weekly Delivery Route Summary\")\n    results_table.add_column(\"Day\", justify=\"center\", style=\"bold yellow\")\n    results_table.add_column(\"Vehicle\", justify=\"center\", style=\"cyan\")\n    results_table.add_column(\"Route\", justify=\"left\", style=\"magenta\")\n    results_table.add_column(\"Load\", justify=\"right\")\n    results_table.add_column(\"Distance\", justify=\"right\")\n\n    for day in days:\n        required_customers_today = customers_by_day[day]\n        if not required_customers_today:\n            continue\n\n        console.print(f\"\\n[yellow]Optimizing routes for Day {day}...[\/yellow]\")\n        daily_dist, daily_routes = solve_daily_vrp(day,\n                                                   required_customers_today,\n                                                   demands, vehicle_capacity,\n                                                   len(vehicles), all_nodes,\n                                                   dist_matrix)\n\n        if daily_dist == float('inf'):\n            console.print(\n                f\"[bold red]Could not find a feasible solution for Day {day}.[\/bold red]\"\n            )\n            continue\n\n        total_weekly_distance += daily_dist\n\n        for route_info in daily_routes:\n            v = route_info['vehicle']\n            route = route_info['route']\n            route_str = \" -> \".join([str(n) if n != 0 else 'D' for n in route])\n            route_load = sum(demands.get(c, 0) for c in route)\n            route_dist = sum(dist_matrix[route[i], route[i + 1]]\n                             for i in range(len(route) - 1))\n            results_table.add_row(str(day), str(v), route_str,\n                                  f\"{route_load}\/{vehicle_capacity}\",\n                                  f\"{route_dist:.2f}\")\n\n    console.print(results_table)\n    console.print(\n        Panel(\n            f\"[bold green]Total Weekly Distance Traveled: {total_weekly_distance:.2f} km[\/bold green]\"\n        ))\n\n\nif __name__ == \"__main__\":\n    solve_weekly_delivery_routing()\n",
    "ground_truth":352.0
  },
  {
    "task_id":"D065",
    "description":"A regional tobacco distribution company operates three distribution centers located in different zones of a metropolitan area to serve 15 retail outlets. The company needs to optimize its weekly delivery operations to minimize total transportation costs while satisfying regulatory constraints and customer demands.\n\nThe three distribution centers have different storage capacities and operational costs. Center A can handle up to 800 units per week with a fixed operating cost of $2,500, Center B can handle up to 600 units per week with a fixed cost of $2,000, and Center C can handle up to 500 units per week with a fixed cost of $1,800. Each retail outlet has specific weekly demand requirements ranging from 45 to 120 units, and due to regulatory compliance, each outlet must receive deliveries from exactly one distribution center to maintain proper tracking and accountability.\n\nThe transportation cost varies based on the distance between distribution centers and retail outlets, ranging from $8 to $25 per unit delivered. Additionally, there are regulatory constraints that limit the maximum number of outlets each distribution center can serve - Center A can serve at most 7 outlets, Center B can serve at most 6 outlets, and Center C can serve at most 5 outlets. The company must also ensure that the total demand assigned to each center does not exceed its capacity, and all retail outlets must be served to maintain market coverage.\n\n| Outlet | Demand | Cost from A | Cost from B | Cost from C |\n|--------|--------|-------------|-------------|-------------|\n| 1      | 85     | $12         | $18         | $22         |\n| 2      | 67     | $15         | $11         | $25         |\n| 3      | 92     | $20         | $14         | $16         |\n| 4      | 78     | $13         | $19         | $23         |\n| 5      | 105    | $17         | $12         | $20         |\n| 6      | 56     | $25         | $16         | $14         |\n| 7      | 120    | $14         | $21         | $18         |\n| 8      | 73     | $16         | $13         | $24         |\n| 9      | 89     | $19         | $15         | $17         |\n| 10     | 95     | $11         | $22         | $19         |\n| 11     | 62     | $23         | $17         | $15         |\n| 12     | 84     | $18         | $14         | $21         |\n| 13     | 76     | $21         | $20         | $13         |\n| 14     | 45     | $24         | $25         | $16         |\n| 15     | 58     | $22         | $23         | $12         |",
    "formulation":"Set:\n1. Distribution Centers\nThe set of distribution centers, D = {A, B, C}\n2. Retail Outlets\nThe set of retail outlets, R = {1, 2, 3, ..., 15}\n\nParameter:\n1. Center Capacity\nCapacity[A] = 800, Capacity[B] = 600, Capacity[C] = 500\n2. Fixed Operating Cost\nFixedCost[A] = 2500, FixedCost[B] = 2000, FixedCost[C] = 1800\n3. Outlet Demand\nDemand = [85, 67, 92, 78, 105, 56, 120, 73, 89, 95, 62, 84, 76, 45, 58]\n4. Transportation Cost per Unit\nTransportCost[i][j] for center i ∈ D and outlet j ∈ R (as shown in the table above)\n5. Maximum Outlets per Center\nMaxOutlets[A] = 7, MaxOutlets[B] = 6, MaxOutlets[C] = 5\n\nDecision variable:\n1. Center Operation\nBinary variable x_i ∈ {0, 1} for all i ∈ D, where x_i = 1 if distribution center i is operated, and x_i = 0 otherwise\n2. Assignment\nBinary variable y_{ij} ∈ {0, 1} for all i ∈ D, j ∈ R, where y_{ij} = 1 if outlet j is served by center i, and y_{ij} = 0 otherwise\n\nObjective:\nMinimize total cost including fixed operating costs and transportation costs\nmin: Σ_{i∈D} FixedCost_i × x_i + Σ_{i∈D} Σ_{j∈R} TransportCost_{ij} × Demand_j × y_{ij}\n\nConstraint:\n1. Each outlet must be served by exactly one distribution center\nΣ_{i∈D} y_{ij} = 1, ∀j ∈ R\n2. Center capacity constraint - total demand assigned to each center cannot exceed its capacity\nΣ_{j∈R} Demand_j × y_{ij} ≤ Capacity_i × x_i, ∀i ∈ D\n3. Maximum number of outlets per center constraint\nΣ_{j∈R} y_{ij} ≤ MaxOutlets_i × x_i, ∀i ∈ D\n4. Logical constraint - outlets can only be assigned to operating centers\ny_{ij} ≤ x_i, ∀i ∈ D, ∀j ∈ R\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_tobacco_distribution(\n    centers=['A', 'B', 'C'],\n    outlets=list(range(1, 16)),\n    capacity={'A': 800, 'B': 600, 'C': 500},\n    fixed_cost={'A': 2500, 'B': 2000, 'C': 1800},\n    demand=[85, 67, 92, 78, 105, 56, 120, 73, 89, 95, 62, 84, 76, 45, 58],\n    max_outlets={'A': 7, 'B': 6, 'C': 5},\n    transport_cost_data=None\n):\n    \"\"\"\n    Solve the multi-depot tobacco distribution network optimization problem.\n    \"\"\"\n    if transport_cost_data is None:\n        transport_cost = {\n            'A': [12, 15, 20, 13, 17, 25, 14, 16, 19, 11, 23, 18, 21, 24, 22],\n            'B': [18, 11, 14, 19, 12, 16, 21, 13, 15, 22, 17, 14, 20, 25, 23],\n            'C': [22, 25, 16, 23, 20, 14, 18, 24, 17, 19, 15, 21, 13, 16, 12]\n        }\n    else:\n        transport_cost = transport_cost_data\n\n    model = gp.Model(\"tobacco_distribution\")\n\n    x = model.addVars(centers, vtype=GRB.BINARY, name=\"center_operation\")\n    y = model.addVars(centers, outlets, vtype=GRB.BINARY, name=\"assignment\")\n\n    fixed_costs = gp.quicksum(fixed_cost[i] * x[i] for i in centers)\n    transport_costs = gp.quicksum(\n        transport_cost[i][j - 1] * demand[j - 1] * y[i, j]\n        for i in centers for j in outlets\n    )\n    model.setObjective(fixed_costs + transport_costs, GRB.MINIMIZE)\n\n    for j in outlets:\n        model.addConstr(gp.quicksum(y[i, j] for i in centers) == 1)\n\n    for i in centers:\n        model.addConstr(gp.quicksum(demand[j - 1] * y[i, j] for j in outlets) <= capacity[i] * x[i])\n        model.addConstr(gp.quicksum(y[i, j] for j in outlets) <= max_outlets[i] * x[i])\n        for j in outlets:\n            model.addConstr(y[i, j] <= x[i])\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_tobacco_distribution()\n    print(result)\n",
    "ground_truth":21922.0
  },
  {
    "task_id":"D066",
    "description":"A distribution company is planning its logistics network for the upcoming year to serve 15 retail stores from 5 potential hub locations. The company aims to minimize its total annual operational cost, which consists of fixed daily costs for opening hubs and variable transportation costs for delivering goods.\n\nThe core decisions are which of the 5 potential hubs to open and which open hub should be assigned to serve each of the 15 retail stores.\n\nEach potential hub has a specific daily operating cost, a maximum daily capacity, and an operational reliability score. The company has a strategic requirement that the average reliability of all opened hubs must be at least 90%. The transportation cost is fixed at $0.80 per unit per mile, and the planning horizon is a full year (365 days).\n\nThe plan must assign each store to exactly one hub, ensure that no hub's daily capacity is exceeded, meet the minimum average reliability standard, and minimize the total annual cost.\n\nHub Data:  \n\n| Hub ID | Daily Setup Cost | Daily Capacity (units) | Reliability |\n|:------:|:----------------:|:----------------------:|:-----------:|\n| 1      | $100,000         | 1000                   | 0.85        |\n| 2      | $80,000          | 800                    | 0.90        |\n| 3      | $120,000         | 1500                   | 0.70        |\n| 4      | $90,000          | 1200                   | 0.95        |\n| 5      | $110,000         | 900                    | 0.80        |\n\nStore Demand Data (units per day):  \n\n| Store | Demand | | Store | Demand | | Store | Demand |\n|:-----:|:------:| |:-----:|:------:| |:-----:|:------:|\n| 1     | 151    | | 6     | 187    | | 11    | 121    |\n| 2     | 188    | | 7     | 199    | | 12    | 173    |\n| 3     | 174    | | 8     | 104    | | 13    | 100    |\n| 4     | 161    | | 9     | 116    | | 14    | 187    |\n| 5     | 111    | | 10    | 88     | | 15    | 199    |\n\nDistance Matrix (Hub to Store, in miles):  \n\n| Hub | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | S9 | S10 | S11 | S12 | S13 | S14 | S15 |\n|:---:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:---:|:---:|:---:|:---:|:---:|:---:|\n|  1  | 18 | 45 | 42 | 38 | 18 | 44 | 47 | 12 | 20 | 10  | 23  | 41  | 10  | 44  | 47  |\n|  2  | 30 | 27 | 21 | 16 | 17 | 12 | 29 | 21 | 38 | 48  | 23  | 15  | 12  | 20  | 26  |\n|  3  | 16 | 13 | 21 | 31 | 30 | 39 | 44 | 44 | 18 | 12  | 13  | 16  | 42  | 49  | 11  |\n|  4  | 34 | 25 | 30 | 20 | 24 | 28 | 42 | 39 | 31 | 44  | 34  | 11  | 36  | 16  | 23  |\n|  5  | 49 | 41 | 17 | 34 | 16 | 49 | 49 | 28 | 42 | 18  | 46  | 23  | 29  | 21  | 49  |",
    "formulation":"Set:\n1. Hubs\n   The set of potential hubs, \\( H = \\{1, 2, 3, 4, 5\\} \\)\n2. Stores\n   The set of retail stores, \\( S = \\{1, 2, ..., 15\\} \\)\n\nParameter:\n1. FixedCost_h\n   The fixed daily operating cost for opening hub \\( h \\): [100000, 80000, 120000, 90000, 110000]\n2. Capacity_h\n   The maximum daily handling capacity of hub \\( h \\): [1000, 800, 1500, 1200, 900]\n3. Reliability_h\n   The operational reliability score of hub \\( h \\): [0.85, 0.9, 0.7, 0.95, 0.8]\n4. Demand_s\n   The daily demand of store \\( s \\): [151, 188, 174, 161, 111, 187, 199, 104, 116, 88, 121, 173, 100, 187, 199]\n5. Distance_hs\n   The distance matrix between hub \\( h \\) and store \\( s \\) as specified in the table.\n6. TransportCost\n   The variable transportation cost per unit per mile: 0.8\n7. MinAvgReliability\n   The minimum required average reliability of opened hubs: 0.9\n8. Days\n   The number of days in the planning horizon: 365\n\nDecision variable:\n1. OpenHub_h\n   Binary variable \\( x_h \\in \\{0, 1\\} \\) for all \\( h \\in H \\), where \\( x_h = 1 \\) if hub \\( h \\) is opened, and 0 otherwise.\n2. AssignStore_hs\n   Binary variable \\( y_{hs} \\in \\{0, 1\\} \\) for all \\( h \\in H, s \\in S \\), where \\( y_{hs} = 1 \\) if store \\( s \\) is assigned to hub \\( h \\), and 0 otherwise.\n\nObjective:\nMinimize the total annual cost, which is the sum of daily fixed and transportation costs multiplied by the number of days.\nmin: \\( \\text{Days} \\cdot \\left( \\sum_{h \\in H} \\text{FixedCost}_h \\cdot x_h + \\sum_{h \\in H} \\sum_{s \\in S} \\text{TransportCost} \\cdot \\text{Demand}_s \\cdot \\text{Distance}_{hs} \\cdot y_{hs} \\right) \\)\n\nConstraint:\n1. Store Assignment\n   Each store must be assigned to exactly one hub.\n   \\( \\sum_{h \\in H} y_{hs} = 1, \\quad \\forall s \\in S \\)\n2. Hub Capacity\n   The total demand of all stores assigned to a hub cannot exceed that hub's capacity. This constraint is only active if the hub is open.\n   \\( \\sum_{s \\in S} \\text{Demand}_s \\cdot y_{hs} \\leq \\text{Capacity}_h \\cdot x_h, \\quad \\forall h \\in H \\)\n3. Minimum Average Reliability\n   The sum of reliability scores of all opened hubs must be greater than or equal to the minimum average reliability multiplied by the number of opened hubs.\n   \\( \\sum_{h \\in H} \\text{Reliability}_h \\cdot x_h \\geq \\text{MinAvgReliability} \\cdot \\left( \\sum_{h \\in H} x_h \\right) \\)\n4. Logical Consistency\n   A store can only be assigned to a hub if that hub is open.\n   \\( y_{hs} \\leq x_h, \\quad \\forall h \\in H, s \\in S \\)\n\nType:\nBinary, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_hub_location(\n    H=[1, 2, 3, 4, 5],\n    S=list(range(1, 16)),\n    SetupCost={1: 100, 2: 80, 3: 120, 4: 90, 5: 110},\n    Capacity={1: 1000, 2: 800, 3: 1500, 4: 1200, 5: 900},\n    Reliability={1: 0.85, 2: 0.9, 3: 0.7, 4: 0.95, 5: 0.8},\n    TransportCost=0.8,\n    MinAvgReliability=0.9,\n    Days=365,\n    Demand_data=None,\n    Distance_data=None\n):\n    \"\"\"\n    Solve the hub location problem.\n    \"\"\"\n    if Demand_data is None:\n        Demand = {\n            1: 151, 2: 188, 3: 174, 4: 161, 5: 111, 6: 187, 7: 199, 8: 104,\n            9: 116, 10: 88, 11: 121, 12: 173, 13: 100, 14: 187, 15: 199\n        }\n    else:\n        Demand = Demand_data\n\n    if Distance_data is None:\n        Distance = {\n            (1, 1): 18, (1, 2): 45, (1, 3): 42, (1, 4): 38, (1, 5): 18, (1, 6): 44, (1, 7): 47, (1, 8): 12, (1, 9): 20, (1, 10): 10, (1, 11): 23, (1, 12): 41, (1, 13): 10, (1, 14): 44, (1, 15): 47,\n            (2, 1): 30, (2, 2): 27, (2, 3): 21, (2, 4): 16, (2, 5): 17, (2, 6): 12, (2, 7): 29, (2, 8): 21, (2, 9): 38, (2, 10): 48, (2, 11): 23, (2, 12): 15, (2, 13): 12, (2, 14): 20, (2, 15): 26,\n            (3, 1): 16, (3, 2): 13, (3, 3): 21, (3, 4): 31, (3, 5): 30, (3, 6): 39, (3, 7): 44, (3, 8): 44, (3, 9): 18, (3, 10): 12, (3, 11): 13, (3, 12): 16, (3, 13): 42, (3, 14): 49, (3, 15): 11,\n            (4, 1): 34, (4, 2): 25, (4, 3): 30, (4, 4): 20, (4, 5): 24, (4, 6): 28, (4, 7): 42, (4, 8): 39, (4, 9): 31, (4, 10): 44, (4, 11): 34, (4, 12): 11, (4, 13): 36, (4, 14): 16, (4, 15): 23,\n            (5, 1): 49, (5, 2): 41, (5, 3): 17, (5, 4): 34, (5, 5): 16, (5, 6): 49, (5, 7): 49, (5, 8): 28, (5, 9): 42, (5, 10): 18, (5, 11): 46, (5, 12): 23, (5, 13): 29, (5, 14): 21, (5, 15): 49\n        }\n    else:\n        Distance = Distance_data\n\n    model = gp.Model(\"HubLocationProblem\")\n\n    OpenHub = model.addVars(H, vtype=GRB.BINARY, name=\"OpenHub\")\n    AssignStore = model.addVars(H, S, vtype=GRB.BINARY, name=\"AssignStore\")\n\n    setup_cost = gp.quicksum(SetupCost[h] * 1000 * OpenHub[h] for h in H)\n    transport_cost = gp.quicksum(\n        TransportCost * Demand[s] * Distance[h, s] * AssignStore[h, s]\n        for h in H for s in S\n    )\n    model.setObjective(Days * (setup_cost + transport_cost), GRB.MINIMIZE)\n\n    model.addConstrs((gp.quicksum(AssignStore[h, s] for h in H) == 1 for s in S))\n    model.addConstrs((gp.quicksum(Demand[s] * AssignStore[h, s] for s in S) <= Capacity[h] * OpenHub[h] for h in H))\n    model.addConstr(gp.quicksum(Reliability[h] * OpenHub[h] for h in H) >= MinAvgReliability * gp.quicksum(OpenHub[h] for h in H))\n    model.addConstrs((AssignStore[h, s] <= OpenHub[h] for h in H for s in S))\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_hub_location()\n    print(result)",
    "ground_truth":110628288.0
  },
  {
    "task_id":"D067",
    "description":"A manufacturing company needs to procure 5 key components (C1-C5, fractional procurement allowed) from 3 potential suppliers (S1-S3) for the next quarter. Each supplier has different pricing, reliability scores (0-1 scale), and maximum supply capacities. The company has forecasted component demands and wants to minimize total procurement cost while ensuring: (1) at least 60% of each component comes from suppliers with reliability ≥0.8, (2) no more than 40% of total spend goes to any single supplier, and (3) all demand is met. The quarterly demand is [1200, 800, 1500, 900, 600] units for C1-C5 respectively. Supplier data: S1 offers prices [12,15,18,20,22] $\/unit with reliability 0.85 and capacity 2000 units; S2 offers [14,16,17,19,21] $\/unit with reliability 0.75 and capacity 1800 units; S3 offers [13,14,19,18,20] $\/unit with with reliability 0.90 and capacity 2500 units.",
    "formulation":"Set:\n1. Components\nThe set of components, \\( C = \\{1, 2, 3, 4, 5\\} \\) representing C1-C5\n2. Suppliers\nThe set of suppliers, \\( S = \\{1, 2, 3\\} \\) representing S1-S3\n\nParameter:\n1. Demand\n[1200, 800, 1500, 900, 600] units for each \\( c \\in C \\)\n2. Price\n\\( p_{scsc} \\): Price from supplier \\( s \\) for component \\( c \\),\nS1: [12,15,18,20,22], S2: [14,16,17,19,21], S3: [13,14,19,18,20]\n3. Reliability\n\\( r_s \\): [0.85, 0.75, 0.90] for S1-S3\n4. Capacity\n\\( cap_s \\): [2000, 1800, 2500] units for S1-S3\n5. MinReliableFraction\n0\n.6 (minimum fraction from reliable suppliers)\n6. MaxSupplierSpendFraction\n0.4 (maximum spend share per supplier)\n\nDecision variable:\n1. ProcurementQuantity\n\\( q_{sc} \\geq 0 \\) for all \\( s \\in S, c \\in C \\), quantity purchased from supplier \\( s \\) for component \\( c \\)\n\nObjective:\nMinimize total procurement cost\nmin: \\( \\sum_{s\\in S}\\sum_{c\\in C} p_{sc} \\cdot q_{sc} \\)\n\nConstraint:\n1. Demand satisfaction\n\\( \\sum_{s\\in S} q_{sc} = Demand_c, \\forall c \\in C \\)\n2. Supplier capacity\n\\( \\sum_{c\\in C} q_{sc} \\leq cap_s, \\forall s \\in S \\)\n3. Reliable sourcing requirement\n\\( \\sum_{s\\in S | r_s \\geq 0.8} q_{sc} \\geq 0.6 \\cdot Demand_c, \\forall c \\in C \\)\n4. Spend concentration limit\n\\( \\sum_{c\\in C} p_{sc} \\cdot q_{sc} \\leq 0.4 \\cdot \\sum_{s'\\in S}\\sum_{c\\in C} p_{s'c} \\cdot q_{s'c}, \\forall s \\in S \\)\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_procurement_problem(\n    components=[1, 2, 3, 4, 5],\n    suppliers=[1, 2, 3],\n    demand={1: 1200, 2: 800, 3: 1500, 4: 900, 5: 600},\n    price_data=None,\n    reliability={1: 0.85, 2: 0.75, 3: 0.90},\n    capacity={1: 2000, 2: 1800, 3: 2500},\n    min_reliable_frac=0.6,\n    max_spend_frac=0.4\n):\n    \"\"\"Solve the supplier procurement optimization problem using Gurobi.\"\"\"\n    if price_data is None:\n        price = {\n            1: {1: 12, 2: 15, 3: 18, 4: 20, 5: 22},\n            2: {1: 14, 2: 16, 3: 17, 4: 19, 5: 21},\n            3: {1: 13, 2: 14, 3: 19, 4: 18, 5: 20}\n        }\n    else:\n        price = price_data\n\n    model = gp.Model(\"ComponentProcurement\")\n\n    q = model.addVars(suppliers, components, name=\"q\", lb=0)\n\n    total_cost = gp.quicksum(price[s][c] * q[s, c] for s in suppliers for c in components)\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    for c in components:\n        model.addConstr(gp.quicksum(q[s, c] for s in suppliers) == demand[c])\n\n    for s in suppliers:\n        model.addConstr(gp.quicksum(q[s, c] for c in components) <= capacity[s])\n\n    reliable_suppliers = [s for s in suppliers if reliability[s] >= 0.8]\n    for c in components:\n        model.addConstr(gp.quicksum(q[s, c] for s in reliable_suppliers) >= min_reliable_frac * demand[c])\n\n    total_spend = gp.quicksum(price[s][c] * q[s, c] for s in suppliers for c in components)\n    for s in suppliers:\n        supplier_spend = gp.quicksum(price[s][c] * q[s, c] for c in components)\n        model.addConstr(supplier_spend <= max_spend_frac * total_spend)\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_procurement_problem()\n    print(result)\n",
    "ground_truth":80740.21739
  },
  {
    "task_id":"D068",
    "description":"A regional water distribution company needs to optimize its pipeline network to maximize the daily water supply from Reservoir A (source) to City D (sink). The network consists of 5 pumping stations (nodes B, C, E, F, G) connected by pipelines with the following capacities (in thousand cubic meters\/day): A→B (15), A→C (10), B→C (5), B→D (10), C→E (8), C→F (12), E→D (7), F→D (20), G→D (0, currently inactive). Pumping station G is temporarily out of service. The system must maintain flow conservation at all intermediate nodes while respecting pipeline capacities.",
    "formulation":"Set:\n1. Nodes\nThe set of all nodes \\( N = \\{A, B, C, D, E, F, G\\} \\), where A is source and D is sink\n2. Arcs\nThe set of directed arcs \\( A = \\{(A,B), (A,C), (B,C), (B,D), (C,E), (C,F), (E,D), (F,D), (G,D)\\} \\)\n\nParameter:\n1. Capacity\nPipeline capacity limits \\( u_{ij} \\): \n\\( u_{AB} = 15 \\), \\( u_{AC} = 10 \\), \\( u_{BC} = 5 \\), \\( u_{BD} = 10 \\), \\( u_{CE} = 8 \\), \\( u_{CF} = 12 \\), \\( u_{ED} = 7 \\), \\( u_{FD} = 20 \\), \\( u_{GD} = 0 \\)\n\nDecision variable:\n1. Flow\nNon-negative variable \\( x_{ij} \\geq 0 \\) representing flow through arc \\( (i,j) \\in A \\)\n\nObjective:\nMaximize total flow from source to sink\nmax: \\( x_{AB} + x_{AC} \\) \n(Equivalent to maximizing inflow at sink D)\n\nConstraint:\n1. Capacity constraints\n\\( x_{ij} \\leq u_{ij}, \\forall (i,j) \\in A \\)\n2. Flow conservation\n\\( \\sum_{(i,k) \\in A} x_{ik} = \\sum_{(k,j) \\in A} x_{kj}, \\forall k \\in N \\setminus \\{A,D\\} \\)\n3. Non-negativity\n\\( x_{ij} \\geq 0, \\forall (i,j) \\in A \\)\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_max_flow(\n    nodes=['A', 'B', 'C', 'D', 'E', 'F', 'G'],\n    arcs={\n        ('A', 'B'): 15,\n        ('A', 'C'): 10,\n        ('B', 'C'): 5,\n        ('B', 'D'): 10,\n        ('C', 'E'): 8,\n        ('C', 'F'): 12,\n        ('E', 'D'): 7,\n        ('F', 'D'): 20,\n        ('G', 'D'): 0\n    }\n):\n    \"\"\"Solve the maximum flow problem for water distribution network.\"\"\"\n    \n    model = gp.Model(\"WaterDistributionMaxFlow\")\n    \n    active_arcs = {k: v for k, v in arcs.items() if v > 0}\n    \n    flow = model.addVars(active_arcs.keys(), name=\"flow\")\n    \n    model.setObjective(flow.sum('A', '*'), GRB.MAXIMIZE)\n    \n    model.addConstrs((flow[i,j] <= active_arcs[i,j] for i,j in active_arcs), \"capacity\")\n    \n    intermediate_nodes = [n for n in nodes if n not in ['A', 'D']]\n    \n    for node in intermediate_nodes:\n        inflow = gp.quicksum(flow[i,j] for i,j in active_arcs if j == node)\n        outflow = gp.quicksum(flow[i,j] for i,j in active_arcs if i == node)\n        model.addConstr(inflow == outflow, f\"flow_conserv_{node}\")\n    \n    model.optimize()\n    \n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_max_flow()\n    print(result)",
    "ground_truth":25.0
  },
  {
    "task_id":"D069",
    "description":"A regional distribution center needs to create a delivery schedule for 4 customer orders using 3 available trucks. Each customer order is a \"job\" that consists of 3 separate \"packages\" or \"operations,\" one for each truck. The time required to process each package on its designated truck is known.\n\nThe center wants to determine the start time for every single package to minimize the **makespan**, which is the total time elapsed until the very last package across all trucks is delivered.\n\nThe scheduling must adhere to two critical constraints:\n1.  **Truck Constraint:** Each truck can only process one package at a time.\n2.  **Customer Constraint:** For a single customer, their different packages (on different trucks) cannot be processed simultaneously.\n\nThe processing times (in hours) are as follows:\n| Customer \/ Job | Package for T1 | Package for T2 | Package for T3 |\n|:--------------:|:--------------:|:--------------:|:--------------:|\n| C1             | 2              | 3              | 1              |\n| C2             | 4              | 2              | 3              |\n| C3             | 1              | 5              | 2              |\n| C4             | 3              | 2              | 4              |",
    "formulation":"Set:\n1. Customers \/ Jobs\n   The set of Customers, \\( J = \\{C1, C2, C3, C4\\} \\)\n2. Trucks \/ Machines\n   The set of Trucks, \\( M = \\{T1, T2, T3\\} \\)\n\nParameter:\n1. ProcessingTime\n   The time \\( p_{jm} \\) required for the package of job \\( j \\) on machine \\( m \\).\n   | Customer \/ Job | Package for T1 | Package for T2 | Package for T3 |\n   | :--- | :--- | :--- | :--- |\n   | C1 | 2 | 3 | 1 |\n   | C2 | 4 | 2 | 3 |\n   | C3 | 1 | 5 | 2 |\n   | C4 | 3 | 2 | 4 |\n   \nDecision variable:\n1. StartTime\n   Continuous variable \\( s_{jm} \\geq 0 \\), the start time of the package for job \\( j \\) on machine \\( m \\).\n2. Makespan\n   Continuous variable \\( C_{max} \\geq 0 \\), representing the total completion time.\n3. MachineSequence\n   Binary variable \\( x_{ijm} \\in \\{0,1\\} \\). If two jobs `i` and `j` are on the same machine `m`, this variable decides their order: `x_ijm = 1` if `i` comes before `j`.\n4. JobSequence\n   Binary variable \\( y_{jmn} \\in \\{0,1\\} \\). For a single job `j`, this variable decides the order of its operations on machines `m` and `n`: `y_jmn = 1` if the operation on `m` comes before the operation on `n`.\n\nObjective:\nMinimize the makespan.\nmin: \\( C_{max} \\)\n\nConstraint:\n1. Machine Non-Overlap: For any two jobs `i` and `j` on the same machine `m`, their processing intervals cannot overlap.\n   \\( s_{im} + p_{im} \\leq s_{jm} + M \\cdot (1 - x_{ijm}), \\quad \\forall i, j \\in J, i \\neq j, m \\in M \\)\n   \\( s_{jm} + p_{jm} \\leq s_{im} + M \\cdot x_{ijm}, \\quad \\forall i, j \\in J, i \\neq j, m \\in M \\)\n2. Job Non-Overlap: For any single job `j`, its operations on two different machines `m` and `n` cannot overlap.\n   \\( s_{jm} + p_{jm} \\leq s_{jn} + M \\cdot (1 - y_{jmn}), \\quad \\forall j \\in J, m, n \\in M, m \\neq n \\)\n   \\( s_{jn} + p_{jn} \\leq s_{jm} + M \\cdot y_{jmn}, \\quad \\forall j \\in J, m, n \\in M, m \\neq n \\)\n3. Makespan Definition: The makespan must be greater than or equal to the completion time of every single package.\n   \\( s_{jm} + p_{jm} \\leq C_{max}, \\quad \\forall j \\in J, m \\in M \\)\n\nType:\nMixed, Linear, Linear\nMILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_open_shop_scheduling(\n    jobs=['C1', 'C2', 'C3', 'C4'],\n    machines=['T1', 'T2', 'T3'],\n    processing_time={\n        'C1': {'T1': 2, 'T2': 3, 'T3': 1},\n        'C2': {'T1': 4, 'T2': 2, 'T3': 3},\n        'C3': {'T1': 1, 'T2': 5, 'T3': 2},\n        'C4': {'T1': 3, 'T2': 2, 'T3': 4}\n    }\n):\n    \"\"\"\n    Solves a classic Open Shop Scheduling problem to minimize makespan.\n    \"\"\"\n    model = gp.Model(\"OpenShopScheduling\")\n\n    M = sum(processing_time[j][m] for j in jobs for m in machines)\n\n    s = model.addVars(jobs, machines, vtype=GRB.CONTINUOUS, name=\"start_time\")\n    C_max = model.addVar(vtype=GRB.CONTINUOUS, name=\"makespan\")\n    x = model.addVars(jobs, jobs, machines, vtype=GRB.BINARY, name=\"machine_sequence\")\n    y = model.addVars(jobs, machines, machines, vtype=GRB.BINARY, name=\"job_sequence\")\n\n    model.setObjective(C_max, GRB.MINIMIZE)\n\n    for j in jobs:\n        for m in machines:\n            model.addConstr(s[j, m] + processing_time[j][m] <= C_max, f\"makespan_{j}_{m}\")\n\n        for m1_idx, m1 in enumerate(machines):\n            for m2_idx, m2 in enumerate(machines):\n                if m1_idx < m2_idx:\n                    model.addConstr(\n                        s[j, m1] + processing_time[j][m1] <= s[j, m2] + M * (1 - y[j, m1, m2]),\n                        f\"job_non_overlap1_{j}_{m1}_{m2}\")\n                    model.addConstr(\n                        s[j, m2] + processing_time[j][m2] <= s[j, m1] + M * y[j, m1, m2],\n                        f\"job_non_overlap2_{j}_{m1}_{m2}\")\n\n    for m in machines:\n        for j1_idx, j1 in enumerate(jobs):\n            for j2_idx, j2 in enumerate(jobs):\n                if j1_idx < j2_idx:\n                    model.addConstr(\n                        s[j1, m] + processing_time[j1][m] <= s[j2, m] + M * (1 - x[j1, j2, m]),\n                        f\"machine_non_overlap1_{j1}_{j2}_{m}\")\n                    model.addConstr(\n                        s[j2, m] + processing_time[j2][m] <= s[j1, m] + M * x[j1, j2, m],\n                        f\"machine_non_overlap2_{j1}_{j2}_{m}\")\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_open_shop_scheduling()\n    print(result)\n",
    "ground_truth":12.0
  },
  {
    "task_id":"D070",
    "description":"Problem description:\nA logistics company manages shipments between 3 suppliers (S1, S2, S3), 2 cross-docking warehouses (W1, W2), and 4 customers (C1, C2, C3, C4). The suppliers have weekly capacities of [120, 150, 90] units respectively. Customers demand [80, 60, 70, 90] units weekly. \n\nTransport costs per unit:\n- Direct shipping: S1→[C1,C2,C3,C4] costs [8,10,12,14], S2→[C1,C2,C3,C4] costs [9,7,11,13], S3→[C1,C2,C3,C4] costs [11,9,8,10]\n- Cross-docking first leg: S1→[W1,W2] costs [4,5], S2→[W1,W2] costs [6,3], S3→[W1,W2] costs [5,4]\n- Cross-docking second leg: W1→[C1,C2,C3,C4] costs [6,5,7,9], W2→[C1,C2,C3,C4] costs [7,6,5,8]\nCross-docking handling cost is $2\/unit at each warehouse. Maximum throughput at W1 is 200 units, W2 is 180 units. \n\nThe company wants to minimize total logistics costs while meeting all customer demands without exceeding supplier capacities and warehouse throughput limits.",
    "formulation":"Set:\n1. Suppliers \nThe set of Suppliers, \\( S = \\{1, 2, 3\\} \\)\n2. Warehouses\nThe set of Warehouses, \\( W = \\{1, 2\\} \\)\n3. Customers\nThe set of Customers, \\( C = \\{1, 2, 3, 4\\} \\)\n\nParameter:\n1. SupplierCapacities\n[120, 150, 90] units for S1, S2, S3 respectively\n2. CustomerDemands\n[80, 60, 70, 90] units for C1 to C4 respectively\n3. DirectCost\nMatrix d where d[s,c] is direct shipping cost from supplier s to customer c:\nd = [[8,10,12,14], [9,7,11,13], [11,9,8,10]]\n4. FirstLegCost\nMatrix f where f[s,w] is cost from supplier s to warehouse w:\nf = [[4,5], [6,3], [5,4]]\n5. SecondLegCost\nMatrix l where l[w,c] is cost from warehouse w to customer c:\nl = [[6,5,7,9], [7,6,5,8]]\n6. HandlingCost\n2 per unit at any warehouse\n7. WarehouseCapacity\n[200, 180] units for W1 and W2 respectively\n\nDecision variable:\n1. DirectShip\nContinuous variable \\( x_{sc} \\geq 0 \\) for all \\( s \\in S, c \\in C \\), units shipped directly from supplier s to customer c\n2. CrossDockFirst\nContinuous variable \\( y_{sw} \\geq 0 \\) for all \\( s \\in S, w \\in W \\), units shipped from supplier s to warehouse w\n3. CrossDockSecond\nContinuous variable \\( z_{wc} \\geq 0 \\) for all \\( w \\in W, c \\in C \\), units shipped from warehouse w to customer c\n\nObjective:\nMinimize total logistics cost including transportation and handling:\nmin: \n\\( \\sum_{s\\in S}\\sum_{c\\in C} d[s][c] \\cdot x_{sc} \\) (direct shipping) \n\\( + \\sum_{s\\in S}\\sum_{w\\in W} f[s][w] \\cdot y_{sw} \\) (first leg) \n\\( + \\sum_{w\\in W}\\sum_{c\\in C} l[w][c] \\cdot z_{wc} \\) (second leg)\n\\( + 2 \\cdot \\sum_{w\\in W}\\sum_{c\\in C} z_{wc} \\) (handling)\n\nConstraint:\n1. Supplier capacity not exceeded\n\\( \\sum_{c\\in C}x_{sc} + \\sum_{w\\in W}y_{sw} \\leq SupplierCapacities_s, \\forall s \\in S \\)\n2. Customer demand satisfied\n\\( \\sum_{s\\in S}x_{sc} + \\sum_{w\\in W}z_{wc} = CustomerDemands_c, \\forall c \\in C \\)\n3. Warehouse flow balance\n\\( \\sum_{s\\in S}y_{sw} = \\sum_{c\\in C}z_{wc}, \\forall w \\in W \\)\n4. Warehouse capacity limit\n\\( \\sum_{s\\in S}y_{sw} \\leq WarehouseCapacity_w, \\forall w \\in W \\)\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_logistics_optimization(\n    suppliers=[0, 1, 2],\n    warehouses=[0, 1],\n    customers=[0, 1, 2, 3],\n    supplier_capacities=[120, 150, 90],\n    customer_demands=[80, 60, 70, 90],\n    direct_cost=[\n        [8, 10, 12, 14],  # S1→C1,C2,C3,C4\n        [9, 7, 11, 13],  # S2→C1,C2,C3,C4\n        [11, 9, 8, 10]  # S3→C1,C2,C3,C4\n    ],\n    first_leg_cost=[\n        [4, 5],  # S1→W1,W2\n        [6, 3],  # S2→W1,W2\n        [5, 4]  # S3→W1,W2\n    ],\n    second_leg_cost=[\n        [6, 5, 7, 9],  # W1→C1,C2,C3,C4\n        [7, 6, 5, 8]  # W2→C1,C2,C3,C4\n    ],\n    handling_cost=2,\n    warehouse_capacities=[200, 180]\n):\n    \"\"\"\n    Models and solves the logistics optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"LogisticsOptimization\")\n\n    # ========== Define Decision Variables ==========\n    # Direct shipment variables (supplier → customer)\n    direct_ship = model.addVars(suppliers,\n                                customers,\n                                lb=0.0,\n                                vtype=GRB.CONTINUOUS,\n                                name=\"DirectShip\")\n\n    # Cross-docking first leg variables (supplier → warehouse)\n    cross_dock_first = model.addVars(suppliers,\n                                     warehouses,\n                                     lb=0.0,\n                                     vtype=GRB.CONTINUOUS,\n                                     name=\"CrossDockFirst\")\n\n    # Cross-docking second leg variables (warehouse → customer)\n    cross_dock_second = model.addVars(warehouses,\n                                      customers,\n                                      lb=0.0,\n                                      vtype=GRB.CONTINUOUS,\n                                      name=\"CrossDockSecond\")\n\n    # ========== Set Objective Function ==========\n    # Direct shipping cost component\n    direct_shipping_cost = gp.quicksum(direct_cost[s][c] *\n                                       direct_ship[s, c] for s in suppliers\n                                       for c in customers)\n\n    # First leg shipping cost component\n    first_leg_shipping_cost = gp.quicksum(\n        first_leg_cost[s][w] * cross_dock_first[s, w] for s in suppliers\n        for w in warehouses)\n\n    # Second leg shipping cost component\n    second_leg_shipping_cost = gp.quicksum(\n        second_leg_cost[w][c] * cross_dock_second[w, c] for w in warehouses\n        for c in customers)\n\n    # Handling cost component (applied to all cross-docked units)\n    handling_cost_total = handling_cost * gp.quicksum(\n        cross_dock_second[w, c] for w in warehouses for c in customers)\n\n    # Set objective: minimize total cost\n    model.setObjective(\n        direct_shipping_cost + first_leg_shipping_cost +\n        second_leg_shipping_cost + handling_cost_total, GRB.MINIMIZE)\n\n    # ========== Add Constraints ==========\n    # 1. Supplier capacity constraints\n    for s in suppliers:\n        model.addConstr(gp.quicksum(direct_ship[s, c] for c in customers) +\n                        gp.quicksum(cross_dock_first[s, w]\n                                    for w in warehouses)\n                        <= supplier_capacities[s],\n                        name=f\"SupplierCapacity_{s}\")\n\n    # 2. Customer demand satisfaction\n    for c in customers:\n        model.addConstr(\n            gp.quicksum(direct_ship[s, c] for s in suppliers) +\n            gp.quicksum(cross_dock_second[w, c]\n                        for w in warehouses) == customer_demands[c],\n            name=f\"CustomerDemand_{c}\")\n\n    # 3. Warehouse flow balance (inflow = outflow)\n    for w in warehouses:\n        model.addConstr(gp.quicksum(cross_dock_first[s, w]\n                                    for s in suppliers) == gp.quicksum(\n                                        cross_dock_second[w, c]\n                                        for c in customers),\n                        name=f\"WarehouseFlowBalance_{w}\")\n\n    # 4. Warehouse throughput capacity\n    for w in warehouses:\n        model.addConstr(gp.quicksum(cross_dock_first[s, w]\n                                    for s in suppliers)\n                        <= warehouse_capacities[w],\n                        name=f\"WarehouseCapacity_{w}\")\n\n    # ========== Solve the Model ==========\n    model.optimize()\n\n    # --- 6. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_logistics_optimization()\n    print(result)",
    "ground_truth":2660.0
  },
  {
    "task_id":"D071",
    "description":"A warehouse needs to distribute 5 types of products (A, B, C, D, E) to 3 retail stores (Store1, Store2, Store3) using delivery trucks. Each truck has a maximum capacity of 15 tons. The products have the following weights per unit: A=2 tons, B=3 tons, C=1 ton, D=4 tons, E=2 tons. The stores require the following quantities: Store1 needs 2A+1B+3C, Store2 needs 1A+2D+1E, Store3 needs 3B+2C+1E. The warehouse has 4 trucks available. The goal is to minimize the total number of trucks used while meeting all store demands without exceeding truck capacities.",
    "formulation":"Mathematical Model:\nSet:\n1. Products\nThe set of products, \\( P = \\{A, B, C, D, E\\} \\)\n2. Stores\nThe set of stores, \\( S = \\{Store1, Store2, Store3\\} \\)\n3. Trucks\nThe set of trucks, \\( T = \\{1, 2, 3, 4\\} \\)\n\nParameter:\n1. ProductWeights\n[2, 3, 1, 4, 2] (tons) for products A to E respectively\n2. StoreDemands\n- Store1: [2, 1, 3, 0, 0] (units of A-E)\n- Store2: [1, 0, 0, 2, 1] \n- Store3: [0, 3, 2, 0, 1]\n3. TruckCapacity\n15 (tons)\n\nDecision variable:\n1. ProductDelivery\nInteger variable \\( x_{pst} \\geq 0 \\) for all \\( p \\in P, s \\in S, t \\in T \\), representing quantity of product p delivered to store s using truck t\n2. TruckUsed\nBinary variable \\( y_t \\in \\{0, 1\\} \\) for all \\( t \\in T \\), where \\( y_t = 1 \\) if truck t is used\n\nObjective:\nMinimize total trucks used\nmin: \\sum_{t\\in T}y_t\n\nConstraint:\n1. Meet all store demands\n\\sum_{t\\in T}x_{pst} = StoreDemands_{sp}, \\forall p \\in P, s \\in S\n2. Truck capacity limit\n\\sum_{p\\in P}\\sum_{s\\in S}ProductWeights_p \\cdot x_{pst} \\leq TruckCapacity \\cdot y_t, \\forall t \\in T\n3. Logical constraint (if any product is delivered by truck t, it must be marked as used)\nx_{pst} \\leq M \\cdot y_t, \\forall p \\in P, s \\in S, t \\in T (where M is a large enough constant)\n\nType:\nInteger, Linear, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_warehouse_distribution(\n    products=['A', 'B', 'C', 'D', 'E'],\n    stores=['Store1', 'Store2', 'Store3'],\n    trucks=[1, 2, 3, 4],\n    product_weights={'A': 2, 'B': 3, 'C': 1, 'D': 4, 'E': 2},\n    truck_capacity=15,\n    store_demands={\n        'Store1': {'A': 2, 'B': 1, 'C': 3, 'D': 0, 'E': 0},\n        'Store2': {'A': 1, 'B': 0, 'C': 0, 'D': 2, 'E': 1},\n        'Store3': {'A': 0, 'B': 3, 'C': 2, 'D': 0, 'E': 1}\n    }\n):\n    \"\"\"\n    Solves the warehouse distribution problem using Gurobi.\n    Minimizes the number of trucks used to deliver products to stores while meeting demand and capacity constraints.\n    \"\"\"\n    # Create model\n    model = gp.Model(\"WarehouseDistribution\")\n\n    # Decision variables\n    # x[p,s,t]: quantity of product p delivered to store s using truck t\n    x = model.addVars(products, stores, trucks, vtype=GRB.INTEGER, name=\"ProductDelivery\")\n\n    # y[t]: binary variable indicating if truck t is used\n    y = model.addVars(trucks, vtype=GRB.BINARY, name=\"TruckUsed\")\n\n    # Objective: Minimize total trucks used\n    model.setObjective(y.sum(), GRB.MINIMIZE)\n\n    # Constraints\n    # 1. Meet all store demands\n    for s in stores:\n        for p in products:\n            model.addConstr(\n                gp.quicksum(x[p, s, t] for t in trucks) == store_demands[s][p],\n                name=f\"Demand_{s}_{p}\"\n            )\n\n    # 2. Truck capacity limit\n    for t in trucks:\n        model.addConstr(\n            gp.quicksum(product_weights[p] * x[p, s, t] for p in products for s in stores)\n            <= truck_capacity * y[t],\n            name=f\"Capacity_{t}\"\n        )\n\n    # 3. Logical constraint: if any product is delivered by truck t, y_t must be 1\n    # Using a large M (here M = max possible demand for any product)\n    M = max(max(demands.values()) for demands in store_demands.values())\n    for p in products:\n        for s in stores:\n            for t in trucks:\n                model.addConstr(\n                    x[p, s, t] <= M * y[t],\n                    name=f\"Logic_{p}_{s}_{t}\"\n                )\n\n    # Solve the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_warehouse_distribution()\n    print(result)",
    "ground_truth":3.0
  },
  {
    "task_id":"D072",
    "description":"A regional distribution center needs to optimize its daily delivery routes for 5 stores located at different distances. The center has 3 available delivery trucks with capacities of 8, 10, and 12 tons respectively. The daily demands of the stores are: Store1 (3 tons), Store2 (4 tons), Store3 (5 tons), Store4 (2 tons), and Store5 (6 tons). The distance matrix (in km) between the distribution center (DC) and stores is: DC-Store1: 15, DC-Store2: 20, DC-Store3: 25, DC-Store4: 30, DC-Store5: 35. Each truck can visit multiple stores but cannot exceed its capacity. The objective is to minimize the total distance traveled by all trucks while ensuring all store demands are met.",
    "formulation":"Set:\n1. Trucks\nThe set of available trucks, \\( T = \\{1, 2, 3\\} \\)\n2. Stores\nThe set of stores to be served, \\( S = \\{1, 2, 3, 4, 5\\} \\)\n\nParameter:\n1. TruckCapacities\n[8, 10, 12]  # Capacity of each truck in tons\n2. StoreDemands\n[3, 4, 5, 2, 6]  # Demand of each store in tons\n3. Distances\n[15, 20, 25, 30, 35]  # Distance from DC to each store in km\n4. BigM\n1000  # A large constant for linearization\n\nDecision variable:\n1. TruckUsed\nBinary variable \\( u_t \\in \\{0, 1\\} \\) for all \\( t \\in T \\), where \\( u_t = 1 \\) if truck \\( t \\) is used, and \\( u_t = 0 \\) otherwise\n2. StoreAssignment\nBinary variable \\( x_{st} \\in \\{0, 1\\} \\) for all \\( s \\in S, t \\in T \\), where \\( x_{st} = 1 \\) if store \\( s \\) is assigned to truck \\( t \\), and \\( x_{st} = 0 \\) otherwise\n3. RouteDistance\nContinuous variable \\( d_t \\geq 0 \\) for all \\( t \\in T \\), representing the total distance traveled by truck \\( t \\)\n\nObjective:\nMinimize the total distance traveled by all trucks\nmin: \\sum_{t\\in T}d_t\n\nConstraint:\n1. Each store must be assigned to exactly one truck\n\\sum_{t\\in T}x_{st} = 1, \\forall s \\in S\n2. Truck capacity cannot be exceeded\n\\sum_{s\\in S}StoreDemands_s \\cdot x_{st} \\leq TruckCapacities_t, \\forall t \\in T\n3. Distance calculation for each truck (using farthest store visited)\nd_t \\geq Distances_s \\cdot x_{st}, \\forall s \\in S, t \\in T\n4. Truck usage constraint (if any store is assigned)\n\\sum_{s\\in S}x_{st} \\leq |S| \\cdot u_t, \\forall t \\in T\n\nType:\nMixed, Linear, Linear\nMILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_delivery_routing(\n    trucks=[1, 2, 3],\n    stores=[1, 2, 3, 4, 5],\n    truck_capacities={1: 8, 2: 10, 3: 12},\n    store_demands={1: 3, 2: 4, 3: 5, 4: 2, 5: 6},\n    distances={1: 15, 2: 20, 3: 25, 4: 30, 5: 35}\n):\n    \"\"\"\n    Solves the delivery routing optimization problem using Gurobi.\n    Minimizes total distance traveled by trucks while meeting store demands and truck capacity constraints.\n    \"\"\"\n    # Create model\n    model = gp.Model(\"DeliveryRouting\")\n\n    # Decision variables\n    # Binary variable indicating if truck t is used\n    truck_used = model.addVars(trucks, vtype=GRB.BINARY, name=\"truck_used\")\n    # Binary variable indicating if store s is assigned to truck t\n    store_assignment = model.addVars(stores, trucks, vtype=GRB.BINARY, name=\"store_assignment\")\n    # Continuous variable for distance traveled by each truck\n    route_distance = model.addVars(trucks, lb=0, vtype=GRB.CONTINUOUS, name=\"route_distance\")\n\n    # Objective: Minimize total distance traveled by all trucks\n    model.setObjective(\n        gp.quicksum(route_distance[t] for t in trucks),\n        GRB.MINIMIZE\n    )\n\n    # Constraints\n    # 1. Each store must be assigned to exactly one truck\n    model.addConstrs(\n        (store_assignment.sum(s, '*') == 1 for s in stores),\n        name=\"store_assignment\"\n    )\n\n    # 2. Truck capacity cannot be exceeded\n    model.addConstrs(\n        (gp.quicksum(store_demands[s] * store_assignment[s, t] for s in stores) <= truck_capacities[t]\n         for t in trucks),\n        name=\"truck_capacity\"\n    )\n\n    # 3. Distance calculation (truck distance is distance to farthest store visited)\n    model.addConstrs(\n        (route_distance[t] >= distances[s] * store_assignment[s, t]\n         for s in stores for t in trucks),\n        name=\"distance_calc\"\n    )\n\n    # 4. Truck usage constraint (if any store is assigned to truck)\n    model.addConstrs(\n        (gp.quicksum(store_assignment[s, t] for s in stores) <= len(stores) * truck_used[t]\n         for t in trucks),\n        name=\"truck_usage\"\n    )\n\n    # Optimize model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_delivery_routing()\n    print(result)",
    "ground_truth":60.0
  },
  {
    "task_id":"D073",
    "description":"A regional beverage distributor needs to optimize the delivery of 5 products (A,B,C,D,E) from their central warehouse (Node 1) to 3 retail stores (Nodes 4,5,6) through a transportation network with 6 nodes and 8 directed arcs. Each arc has a maximum capacity (in pallets\/day) and transportation cost ($\/pallet): (1→2): 20 pallets, $3; (1→3): 15 pallets, $4; (2→3): 10 pallets, $2; (2→4): 12 pallets, $5; (3→5): 18 pallets, $3; (3→6): 10 pallets, $6; (4→5): 8 pallets, $1; (5→6): 15 pallets, $2. The daily demands are: Store 4 needs 8 pallets (A:3, B:2, C:3), Store 5 needs 12 pallets (B:4, D:5, E:3), Store 6 needs 10 pallets (A:2, C:3, E:5). The warehouse can supply up to 30 pallets total daily. The goal is to satisfy all demands at minimum transportation cost while respecting arc capacities and product-specific requirements.",
    "formulation":"Set:\n1. Nodes\nThe set of nodes in the network, \\( N = \\{1,2,3,4,5,6\\} \\), where 1 is the source, {4,5,6} are sinks\n2. Arcs\nThe set of directed arcs, \\( A = \\{(1,2),(1,3),(2,3),(2,4),(3,5),(3,6),(4,5),(5,6)\\} \\)\n3. Products\nThe set of products, \\( P = \\{A,B,C,D,E\\} \\)\n\nParameter:\n1. ArcCapacity\nThe maximum flow capacity for each arc (pallets\/day):\n\\( u_{12} = 20, u_{13} = 15, u_{23} = 10, u_{24} = 12, u_{35} = 18, u_{36} = 10, u_{45} = 8, u_{56} = 15 \\)\n2. ArcCost\nThe transportation cost per pallet for each arc ($):\n\\( c_{12} = 3, c_{13} = 4, c_{23} = 2, c_{24} = 5, c_{35} = 3, c_{36} = 6, c_{45} = 1, c_{56} = 2 \\)\n3. Demand\nThe product-specific demand at each sink node (pallets\/day):\n\\( d_{4A} = 3, d_{4B} = 2, d_{4C} = 3, d_{5B} = 4, d_{5D} = 5, d_{5E} = 3, d_{6A} = 2, d_{6C} = 3, d_{6E} = 5 \\)\n4. SupplyLimit\nThe maximum total supply from the source: 30 pallets\/day\n\nDecision variable:\n1. ProductFlow\n\\( x_{ij}^p \\geq 0 \\) for all \\( (i,j) \\in A, p \\in P \\), representing the flow of product \\( p \\) on arc \\( (i,j) \\)\n\nObjective:\nMinimize the total transportation cost\nmin: \\( \\sum_{(i,j)\\in A} \\sum_{p\\in P} c_{ij} \\cdot x_{ij}^p \\)\n\nConstraint:\n1. Flow conservation at intermediate nodes\n\\( \\sum_{j:(i,j)\\in A} x_{ij}^p - \\sum_{j:(j,i)\\in A} x_{ji}^p = 0, \\forall i \\in N\\setminus\\{1,4,5,6\\}, \\forall p \\in P \\)\n2. Demand satisfaction at sink nodes\n\\( \\sum_{j:(j,i)\\in A} x_{ji}^p - \\sum_{j:(i,j)\\in A} x_{ij}^p = d_{ip}, \\forall i \\in \\{4,5,6\\}, \\forall p \\in P \\)\n3. Arc capacity constraints\n\\( \\sum_{p\\in P} x_{ij}^p \\leq u_{ij}, \\forall (i,j) \\in A \\)\n4. Source supply limit\n\\( \\sum_{j:(1,j)\\in A} \\sum_{p\\in P} x_{1j}^p \\leq 30 \\)\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_beverage_distribution(\n    N=[1, 2, 3, 4, 5, 6],\n    A=[(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (3, 6), (4, 5), (5, 6)],\n    P=['A', 'B', 'C', 'D', 'E'],\n    source=1,\n    sinks=[4, 5, 6],\n    u={\n        (1, 2): 20, (1, 3): 15, (2, 3): 10, (2, 4): 12,\n        (3, 5): 18, (3, 6): 10, (4, 5): 8, (5, 6): 15\n    },\n    c={\n        (1, 2): 3, (1, 3): 4, (2, 3): 2, (2, 4): 5,\n        (3, 5): 3, (3, 6): 6, (4, 5): 1, (5, 6): 2\n    },\n    d={\n        (4, 'A'): 3, (4, 'B'): 2, (4, 'C'): 3,\n        (5, 'B'): 4, (5, 'D'): 5, (5, 'E'): 3,\n        (6, 'A'): 2, (6, 'C'): 3, (6, 'E'): 5\n    },\n    supply_limit=30\n):\n    \"\"\"Solve the multi-commodity beverage distribution problem using Gurobi.\"\"\"\n    # Create model\n    model = gp.Model(\"BeverageDistribution\")\n\n    # ========== Decision Variables ==========\n    # Flow of product p on arc (i,j)\n    x = model.addVars(A, P, lb=0, name=\"flow\")\n\n    # ========== Objective Function ==========\n    # Minimize total transportation cost\n    model.setObjective(\n        gp.quicksum(c[i, j] * x[i, j, p] for (i, j) in A for p in P),\n        GRB.MINIMIZE\n    )\n\n    # ========== Constraints ==========\n    # 1. Flow conservation at intermediate nodes (nodes 2,3)\n    for i in [2, 3]:\n        for p in P:\n            model.addConstr(\n                gp.quicksum(x[i, j, p] for (i_, j) in A if i_ == i) -\n                gp.quicksum(x[j, i, p] for (j, i_) in A if i_ == i) == 0,\n                f\"flow_conservation_node_{i}_product_{p}\"\n            )\n\n    # 2. Demand satisfaction at sink nodes\n    for i in sinks:\n        for p in P:\n            if (i, p) in d:\n                model.addConstr(\n                    gp.quicksum(x[j, i, p] for (j, i_) in A if i_ == i) -\n                    gp.quicksum(x[i, j, p] for (i_, j) in A if i_ == i) == d[i, p],\n                    f\"demand_satisfaction_node_{i}_product_{p}\"\n                )\n            else:\n                # No demand for this product at this node\n                model.addConstr(\n                    gp.quicksum(x[j, i, p] for (j, i_) in A if i_ == i) -\n                    gp.quicksum(x[i, j, p] for (i_, j) in A if i_ == i) == 0,\n                    f\"no_demand_node_{i}_product_{p}\"\n                )\n\n    # 3. Arc capacity constraints\n    for (i, j) in A:\n        model.addConstr(\n            gp.quicksum(x[i, j, p] for p in P) <= u[i, j],\n            f\"arc_capacity_{i}_{j}\"\n        )\n\n    # 4. Source supply limit\n    model.addConstr(\n        gp.quicksum(x[source, j, p] for (i, j) in A if i == source for p in P) <= supply_limit,\n        \"source_supply_limit\"\n    )\n\n    # ========== Solve the Model ==========\n    model.optimize()\n\n    # ========== Return Results ==========\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Execute the function\nif __name__ == \"__main__\":\n    result = solve_beverage_distribution()\n    print(result)",
    "ground_truth":249.0
  },
  {
    "task_id":"D074",
    "description":"A distribution center needs to assign 4 delivery trucks to 4 customer locations for same-day shipments. Each truck has different transportation costs to each location due to varying distances and fuel consumption rates. The cost matrix (in USD) for assigning trucks to locations is as follows:\n\n| Truck\\Location | Loc1 | Loc2 | Loc3 | Loc4 |\n|----------------|------|------|------|------|\n| Truck1         | 120  | 150  | 180  | 90   |\n| Truck2         | 110  | 140  | 170  | 80   |\n| Truck3         | 130  | 160  | 190  | 100  |\n| Truck4         | 140  | 170  | 200  | 110  |\n\nThe distribution center aims to minimize total transportation costs while ensuring each truck is assigned to exactly one location and each location receives exactly one truck.",
    "formulation":"Set:\n1. Trucks\nThe set of delivery trucks, \\( T = \\{1, 2, 3, 4\\} \\)\n2. Locations\nThe set of customer locations, \\( L = \\{1, 2, 3, 4\\} \\)\n\nParameter:\n1. CostMatrix\nThe transportation cost (USD) when truck \\( t \\) is assigned to location \\( l \\), represented as \\( c_{tl} \\):\n- \\( c_{11} = 120 \\), \\( c_{12} = 150 \\), \\( c_{13} = 180 \\), \\( c_{14} = 90 \\)\n- \\( c_{21} = 110 \\), \\( c_{22} = 140 \\), \\( c_{23} = 170 \\), \\( c_{24} = 80 \\)\n- \\( c_{31} = 130 \\), \\( c_{32} = 160 \\), \\( c_{33} = 190 \\), \\( c_{34} = 100 \\)\n- \\( c_{41} = 140 \\), \\( c_{42} = 170 \\), \\( c_{43} = 200 \\), \\( c_{44} = 110 \\)\n\nDecision variable:\n1. Assignment\nBinary variable \\( x_{tl} \\in \\{0, 1\\} \\) for all \\( t \\in T, l \\in L \\), where \\( x_{tl} =  1 \\) if truck \\( t \\) is assigned to location \\( l \\), and \\( x_{tl} = 0 \\) otherwise\n\nObjective:\nMinimize total transportation cost\nmin: \\( \\sum_{t\\in T}\\ Tsum_{l\\in L}c_{tl}x_{tl} \\)\n\nConstraint:\n1. Each truck must be assigned to exactly one location\n\\( \\sum_{l\\in L}x_{tl} = 1, \\forall t \\in T \\)\n2. Each location must receive exactly one truck\n\\( \\sum_{t\\in T}x_{tl} = 1, \\forall l \\in L \\)\n\nType:\nBinary, Linear,, Linear\nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_truck_assignment(\n    trucks=[1, 2, 3, 4],\n    locations=[1, 2, 3, 4],\n    cost={\n        (1, 1): 120, (1, 2): 150, (1, 3): 180, (1, 4): 90,\n        (2, 1): 110, (2, 2): 140, (2, 3): 170, (2, 4): 80,\n        (3, 1): 130, (3, 2): 160, (3, 3): 190, (3, 4): 100,\n        (4, 1): 140, (4, 2): 170, (4, 3): 200, (4, 4): 110\n    }\n):\n    \"\"\"\n    Solves the truck assignment problem.\n    \"\"\"\n    # Create optimization model\n    model = gp.Model(\"TruckAssignment\")\n\n    # Decision variables: x[t,l] = 1 if truck t is assigned to location l\n    x = model.addVars(trucks, locations, vtype=GRB.BINARY, name=\"assign\")\n\n    # Set objective: minimize total transportation cost\n    model.setObjective(gp.quicksum(cost[t, l] * x[t, l] for t in trucks for l in locations), GRB.MINIMIZE)\n\n    # Constraints:\n    # Each truck must be assigned to exactly one location\n    model.addConstrs((x.sum(t, '*') == 1 for t in trucks), name=\"truck_assignment\")\n\n    # Each location must receive exactly one truck\n    model.addConstrs((x.sum('*', l) == 1 for l in locations), name=\"location_assignment\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_truck_assignment()\n    print(result)",
    "ground_truth":560.0
  },
  {
    "task_id":"D075",
    "description":"# Problem Description:\nA mining company operates three ore processing plants (P1, P2, P3) with monthly processing capacities of 8000, 10000, and 12000 tons respectively. The company sources ore from four different mines (M1, M2, M3, M4) with available quantities of 6000, 9000, 7000, and 5000 tons per month. \n\nEach ore type has different characteristics:\n- Metal recovery rates: M1=85%, M2=92%, M3=78%, M4=88%\n- Processing costs per ton: M1=$12, M2=$18, M3=$10, M4=$15\n- Sulfur content (impurity): M1=1.2%, M2=0.8%, M3=2.1%, M4=1.5%\n- Maximum allowed average sulfur content across all plants: 1.5%\n\nTransportation costs per ton from mines to plants:\n|       | P1  | P2  | P3  |\n|-------|-----|-----|-----|\n|   M1  | $4  | $6  | $5  |\n|   M2  | $7  | $5  | $8  |\n|   M3  | $3  | $4  | $6  |\n|   M4  | $8  | $6  | $7  |\n\nThe company needs to determine the optimal ore allocation from mines to plants to maximize total metal recovery while keeping total costs under $500,000 and meeting all operational constraints.",
    "formulation":"Set:\n1. Mines \nThe set of mines, \\( M = \\{M1, M2, M3, M4\\} \\)\n2. Plants\nThe set of processing plants, \\( P = \\{P1, P2, P3\\} \\)\n\nParameter:\n1. MineSupply  \n\\( s_m \\): Available ore at mine m (tons)  \n[M1:6000, M2:9000, M3:7000, M4:5000]  \n2. PlantCapacity  \n\\( c_p \\): Processing capacity of plant p (tons)  \n[P1:8000, P2:10000, P3:12000]  \n3. RecoveryRate  \n\\( r_m \\): Metal recovery rate for mine m (%)  \n[M1:0.85, M2:0.92, M3:0.78, M4:0.88]  \n4. ProcessingCost  \n\\( pc_m \\): Processing cost per ton for mine m ($)  \n[M1:12, M2:18, M3:10, M4:15]  \n5. SulfurContent  \n\\( sc_m \\): Sulfur content for mine m (%)  \n[M1:1.2, M2:0.8, M3:2.1, M4:1.5]  \n6. TransportCost  \n\\( tc_{mp} \\): Transportation cost from mine m to plant p ($)  \n(As given in the cost matrix)  \n7. MaxSulfur  \n1.5 (%) Maximum allowed average sulfur content  \n8. Budget  \n500000 ($) Total cost limit  \n\nDecision variable:\n1. Allocation  \n\\( x_{mp} \\geq 0 \\): Continuous variable representing tons of ore shipped from mine m to plant p  \n\nObjective:  \nMaximize total metal recovery  \nmax: \\( \\sum_{m\\in M} \\sum_{p\\in P} r_m \\cdot x_{mp} \\)\n\nConstraint:\n1. Mine supply limit  \n\\( \\sum_{p\\in P} x_{mp} \\leq s_m, \\forall m \\in M \\)\n2. Plant capacity limit  \n\\( \\sum_{m\\in M} x_{mp} \\leq c_p, \\forall p \\in P \\)\n3. Total cost limit (processing + transportation)  \n\\( \\sum_{m\\in M} \\sum_{p\\in P} (pc_m + tc_{mp}) \\cdot x_{mp} \\leq 500000 \\)\n4. Average sulfur content restriction  \n\\( \\frac{\\sum_{m\\in M} \\sum_{p\\in P} sc_m \\cdot x_{mp}}{\\sum_{m\\in M} \\sum_{p\\in P} x_{mp}} \\leq 1.5 \\)\n5. Non-negativity  \n\\( x_{mp} \\geq 0, \\forall m \\in M, p \\in P \\)\n\nType:\nContinuous, Linear, Linear  \nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_mining_optimization(\n    mines=['M1', 'M2', 'M3', 'M4'],\n    plants=['P1', 'P2', 'P3'],\n    mine_supply={'M1': 6000, 'M2': 9000, 'M3': 7000, 'M4': 5000},\n    plant_capacity={'P1': 8000, 'P2': 10000, 'P3': 12000},\n    recovery_rate={'M1': 0.85, 'M2': 0.92, 'M3': 0.78, 'M4': 0.88},\n    processing_cost={'M1': 12, 'M2': 18, 'M3': 10, 'M4': 15},\n    sulfur_content={'M1': 1.2, 'M2': 0.8, 'M3': 2.1, 'M4': 1.5},\n    max_sulfur=1.5,\n    budget=500000,\n    transport_cost={\n        'M1': {'P1': 4, 'P2': 6, 'P3': 5},\n        'M2': {'P1': 7, 'P2': 5, 'P3': 8},\n        'M3': {'P1': 3, 'P2': 4, 'P3': 6},\n        'M4': {'P1': 8, 'P2': 6, 'P3': 7}\n    }\n):\n    \"\"\"Solve the mining company's ore allocation optimization problem.\"\"\"\n    # Create a new model\n    model = gp.Model(\"MiningAllocation\")\n\n    # Decision variables: x_mp = tons shipped from mine m to plant p\n    x = model.addVars(mines, plants, name=\"Allocation\", lb=0)\n\n    # Objective: Maximize total metal recovery\n    model.setObjective(\n        gp.quicksum(recovery_rate[m] * x[m, p] for m in mines for p in plants),\n        GRB.MAXIMIZE\n    )\n\n    # Constraints\n    # 1. Mine supply limit\n    model.addConstrs(\n        (gp.quicksum(x[m, p] for p in plants) <= mine_supply[m] for m in mines),\n        name=\"MineSupply\"\n    )\n\n    # 2. Plant capacity limit\n    model.addConstrs(\n        (gp.quicksum(x[m, p] for m in mines) <= plant_capacity[p] for p in plants),\n        name=\"PlantCapacity\"\n    )\n\n    # 3. Total cost limit (processing + transportation)\n    model.addConstr(\n        gp.quicksum((processing_cost[m] + transport_cost[m][p]) * x[m, p]\n                   for m in mines for p in plants) <= budget,\n        name=\"TotalCost\"\n    )\n\n    # 4. Average sulfur content restriction\n    total_sulfur = gp.quicksum(sulfur_content[m] * x[m, p] for m in mines for p in plants)\n    total_tonnage = gp.quicksum(x[m, p] for m in mines for p in plants)\n    model.addConstr(total_sulfur <= max_sulfur * total_tonnage, name=\"SulfurLimit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Execute the function\nif __name__ == \"__main__\":\n    result = solve_mining_optimization()\n    print(result)",
    "ground_truth":22933.33333
  },
  {
    "task_id":"D076",
    "description":"A regional grocery chain is launching a new energy drink product and needs to optimally allocate initial stock to its stores. There are 6 stores (S1-S6) with varying characteristics. Each store has a known customer traffic (daily visits: S1-1200, S2-800, S3-1500, S4-900, S5-1100, S6-700), shelf space allocation (units: S1-50, S2-30, S3-60, S4-35, S5-45, S6-25), and historical sales similarity score for similar products (0-1 scale: S1-0.8, S2-0.6, S3-0.9, S4-0.7, S5-0.75, S6-0.5). The warehouse has 300 units available for initial distribution. There are two types of display setups: standard (costs $5 per store) and promotional (costs $15 per store but increases effective shelf space by 20%). The total display budget is $120. The goal is to maximize expected product exposure, calculated as: (customer traffic) × (units allocated) × (sales similarity score).",
    "formulation":"Set:\n1. Stores\n   The set of Stores, \\( S = \\{S1, S2, S3, S4, S5, S6\\} \\)\n\nParameter:\n1. CustomerTraffic_s  \n   [S1:1200, S2:800, S3:1500, S4:900, S5:1100, S6:700]\n2. ShelfSpace_s  \n   [S1:50, S2:30, S3:60, S4:35, S5:45, S6:25]\n3. SimilarityScore_s  \n   [S1:0.8, S2:0.6, S3:0.9, S4:0.7, S5:0.75, S6:0.5]\n4. DisplayCost  \n   Standard:5, Promotional:15\n5. SpaceMultiplier  \n   1.2 (for promotional display)\n6. TotalInventory  \n   300\n7. Budget  \n   120\n\nDecision variable:\n1. AllocateUnits_s  \n   Integer variable \\( u_s \\geq 0 \\) for all \\( s \\in S \\), units allocated to store s\n2. DisplayType_s  \n   Binary variable \\( d_s \\in \\{0,1\\} \\) for all \\( s \\in S \\), where 1=promotional display\n\nObjective:\nMaximize total expected product exposure\nmax: \\( \\sum_{s\\in S} CustomerTraffic_s \\times u_s \\times SimilarityScore_s \\)\n\nConstraint:\n1. Inventory limit  \n   \\( \\sum_{s\\in S} u_s \\leq TotalInventory \\)\n2. Budget limit  \n   \\( \\sum_{s\\in S} (5(1-d_s) + 15d_s) \\leq Budget \\)\n3. Shelf space constraints  \n   \\( u_s \\leq ShelfSpace_s \\times (1 + 0.2d_s), \\forall s \\in S \\)\n4. Non-negativity  \n   \\( u_s \\geq 0, \\forall s \\in S \\)\n\nType:\nInteger, Linear, Linear  \nILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_energy_drink_allocation(\n    stores=['S1', 'S2', 'S3', 'S4', 'S5', 'S6'],\n    customer_traffic={\n        'S1': 1200,\n        'S2': 800,\n        'S3': 1500,\n        'S4': 900,\n        'S5': 1100,\n        'S6': 700\n    },\n    shelf_space={\n        'S1': 50,\n        'S2': 30,\n        'S3': 60,\n        'S4': 35,\n        'S5': 45,\n        'S6': 25\n    },\n    similarity_score={\n        'S1': 0.8,\n        'S2': 0.6,\n        'S3': 0.9,\n        'S4': 0.7,\n        'S5': 0.75,\n        'S6': 0.5\n    },\n    total_inventory=300,\n    budget=120,\n    standard_cost=5,\n    promotional_cost=15,\n    space_multiplier=1.2\n):\n    \"\"\"\n    Solves the energy drink allocation problem using Gurobi optimizer.\n    Maximizes expected product exposure under inventory, budget, and shelf space constraints.\n    \"\"\"\n    # Create model\n    model = gp.Model(\"EnergyDrinkAllocation\")\n\n    # Decision variables\n    allocate_units = model.addVars(stores, vtype=GRB.INTEGER, name=\"units\")\n    display_type = model.addVars(stores, vtype=GRB.BINARY, name=\"display\")\n\n    # Objective: Maximize expected exposure\n    exposure = gp.quicksum(customer_traffic[s] * allocate_units[s] *\n                           similarity_score[s] for s in stores)\n    model.setObjective(exposure, GRB.MAXIMIZE)\n\n    # Constraints\n    # Inventory limit\n    model.addConstr(\n        gp.quicksum(allocate_units[s] for s in stores) <= total_inventory,\n        \"inventory_limit\")\n\n    # Budget constraint\n    model.addConstr(\n        gp.quicksum(standard_cost * (1 - display_type[s]) +\n                    promotional_cost * display_type[s]\n                    for s in stores) <= budget, \"budget_limit\")\n\n    # Shelf space constraints\n    for s in stores:\n        model.addConstr(\n            allocate_units[s] <= shelf_space[s] *\n            (1 + (space_multiplier - 1) * display_type[s]),\n            f\"shelf_space_{s}\")\n\n    # Optimize model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Execute the function\nif __name__ == \"__main__\":\n    result = solve_energy_drink_allocation()\n    print(result)\n",
    "ground_truth":253590.0
  },
  {
    "task_id":"D077",
    "description":"A shipping company operates a fleet of cargo ships to transport containers between three ports: PortA, PortB, and PortC. The company aims to allocate its ships across six possible shipping routes in a way that maximizes overall profit while satisfying all container demand and adhering to operational constraints.\n\nEach ship has a capacity of 8000 TEUs (Twenty-foot Equivalent Units) and consumes 200 tons of fuel per 1000 nautical miles traveled. Fuel costs 600 USD per ton. There are 12 ships available in total, but at least 2 must remain in reserve and cannot be assigned to any route. Each ship can only be assigned to one route per day.\n\nThe six possible shipping routes, along with their respective distances, are as follows:\n- Route1: PortA → PortB (1200 nautical miles)\n- Route2: PortA → PortC (1800 nautical miles)\n- Route3: PortB → PortC (900 nautical miles)\n- Route4: PortB → PortA (1200 nautical miles)\n- Route5: PortC → PortA (1800 nautical miles)\n- Route6: PortC → PortB (900 nautical miles)\n\nFor each route, the container demand in TEUs is:\n- Route1: 6500 TEUs\n- Route2: 7200 TEUs\n- Route3: 4800 TEUs\n- Route4: 5100 TEUs\n- Route5: 6200 TEUs\n- Route6: 3900 TEUs\n\nRevenue generated per TEU varies by route:\n- Route1: $120 per TEU\n- Route2: $150 per TEU\n- Route3: $90 per TEU\n- Route4: $110 per TEU\n- Route5: $140 per TEU\n- Route6: $80 per TEU\n\nOperational constraints include:\n- A ship assigned to a route must carry at least 70% of its capacity, i.e., at least 5600 TEUs.\n- The number of ships assigned to a route cannot exceed the ceiling of the ratio of demand to ship capacity (i.e., ceiling(demand \/ 8000)).\n- All container demand for each route must be fully satisfied.\n\nThe objective is to determine the optimal allocation of ships to routes that maximizes net profit (revenue from transported containers minus fuel costs), while respecting all constraints.",
    "formulation":"Set:\n1. Grades\nThe set of orange grades, \\( G = \\{9, 6\\} \\)\n\nParameter:\n1. Inventory (kg)\n\\( Q_9 = 90,000 \\), \\( Q_6 = 110,000 \\)\n2. Quality Scores\n\\( s_9 = 9 \\), \\( s_6 = 6 \\)\n3. FP Economic Data\nRevenue \\( R_{FP} = 2.80 \\), Cost \\( C_{FP} = 1.20 \\)\n4. JE Economic Data\nJuice Price \\( P_{JE} = 3.00 \\), Yield \\( Y_{JE} = 0.5 \\), Cost \\( C_{JE} = 0.90 \\)\n5. Quality Thresholds\n\\( T_{FP} = 7.5 \\), \\( T_{JE} = 8.25 \\)\n6. Operational Limits\n\\( JE_{max} = 70,000 \\), \\( FP_{min} = 20,000 \\)\n\nDecision variable:\n1. Allocation\nContinuous variable \\( x_{g,p} \\geq 0 \\) for all \\( g \\in G, p \\in \\{FP, JE\\} \\), representing kg of grade \\( g \\) oranges allocated to process \\( p \\)\n\nObjective:\nMaximize daily profit\nmax: \\( \\sum_{g\\in G} [(R_{FP} - C_{FP})x_{g,FP} + (P_{JE} \\cdot Y_{JE} - C_{JE})x_{g,JE}] \\)\n\nConstraint:\n1. Inventory limits\n\\( x_{9,FP} + x_{9,JE} \\leq Q_9 \\)\n\\( x_{6,FP} + x_{6,JE} \\leq Q_6 \\)\n2. Quality requirements\n\\( \\frac{9x_{9,FP} + 6x_{6,FP}}{x_{9,FP} + x_{6,FP}} \\geq T_{FP} \\)\n\\( \\frac{9x_{9,JE} + 6x_{6,JE}}{x_{9,JE} + x_{6,JE}} \\geq T_{JE} \\)\n3. Operational constraints\n\\( x_{9,JE} + x_{6,JE} \\leq JE_{max} \\)\n\\( x_{9,FP} + x_{6,FP} \\geq FP_{min} \\)\n4. Non-negativity\n\\( x_{g,p} \\geq 0 \\)\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_shipping_problem(\n    routes=[1, 2, 3, 4, 5, 6],\n    ships=list(range(1, 11)),\n    RouteDemand={\n        1: 6500,\n        2: 7200,\n        3: 4800,\n        4: 5100,\n        5: 6200,\n        6: 3900\n    },\n    Revenue={\n        1: 120,\n        2: 150,\n        3: 90,\n        4: 110,\n        5: 140,\n        6: 80\n    },\n    Distance={\n        1: 1200,\n        2: 1800,\n        3: 900,\n        4: 1200,\n        5: 1800,\n        6: 900\n    },\n    ShipCapacity=8000,\n    FuelConsumptionRate=0.2,\n    FuelCost=600,\n    MinLoadPercentage=0.7\n):\n    # Create model\n    model = gp.Model(\"Shipping_Optimization\")\n\n    # Decision variables\n    # Binary variable: 1 if ship s is assigned to route r\n    x = model.addVars(ships, routes, vtype=GRB.BINARY, name=\"assign\")\n\n    # Continuous variable: total containers shipped on route r\n    y = model.addVars(routes, lb=0, vtype=GRB.CONTINUOUS, name=\"containers\")\n\n    # Objective function: maximize profit (revenue - fuel costs)\n    revenue = gp.quicksum(Revenue[r] * y[r] for r in routes)\n    fuel_cost = gp.quicksum(\n        x[s, r] * Distance[r] * FuelConsumptionRate * FuelCost\n        for s in ships for r in routes\n    )\n    model.setObjective(revenue - fuel_cost, GRB.MAXIMIZE)\n\n    # Constraints\n    # 1. Demand satisfaction\n    model.addConstrs(\n        (y[r] >= RouteDemand[r] for r in routes),\n        name=\"demand_satisfaction\"\n    )\n\n    # 2. Ship capacity constraints\n    model.addConstrs(\n        (y[r] <= gp.quicksum(x[s, r] for s in ships) * ShipCapacity for r in routes),\n        name=\"capacity_limit\"\n    )\n\n    # 3. Minimum loading requirement (70% of capacity)\n    model.addConstrs(\n        (y[r] >= gp.quicksum(x[s, r] for s in ships) * ShipCapacity * MinLoadPercentage for r in routes),\n        name=\"min_loading\"\n    )\n\n    # 4. Each ship can be assigned to at most 1 route\n    model.addConstrs(\n        (gp.quicksum(x[s, r] for r in routes) <= 1 for s in ships),\n        name=\"ship_assignment_limit\"\n    )\n\n    # 5. Maximum ships per route (ceil(demand\/capacity))\n    max_ships_per_route = {\n        r: math.ceil(RouteDemand[r] \/ ShipCapacity) for r in routes\n    }\n    model.addConstrs(\n        (gp.quicksum(x[s, r] for s in ships) <= max_ships_per_route[r] for r in routes),\n        name=\"max_ships_per_route\"\n    )\n\n    # 6. Total ship usage cannot exceed available ships (10)\n    model.addConstr(\n        gp.quicksum(x[s, r] for s in ships for r in routes) <= 10,\n        name=\"total_ship_usage\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_shipping_problem()\n    print(result)",
    "ground_truth":4584000.0
  },
  {
    "task_id":"D078",
    "description":"A specialty coffee roasting company has received shipments of two premium green coffee beans: Ethiopia Yirgacheffe (8,000 kg) and Colombia Supremo (12,000 kg). The company needs to allocate these beans to two different product lines to maximize its weekly profit:\n1.  **Single-Origin Bags (SO):** High-end bags of whole beans sold to specialty cafes.\n2.  **House Blend (HB):** A signature blend sold ground to retail partners.\n\n**Economic & Quality Data:**\nThe profitability of each product line depends on the cost of the beans and the processing involved. Furthermore, each product line must meet a minimum average quality standard, measured by the coffee's \"cupping score\" (a 0-100 scale).\n\n| Bean Origin | Available (kg) | Cupping Score |\n|:-----------:|:--------------:|:-------------:|\n| Ethiopia    | 8,000          | 92            |\n| Colombia    | 12,000         | 87            |\n\n| Product Line      | Revenue per kg | Processing Cost per kg | Minimum Avg. Cupping Score |\n|:------------------|:--------------:|:----------------------:|:--------------------------:|\n| Single-Origin (SO)| $40.00         | $5.00                  | 90                         |\n| House Blend (HB)  | $28.00         | $8.50                  | 88                         |\n\n**Operational Constraints:**\n- The company's primary roaster, used for the House Blend, has a maximum weekly processing capacity of 10,000 kg.\n- Due to a contract with a key client, the company must produce at least 2,000 kg of Single-Origin bags per week.\n\nThe goal is to determine the optimal quantity (in kg) of each type of green bean to allocate to each product line to maximize total weekly profit, while respecting all inventory, quality, and operational constraints.",
    "formulation":"Set:\n1. Beans\n   The set of green coffee bean origins, \\( B = \\{\\text{Ethiopia}, \\text{Colombia}\\} \\)\n2. Processes\n   The set of product lines, \\( P = \\{\\text{SO}, \\text{HB}\\} \\)\n\nParameter:\n1. Inventory (kg)\n   \\( I_b \\): Available inventory for each bean origin b.\n   \\( I_{\\text{Ethiopia}} = 8000 \\), \\( I_{\\text{Colombia}} = 12000 \\)\n2. CuppingScore\n   \\( s_b \\): The quality score for each bean origin b.\n   \\( s_{\\text{Ethiopia}} = 92 \\), \\( s_{\\text{Colombia}} = 87 \\)\n3. RevenuePerKg\n   \\( R_p \\): Revenue per kg for each product line p.\n   \\( R_{\\text{SO}} = 40 \\), \\( R_{\\text{HB}} = 28 \\)\n4. ProcessingCostPerKg\n   \\( C_p \\): Processing cost per kg for each product line p.\n   \\( C_{\\text{SO}} = 5 \\), \\( C_{\\text{HB}} = 8.5 \\)\n5. QualityThreshold\n   \\( T_p \\): Minimum required average cupping score for product line p.\n   \\( T_{\\text{SO}} = 90 \\), \\( T_{\\text{HB}} = 88 \\)\n6. OperationalLimits\n   Roaster capacity (for HB): \\( \\text{Cap}_{\\text{HB}} = 10000 \\) kg\n   Minimum SO production: \\( \\text{Min}_{\\text{SO}} = 2000 \\) kg\n\nDecision variable:\n1. Allocation\n   Continuous variable \\( x_{bp} \\geq 0 \\) for all \\( b \\in B, p \\in P \\), representing the kilograms of bean b allocated to product line p.\n\nObjective:\nMaximize total weekly profit.\nmax: \\( \\sum_{b \\in B} \\sum_{p \\in P} (R_p - C_p) \\cdot x_{bp} \\)\n\nConstraint:\n1. Inventory limits\n   The total amount of each bean type allocated cannot exceed its available inventory.\n   \\( \\sum_{p \\in P} x_{bp} \\leq I_b, \\quad \\forall b \\in B \\)\n2. Quality requirements (linearized)\n   The weighted average cupping score for each product line must meet its threshold. This is linearized from \\( \\frac{\\sum_b s_b \\cdot x_{bp}}{\\sum_b x_{bp}} \\geq T_p \\).\n   \\( \\sum_{b \\in B} (s_b - T_p) \\cdot x_{bp} \\geq 0, \\quad \\forall p \\in P \\)\n3. Operational constraints\n   The total amount allocated to the House Blend cannot exceed the roaster's capacity.\n   \\( \\sum_{b \\in B} x_{b, \\text{HB}} \\leq \\text{Cap}_{\\text{HB}} \\)\n   The total amount allocated to Single-Origin bags must meet the minimum contractual obligation.\n   \\( \\sum_{b \\in B} x_{b, \\text{SO}} \\geq \\text{Min}_{\\text{SO}} \\)\n\nType:\nContinuous, Linear, Linear\nLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_coffee_blending(\n    beans=['Ethiopia', 'Colombia'],\n    processes=['SO', 'HB'],\n    inventory={'Ethiopia': 8000, 'Colombia': 12000},\n    cupping_score={'Ethiopia': 92, 'Colombia': 87},\n    revenue={'SO': 40, 'HB': 28},\n    proc_cost={'SO': 5, 'HB': 8.5},\n    quality_threshold={'SO': 90, 'HB': 88},\n    roaster_capacity_hb=10000,\n    min_production_so=2000\n):\n    \"\"\"\n    Solves the specialty coffee blending and allocation problem to maximize profit.\n    \"\"\"\n\n    # Create a new model\n    model = gp.Model(\"CoffeeBlending\")\n\n    # --- Decision Variables ---\n    # x[b, p]: kg of bean 'b' allocated to process 'p'\n    x = model.addVars(beans, processes, lb=0, name=\"allocation\")\n\n    # --- Objective Function ---\n    # Maximize total profit: (Revenue - Processing Cost) * Quantity\n    profit = gp.quicksum((revenue[p] - proc_cost[p]) * x[b, p]\n                         for b in beans for p in processes)\n    model.setObjective(profit, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    # 1. Inventory limits for each bean type\n    model.addConstrs((x.sum(b, '*') <= inventory[b] for b in beans),\n                     name=\"inventory\")\n\n    # 2. Quality requirements for each product line (linearized)\n    for p in processes:\n        model.addConstr(gp.quicksum(\n            (cupping_score[b] - quality_threshold[p]) * x[b, p]\n            for b in beans) >= 0,\n                        name=f\"quality_{p}\")\n\n    # 3. Operational constraints\n    model.addConstr(x.sum('*', 'HB') <= roaster_capacity_hb,\n                    name=\"roaster_capacity\")\n    model.addConstr(x.sum('*', 'SO') >= min_production_so,\n                    name=\"min_so_production\")\n\n    # --- Solve the model ---\n    model.optimize()\n\n    # --- Return results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_coffee_blending()\n    print(result)",
    "ground_truth":545000.0
  },
  {
    "task_id":"D079",
    "description":"PharmaLogistics Inc. is planning the distribution network for its new temperature-sensitive drug, 'VitaBoost', for the upcoming 6 months (Month 1 to Month 6). The company has two manufacturing plants (P1 located in City A, P2 located in City B) and is considering opening and operating up to three potential distribution centers (DC1 in Region X, DC2 in Region Y, DC3 in Region Z) to serve four key demand regions (R1, R2, R3, R4). The primary objective is to minimize the total operational costs over the 6-month planning horizon. These costs include: the fixed monthly costs of operating any active DCs, transportation costs for shipping VitaBoost from plants to DCs and from DCs to demand regions, inventory holding costs for products stored at DCs, costs associated with product expiry and disposal, and shortage costs incurred for any unmet demand in the regions.\n\nVitaBoost has a strict shelf life of 2 months. This means that any product manufactured in a given month (say, Month `m`) must be used to satisfy demand by the end of the following month (Month `m+1`). Product not used by this deadline expires and must be disposed of.\n\nAt the beginning of Month 1, DC1 has an initial stock of VitaBoost, provided it is chosen to be operational in Month 1: 10 units that were produced in the immediately preceding month (referred to as 'Month 0' batch, thus being 1-month old at the start of Month 1) and 5 units that were produced two months prior (referred to as 'Month -1' batch, thus being 2-months old at the start of Month 1). This 'Month -1' batch must be used or discarded during Month 1. No other initial inventory exists at other potential DCs or plants.\n\nThe monthly production capacities for the manufacturing plants are as follows (in units, for Months 1 through 6 respectively):\n-   Plant P1: [250, 250, 260, 260, 270, 270]\n-   Plant P2: [200, 200, 210, 210, 220, 220]\n\nThe potential distribution centers have associated costs and capacities:\n-   Fixed monthly operating costs if active: DC1: $10,000; DC2: $12,000; DC3: $9,000.\n-   Storage capacities (max units): DC1: 300; DC2: 350; DC3: 280.\n\nTransportation costs per unit of VitaBoost are:\n-   From Plant P1 to DCs: DC1: $5, DC2: $7, DC3: $6.\n-   From Plant P2 to DCs: DC1: $8, DC2: $4, DC3: $7.\n-   From DC1 to Regions: R1: $3, R2: $4, R3: $5, R4: $6.\n-   From DC2 to Regions: R1: $5, R2: $3, R3: $4, R4: $5.\n-   From DC3 to Regions: R1: $4, R2: $5, R3: $3, R4: $4.\n\nOther relevant costs are:\n-   Monthly inventory holding cost per unit at DCs: DC1: $2.0; DC2: $2.5; DC3: $1.8.\n-   Disposal cost for expired product: $1 per unit at any DC.\n-   Shortage cost for unmet demand: $50 per unit, uniform across all regions and months.\n\nThe forecasted monthly demand for VitaBoost (in units) for each region over the 6-month horizon is:\n-   Region R1: [100, 110, 120, 130, 140, 150]\n-   Region R2: [80, 85, 90, 95, 100, 105]\n-   Region R3: [120, 125, 130, 135, 140, 145]\n-   Region R4: [60, 65, 70, 75, 80, 85]\n\nPharmaLogistics Inc. needs to determine an optimal plan that specifies: which DCs to operate in each month, the quantity of VitaBoost to produce at each plant monthly, and the detailed shipping and inventory quantities across the network. This plan must ensure that demand is met as effectively as possible while respecting the product's shelf life and minimizing total costs.",
    "formulation":"Sets:\nT: Set of time periods (months), ( T = {1, 2, 3, 4, 5, 6} ).\nP: Set of manufacturing plants, ( P = {P1, P2} ).\nD: Set of potential distribution centers, ( D = {DC1, DC2, DC3} ).\nR: Set of demand regions, ( R = {R1, R2, R3, R4} ).\nB: Set of batch production months, ( B = {-1, 0, 1, 2, 3, 4, 5, 6} ). Batch -1 is 2 months old at the start of period 1, batch 0 is 1 month old.\n\nParameters:\nDemand_{rt}: Forecasted demand for product in region (r \\in R) in period (t \\in T).\nR1: [100, 110, 120, 130, 140, 150]\nR2: [80, 85, 90, 95, 100, 105]\nR3: [120, 125, 130, 135, 140, 145]\nR4: [60, 65, 70, 75, 80, 85]\n\nProdCap_{pt}: Production capacity of plant (p \\in P) in period (t \\in T).\nP1: [250, 250, 260, 260, 270, 270]\nP2: [200, 200, 210, 210, 220, 220]\n\nFixedDCost_d: Fixed cost to operate DC (d \\in D) per period.\nDC1: $10,000; DC2: $12,000; DC3: $9,000\n\nDCStoreCap_d: Storage capacity of DC (d \\in D).\nDC1: 300; DC2: 350; DC3: 280\n\nTransCostPD_{pd}: Unit transportation cost from plant (p \\in P) to DC (d \\in D).\nP1 to (DC1, DC2, DC3): [$5, $7, $6]\nP2 to (DC1, DC2, DC3): [$8, $4, $7]\n\nTransCostDR_{dr}: Unit transportation cost from DC (d \\in D) to region (r \\in R).\nDC1 to (R1, R2, R3, R4): [$3, $4, $5, $6]\nDC2 to (R1, R2, R3, R4): [$5, $3, $4, $5]\nDC3 to (R1, R2, R3, R4): [$4, $5, $3, $4]\n\nInvHoldCost_d: Unit inventory holding cost at DC (d \\in D) per period.\nDC1: $2.0; DC2: $2.5; DC3: $1.8\n\nDisposalCost_d: Unit cost for disposing an expired product at DC (d \\in D).\nDC1: $1; DC2: $1; DC3: $1\n\nShortageCost_r: Unit shortage cost for region (r \\in R) per period.\nR1, R2, R3, R4: $50\n\nL = 2: Shelf life of the product in months.\nInitialInv_{db}: Initial inventory at DC (d \\in D) from batch (b \\in B) (where (b \\le 0)).\nInitialInv = { (DC1, -1): 5, (DC1, 0): 10 }; all other initial inventories are 0.\n\nBigM_flow: A sufficiently large number, e.g., 2400.\n\nDecision Variables\nY_{dt} \\in \\{0,1\\}: Binary variable, 1 if DC (d \\in D) is open in period (t \\in T); 0 otherwise.\nP_{pt} \\ge 0: Continuous variable, quantity produced at plant (p \\in P) in period (t \\in T).\nQ_{pdt} \\ge 0: Continuous variable, quantity shipped from plant (p \\in P) to DC (d \\in D) in period (t \\in T). This product belongs to batch t.\nS_{bdrt} \\ge 0: Continuous variable, quantity shipped from DC (d \\in D) to region (r \\in R) in period (t \\in T), taken from batch (b \\in B).\nI_{bdt} \\ge 0: Continuous variable, inventory at DC (d \\in D) at the end of period (t \\in T), originating from batch (b \\in B).\nU_{rt} \\ge 0: Continuous variable, unmet demand (shortage) in region (r \\in R) in period (t \\in T).\nW_{bdt} \\ge 0: Continuous variable, quantity of product from batch (b \\in B) that expires (is wasted) at DC (d \\in D) at the end of period (t \\in T).\n\nObjective Function\nMinimize total cost Z:\n( \\min Z = \\sum_{d \\in D} \\sum_{t \\in T} \\text{FixedDCost}d \\cdot Y{dt} ) (Fixed Costs)\n( + \\sum_{p \\in P} \\sum_{d \\in D} \\sum_{t \\in T} \\text{TransCostPD}{pd} \\cdot Q{pdt} ) (Plant-to-DC Transport)\n( + \\sum_{b \\in B} \\sum_{d \\in D} \\sum_{r \\in R} \\sum_{t \\in T} \\text{TransCostDR}{dr} \\cdot S{bdrt} ) (DC-to-Region Transport)\n( + \\sum_{b \\in B} \\sum_{d \\in D} \\sum_{t \\in T} \\text{InvHoldCost}d \\cdot I{bdt} ) (Inventory Holding)\n( + \\sum_{b \\in B} \\sum_{d \\in D} \\sum_{t \\in T} \\text{DisposalCost}d \\cdot W{bdt} ) (Disposal)\n( + \\sum_{r \\in R} \\sum_{t \\in T} \\text{ShortageCost}r \\cdot U{rt} ) (Shortage)\n\nConstraints\nDC Activation & Capacity:\n\nTotal inventory at DC (d) cannot exceed its capacity if open:\n( \\sum_{b \\in B} I_{bdt} \\le \\text{DCStoreCap}d \\cdot Y{dt} ), for all (d \\in D, t \\in T ).\n\nShipments into a DC (d) can only occur if it's open:\n( \\sum_{p \\in P} Q_{pdt} \\le \\text{BigM_flow} \\cdot Y_{dt} ), for all (d \\in D, t \\in T ).\n\nShipments out of a DC (d) can only occur if it's open:\n( \\sum_{b \\in B} \\sum_{r \\in R} S_{bdrt} \\le \\text{BigM_flow} \\cdot Y_{dt} ), for all (d \\in D, t \\in T ).\n\nProduction & Plant Flow:\n\nProduction at plant (p) cannot exceed its capacity:\n( P_{pt} \\le \\text{ProdCap}_{pt} ), for all (p \\in P, t \\in T ).\n\nAll products produced at plant (p) are shipped to DCs:\n( P_{pt} = \\sum_{d \\in D} Q_{pdt} ), for all (p \\in P, t \\in T ).\n\nInventory Balance & Shelf Life: For all DCs (d), periods (t), and batches (b):\n\nInventory Balance:\nLet (I_{bd,t-1}) be the inventory from the previous period (for (t=1), this is InitialInv).\nLet (\\text{Inflow}{bdt}) be the new stock from production (equals (\\sum_p Q{pdt}) if (b=t), else 0).\nLet (\\text{Outflow}{bdt}) be the shipments to customers ((\\sum_r S{bdrt})).\nThen: ( I_{bdt} = I_{bd,t-1} + \\text{Inflow}{bdt} - \\text{Outflow}{bdt} - W_{bdt} )\n\nShelf Life: Product from batch b expires at the end of period b+L-1.\nWaste can only occur at the expiration period: ( W_{bdt} = 0 ), if ( t \\neq b+L-1 ).\nInventory must be zero after expiration: ( I_{bdt} = 0 ), if ( t \\geq b+L-1 ).\n\nDemand Satisfaction: For all regions (r) and periods (t):\n\nTotal quantity shipped to region (r) from all usable batches plus unmet demand equals the demand. A batch b is usable in period t if it's not expired (t < b+L).\n( \\sum_{d \\in D} \\sum_{b \\in B : t < b+L} S_{bdrt} + U_{rt} = \\text{Demand}_{rt} ).\n\nType\nMixed, Linear, Linear\nMILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_pharma_distribution_corrected(\n    T=range(1, 7),\n    P=['P1', 'P2'],\n    D=['DC1', 'DC2', 'DC3'],\n    R=['R1', 'R2', 'R3', 'R4'],\n    B=range(-1, 7),\n    L=2,\n    BigM_flow=2400,\n    Demand={\n        ('R1', 1): 100,\n        ('R1', 2): 110,\n        ('R1', 3): 120,\n        ('R1', 4): 130,\n        ('R1', 5): 140,\n        ('R1', 6): 150,\n        ('R2', 1): 80,\n        ('R2', 2): 85,\n        ('R2', 3): 90,\n        ('R2', 4): 95,\n        ('R2', 5): 100,\n        ('R2', 6): 105,\n        ('R3', 1): 120,\n        ('R3', 2): 125,\n        ('R3', 3): 130,\n        ('R3', 4): 135,\n        ('R3', 5): 140,\n        ('R3', 6): 145,\n        ('R4', 1): 60,\n        ('R4', 2): 65,\n        ('R4', 3): 70,\n        ('R4', 4): 75,\n        ('R4', 5): 80,\n        ('R4', 6): 85\n    },\n    ProdCap={\n        ('P1', 1): 250,\n        ('P1', 2): 250,\n        ('P1', 3): 260,\n        ('P1', 4): 260,\n        ('P1', 5): 270,\n        ('P1', 6): 270,\n        ('P2', 1): 200,\n        ('P2', 2): 200,\n        ('P2', 3): 210,\n        ('P2', 4): 210,\n        ('P2', 5): 220,\n        ('P2', 6): 220\n    },\n    FixedDCost={'DC1': 10000, 'DC2': 12000, 'DC3': 9000},\n    DCStoreCap={'DC1': 300, 'DC2': 350, 'DC3': 280},\n    TransCostPD={\n        ('P1', 'DC1'): 5,\n        ('P1', 'DC2'): 7,\n        ('P1', 'DC3'): 6,\n        ('P2', 'DC1'): 8,\n        ('P2', 'DC2'): 4,\n        ('P2', 'DC3'): 7\n    },\n    TransCostDR={\n        ('DC1', 'R1'): 3,\n        ('DC1', 'R2'): 4,\n        ('DC1', 'R3'): 5,\n        ('DC1', 'R4'): 6,\n        ('DC2', 'R1'): 5,\n        ('DC2', 'R2'): 3,\n        ('DC2', 'R3'): 4,\n        ('DC2', 'R4'): 5,\n        ('DC3', 'R1'): 4,\n        ('DC3', 'R2'): 5,\n        ('DC3', 'R3'): 3,\n        ('DC3', 'R4'): 4\n    },\n    InvHoldCost={'DC1': 2.0, 'DC2': 2.5, 'DC3': 1.8},\n    DisposalCost={'DC1': 1, 'DC2': 1, 'DC3': 1},\n    ShortageCost={'R1': 50, 'R2': 50, 'R3': 50, 'R4': 50},\n    InitialInv={('DC1', -1): 5, ('DC1', 0): 10}\n):\n    \"\"\"\n    Solves a corrected and robust version of the PharmaLogistics distribution network problem,\n    accurately handling inventory flow and shelf life.\n    \"\"\"\n    model = gp.Model(\"PharmaLogistics_Corrected\")\n\n    # ========== Decision Variables ==========\n    Y = model.addVars(D, T, vtype=GRB.BINARY, name=\"Y_dc_open\")\n    P_prod = model.addVars(P, T, lb=0, name=\"P_prod\")\n    Q_ship_pd = model.addVars(P, D, T, lb=0, name=\"Q_ship_plant_dc\")\n    S_ship_dr = model.addVars(B, D, R, T, lb=0, name=\"S_ship_dc_region\")\n    I_inv = model.addVars(B, D, T, lb=0, name=\"I_inventory\")\n    U_unmet = model.addVars(R, T, lb=0, name=\"U_unmet_demand\")\n    W_waste = model.addVars(B, D, T, lb=0, name=\"W_waste\")\n\n    # ========== Objective Function ==========\n    total_fixed_cost = gp.quicksum(FixedDCost[d] * Y[d, t] for d in D\n                                   for t in T)\n    total_transport_pd_cost = gp.quicksum(\n        TransCostPD[p, d] * Q_ship_pd[p, d, t] for p in P for d in D\n        for t in T)\n    total_transport_dr_cost = gp.quicksum(\n        TransCostDR[d, r] * S_ship_dr[b, d, r, t] for b in B for d in D\n        for r in R for t in T)\n    total_inventory_cost = gp.quicksum(InvHoldCost[d] * I_inv[b, d, t]\n                                       for b in B for d in D for t in T)\n    total_disposal_cost = gp.quicksum(DisposalCost[d] * W_waste[b, d, t]\n                                      for b in B for d in D for t in T)\n    total_shortage_cost = gp.quicksum(ShortageCost[r] * U_unmet[r, t]\n                                      for r in R for t in T)\n\n    model.setObjective(\n        total_fixed_cost + total_transport_pd_cost +\n        total_transport_dr_cost + total_inventory_cost +\n        total_disposal_cost + total_shortage_cost, GRB.MINIMIZE)\n\n    # ========== Constraints ==========\n    # DC Activation and Capacity\n    model.addConstrs((gp.quicksum(I_inv[b, d, t]\n                                  for b in B) <= DCStoreCap[d] * Y[d, t]\n                      for d in D for t in T),\n                     name=\"DC_Capacity\")\n    model.addConstrs((gp.quicksum(Q_ship_pd[p, d, t]\n                                  for p in P) <= BigM_flow * Y[d, t]\n                      for d in D for t in T),\n                     name=\"DC_Open_Inbound\")\n    model.addConstrs((gp.quicksum(S_ship_dr[b, d, r, t] for b in B\n                                  for r in R) <= BigM_flow * Y[d, t]\n                      for d in D for t in T),\n                     name=\"DC_Open_Outbound\")\n\n    # Production and Plant Flow\n    model.addConstrs((P_prod[p, t] <= ProdCap[p, t] for p in P for t in T),\n                     name=\"Production_Capacity\")\n    model.addConstrs((P_prod[p, t] == gp.quicksum(Q_ship_pd[p, d, t]\n                                                  for d in D) for p in P\n                      for t in T),\n                     name=\"Plant_Flow\")\n\n    # Inventory Balance and Shelf Life\n    for d in D:\n        for t in T:\n            for b in B:\n                # Previous inventory\n                if t == 1:\n                    prev_inv = InitialInv.get((d, b), 0)\n                else:\n                    prev_inv = I_inv[b, d, t - 1]\n\n                # Inflow from production\n                inflow = gp.quicksum(Q_ship_pd[p, d, t]\n                                     for p in P) if b == t else 0\n\n                # Outflow to customers\n                outflow = gp.quicksum(S_ship_dr[b, d, r, t] for r in R)\n\n                # Inventory Balance Equation\n                model.addConstr(I_inv[b, d, t] == prev_inv + inflow -\n                                outflow - W_waste[b, d, t],\n                                name=f\"Inv_Balance_{b}_{d}_{t}\")\n\n                # --- CORRECTED: Shelf-life constraints ---\n                # Product from batch 'b' expires at the end of period 'b + L - 1'\n                expiration_period = b + L - 1\n\n                # If the current period 't' is after the expiration period, inventory must be zero\n                if t > expiration_period:\n                    model.addConstr(I_inv[b, d, t] == 0,\n                                    f\"Expired_Inv_Zero_{b}_{d}_{t}\")\n\n                # Waste can only occur AT the expiration period.\n                if t == expiration_period:\n                    # Waste is whatever is left from the previous period that isn't shipped out\n                    model.addConstr(W_waste[b, d, t] == prev_inv - outflow,\n                                    f\"Waste_Calc_{b}_{d}_{t}\")\n                else:\n                    model.addConstr(W_waste[b, d, t] == 0,\n                                    f\"No_Waste_{b}_{d}_{t}\")\n\n    # Demand Satisfaction\n    for r in R:\n        for t in T:\n            # Sum of shipments from all DCs and all VALID (non-expired) batches\n            valid_shipments = gp.quicksum(S_ship_dr[b, d, r, t] for d in D\n                                          for b in B if t < b + L)\n            model.addConstr(valid_shipments + U_unmet[r, t] == Demand[r,\n                                                                      t],\n                            name=f\"Demand_{r}_{t}\")\n\n    # ========== Solve ==========\n    model.Params.TimeLimit = 120  # 2-minute time limit for this complex model\n    model.optimize()\n\n    # ========== Return Results ==========\n    if model.Status == GRB.OPTIMAL or model.Status == GRB.TIME_LIMIT:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_pharma_distribution_corrected()\n    print(result)\n",
    "ground_truth":81060.0
  },
  {
    "task_id":"D080",
    "description":"A large manufacturing enterprise needs to ship a consignment of 1,000 tons of goods from its factory in City F to a distribution center in City D. There are three potential transportation routes available. Each route is composed of segments using different modes of transport (road or rail). The transportation cost for each segment is calculated based on a per ton-kilometer rate. Furthermore, certain road segments are subject to a congestion fee to account for the social costs of traffic. This fee is non-linear and is calculated as `Congestion Coefficient * (Total Traffic Flow)^2`. The total traffic flow on a segment is the sum of the cargo shipped by the enterprise and the existing background traffic from other companies.\n\nThe details for the three routes are provided in the table below. For congested segments, the existing background traffic is also listed.\n\n| Route | Segment | Mode | Distance (km) | Base Fee ($\/ton-km) | Congestion Coefficient | Background Traffic (tons) |\n| ----- | ------- | ---- | ------------- | ------------------- | ---------------------- | ------------------------- |\n| 1     | 1A      | Road | 150           | 2.00                | 5×10−7                 | 2,000                     |\n|       | 1B      | Rail | 500           | 0.80                | -                      | -                         |\n| 2     | 2A      | Road | 200           | 2.10                | -                      | -                         |\n|       | 2B      | Road | 350           | 1.90                | 8×10−7                 | 1,500                     |\n| 3     | 3A      | Road | 100           | 2.20                | -                      | -                         |\n|       | 3B      | Rail | 600           | 0.75                | -                      | -                         |\n\nHow should the enterprise allocate the shipment of 1,000 tons of goods across the three routes to minimize the total transportation cost?",
    "formulation":"Set:\n1. Route \nThe set of available transportation routes, \\( R = \\{1, 2, 3\\} \\)\n\nParameter:\n1. TotalTonnage\n# The total amount of goods to be shipped\n100 \n2. LinearCostPerTon \n# The base transportation cost per ton for each route, excluding congestion fees. This is calculated by summing the costs of all segments for a given route (`distance * base_fee`).  \n[700, 1085, 670] # in dollars per ton for Route 1, 2, and 3 respectively.\n3. CongestionCoeff \n# The coefficient for calculating the congestion fee on applicable routes.  \n[5e-7, 8e-7, 0] # Route 3 has no congestion fee.\n4. BackgroundTraffic \n# The existing traffic volume on congested routes.  \n[2000, 1500, 0] # in tons. Route 3 has no congested segment.\n\nDecision variable:\n1. TonnageOnRoute \nContinuous variable, \\( TonnageOnRoute[r] \\forall r \\in R \\), representing the amount of goods in tons transported via route \\( r \\).\n\nObjective:\n1. Minimize the total transportation cost. The objective is to minimize the sum of the linear transportation costs and the non-linear congestion fees for all routes.  \nmin: \\( \\sum_{r \\in R} (LinearCostPerTon[r] \\times TonnageOnRoute[r] + CongestionCoeff[r] \\times (BackgroundTraffic[r] + TonnageOnRoute[r])^2) \\)\n\nConstraint:\n1. Total Shipment Constraint. The sum of goods transported on all routes must equal the total tonnage required to be shipped.  \n\\( \\sum_{r \\in R} TonnageOnRoute[r] = TotalTonnage \\)\n2. Non-negativity constraint. The amount of goods transported on any route cannot be negative.  \n\\( TonnageOnRoute[r] \\geq 0 \\forall r \\in R \\)\n\nType:\nContinuous, Non-linear, Linear  \nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_logistics(\n    routes=[\"Route1\", \"Route2\", \"Route3\"],\n    total_tonnage_to_ship=1000.0,\n    linear_cost_per_ton={\n        \"Route1\": 700,\n        \"Route2\": 1085,\n        \"Route3\": 670\n    },\n    congestion_coeff={\n        \"Route1\": 5e-7,\n        \"Route2\": 8e-7,\n        \"Route3\": 0\n    },\n    background_traffic={\n        \"Route1\": 2000,\n        \"Route2\": 1500,\n        \"Route3\": 0\n    }\n):\n    \"\"\"\n    Solves the transportation logistics problem with congestion pricing.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"LogisticsOptimization\")\n\n    # --- Decision Variables ---\n    # Amount of goods to ship on each route (in tons)\n    tonnage_on_route = model.addVars(routes, name=\"TonnageOnRoute\", lb=0)\n\n    # --- Objective Function: Minimize Total Transportation Cost ---\n    # Linear cost component\n    total_linear_cost = gp.quicksum(\n        linear_cost_per_ton[r] * tonnage_on_route[r] for r in routes\n    )\n\n    # Congestion cost component (this makes the objective quadratic)\n    total_congestion_cost = gp.quicksum(\n        congestion_coeff[r] *\n        (background_traffic[r] + tonnage_on_route[r]) *\n        (background_traffic[r] + tonnage_on_route[r])\n        for r in routes if congestion_coeff[r] > 0\n    )\n\n    # Set the complete objective function\n    model.setObjective(total_linear_cost + total_congestion_cost, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # 1. Total Tonnage Constraint: Must ship the exact total amount of goods\n    model.addConstr(\n        tonnage_on_route.sum('*') == total_tonnage_to_ship,\n        name=\"TotalTonnageRequirement\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_logistics()\n    print(result)",
    "ground_truth":670003.8
  },
  {
    "task_id":"D081",
    "description":"A container shipping company needs to execute a transport contract from Shanghai to Los Angeles, a total sailing distance of 6000 nautical miles. The voyage must be completed within 12 days (288 hours). The company can choose one of three different types of vessels from its fleet to carry out this mission. The fuel consumption rate for each vessel is an approximate quadratic function of its sailing speed v. The price of fuel is ¥4000 per ton. Additionally, due to new environmental regulations, the company must pay for its carbon dioxide emissions at a rate of ¥300 per ton of CO2. Specific information for the three vessels is shown in Table 1, including their fuel consumption formulas, CO2 emission factors, and a fixed cost for selecting each vessel.\n\nTable 1: Vessel Information \n\n| Vessel | Fuel Consumption (tons\/hour) | CO2 Emission Factor (ton CO2\/ton fuel) | Selection Fixed Cost (¥) |\n|------|----------------------------------|------|---------|\n| Ship A | $0.005 \\times v^2 + 0.1v + 1.2$  | 3.2  | 500,000 |\n| Ship B | $0.004 \\times v^2 + 0.08v + 1.5$ | 3.15 | 600,000 |\n| Ship C | $0.006 \\times v^2 + 0.12v + 1.0$ | 3.25 | 450,000 |\n\nThe objective is to select one vessel and determine its optimal sailing speed to minimize the total cost of the voyage.",
    "formulation":"Set:\n1.  Vessel \nThe set of available vessels, \\( S = \\{1, 2, 3\\} \\) # 1: Ship A, 2: Ship B, 3: Ship C\n\nParameter:\n1.  Distance\nThe total sailing distance.  \n    6000 # in nautical miles\n2.  MaxTime\nThe maximum allowed time for the voyage.  \n    288 # in hours\n3.  FuelPrice\nThe cost of fuel.  \n    4000 # in ¥ per ton\n4.  CarbonTax\nThe tax on CO2 emissions.  \n    300 # in ¥ per ton of CO2\n5.  FuelCoeffs\nThe coefficients \\([a, b, c]\\) for the fuel consumption formula \\(a \\times v^2 + b \\times v + c\\).  \n    [[0.005, 0.1, 1.2], [0.004, 0.08, 1.5], [0.006, 0.12, 1.0]]\n6.  CO2Factor\nThe CO2 emission factor for each vessel.  \n    [3.2, 3.15, 3.25] # in tons of CO2 per ton of fuel\n7.  FixedCost\nThe fixed cost for selecting each vessel.  \n    [500000, 600000, 450000] # in ¥\n\nDecision variable:\n1.  SelectVessel\nBinary variable, \\( y[s] \\forall s \\in S \\), which is 1 if vessel \\(s\\) is selected, and 0 otherwise.\n2.  SailingSpeed\nContinuous variable, \\( v \\), representing the sailing speed in knots.\n\nObjective:\n1.  Minimize the total cost.\nThe objective is to minimize the sum of the selected vessel's fixed cost, fuel cost, and carbon cost. The fuel and carbon costs are functions of the sailing speed \\( v \\).  \n    min: \\( \\sum_{s \\in S} y[s] \\times \\bigg( FixedCost[s] + (FuelPrice + CarbonTax \\times CO2Factor[s]) \\times Distance \\times (FuelCoeffs[s][0] \\times v + FuelCoeffs[s][1] + \\frac{FuelCoeffs[s][2]}{v}) \\bigg) \\)\n\nConstraint:\n1. Vessel Selection Constraint\nExactly one vessel must be selected for the mission.  \n    \\( \\sum_{s \\in S} y[s] = 1 \\)\n2. Time Constraint\nThe total voyage time must not exceed the maximum allowed time. This imposes a minimum required speed.  \n    \\( v \\geq \\frac{Distance}{MaxTime} \\)\n3. Variable Type Constraints\n\\( y[s] \\in \\{0, 1\\} \\forall s \\in S \\)  \n    \\( v > 0 \\)\n\nType:\nMixed, Non-linear, Linear  \nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_shipping_minlp_robust(\n    vessels=[\"Ship_A\", \"Ship_B\", \"Ship_C\"],\n    distance=6000.0,\n    max_time=288.0,\n    fuel_price=4000.0,\n    carbon_tax=300.0,\n    max_speed=30.0,\n    fixed_cost={\n        \"Ship_A\": 500000,\n        \"Ship_B\": 600000,\n        \"Ship_C\": 450000\n    },\n    co2_factor={\n        \"Ship_A\": 3.2,\n        \"Ship_B\": 3.15,\n        \"Ship_C\": 3.25\n    },\n    fuel_coeffs={\n        \"Ship_A\": {\"a\": 0.005, \"b\": 0.1, \"c\": 1.2},\n        \"Ship_B\": {\"a\": 0.004, \"b\": 0.08, \"c\": 1.5},\n        \"Ship_C\": {\"a\": 0.006, \"b\": 0.12, \"c\": 1.0}\n    }\n):\n    \"\"\"\n    Solves the vessel selection and speed optimization problem using a robust\n    MIQCP (Mixed-Integer Quadratically Constrained Programming) formulation.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"ShippingOptimization_Robust\")\n\n    # --- Decision Variables ---\n    # 1. Binary variable to select exactly one vessel\n    select_vessel = model.addVars(vessels, vtype=GRB.BINARY, name=\"SelectVessel\")\n\n    # 2. Continuous variable for the speed of EACH vessel\n    speed_per_vessel = model.addVars(vessels, lb=0.0, ub=max_speed, name=\"Speed\")\n\n    # 3. Auxiliary variable z_s = y_s \/ v_s\n    aux_z = model.addVars(vessels, lb=0.0, name=\"Aux_Z\")\n\n    # --- Constraints ---\n    # 1. Vessel Selection Constraint: Exactly one vessel must be chosen\n    model.addConstr(select_vessel.sum('*') == 1, name=\"OneVesselMustBeSelected\")\n\n    # 2. Link speed to vessel selection\n    min_speed = distance \/ max_time\n    for s in vessels:\n        # The speed v_s must be >= min_speed if vessel s is selected (y_s=1)\n        model.addConstr(speed_per_vessel[s] >= min_speed * select_vessel[s], name=f\"MinSpeed_{s}\")\n        # The speed v_s must be <= max_speed if vessel s is selected (y_s=1)\n        model.addConstr(speed_per_vessel[s] <= max_speed * select_vessel[s], name=f\"MaxSpeed_{s}\")\n\n        # 3. Core non-convex quadratic constraint: z_s * v_s = y_s\n        model.addQConstr(aux_z[s] * speed_per_vessel[s] == select_vessel[s], name=f\"AuxConstraint_{s}\")\n\n    # --- Objective Function: Minimize Total Cost ---\n    # Total Fixed Cost\n    total_fixed_cost = select_vessel.prod(fixed_cost)\n\n    # Total Variable Cost (Fuel + Carbon)\n    # The original variable cost per ship was C_var * D * (a*v + b + c\/v)\n    # With our auxiliary variables, this becomes:\n    # C_var * D * (a*v_s + b*y_s + c*z_s)\n    total_variable_cost = gp.quicksum(\n        (fuel_price + carbon_tax * co2_factor[s]) * distance * (\n            fuel_coeffs[s]['a'] * speed_per_vessel[s] +\n            fuel_coeffs[s]['b'] * select_vessel[s] +\n            fuel_coeffs[s]['c'] * aux_z[s]\n        ) for s in vessels\n    )\n\n    model.setObjective(total_fixed_cost + total_variable_cost, GRB.MINIMIZE)\n\n    # --- Gurobi Settings for Non-Convex Problems ---\n    model.Params.NonConvex = 2\n\n    # Optimize the model\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_shipping_minlp_robust()\n    print(result)",
    "ground_truth":7582340.0
  },
  {
    "task_id":"D082",
    "description":"A food delivery platform is facing a shortage of delivery capacity during peak hours. To address this, it plans to adopt a crowdsourcing model by recruiting gig workers (\"crowdsourced riders\") to complete a portion of the orders. The platform has found that the number of crowdsourced riders willing to accept orders is related to the compensation structure, which consists of a base delivery fee and an additional bonus per order. The specific relationship is modeled as:\n\nNumber of available riders = 0.8 * (base delivery fee)² + 17 * (additional bonus)\n\nDuring the peak period, there are 1,500 orders that need to be delivered by crowdsourced riders., and each available crowdsourced rider can complete an average of 12 orders. The platform earns an average revenue of $15 for each completed order. The platform has two key requirements: 1) A minimum of 1,000 orders must be completed; 2) The base delivery fee offered to riders must be at least $3. The platform needs to design an optimal \"base delivery fee + additional bonus\" compensation plan to maximize its profit, while ensuring the minimum order completion target is met.",
    "formulation":"Set:\nThis problem does not involve discrete sets.\n\nParameter:\n1.  TotalOrdersAvailable\n    The total number of orders that need to be delivered by crowdsourced riders during the peak period.\n    1500\n2.  OrdersPerRider\n    The average number of orders a single crowdsourced rider can complete.\n    12\n3.  RevenuePerOrder\n    The average revenue the platform earns for each completed order.\n    15 # in dollars\n4.  MinOrdersRequired\n    The minimum number of orders that must be completed.\n    1000\n5.  MinBaseFee\n    The minimum allowed base delivery fee for riders.\n    3 # in dollars\n6.  RiderModelCoeff_BaseFee\n    The coefficient for the base delivery fee in the rider availability model.\n    0.8\n7.  RiderModelCoeff_Bonus\n    The coefficient for the additional bonus in the rider availability model.\n    17.0\n\nDecision variable:\n1.  BaseFee\n    Continuous variable, \\( b \\), representing the base delivery fee offered per order.\n2.  Bonus\n    Continuous variable, \\( p \\), representing the additional bonus offered per order.\n3.  OrdersCompleted\n    Integer variable, \\( c \\), representing the total number of orders successfully completed.\n\nObjective:\n1.  Maximize the total profit.\n    The objective is to maximize the total revenue from completed orders minus the total compensation paid to riders.\n    max: \\( c \\times \\text{RevenuePerOrder} - c \\times (b + p) \\)\n\nConstraint:\n1.  Rider Capacity Constraint\n    The number of orders completed cannot exceed the total capacity of the available riders. The number of riders is determined by the compensation plan.\n    \\( c \\leq \\text{OrdersPerRider} \\times (\\text{RiderModelCoeff\\_BaseFee} \\times b^2 + \\text{RiderModelCoeff\\_Bonus} \\times p) \\)\n2.  Order Availability Constraint\n    The number of orders completed cannot be more than the total orders available.\n    \\( c \\leq \\text{TotalOrdersAvailable} \\)\n3.  Minimum Completion Constraint\n    The number of completed orders must meet the platform's minimum target.\n    \\( c \\geq \\text{MinOrdersRequired} \\)\n4.  Minimum Fee Constraint\n    The base delivery fee must meet the minimum requirement.\n    \\( b \\geq \\text{MinBaseFee} \\)\n5.  Non-negativity Constraint\n    The additional bonus cannot be negative.\n    \\( p \\geq 0 \\)\n\nType:\nMixed, Non-linear, Non-linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nfrom typing import Dict\n\ndef solve_delivery_optimization(\n    TotalOrdersAvailable: int = 1500,\n    OrdersPerRider: int = 12,\n    RevenuePerOrder: float = 15.0,\n    MinOrdersRequired: int = 1000,\n    MinBaseFee: float = 3.0,\n    RiderModelCoeffs: Dict[str, float] = {'base_fee_sq': 0.8, 'bonus': 17.0}\n):\n    \"\"\"\n    Solves the food delivery platform's compensation optimization problem.\n\n    Args:\n        TotalOrdersAvailable (int): Total orders needing delivery.\n        OrdersPerRider (int): Average orders a rider can complete.\n        RevenuePerOrder (float): Revenue earned per completed order.\n        MinOrdersRequired (int): Minimum number of orders that must be completed.\n        MinBaseFee (float): Minimum allowed base delivery fee.\n        RiderModelCoeffs (Dict[str, float]): Coefficients for the rider availability model.\n    \"\"\"\n    \n    # --- Model Initialization ---\n    model = gp.Model(\"DeliveryPlatformOptimization\")\n\n    # --- Decision Variables ---\n    # base_fee (b): The base delivery fee per order.\n    base_fee = model.addVar(name=\"BaseFee\", vtype=GRB.CONTINUOUS, lb=MinBaseFee)\n    \n    # bonus (p): The additional bonus per order.\n    bonus = model.addVar(name=\"Bonus\", vtype=GRB.CONTINUOUS, lb=0.0)\n    \n    # orders_completed (c): The total number of orders completed.\n    orders_completed = model.addVar(\n        name=\"OrdersCompleted\", \n        vtype=GRB.INTEGER, \n        lb=MinOrdersRequired, \n        ub=TotalOrdersAvailable\n    )\n\n    # --- Objective Function ---\n    # Maximize: Total Revenue - Total Rider Payout\n    # Maximize: c * RevenuePerOrder - c * (base_fee + bonus)\n    total_profit = orders_completed * (RevenuePerOrder - base_fee - bonus)\n    model.setObjective(total_profit, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    # Rider Capacity Constraint:\n    # Completed orders <= Total rider capacity\n    # Rider capacity = (Number of riders) * (Orders per rider)\n    # Number of riders = 0.8 * b^2 + 15 * p\n    num_riders = RiderModelCoeffs['base_fee_sq'] * base_fee * base_fee + RiderModelCoeffs['bonus'] * bonus\n    rider_capacity = num_riders * OrdersPerRider\n    model.addConstr(orders_completed <= rider_capacity, \"RiderCapacity\")\n\n    # --- Solver Configuration ---\n    # This is a non-convex quadratic problem (objective and constraint).\n    # We must set the 'NonConvex' parameter to 2 for Gurobi to solve it.\n    model.setParam('NonConvex', 2)\n\n    # --- Solve the Model ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.Status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    # Call the function with the problem's default parameters.\n    result = solve_delivery_optimization()\n    print(result)\n",
    "ground_truth":7871.5480392157
  },
  {
    "task_id":"D083",
    "description":"You are in charge of Green Freight, a logistics company that owns 5 old diesel trucks and plans to renew part of its fleet with new electric trucks to reduce costs and emissions. The company needs to decide which of the 5 old trucks to retire and may purchase up to 3 new electric trucks, while it must maintain a total fleet capacity of at least 4 trucks. The government imposes a punitive carbon tax on the company's total carbon emissions, which is proportional to the square of the total emissions, with a tax coefficient of 80. The company's goal is to make an optimal vehicle replacement decision to minimize the total operating cost for the coming year, which consists of vehicle costs, operating costs, and the punitive carbon tax. The specific vehicle information and cost data are shown in Table 1.\n\nHow should Green Freight decide which trucks to keep and which to buy to minimize its total annual cost?\n\nTable 1: Vehicle Cost and Emission Data\n| Vehicle Model | Attribute | Annual Operating Cost (¥) | Annual Carbon Emissions (tons) | Annualized Investment\/Depreciation Cost (¥) |\n| :--- | :--- | :--- | :--- | :--- |\n| Old Diesel Truck D1 | - | 80,000 | 15 | - |\n| Old Diesel Truck D2 | - | 85,000 | 16 | - |\n| Old Diesel Truck D3 | - | 78,000 | 14 | - |\n| Old Diesel Truck D4 | - | 92,000 | 18 | - |\n| Old Diesel Truck D5 | - | 88,000 | 17 | - |\n| New Electric Truck | (per vehicle) | 30,000 | 0 | 120,000 |",
    "formulation":"Set:\n1.  OldTrucks\n    The set of old diesel trucks, \\( D = \\{1, 2, 3, 4, 5\\} \\)\n\nParameter:\n1.  AnnualOperatingCostOld\n    [80000, 85000, 78000, 92000, 88000] # Annual operating cost for each old diesel truck in ¥\n2.  AnnualCarbonEmissionsOld\n    [15, 16, 14, 18, 17] # Annual carbon emissions for each old diesel truck in tons\n3.  AnnualOperatingCostNew\n    30000 # Annual operating cost per new electric truck in ¥\n4.  AnnualizedInvestmentNew\n    120000 # Annualized investment cost per new electric truck in ¥\n5.  CarbonTaxCoefficient\n    80 # Coefficient for the carbon tax calculation\n6.  MinFleetSize\n    4 # Minimum number of trucks required in the fleet\n7.  MaxNewTrucks\n    3 # Maximum number of new electric trucks that can be purchased\n\nDecision variable:\n1.  KeepOldTruck\n    Binary variable, \\( KeepOldTruck[d] \\forall d \\in D \\), equals 1 if old truck \\( d \\) is kept, 0 otherwise.\n2.  BuyNewTrucks\n    Integer variable, \\( BuyNewTrucks \\), the number of new electric trucks to purchase.\n\nObjective:\n1.  Minimize the total annual cost.\n    min: \\( \\sum_{d \\in D} (AnnualOperatingCostOld[d] \\cdot KeepOldTruck[d]) + (AnnualOperatingCostNew + AnnualizedInvestmentNew) \\cdot BuyNewTrucks + CarbonTaxCoefficient \\cdot (\\sum_{d \\in D} (AnnualCarbonEmissionsOld[d] \\cdot KeepOldTruck[d]))^2 \\)\n\nConstraint:\n1.  Minimum fleet size constraint.\n    \\( \\sum_{d \\in D} KeepOldTruck[d] + BuyNewTrucks \\geq MinFleetSize \\)\n2.  New truck purchase limit.\n    \\( BuyNewTrucks \\leq MaxNewTrucks \\)\n3.  Variable domain constraints.\n    \\( KeepOldTruck[d] \\in \\{0, 1\\} \\forall d \\in D \\)\n    \\( BuyNewTrucks \\geq 0 \\), and integer\n\nType:\nInteger, Non-linear, Linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_green_freight_minlp(\n    old_trucks=['D1', 'D2', 'D3', 'D4', 'D5'],\n    annual_op_cost_old={\n        'D1': 80000, 'D2': 85000, 'D3': 78000, 'D4': 92000, 'D5': 88000\n    },\n    annual_emissions_old={\n        'D1': 15, 'D2': 16, 'D3': 14, 'D4': 18, 'D5': 17\n    },\n    annual_op_cost_new=30000,\n    annualized_investment_new=120000,\n    carbon_tax_coeff=80,\n    min_fleet_size=4,\n    max_new_trucks=3\n):\n    \"\"\"\n    Solves the Green Freight vehicle replacement problem to minimize total annual cost.\n    This is a Mixed-Integer Non-Linear Programming (MINLP) problem due to the\n    quadratic term in the carbon tax calculation.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"GreenFreight\")\n\n    # --- Decision Variables ---\n    # Binary variable: 1 if an old truck is kept, 0 if retired\n    keep_old_truck = model.addVars(old_trucks, vtype=GRB.BINARY, name=\"KeepOldTruck\")\n\n    # Integer variable: number of new electric trucks to buy\n    buy_new_trucks = model.addVar(vtype=GRB.INTEGER, name=\"BuyNewTrucks\", lb=0)\n\n    # --- Objective Function: Minimize Total Annual Cost ---\n    \n    # 1. Cost of operating the old trucks that are kept\n    cost_kept_trucks = gp.quicksum(annual_op_cost_old[d] * keep_old_truck[d] \n                                   for d in old_trucks)\n\n    # 2. Cost (operating + investment) of new trucks\n    cost_new_trucks = (annual_op_cost_new + annualized_investment_new) * buy_new_trucks\n\n    # 3. Punitive carbon tax (non-linear part)\n    total_emissions = gp.quicksum(annual_emissions_old[d] * keep_old_truck[d] \n                                  for d in old_trucks)\n    carbon_tax = carbon_tax_coeff * total_emissions * total_emissions\n\n    model.setObjective(\n        cost_kept_trucks + cost_new_trucks + carbon_tax,\n        GRB.MINIMIZE\n    )\n\n    # --- Constraints ---\n    \n    # 1. Minimum fleet size constraint\n    model.addConstr(keep_old_truck.sum('*') + buy_new_trucks >= min_fleet_size, \n                    name=\"MinFleetSize\")\n\n    # 2. New truck purchase limit\n    model.addConstr(buy_new_trucks <= max_new_trucks, \n                    name=\"MaxNewTrucks\")\n\n    # The domain of the variables (Binary, Integer, >=0) is already set during their creation.\n\n    # Optimize the model\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_green_freight_minlp()\n    print(result)",
    "ground_truth":525280.0
  },
  {
    "task_id":"D084",
    "description":"You are the manager of a large cross-docking center responsible for assigning docks for the next hour's operations, which involves 4 arriving shipments and 3 departing shipments. The center has 4 inbound docks (I1, I2, I3, I4) and 3 outbound docks (O1, O2, O3), distributed across two different operational zones. The docks in Zone A include I1, I2, and O1, while Zone B includes I3, I4, O2, and O3. The efficiency of forklift operations within a zone decreases with congestion, which is modeled as a cost function that is quadratic in the total number of items passing through that zone. The congestion cost coefficient is 0.00005 for Zone A and 0.00004 for Zone B. Decision-makers need to assign a unique dock to each shipment to minimize the total internal handling cost, which is composed of a base handling cost and a zonal congestion cost. The base handling cost is ¥0.1 per item. The arriving shipments consist of four suppliers: S1 with 200 items, S2 with 150 items, S3 with 180 items, and S4 with 220 items. The departing shipments consist of three retailers: R1 with 250 items, R2 with 300 items, and R3 with 200 items. How should the center assign each shipment to a unique dock to minimize the total internal handling cost?",
    "formulation":"Set:\n1.  InboundShipments\n    The set of arriving shipments, \\( S = \\{1, 2, 3, 4\\} \\)\n2.  OutboundShipments\n    The set of departing shipments, \\( R = \\{1, 2, 3\\} \\)\n3.  InboundDocks\n    The set of inbound docks, \\( I = \\{1, 2, 3, 4\\} \\)\n4.  OutboundDocks\n    The set of outbound docks, \\( O = \\{1, 2, 3\\} \\)\n5.  Zones\n    The set of operational zones, \\( Z = \\{1, 2\\} \\) # 1: Zone A, 2: Zone B\n\nParameter:\n1.  NumItemsInbound\n    [200, 150, 180, 220] # Number of items in each arriving shipment s ∈ S\n2.  NumItemsOutbound\n    [250, 300, 200] # Number of items in each departing shipment r ∈ R\n3.  InboundDockInZone\n    [[1, 1, 0, 0], [0, 0, 1, 1]] # Binary matrix indicating if inbound dock i ∈ I is in zone z ∈ Z\n4.  OutboundDockInZone\n    [[1, 0, 0], [0, 1, 1]] # Binary matrix indicating if outbound dock o ∈ O is in zone z ∈ Z\n5.  CongestionCoefficient\n    [0.00005, 0.00004] # Congestion cost coefficient for each zone z ∈ Z\n6.  BaseHandlingCost\n    0.1 # Base handling cost per item in ¥\n\nDecision variable:\n1.  AssignInbound\n    Binary variable, \\( AssignInbound[s][i] \\forall s \\in S, i \\in I \\), equals 1 if arriving shipment \\(s\\) is assigned to inbound dock \\(i\\), 0 otherwise.\n2.  AssignOutbound\n    Binary variable, \\( AssignOutbound[r][o] \\forall r \\in R, o \\in O \\), equals 1 if departing shipment \\(r\\) is assigned to outbound dock \\(o\\), 0 otherwise.\n\nObjective:\n1.  Minimize the total internal handling cost.\n    min: \\( \\sum_{z \\in Z} CongestionCoefficient[z] \\cdot (\\sum_{s \\in S}\\sum_{i \\in I} AssignInbound[s][i] \\cdot NumItemsInbound[s] \\cdot InboundDockInZone[z][i] + \\sum_{r \\in R}\\sum_{o \\in O} AssignOutbound[r][o] \\cdot NumItemsOutbound[r] \\cdot OutboundDockInZone[z][o])^2 + BaseHandlingCost \\cdot (\\sum_{s \\in S} NumItemsInbound[s] + \\sum_{r \\in R} NumItemsOutbound[r]) \\)\n\nConstraint:\n1.  Each arriving shipment must be assigned to exactly one inbound dock.\n    \\( \\sum_{i \\in I} AssignInbound[s][i] = 1 \\forall s \\in S \\)\n2.  Each inbound dock must be assigned to exactly one arriving shipment.\n    \\( \\sum_{s \\in S} AssignInbound[s][i] = 1 \\forall i \\in I \\)\n3.  Each departing shipment must be assigned to exactly one outbound dock.\n    \\( \\sum_{o \\in O} AssignOutbound[r][o] = 1 \\forall r \\in R \\)\n4.  Each outbound dock must be assigned to exactly one departing shipment.\n    \\( \\sum_{r \\in R} AssignOutbound[r][o] = 1 \\forall o \\in O \\)\n5.  Variable domain constraints.\n    \\( AssignInbound[s][i] \\in \\{0, 1\\} \\forall s \\in S, i \\in I \\)\n    \\( AssignOutbound[r][o] \\in \\{0, 1\\} \\forall r \\in R, o \\in O \\)\n\nType:\nInteger, Non-linear, Linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_cross_docking_qap(\n    inbound_shipments=['S1', 'S2', 'S3', 'S4'],\n    outbound_shipments=['R1', 'R2', 'R3'],\n    inbound_docks=['I1', 'I2', 'I3', 'I4'],\n    outbound_docks=['O1', 'O2', 'O3'],\n    zones=['A', 'B'],\n    shipment_items={\n        'S1': 200, 'S2': 150, 'S3': 180, 'S4': 220,\n        'R1': 250, 'R2': 300, 'R3': 200\n    },\n    dock_zones={\n        'I1': 'A', 'I2': 'A', 'O1': 'A',\n        'I3': 'B', 'I4': 'B', 'O2': 'B', 'O3': 'B'\n    },\n    congestion_coeffs={'A': 0.00005, 'B': 0.00004},\n    base_handling_cost_per_item=0.1\n):\n    \"\"\"\n    Solves the Cross-Docking Center dock assignment problem to minimize\n    the total internal handling cost. This is a Quadratic Assignment Problem (QAP)\n    due to the non-linear congestion cost function.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"CrossDockingCenter\")\n\n    # --- Decision Variables ---\n    # Binary variable: 1 if an inbound shipment is assigned to an inbound dock\n    assign_inbound = model.addVars(inbound_shipments, inbound_docks, vtype=GRB.BINARY, name=\"AssignInbound\")\n    \n    # Binary variable: 1 if an outbound shipment is assigned to an outbound dock\n    assign_outbound = model.addVars(outbound_shipments, outbound_docks, vtype=GRB.BINARY, name=\"AssignOutbound\")\n\n    # --- Constraints (Assignment Logic) ---\n    # 1. Each inbound shipment must be assigned to exactly one inbound dock.\n    model.addConstrs((assign_inbound.sum(s, '*') == 1 for s in inbound_shipments), name=\"AssignEachInboundShipment\")\n    \n    # 2. Each inbound dock can only be assigned to one inbound shipment.\n    model.addConstrs((assign_inbound.sum('*', i) == 1 for i in inbound_docks), name=\"AssignEachInboundDock\")\n\n    # 3. Each outbound shipment must be assigned to exactly one outbound dock.\n    model.addConstrs((assign_outbound.sum(r, '*') == 1 for r in outbound_shipments), name=\"AssignEachOutboundShipment\")\n\n    # 4. Each outbound dock can only be assigned to one outbound shipment.\n    model.addConstrs((assign_outbound.sum('*', o) == 1 for o in outbound_docks), name=\"AssignEachOutboundDock\")\n    \n    # --- Objective Function: Minimize Total Cost ---\n    \n    # 1. Calculate total items flowing through each zone based on assignments\n    items_in_zone = {}\n    for z in zones:\n        inbound_items_in_zone = gp.quicksum(\n            assign_inbound[s, i] * shipment_items[s] \n            for s, i in assign_inbound if dock_zones[i] == z\n        )\n        outbound_items_in_zone = gp.quicksum(\n            assign_outbound[r, o] * shipment_items[r] \n            for r, o in assign_outbound if dock_zones[o] == z\n        )\n        items_in_zone[z] = inbound_items_in_zone + outbound_items_in_zone\n\n    # 2. Calculate the non-linear congestion cost\n    congestion_cost = gp.quicksum(\n        congestion_coeffs[z] * items_in_zone[z] * items_in_zone[z] for z in zones\n    )\n    \n    # 3. Calculate the fixed base handling cost\n    total_items = sum(shipment_items.values())\n    base_cost = base_handling_cost_per_item * total_items\n    \n    model.setObjective(congestion_cost + base_cost, GRB.MINIMIZE)\n\n    # Optimize the model\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_cross_docking_qap()\n    print(result)",
    "ground_truth":200.001
  },
  {
    "task_id":"D085",
    "description":"You are in charge of a national health agency planning to establish 2 regional emergency blood centers in a province by selecting from 4 candidate cities. These centers will serve the province's 3 main hospitals. The success probability of blood transportation is known to decrease with the square of the distance, following the formula: p = 1 - 0.00005 * (distance)², where p is the success probability. Regulations require that for each hospital, the joint supply failure probability (i.e., the probability that all designated service channels fail) must be less than 10%. The agency's objective is to select the two locations that minimize the total construction cost while satisfying this reliability constraint. The costs for candidate locations, hospital locations, and distance data are shown in Table 1.\n\nHow should the agency select the two locations for the centers to minimize the total construction cost, subject to the reliability requirement?\n\nTable 1: Blood Center Location Data\n| Candidate City | Construction Cost (¥M) | Distance to H1 (km) | Distance to H2 (km) | Distance to H3 (km) |\n|:---:|:---:|:---:|:---:|:---:|\n| C1 | 8 | 50 | 80 | 120 |\n| C2 | 7 | 60 | 40 | 90 |\n| C3 | 9 | 110 | 70 | 50 |\n| C4 | 7.5 | 130 | 100 | 60 |",
    "formulation":"Set:\n1.  CandidateCities\n    The set of candidate cities, \\( C = \\{1, 2, 3, 4\\} \\)\n2.  Hospitals\n    The set of hospitals to be served, \\( H = \\{1, 2, 3\\} \\)\n\nParameter:\n1.  ConstructionCost\n    [8, 7, 9, 7.5] # Construction cost for each city c ∈ C in ¥M\n2.  Distances\n    [[50, 80, 120], [60, 40, 90], [110, 70, 50], [130, 100, 60]] # Distance from city c ∈ C to hospital h ∈ H in km\n3.  NumToSelect\n    2 # The number of centers to be established\n4.  MaxJointFailureProb\n    0.1 # The maximum allowed joint supply failure probability for each hospital\n5.  ProbCoeff\n    0.00005 # Coefficient for the transportation failure probability calculation\n\nDecision variable:\n1.  SelectCity\n    Binary variable, \\( SelectCity[c] \\forall c \\in C \\), equals 1 if a center is built in city \\(c\\), 0 otherwise.\n\nObjective:\n1.  Minimize the total construction cost.\n    min: \\( \\sum_{c \\in C} ConstructionCost[c] \\cdot SelectCity[c] \\)\n\nConstraint:\n1.  Total number of centers constraint.\n    \\( \\sum_{c \\in C} SelectCity[c] = NumToSelect \\)\n2.  Reliability constraint for each hospital.\n    \\( \\prod_{c \\in C} (1 - (1 - ProbCoeff \\cdot Distances[c][h]^2) \\cdot SelectCity[c]) < MaxJointFailureProb \\forall h \\in H \\)\n3.  Variable domain constraints.\n    \\( SelectCity[c] \\in \\{0, 1\\} \\forall c \\in C \\)\n\nType:\nInteger, Linear, Non-linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_blood_center_location(\n    candidate_cities=[1, 2, 3, 4],\n    hospitals=[1, 2, 3],\n    construction_cost={1: 8, 2: 7, 3: 9, 4: 7.5},\n    distances_matrix=[[50, 80, 120], [60, 40, 90], [110, 70, 50], [130, 100, 60]],\n    num_to_select=2,\n    max_joint_failure_prob=0.1,\n    prob_coeff=0.00005\n):\n    \"\"\"\n    Solve the blood center location problem using Gurobi.\n    The model aims to minimize construction cost while satisfying the number of centers and supply reliability constraints.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"BloodCenterLocation\")\n\n    # Convert distance data to a dictionary for easy access\n    distances = {(c, h): distances_matrix[c-1][h-1]\n                 for c in candidate_cities for h in hospitals}\n\n    # --- Decision Variables ---\n    # 1 if a center is built in city c, 0 otherwise\n    select_city = model.addVars(candidate_cities, vtype=GRB.BINARY, name=\"SelectCity\")\n    \n    # Auxiliary variable for joint failure probability for each hospital\n    joint_failure_prob = model.addVars(hospitals, vtype=GRB.CONTINUOUS, \n                                       lb=0, ub=1, name=\"JointFailureProb\")\n\n    # --- Objective Function: Minimize Total Construction Cost ---\n    total_construction_cost = gp.quicksum(construction_cost[c] * select_city[c]\n                                          for c in candidate_cities)\n    model.setObjective(total_construction_cost, GRB.MINIMIZE)\n\n    # --- Constraints ---\n\n    # 1. The total number of centers built must equal the specified number\n    model.addConstr(select_city.sum('*') == num_to_select, name=\"TotalCentersConstraint\")\n\n    # 2. Supply reliability constraint for each hospital (nonlinear constraint)\n    for h in hospitals:\n        # Expression for joint failure probability\n        joint_failure_prob_expr = 1\n        for c in candidate_cities:\n            fail_prob_ch = prob_coeff * (distances[c, h] ** 2)\n            term = (1 - select_city[c]) + select_city[c] * fail_prob_ch\n            joint_failure_prob_expr *= term\n        \n        # Use equality constraint to define auxiliary variable\n        model.addConstr(joint_failure_prob[h] == joint_failure_prob_expr,\n                        name=f\"JointFailureProb_Hospital_{h}\")\n        \n        # Add linear constraint for reliability requirement\n        model.addConstr(joint_failure_prob[h] <= max_joint_failure_prob,\n                        name=f\"Reliability_Hospital_{h}\")\n\n    # --- Solve ---\n    # Gurobi needs to know the model is non-convex\n    model.params.NonConvex = 2\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_blood_center_location()\n    print(result)",
    "ground_truth":17.0
  },
  {
    "task_id":"D086",
    "description":"You are in charge of a taxi company, managing its fleet during the evening peak hours. The company needs to dispatch its idle taxis from 3 areas to 3 passenger demand hotspots. To improve profitability, in addition to setting a dynamic surcharge for each hotspot to incentivize drivers, the company has also established a fixed base fare of ¥15 for every successful dispatch. The supply of drivers willing to go to a certain hotspot is proportional to the square of the surcharge, with a coefficient of 0.5. The company's objective is to set the surcharges and plan the vehicle dispatch to maximize total profit. Total profit is calculated as (total base fare revenue + total surcharge revenue - total deadheading costs). Through operational optimization, the company has reduced its deadheading costs by 20%. The number of available taxis in each area, the passenger demand at each hotspot, and the adjusted deadheading costs from each area to each hotspot are shown in the table below.\n\nTable 1: Adjusted Taxi Dispatch Data \n\n| Attribute | H1 | H2 | H3 | Available Taxis |\n|:---:|:---:|:---:|:---:|:---:|\n| Demand | 30  | 50  | 40  | - |\n| Deadheading Cost from A1 | 16 | 28 | 24 | 25  |\n| Deadheading Cost from A2 | 20 | 12 | 32 | 40  |\n| Deadheading Cost from A3 | 24 | 20 | 16 | 35  |\n\nHow can the taxi company set its dynamic surcharges and dispatch plan to maximize its total profit while satisfying all supply and demand constraints?",
    "formulation":"Set:\n1.  Area\n    [cite_start]The set of areas with available taxis, \\( A = \\{1, 2, 3\\} \\) # 1: A1, 2: A2, 3: A3 [cite: 12]\n2.  Hotspot\n    [cite_start]The set of passenger demand hotspots, \\( H = \\{1, 2, 3\\} \\) # 1: H1, 2: H2, 3: H3 [cite: 12]\n\nParameter:\n1.  AvailableTaxis\n   [25, 40, 35] # number of available taxis in each area \n2.  Demand\n    [30, 50, 40] # number of passengers demanding taxis at each hotspot \n3.  DeadheadingCost\n    [16, 28, 24], [20, 12, 32], [24, 20, 16] # cost to dispatch a taxi from an area to a hotspot\n    # The deadheading costs data in the table is already adjusted to reflect a 20% reduction.\n4.  SurchargeCoefficient\n    0.5 # coefficient relating driver supply to the square of the surcharge \n5.  BaseFare \n    15.0 # fixed base fare for each successful dispatch\n\nDecision variable:\n1.  DispatchAmount\nInteger variable, \\( DispatchAmount[a][h] \\forall a \\in A, h \\in H \\), the number of taxis dispatched from area \\( a \\) to hotspot \\( h \\).\n2.  Surcharge\nContinuous variable, \\( Surcharge[h] \\forall h \\in H \\), the dynamic surcharge set for hotspot \\( h \\). \n\nObjective:\n1.  Maximize the total profit. \n    max: \\( \\sum_{h \\in H} ((BaseFare + Surcharge[h]) * \\sum_{a \\in A} DispatchAmount[a][h]) - \\sum_{a \\in A} \\sum_{h \\in H} (DeadheadingCost[a][h] * DispatchAmount[a][h]) \\)\n\nConstraint:\n1.  Area supply constraint.\n \\sum_{h \\in H} DispatchAmount[a][h] \\leq AvailableTaxis[a] \\forall a \\in A \\\n2.  Hotspot demand constraint.\n\\sum_{a \\in A} DispatchAmount[a][h] \\leq Demand[h] \\forall h \\in H \\\n3.  Surcharge-supply relationship constraint.\n \\sum_{a \\in A} DispatchAmount[a][h] = SurchargeCoefficient * Surcharge[h]^2 \\forall h \\in H \\\n4.  Non-negativity constraint.\n   DispatchAmount[a][h] \\geq 0 \\forall a \\in A, h \\in H \\\n   Surcharge[h] \\geq 0 \\forall h \\in H \\\n\nType:\nMixed, Non-linear, Non-linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\ndef solve_profitable_taxi_dispatch(\n    areas=[\"A1\", \"A2\", \"A3\"],\n    hotspots=[\"H1\", \"H2\", \"H3\"],\n    demand={\"H1\": 30, \"H2\": 50, \"H3\": 40},\n    available_taxis={\"A1\": 25, \"A2\": 40, \"A3\": 35},\n    base_fare=15.0,\n    deadheading_costs_data={\n        (\"A1\", \"H1\"): 16, (\"A1\", \"H2\"): 28, (\"A1\", \"H3\"): 24,\n        (\"A2\", \"H1\"): 20, (\"A2\", \"H2\"): 12, (\"A2\", \"H3\"): 32,\n        (\"A3\", \"H1\"): 24, (\"A3\", \"H2\"): 20, (\"A3\", \"H3\"): 16,\n    }\n):\n    \"\"\"\n    Solves the adjusted (profitable) taxi dispatch optimization problem using Gurobi.\n    This model includes a base fare and reduced deadheading costs.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"ProfitableTaxiDispatch\")\n\n    deadheading_costs = gp.tupledict(deadheading_costs_data)\n\n    # --- Decision Variables ---\n    # dispatch_plan[i, j]: Number of taxis dispatched from area i to hotspot j\n    dispatch_plan = model.addVars(areas, hotspots, vtype=GRB.INTEGER, name=\"DispatchPlan\", lb=0)\n\n    # supply[j]: Total number of taxis arriving at hotspot j\n    supply = model.addVars(hotspots, name=\"Supply\", lb=0)\n    \n    # revenue_calc_surcharge[j]: Auxiliary variable for the non-linear surcharge revenue term, representing supply[j]^1.5\n    revenue_calc_surcharge = model.addVars(hotspots, name=\"SurchargeRevenueCalc\", lb=0)\n\n    # --- Objective Function: Maximize Total Profit ---\n    total_base_fare_revenue = base_fare * gp.quicksum(supply[j] for j in hotspots)\n    \n    total_surcharge_revenue = math.sqrt(2) * gp.quicksum(revenue_calc_surcharge[j] for j in hotspots)\n\n    total_revenue = total_base_fare_revenue + total_surcharge_revenue\n\n    total_deadheading_cost = dispatch_plan.prod(deadheading_costs)\n\n    model.setObjective(total_revenue - total_deadheading_cost, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    # 1. Supply definition constraint\n    for j in hotspots:\n        model.addConstr(supply[j] == gp.quicksum(dispatch_plan[i, j] for i in areas),\n                        name=f\"SupplyDef_{j}\")\n\n    # 2. Surcharge revenue calculation (non-linear power constraint)\n    for j in hotspots:\n        model.addGenConstrPow(supply[j], revenue_calc_surcharge[j], 1.5, name=f\"RevenuePow_{j}\")\n\n    # 3. Hotspot demand constraint\n    for j in hotspots:\n        model.addConstr(supply[j] <= demand[j], name=f\"Demand_{j}\")\n\n    # 4. Area availability constraint\n    for i in areas:\n        model.addConstr(dispatch_plan.sum(i, '*') <= available_taxis[i], name=f\"Availability_{i}\")\n    \n    # Optimize the model\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_profitable_taxi_dispatch()\n    print(result)",
    "ground_truth":887.3785809835
  },
  {
    "task_id":"D087",
    "description":"An urban shared e-bike company, \"E-Donkey Express,\" needs to create a nightly battery-swapping plan for its fleet, which is distributed across three zones using its two mobile maintenance vans. The company's objective is to minimize the total nightly cost, which consists of a fixed dispatch fee for each van used and a variable operational cost. This operational cost is uniquely challenging, as it is proportional to the square of the number of batteries replaced by a van in a given zone (Cost = Coefficient × N²), reflecting a diseconomy of scale due to on-site logistical complexities.\nThe plan must ensure that all e-bikes with low-power batteries are serviced, while also respecting the maximum number of new batteries each van can carry. The core decision is how to assign the battery-swapping workload—which zones each van should service, and how many batteries to replace in each—to meet all demands at the lowest possible total cost. All necessary operational data is provided below.\n\nTable 1: Zonal Demand Data\n\n| Zone | Total E-Bikes | Low Battery Percentage (%) |\n|:----:|:--------------:|:--------------------------:|\n|   A  |      200       |             60             |\n|   B  |      150       |             80             |\n|   C  |      180       |             50             |\n\nTable 2: Maintenance Station Parameters\n\n| Parameter                    | Van 1 | Van 2 |\n|:-----------------------------|:-----:|:-----:|\n| Dispatch Cost ($)            |  300  |  320  |\n| Max Battery Capacity (units) |  150  |  180  |\n| Operational Cost Coefficient | 0.08  | 0.07  |",
    "formulation":"Set\n1.  Station\n    The set of maintenance stations, \\( I = \\{1, 2\\} \\) # 1: Van 1, 2: Van 2\n2.  Zone\n    The set of zones, \\( J = \\{1, 2, 3\\} \\) # 1: Zone A, 2: Zone B, 3: Zone C\n\nParameter\n1.  DispatchCost\n    [300, 320] # Fixed cost for using van 1 and 2\n2.  VanCapacity\n    [150, 180] # Max battery capacity for van 1 and 2\n3.  OperationalCostCoefficient\n    [0.08, 0.07] # Operational cost coefficient for van 1 and 2\n4.  BatteryDemand\n    [120, 120, 90] # Number of batteries needed in Zone A, B, and C\n\nDecision variable\n1.  BatteriesReplaced\n    Integer variable, \\( x_{ij} \\), \\( \\forall i \\in I, j \\in J \\), the number of batteries replaced by station \\(i\\) in zone \\(j\\).\n2.  StationUsed\n    Binary variable, \\( y_i \\), \\( \\forall i \\in I \\), 1 if station \\(i\\) is used, 0 otherwise.\n\nObjective\n1.  Minimize the total operational cost.\n    min: \\( \\sum_{i \\in I} (\\text{DispatchCost}[i] \\cdot y_i) + \\sum_{i \\in I} \\sum_{j \\in J} (\\text{OperationalCostCoefficient}[i] \\cdot x_{ij}^2) \\)\n\nConstraint\n1.  Demand Fulfillment constraint.\n    \\( \\sum_{i \\in I} x_{ij} = \\text{BatteryDemand}[j], \\forall j \\in J \\)\n2.  Van Capacity constraint.\n    \\( \\sum_{j \\in J} x_{ij} \\le \\text{VanCapacity}[i] \\cdot y_i, \\forall i \\in I \\)\n3.  Non-negativity constraint.\n    \\( x_{ij} \\ge 0, \\forall i \\in I, j \\in J \\)\n\nType\nMixed, Non-linear, Linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_ebike_battery_swapping(\n    stations=[\"Van1\", \"Van2\"],\n    zones=[\"ZoneA\", \"ZoneB\", \"ZoneC\"],\n    dispatch_cost={\"Van1\": 300, \"Van2\": 320},\n    van_capacity={\"Van1\": 150, \"Van2\": 180},\n    op_cost_coeff={\"Van1\": 0.08, \"Van2\": 0.07},\n    battery_demand={\"ZoneA\": 120, \"ZoneB\": 120, \"ZoneC\": 90}\n):\n    \"\"\"\n    Solves the E-Donkey Express battery swapping optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"EbikeBatterySwapping\")\n\n    # --- Decision Variables ---\n    # Number of batteries replaced by station i in zone j\n    batteries_replaced = model.addVars(stations,\n                                       zones,\n                                       vtype=GRB.INTEGER,\n                                       name=\"BatteriesReplaced\",\n                                       lb=0)\n\n    # Whether station i is used (dispatched)\n    station_used = model.addVars(stations, vtype=GRB.BINARY, name=\"StationUsed\")\n\n    # --- Objective Function: Minimize Total Nightly Cost ---\n    total_dispatch_cost = gp.quicksum(dispatch_cost[i] * station_used[i]\n                                      for i in stations)\n\n    # The operational cost is a quadratic term (cost = k * x^2)\n    # Gurobi can handle quadratic objectives directly.\n    total_operational_cost = gp.quicksum(\n        op_cost_coeff[i] * batteries_replaced[i, j] * batteries_replaced[i, j]\n        for i in stations for j in zones)\n\n    model.setObjective(total_dispatch_cost + total_operational_cost,\n                       GRB.MINIMIZE)\n\n    # --- Constraints ---\n\n    # 1. Demand Fulfillment constraint: All low-power batteries in each zone must be replaced.\n    for j in zones:\n        model.addConstr(\n            gp.quicksum(batteries_replaced[i, j] for i in stations) ==\n            battery_demand[j],\n            name=f\"DemandFulfillment_{j}\")\n\n    # 2. Van Capacity constraint: The number of batteries handled by a van cannot exceed its capacity.\n    #    This constraint also links the station_used variable to the number of batteries replaced.\n    #    If a van is not used (y_i=0), it cannot replace any batteries.\n    for i in stations:\n        model.addConstr(\n            gp.quicksum(batteries_replaced[i, j] for j in zones) <=\n            van_capacity[i] * station_used[i],\n            name=f\"Capacity_{i}\")\n\n    # Optimize the model\n    # This is a Mixed-Integer Quadratically Constrained Program (MIQP).\n    # The objective function is convex, so Gurobi will find the global optimum.\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_ebike_battery_swapping()\n    print(result)",
    "ground_truth":1998.5
  },
  {
    "task_id":"D088",
    "description":"A courier company needs to plan an optimal single-delivery route for one of its couriers. The route starts at a central depot, serves 10 customers, and then returns to the depot. The courier's travel speed is constant at 30 km\/h, and the travel cost is ¥5 per kilometer.\nEach customer has a desired \"service time window.\" If the courier's actual arrival time deviates from the center of the customer's desired time window, the company incurs a \"customer satisfaction penalty\" cost. This cost is proportional to the square of the time deviation, calculated by the formula: $Cost = 0.2 \\times (\\text{Actual Arrival Time} - \\text{Time Window Center})^2$.\nThe company's objective is to determine a unique customer visit sequence and calculate a precise arrival time for each customer to minimize the cost. The courier departs at 8:30 AM from the depot, located at coordinates (0,0). All relevant data are listed in the table below.\n\nTable 1: Customer Data and Service Requirements\n\n| Location ID | Location Type | Position (x, y) km | Service Time (minutes) | Desired Service Window |\n|:---:|:---:|:---:|:---:|:---:|\n| 1 | Customer | (3, 5) | 5 | 9:30 - 10:00 |\n| 2 | Customer | (5, 8) | 8 | 10:00 - 10:20 |\n| 3 | Customer | (2, 1) | 5 | 9:00 - 9:20 |\n| 4 | Customer | (8, 6) | 10 | 10:30 - 11:00 |\n| 5 | Customer | (4, 2) | 6 | 9:45 - 10:15 |\n| 6 | Customer | (9, 8) | 7 | 11:15 - 11:40 |\n| 7 | Customer | (1, 9) | 9 | 10:10 - 10:40 |\n| 8 | Customer | (1, 3) | 5 | 9:15 - 9:40 |\n| 9 | Customer | (6, 4) | 12 | 10:20 - 10:50 |\n| 10 | Customer | (7, 1) | 6 | 11:00 - 11:20 |",
    "formulation":"Set:\n1. Locations\nThe set of all locations, \\( N = \\{0, 1, 2, 3, 4, 5\\} \\), where 0 is the depot and {1, 2, 3, 4, 5} is the set of customers C.\n2. Arcs\nThe set of possible travel arcs between locations, \\( A = \\{(i, j) | i, j \\in N, i \\neq j\\} \\).\n\nParameter:\n1. Position\n# The (x, y) coordinates for each location in kilometers.\n{0: (0,0), 1: (3,5), 2: (5,8), 3: (2,1), 4: (8,6), 5: (4,2), 6: (9,8), 7: (1,9), 8: (1,3), 9: (6,4), 10: (7,1)}\n2. Distance\n# The Euclidean distance between location i and j, calculated from Position. Distance_ij = sqrt((x_i - x_j)^2 + (y_i - y_j)^2).\nDistance_ij,  ∀ (i, j) ∈ A\n3. TravelTime\n# The time in minutes to travel from location i to j. TravelTime_ij = (Distance_ij \/ 30 km\/h) * 60 min\/h.\nTravelTime_ij, ∀ (i, j) ∈ A\n4. ServiceTime\n# The service time required at each customer location in minutes.\n{1: 5, 2: 8, 3: 5, 4: 10, 5: 6, 6: 7, 7: 9, 8: 5, 9: 12, 10: 6}\n5. TimeWindowCenter\n# The center of the desired service time window for each customer, in minutes from midnight. (e.g., 9:30 = 570)\n{1: 585, 2: 610, 3: 550, 4: 645, 5: 600, 6: 687.5, 7: 625, 8: 567.5, 9: 635, 10: 660}\n6. DepartureTime\n# The departure time from the depot (location 0) in minutes from midnight.\n510 # (8:30 AM)\n7. TravelCostRate\n# The cost per kilometer of travel.\n5 # in currency units\n8. PenaltyCoefficient\n# The coefficient for calculating the customer satisfaction penalty.\n0.2\n\nDecision variable:\n1. Path\nBinary variable, \\( x_{ij} \\), \\( \\forall (i, j) \\in A \\). \\( x_{ij} = 1 \\) if the courier travels directly from location i to location j, and 0 otherwise.\n2. ArrivalTime\nContinuous variable, \\( t_i \\), \\( \\forall i \\in N \\). The time at which the courier arrives at location i, in minutes from midnight.\n3. Sequence\nInteger variable, \\( u_i \\), \\( \\forall i \\in C \\). An auxiliary variable to eliminate sub-tours, representing the position of customer i in the sequence.\n\nObjective:\n1. Minimize the sum of total travel cost and total satisfaction penalty cost.\nmin: \\( \\sum_{i \\in N} \\sum_{j \\in N, i \\neq j} \\text{TravelCostRate} \\cdot \\text{Distance}_{ij} \\cdot x_{ij} + \\sum_{i \\in C} \\text{PenaltyCoefficient} \\cdot (t_i - \\text{TimeWindowCenter}_i)^2 \\)\n\nConstraint:\n1. The courier must leave from the depot to exactly one customer.\n\\( \\sum_{j \\in C} x_{0j} = 1 \\)\n2. The courier must arrive at the depot from exactly one customer.\n\\( \\sum_{i \\in C} x_{i0} = 1 \\)\n3. Each customer is visited exactly once.\n\\( \\sum_{j \\in N, j \\neq i} x_{ji} = 1, \\forall i \\in C \\)\n\\( \\sum_{j \\in N, j \\neq i} x_{ij} = 1, \\forall i \\in C \\)\n4. Time flow constraint. If the courier travels from i to j, the arrival time at j must be at least the arrival time at i plus service time at i and travel time from i to j. (M is a large number).\n\\( t_j \\geq t_i + \\text{ServiceTime}_i + \\text{TravelTime}_{ij} - M \\cdot (1 - x_{ij}), \\forall i \\in C, j \\in C, i \\neq j \\)\n5. Time flow constraint for travel from the depot.\n\\( t_j \\geq t_0 + \\text{TravelTime}_{0j} - M \\cdot (1 - x_{0j}), \\forall j \\in C \\)\n6. The arrival time at the depot is the departure time.\n\\( t_0 = \\text{DepartureTime} \\)\n7. Sub-tour elimination constraint (MTZ formulation).\n\\( u_i - u_j + |C| \\cdot x_{ij} \\leq |C| - 1, \\forall i, j \\in C, i \\neq j \\)\n8. Sequence variable bounds.\n\\( 1 \\leq u_i \\leq |C|, \\forall i \\in C \\)\n\nType:\nMixed-Integer, Non-linear, Linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nfrom typing import List, Dict, Tuple\nimport math\n\ndef solve_courier_routing(\n    Customers: List[int] = [i for i in range(1, 11)],\n    Depot: int = 0,\n    Positions: Dict[int, Tuple[float, float]] = {\n        0: (0, 0), 1: (3, 5), 2: (5, 8), 3: (2, 1), 4: (8, 6), 5: (4, 2), 6: (9, 8), 7: (1, 9), 8: (1, 3), 9: (6, 4), 10: (7, 1)\n    },\n    ServiceTime: Dict[int, int] = {1: 5, 2: 8, 3: 5, 4: 10, 5: 6, 6: 7, 7: 9, 8: 5, 9: 12, 10: 6, 0: 0},\n    TimeWindows: Dict[int, Tuple[str, str]] = {\n        1: (\"9:30\", \"10:00\"), 2: (\"10:00\", \"10:20\"), 3: (\"9:00\", \"9:20\"),\n        4: (\"10:30\", \"11:00\"), 5: (\"9:45\", \"10:15\"), 6: (\"11:15\", \"11:40\"),\n        7: (\"10:10\", \"10:40\"), 8: (\"9:15\", \"9:40\"), 9: (\"10:20\", \"10:50\"),\n        10: (\"11:00\", \"11:20\")\n    },\n    DepartureTimeStr: str = \"8:30\",\n    TravelSpeed_kmh: float = 30.0,\n    TravelCostRate_per_km: float = 5.0,\n    PenaltyCoefficient: float = 0.2\n):\n    \"\"\"\n    Solves the courier routing problem with soft time windows and a quadratic penalty function.\n    This version includes corrections for sub-tour elimination.\n    \"\"\"\n    # --- Data Pre-processing ---\n    Locations = [Depot] + Customers\n    \n    def time_to_minutes(t_str: str) -> int:\n        h, m = map(int, t_str.split(':'))\n        return h * 60 + m\n\n    DepartureTime = time_to_minutes(DepartureTimeStr)\n    TimeWindowCenter = {\n        c: (time_to_minutes(tw[0]) + time_to_minutes(tw[1])) \/ 2\n        for c, tw in TimeWindows.items()\n    }\n\n    def euclidean_distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    Distances = {\n        (i, j): euclidean_distance(Positions[i], Positions[j])\n        for i in Locations for j in Locations if i != j\n    }\n    \n    TravelTimes = {\n        (i, j): (Distances[i, j] \/ TravelSpeed_kmh) * 60\n        for i, j in Distances\n    }\n    \n    # A large number for Big-M constraints\n    M = 24 * 60 # Max minutes in a day\n\n    # --- Model Initialization ---\n    model = gp.Model(\"CourierRoutingWithTimeWindows\")\n\n    # --- Decision Variables ---\n    x = model.addVars(Locations, Locations, name=\"Path\", vtype=GRB.BINARY)\n    t = model.addVars(Locations, name=\"ArrivalTime\", vtype=GRB.CONTINUOUS, lb=0)\n    u = model.addVars(Locations, name=\"Sequence\", vtype=GRB.CONTINUOUS, lb=0)\n\n    # --- Objective Function ---\n    travel_cost = gp.quicksum(TravelCostRate_per_km * Distances[i, j] * x[i, j] \n                              for i in Locations for j in Locations if i != j)\n    \n    penalty_cost = gp.quicksum(PenaltyCoefficient * (t[i] - TimeWindowCenter[i]) * (t[i] - TimeWindowCenter[i])\n                               for i in Customers)\n\n    model.setObjective(travel_cost + penalty_cost, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    model.addConstrs((x[i, i] == 0 for i in Locations), \"NoSelfLoops\")\n    model.addConstr(gp.quicksum(x[Depot, j] for j in Customers) == 1, \"LeaveDepot\")\n    model.addConstr(gp.quicksum(x[i, Depot] for i in Customers) == 1, \"ReturnToDepot\")\n    model.addConstrs((gp.quicksum(x[i, j] for i in Locations if i != j) == 1 for j in Customers), \"EnterCustomerOnce\")\n    model.addConstrs((gp.quicksum(x[j, i] for i in Locations if i != j) == 1 for j in Customers), \"LeaveCustomerOnce\")\n    model.addConstr(t[Depot] == DepartureTime, \"SetDepartureTime\")\n\n    # Constraint 5: Time flow constraints \n    for i in Locations:\n        for j in Customers:\n            if i == j:\n                continue\n            model.addConstr(t[j] >= t[i] + ServiceTime[i] + TravelTimes[i, j] - M * (1 - x[i, j]), f\"TimeFlow_{i}_{j}\")\n    \n    # Constraint 6: Sub-tour elimination (MTZ)\n    model.addConstr(u[Depot] == 0, \"MTZ_Depot_Start\")\n    M_u = len(Customers) + 1 # A sufficiently large number for the u sequence\n\n    for i in Locations:\n        for j in Customers:\n            if i == j:\n                continue\n            # If courier travels from i to j, then u[j] must be at least u[i] + 1\n            model.addConstr(u[j] >= u[i] + 1 - M_u * (1 - x[i, j]), f\"MTZ_Flow_{i}_{j}\")\n    \n    # Add bounds on u for customers to strengthen the formulation\n    model.addConstrs((u[i] >= 1 for i in Customers), \"MTZ_Lower_Bound\")\n    model.addConstrs((u[i] <= len(Customers) for i in Customers), \"MTZ_Upper_Bound\")\n    \n    # --- Solve the Model ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.Status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_courier_routing()\n    print(result)\n",
    "ground_truth":480.5757733434
  },
  {
    "task_id":"D089",
    "description":"A shared mobility company plans to deploy a fleet of 1,000 electric scooters across five key hotspot zones in a city. To ensure service stability and a positive user experience, the company aims to achieve a balanced deployment that aligns with the demand profile of each zone.\n\nThe company's goal is to minimize the network's imbalance. This imbalance is defined as the sum of the squared differences between the number of scooters deployed in each zone and an ideal, attractiveness-weighted deployment. The ideal deployment for a zone is calculated by distributing the total fleet proportionally to that zone's share of the total attractiveness.\n\nWhen planning the deployment, the following conditions must be met:\n1. The total number of scooters deployed across all zones must equal 1,000.\n2. To align operational capacity with potential demand, the number of scooters in each zone must not be less than a minimum quota. This quota is set at 10% of the total fleet size, weighted by the proportion of that zone's attractiveness relative to the total attractiveness of all zones.\n3. The 'Commercial Center' and 'Transit Hub' zones are geographically adjacent and frequently interact with each other. To ensure service continuity, the absolute difference in the number of scooters deployed in these two zones must not exceed 50.\n4. The company has divided the zones into two operational clusters: Cluster 1 (Commercial Center, Tourist Area) and Cluster 2 (University City, Tech Park, Transit Hub). Each cluster can deploy a maximum of 600 scooters to match the management capacity of local operational teams.\n\nThe attractiveness data for each zone is provided in the table below. Please devise a deployment plan that minimizes the network imbalance while satisfying all constraints.\n\nTable: Zonal Attractiveness Data\n\n| Hotspot Zone | Attractiveness (Predicted Daily Trips) |\n|:---|:---|\n| Commercial Center | 500 |\n| University City | 800 |\n| Tech Park | 700 |\n| Tourist Area | 600 |\n| Transit Hub | 900 |",
    "formulation":"Set:\n1. Zones\nThe set of hotspot zones, \\( I = \\{\\text{Commercial Center, University City, Tech Park, Tourist Area, Transit Hub}\\} \\).\n\nParameters:\n1.  TotalScooters\n    The total number of scooters to be deployed.\n    1000\n2.  Attractiveness\n    A dictionary mapping each zone \\(i \\in I\\) to its attractiveness value.\n     \\(\\{\\text{Commercial Center: 500, University City: 800, Tech Park: 700, Tourist Area: 600, Transit Hub: 900}\\}\\)\n3.  TotalAttractiveness\n    The sum of all attractiveness values.\n    \\(500 + 800 + 700 + 600 + 900 = 3500\\)\n4.  MinQuotaFactor\n    The minimum allocation factor based on total fleet size.\n    0.1\n5.  TargetDeployment\n    The ideal, attractiveness-weighted deployment for each zone \\(i \\in I\\).\n    \\(\\text{TargetDeployment}_i = \\text{TotalScooters} \\times \\frac{\\text{Attractiveness}_i}{\\text{TotalAttractiveness}}\\)\n\nDecision Variable:\n1.  Deployment\n    Integer variable, \\(n_i \\ge 0\\) for each zone \\(i \\in I\\), representing the number of scooters to be deployed in that zone.\n\nObjective:\n1.  Minimize the network imbalance, defined as the sum of squared deviations from the target deployment.\n    min: \\(\\sum_{i \\in I} (n_i - \\text{TargetDeployment}_i)^2\\)\n\nConstraints:\n1.  Total Deployment Constraint\n    The sum of scooters deployed in all zones must equal the total number of available scooters.\n    \\(\\sum_{i \\in I} n_i = \\text{TotalScooters}\\)\n2.  Minimum Quota Constraint\n    The number of scooters in each zone must be greater than or equal to a minimum quota, which is weighted by the zone's relative attractiveness.\n    \\(n_i \\ge \\text{TotalScooters} \\times \\text{MinQuotaFactor} \\times \\frac{\\text{Attractiveness}_i}{\\text{TotalAttractiveness}} \\quad \\forall i \\in I\\)\n3.  Adjacency Constraint (New)\n    The absolute difference in deployment between 'Commercial Center' and 'Transit Hub' must not exceed 50.\n    \\(|n_{\\text{Commercial Center}} - n_{\\text{Transit Hub}}| \\le 50\\)\n4.  Operational Cluster Capacity Constraint (New)\n    The total number of scooters in each operational cluster cannot exceed its capacity of 600.\n    \\(n_{\\text{Commercial Center}} + n_{\\text{Tourist Area}} \\le 600\\)\n    \\(n_{\\text{University City}} + n_{\\text{Tech Park}} + n_{\\text{Transit Hub}} \\le 600\\)\n\nType:\nInteger, Non-linear, Linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nfrom typing import List, Dict\n\ndef solve_scooter_deployment(\n    zones: List[str] = ['Commercial Center', 'University City', 'Tech Park', 'Tourist Area', 'Transit Hub'],\n    attractiveness: Dict[str, int] = {\n        'Commercial Center': 500,\n        'University City': 800,\n        'Tech Park': 700,\n        'Tourist Area': 600,\n        'Transit Hub': 900\n    },\n    total_scooters: int = 1000,\n    min_quota_factor: float = 0.1,\n    adjacency_limit: int = 50,\n    cluster_capacity: int = 600\n):\n    \"\"\"\n    Solves the shared e-scooter network balancing problem using Gurobi.\n\n    Args:\n        zones (List[str]): A list of hotspot zone names.\n        attractiveness (Dict[str, int]): A dictionary mapping each zone to its attractiveness value.\n        total_scooters (int): The total number of scooters to be deployed.\n        min_quota_factor (float): The factor of the total fleet size used for calculating the minimum deployment quota.\n        adjacency_limit (int): The maximum allowed difference in deployment for adjacent key zones.\n        cluster_capacity (int): The maximum number of scooters an operational cluster can manage.\n    \"\"\"\n    # --- 1. Setup and Pre-calculation ---\n    num_zones = len(zones)\n    if num_zones == 0:\n        return {\"status\": \"error\", \"message\": \"The list of zones cannot be empty.\"}\n\n    total_attractiveness = sum(attractiveness.values())\n\n    # --- 2. Gurobi Model Initialization ---\n    model = gp.Model(\"ScooterDeployment_Complex\")\n\n    # --- 3. Define Decision Variables ---\n    # n[i]: number of scooters deployed in zone i\n    n = model.addVars(zones, name=\"deployment\", vtype=GRB.INTEGER, lb=0)\n\n    # --- 4. Set Objective Function ---\n    # Objective: Minimize the deviation from an ideal, attractiveness-weighted deployment.\n    target_deployments = {}\n    if total_attractiveness > 0:\n        for i in zones:\n            target_deployments[i] = total_scooters * (attractiveness[i] \/ total_attractiveness)\n    else: # Handle case of zero total attractiveness\n        avg_deployment = total_scooters \/ num_zones\n        for i in zones:\n            target_deployments[i] = avg_deployment\n\n    # The objective is the sum of squared differences from this new weighted target.\n    imbalance = gp.quicksum((n[i] - target_deployments[i]) * (n[i] - target_deployments[i]) for i in zones)\n    model.setObjective(imbalance, GRB.MINIMIZE)\n\n    # --- 5. Add Constraints ---\n    # Constraint 1: Total Deployment Constraint\n    model.addConstr(gp.quicksum(n[i] for i in zones) == total_scooters, \"TotalDeployment\")\n\n    # Constraint 2: Minimum Quota Constraint\n    if total_attractiveness > 0:\n        for i in zones:\n            min_quota = total_scooters * min_quota_factor * (attractiveness[i] \/ total_attractiveness)\n            model.addConstr(n[i] >= min_quota, f\"MinQuota_{i}\")\n\n    # Constraint 3: Adjacency Constraint\n    # The absolute difference between 'Commercial Center' and 'Transit Hub' must not exceed the limit.\n    model.addConstr(n['Commercial Center'] - n['Transit Hub'] <= adjacency_limit, \"Adjacency_Upper\")\n    model.addConstr(n['Commercial Center'] - n['Transit Hub'] >= -adjacency_limit, \"Adjacency_Lower\")\n\n    # Constraint 4: Operational Cluster Capacity Constraints\n    # Cluster 1: Commercial Center, Tourist Area\n    model.addConstr(n['Commercial Center'] + n['Tourist Area'] <= cluster_capacity, \"Cluster1_Capacity\")\n    # Cluster 2: University City, Tech Park, Transit Hub\n    model.addConstr(n['University City'] + n['Tech Park'] + n['Transit Hub'] <= cluster_capacity, \"Cluster2_Capacity\")\n    \n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.Status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_scooter_deployment()\n    print(result)\n",
    "ground_truth":6122.9795918367
  },
  {
    "task_id":"D090",
    "description":"A community food bank plans to dispatch a refrigerated truck on a Friday afternoon to visit 4 partner supermarkets and collect same-day leftover fresh food donations. The truck has a maximum refrigerated capacity of 2 cubic meters and a payload limit of 500 kilograms. The truck will depart from the food bank at 13:00 and must return by 17:00, for a total operating time of 4 hours. The food bank's geographic coordinates are (0, 0), and the units for all location coordinates are kilometers (km). The truck's travel speed is a constant 40 km\/h, and the distance between two points is calculated using straight-line Euclidean distance. Additionally, each stop at a supermarket for loading operations requires a fixed 20 minutes. The objective of the task is to plan an optimal route, deciding which supermarkets to visit and which items to collect, in order to maximize the total sum of priority weights of the collected donations. The detailed locations of each supermarket and the information on available donations are shown in the table below:\n\n| Stop | Location Coordinates (km) | Donation Item | Volume (m³) | Weight (kg) | Priority Weight |\n|:---:|:---:|:---|:---:|:---:|:---:|\n| Supermarket S1 | (5, 10) | Milk | 0.8 | 150 | 80 |\n| Supermarket S1 | (5, 10) | Cheese | 0.3 | 50 | 65 |\n| Supermarket S2 |(15, 5) | Bread | 1.0 | 100 | 50 |\n| Supermarket S2 |(15, 5) | Vegetables | 0.5 | 80 | 40 |\n| Supermarket S3 |(20, 15) | Frozen Meat | 0.6 | 200 | 100 |\n| Supermarket S3 |(20, 15) | Pasta | 0.4 | 60 | 45 |\n| Supermarket S4 |(25, 20) | Fruit | 0.7 | 120 | 60 |\n| Supermarket S4 |(25, 20) |Yogurt | 0.4 | 100 | 70 |\n| Supermarket S4 |(25, 20) | Berries | 0.2 | 30 | 55 |\n| Supermarket S5 |(30, 25) | Eggs | 0.3 | 40 | 75 |\n| Supermarket S5 |(30, 25) | Butter | 0.2 | 50 | 50 |\n| Supermarket S6 |(35, 30) | Sausages | 0.5 | 110 | 90 |\n| Supermarket S6 |(35, 30) | Fish Fillets | 0.4 | 90 | 95 |\n| Supermarket S7 |(40, 35) | Juice | 0.6 | 120 | 30 |\n| Supermarket S7 |(40, 35) | Canned Soup | 0.8 | 150 | 25 |\n| Supermarket S8 |(45, 40) | Salad Mix | 0.9 | 70 | 35 |",
    "formulation":"Sets:\n1. Nodes\n    The set of all locations, \\( N = \\{0, 1, 2, 3, 4\\} \\), where node 0 is the Food Bank (Depot) and nodes \\( S = \\{1, 2, 3, 4\\} \\) represent the supermarkets.\n2. Items\n    The set of all available donation items, \\( I = \\{\\text{Milk, Bread, Vegetables, Meat, Fruit, Yogurt}\\} \\).\n\nParameters:\n1. Item Priority \\(p_i\\)\n    The priority weight for each item \\(i \\in I\\).\n2. Item Volume \\(v_i\\)\n    The volume (m³) for each item \\(i \\in I\\).\n3. Item Weight \\(w_i\\)\n    The weight (kg) for each item \\(i \\in I\\).\n4. Item Location \\(L_i\\)\n    A mapping indicating which supermarket node \\(j \\in S\\) an item \\(i \\in I\\) belongs to.\n5. Node Coordinates \\((cx_j, cy_j)\\)\n    The coordinates (km) for each node \\(j \\in N\\).\n6. Travel Time \\(t_{jk}\\)\n    The pre-calculated travel time (in minutes) between node \\(j\\) and node \\(k\\).\n    \\(t_{jk} = \\frac{\\sqrt{(cx_j - cx_k)^2 + (cy_j - cy_k)^2}}{\\text{Speed}} \\times 60\\)\n7. Truck Volume Capacity \\(V_{max}\\)\n    The maximum volume capacity of the truck (2 m³).\n8. Truck Weight Capacity \\(W_{max}\\)\n    The maximum weight capacity of the truck (500 kg).\n9. Total Time Available \\(T_{max}\\)\n    The maximum operational time available (4 hours = 240 minutes).\n10. Loading Time \\(T_{load}\\)\n    The fixed time required for loading at each supermarket stop (20 minutes).\n\nDecision Variables\n1. Collect Item \\(c_i\\)\n    Binary variable, \\(c_i \\in \\{0, 1\\}\\) for each item \\(i \\in I\\). \\(c_i = 1\\) if item \\(i\\) is collected, 0 otherwise.\n2. Visit Supermarket \\(y_j\\)\n    Binary variable, \\(y_j \\in \\{0, 1\\}\\) for each supermarket \\(j \\in S\\). \\(y_j = 1\\) if supermarket \\(j\\) is visited, 0 otherwise.\n3. Travel Arc \\(z_{jk}\\)\n    Binary variable, \\(z_{jk} \\in \\{0, 1\\}\\) for each pair of nodes \\(j, k \\in N\\). \\(z_{jk} = 1\\) if the truck travels directly from node \\(j\\) to node \\(k\\), 0 otherwise.\n\nObjective:\n1. Maximize Total Priority\n    Maximize the sum of the priority weights of all collected items.\n    \\(\\text{max:} \\sum_{i \\in I} p_i \\cdot c_i\\)\n\nConstraints:\n1. Volume Capacity Constraint\n    The total volume of collected items must not exceed the truck's volume capacity.\n    \\(\\sum_{i \\in I} v_i \\cdot c_i \\le V_{max}\\)\n2. Weight Capacity Constraint\n    The total weight of collected items must not exceed the truck's weight capacity.\n    \\(\\sum_{i \\in I} w_i \\cdot c_i \\le W_{max}\\)\n3. Time Constraint\n    The total travel time plus total loading time must not exceed the available operational time.\n    \\(\\sum_{j \\in N} \\sum_{k \\in N, j \\ne k} t_{jk} \\cdot z_{jk} + \\sum_{j \\in S} T_{load} \\cdot y_j \\le T_{max}\\)\n4. Item Collection Logic\n    An item can only be collected if its corresponding supermarket is visited.\n    \\(c_i \\le y_{L_i} \\quad \\forall i \\in I\\)\n5. Routing Flow Conservation\n    The truck must leave each supermarket it visits exactly once.\n    \\(\\sum_{k \\in N, k \\ne j} z_{jk} = y_j \\quad \\forall j \\in S\\)\n    The truck must arrive at each supermarket it visits exactly once.\n    \\(\\sum_{j \\in N, j \\ne k} z_{jk} = y_k \\quad \\forall k \\in S\\)\n6. Depot Departure and Return\n    The truck must leave the depot once and return to the depot once.\n    \\(\\sum_{k \\in S} z_{0k} = 1\\)\n    \\(\\sum_{j \\in S} z_{j0} = 1\\)\n7. Subtour Elimination\n    Constraints to prevent disconnected loops (e.g., using the MTZ formulation, which requires additional variables \\(u_j\\) for tour position). A simplified representation is to state the requirement: Ensure a single continuous tour starting and ending at the depot.\n\nType:\n# Pre-calculating travel time linearizes the nonlinear components, but the problem itself is inherently nonlinear.\nInteger, Linear, Non-linear\nNLP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nfrom typing import List, Dict, Tuple\nimport math\n\ndef solve_food_bank_routing(\n    supermarkets: Dict[str, Tuple[int, int]] = {\n        'S1': (5, 10),\n        'S2': (12, 8),\n        'S3': (-10, 5),\n        'S4': (0, -15),\n        'S5': (-15, -10),\n        'S6': (15, -5),\n        'S7': (8, 18),\n        'S8': (-5, -20)\n    },\n    items: Dict[str, Dict] = {\n        # S1 Items\n        'Milk':       {'supermarket': 'S1', 'volume': 0.8, 'weight': 150, 'priority': 80},\n        'Cheese':     {'supermarket': 'S1', 'volume': 0.3, 'weight': 50,  'priority': 65},\n        # S2 Items\n        'Bread':      {'supermarket': 'S2', 'volume': 1.0, 'weight': 100, 'priority': 50},\n        'Vegetables': {'supermarket': 'S2', 'volume': 0.5, 'weight': 80,  'priority': 40},\n        # S3 Items\n        'Frozen Meat':{'supermarket': 'S3', 'volume': 0.6, 'weight': 200, 'priority': 100},\n        'Pasta':      {'supermarket': 'S3', 'volume': 0.4, 'weight': 60,  'priority': 45},\n        # S4 Items\n        'Fruit':      {'supermarket': 'S4', 'volume': 0.7, 'weight': 120, 'priority': 60},\n        'Yogurt':     {'supermarket': 'S4', 'volume': 0.4, 'weight': 100, 'priority': 70},\n        'Berries':    {'supermarket': 'S4', 'volume': 0.2, 'weight': 30,  'priority': 55},\n        # S5 Items\n        'Eggs':       {'supermarket': 'S5', 'volume': 0.3, 'weight': 40,  'priority': 75},\n        'Butter':     {'supermarket': 'S5', 'volume': 0.2, 'weight': 50,  'priority': 50},\n        # S6 Items\n        'Sausages':   {'supermarket': 'S6', 'volume': 0.5, 'weight': 110, 'priority': 90},\n        'Fish Fillets':{'supermarket': 'S6', 'volume': 0.4, 'weight': 90, 'priority': 95},\n        # S7 Items\n        'Juice':      {'supermarket': 'S7', 'volume': 0.6, 'weight': 120, 'priority': 30},\n        'Canned Soup':{'supermarket': 'S7', 'volume': 0.8, 'weight': 150, 'priority': 25},\n        # S8 Items\n        'Salad Mix':  {'supermarket': 'S8', 'volume': 0.9, 'weight': 70,  'priority': 35},\n    },\n    depot_coords: Tuple[int, int] = (0, 0),\n    truck_volume_capacity: float = 2.0,\n    truck_weight_capacity: float = 500.0,\n    max_time_mins: int = 240,\n    truck_speed_kmh: int = 40,\n    loading_time_mins: int = 20,\n    M: int = 10000 # A large number for MTZ constraints\n):\n    \"\"\"\n    Solves the Food Bank Vehicle Routing Problem with Profits using Gurobi.\n\n    Args:\n        supermarkets (Dict[str, Tuple[int, int]]): A dictionary mapping supermarket IDs to their (x, y) coordinates.\n        items (Dict[str, Dict]): A dictionary mapping item names to their properties.\n        depot_coords (Tuple[int, int]): The (x, y) coordinates of the food bank depot.\n        truck_volume_capacity (float): The maximum volume capacity of the truck (m³).\n        truck_weight_capacity (float): The maximum weight capacity of the truck (kg).\n        max_time_mins (int): The total available time for the route in minutes.\n        truck_speed_kmh (int): The constant speed of the truck in km\/h.\n        loading_time_mins (int): The fixed time spent loading at each visited supermarket.\n        M (int): A sufficiently large number for Big-M method constraints.\n    \"\"\"\n\n    # --- 1. Data Pre-processing ---\n    depot_id = 'Depot'\n    supermarket_ids = list(supermarkets.keys())\n    nodes = [depot_id] + supermarket_ids\n    node_coords = {depot_id: depot_coords, **supermarkets}\n    num_nodes = len(nodes)\n    item_ids = list(items.keys())\n\n    # Pre-calculate travel times between all nodes\n    def euclidean_distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    travel_times = {}\n    for j in nodes:\n        for k in nodes:\n            if j == k:\n                continue\n            dist = euclidean_distance(node_coords[j], node_coords[k])\n            time_mins = (dist \/ truck_speed_kmh) * 60\n            travel_times[j, k] = time_mins\n\n    # --- 2. Gurobi Model Initialization ---\n    model = gp.Model(\"FoodBankRouting\")\n\n    # --- 3. Define Decision Variables ---\n    # c[i]: 1 if item i is collected, 0 otherwise\n    c = model.addVars(item_ids, name=\"Collect\", vtype=GRB.BINARY)\n    # y[j]: 1 if supermarket j is visited, 0 otherwise\n    y = model.addVars(supermarket_ids, name=\"Visit\", vtype=GRB.BINARY)\n    # z[j,k]: 1 if truck travels from node j to node k, 0 otherwise\n    z = model.addVars(nodes, nodes, name=\"Arc\", vtype=GRB.BINARY)\n    # u[j]: Auxiliary variable for MTZ subtour elimination\n    u = model.addVars(nodes, name=\"MTZ_u\", vtype=GRB.CONTINUOUS)\n\n    # --- 4. Set Objective Function ---\n    total_priority = gp.quicksum(items[i]['priority'] * c[i] for i in item_ids)\n    model.setObjective(total_priority, GRB.MAXIMIZE)\n\n    # --- 5. Add Constraints ---\n    # Constraint 1: Volume Capacity\n    model.addConstr(gp.quicksum(items[i]['volume'] * c[i] for i in item_ids) <= truck_volume_capacity, \"VolumeCapacity\")\n\n    # Constraint 2: Weight Capacity\n    model.addConstr(gp.quicksum(items[i]['weight'] * c[i] for i in item_ids) <= truck_weight_capacity, \"WeightCapacity\")\n\n    # Constraint 3: Time Constraint\n    total_travel_time = gp.quicksum(travel_times[j, k] * z[j, k] for j in nodes for k in nodes if j != k)\n    total_loading_time = gp.quicksum(loading_time_mins * y[j] for j in supermarket_ids)\n    model.addConstr(total_travel_time + total_loading_time <= max_time_mins, \"TimeLimit\")\n\n    # Constraint 4: Item Collection Logic\n    for i in item_ids:\n        supermarket_of_item = items[i]['supermarket']\n        model.addConstr(c[i] <= y[supermarket_of_item], f\"CollectLogic_{i}\")\n\n    # Constraint 5: Routing Flow Conservation\n    for j in supermarket_ids:\n        # If a supermarket is visited, truck must enter and leave it exactly once\n        model.addConstr(gp.quicksum(z[k, j] for k in nodes if k != j) == y[j], f\"Flow_In_{j}\")\n        model.addConstr(gp.quicksum(z[j, k] for k in nodes if k != j) == y[j], f\"Flow_Out_{j}\")\n\n    # Constraint 6: Depot Departure and Return\n    model.addConstr(gp.quicksum(z[depot_id, k] for k in supermarket_ids) == 1, \"Depot_Leave\")\n    model.addConstr(gp.quicksum(z[j, depot_id] for j in supermarket_ids) == 1, \"Depot_Return\")\n    \n    # Disallow travel from a node to itself\n    for j in nodes:\n        model.addConstr(z[j,j] == 0, f\"No_Self_Loop_{j}\")\n\n    # Constraint 7: Subtour Elimination (MTZ formulation)\n    for j in supermarket_ids:\n        model.addConstr(u[j] >= 2, f\"MTZ_Lower_{j}\")\n        model.addConstr(u[j] <= num_nodes, f\"MTZ_Upper_{j}\")\n\n    for j in supermarket_ids:\n        for k in supermarket_ids:\n            if j != k:\n                model.addConstr(u[j] - u[k] + num_nodes * z[j, k] <= num_nodes - 1, f\"MTZ_Main_{j}_{k}\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.Status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_food_bank_routing()\n    print(result)\n",
    "ground_truth":440.0
  },
  {
    "task_id":"D091",
    "description":"A container terminal needs to allocate berths for a fleet of 10 cargo ships within the next 72 hours. The terminal has 3 available berths (B1, B2, B3). Due to interdependencies where some ships carry import\/export goods required by other ships, there are collaborative operation requirements between them. Specifically, ship C can only start loading after ship A completes unloading; ship E can only start loading after ship D completes unloading. To incentivize efficient collaboration, a **¥50,000 \"rapid transshipment\" bonus** can be earned if the start time of a dependent task (e.g., C starting to load) immediately follows the completion time of its predecessor task (e.g., A completing unloading) with a time gap of 2 hours or less. Ship information and operational requirements are shown in Table 1. The objective is to assign each ship a unique berth and a conflict-free berthing time window to maximize the total rapid transshipment bonus while minimizing the ships' waiting time costs in the port** (¥2,000 per hour).\n\nTable 1: Ship Information and Operational Requirements\n\n| Ship ID | Operation Type | Dependencies | Estimated Arrival Time (hours) | Required Berth Operation Time (hours) |\n|:---|:---|:---|:---:|:---:|\n| A | Unloading | - | 2 | 8 |\n| B | Loading\/Unloading | - | 5 | 10 |\n| C | Loading | A | 10 | 6 |\n| D | Unloading | - | 12 | 9 |\n| E | Loading | D | 18 | 7 |\n| F | Loading | - | 20 | 11 |\n| G | Loading | B | 25 | 8 |\n| H | Unloading | - | 30 | 12 |\n| I | Loading | H | 35 | 5 |\n| J | Unloading | G | 40 | 9 |",
    "formulation":"Set:\n1. Ships\nThe set of ships, \\( S = \\{A, B, C, D, E, F, G, H, I, J\\} \\)\n2. Berths\nThe set of berths, \\( B = \\{B1, B2, B3\\} \\)\n3. Dependencies\nThe set of dependencies, \\( D = \\{(A, C), (D, E), (B, G), (H, I), (G, J)\\} \\)  # where each tuple represents a dependency where the first ship must complete its operation before the second ship can start its operation.\n\nParameter:\n1. ArrivalTime\n# The estimated arrival time of each ship\n[2, 5, 10, 12, 18, 20, 25, 30, 35, 40] # in hours\n2. OperationTime\n# The required operation time for each ship at the berth\n[8, 10, 6, 9, 7, 11, 8, 12, 5, 9] # in hours\n3. RapidTransshipmentBonus\n# The bonus for rapid transshipment\n50000 # in currency units\n4. MaxTransshipmentGap\n# The maximum time gap for rapid transshipment to qualify for the bonus\n2 # in hours\n5. WaitingCost\n# The cost of waiting per hour\n2000 # in currency units\n6. MaxTime\n# The maximum time for the scheduling horizon\n72 # in hours\n\nDecision variable:\n1. StartTime\nContinuous variable, \\(StartTime_i \\forall i \\in Ships\\), where \\( StartTime_i \\) is the start time of ship \\( i \\) at its assigned berth.\n2. Assignment\nBinary variable, \\(Assignment_{ib} \\forall i \\in Ships, b \\in Berths\\), where \\(Assignment_{ib} = 1\\) if vessel \\(i\\) is assigned to berth \\(b\\), and 0 otherwise.\n3. Precedence\nBinary variable, \\(Precedence_{ij} \\forall i, j \\in Ships, i \\neq j\\), where \\(Precedence_{ij} = 1\\) if vessels \\(i\\) and \\(j\\) are assigned to the same berth and \\(i\\) is serviced before \\(j\\), and 0 otherwise.\n4. DependencySatisfaction\nBinary variable, \\(DependencySatisfaction_{p} \\forall p \\in Dependencies\\), where \\(DependencySatisfaction_p = 1\\) if the dependency \\(p\\) is satisfied (i.e., the dependent ship starts its operation within the allowed time gap after the predecessor ship completes its operation), and 0 otherwise.\n\nObjective:\n1. Maximize the total rapid transshipment bonus and minimize the total waiting cost.\nmax: \\sum_{p \\in Dependencies} RapidTransshipmentBonus * DependencySatisfaction_p - \\sum_{i \\in Ships} WaitingCost * (StartTime_i - ArrivalTime_i)\n\nConstraint:\n1. Each ship must be assigned to exactly one berth.\n\\sum_{b \\in Berths} Assignment_{ib} = 1 \\forall i \\in Ships\n2. The start time of each ship must be after its arrival time.\nStartTime_i \\geq ArrivalTime_i \\forall i \\in Ships\n3. The start time of each ship plus its operation time must not exceed the maximum time.\nStartTime_i + OperationTime_i \\leq MaxTime \\forall i \\in Ships\n4. The precedence relation must be respected.\nStartTime_j \\geq StartTime_i + OperationTime_i \\forall (i, j) \\in Dependencies\n5. The berth assignment must be non-overlapping for ships assigned to the same berth.\nStartTime_i + OperationTime_i \\leq StartTime_j + M * (1 - Precedence_{ij}) + M * (2 - Assignment_{ib} - Assignment_{jb}) \\forall i, j \\in Ships, i \\neq j, b \\in Berths\nStartTime_j + OperationTime_j \\leq StartTime_i + M * Precedence_{ij} + M * (2 - Assignment_{ib} - Assignment_{jb}) \\forall i, j \\in Ships, i \\neq j, b \\in Berths\n6. The bonus logic constraint.\nStartTime_j - (StartTime_i + OperationTime_i) \\leq MaxTransshipmentGap + M * (1 - DependencySatisfaction_p) \\forall p=\\(i, j\\) \\in Dependencies\n\nType:\nMixed, Linear, Linear\nMILP",
    "correct_program":"import gurobipy as gp\nfrom gurobipy import GRB\nfrom typing import List, Dict, Tuple\n\ndef solve_berth_allocation(\n    Ships: List[str] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'],\n    Berths: List[str] = ['B1', 'B2', 'B3'],\n    ArrivalTime: Dict[str, int] = {'A': 2, 'B': 5, 'C': 10, 'D': 12, 'E': 18, 'F': 20, 'G': 25, 'H': 30, 'I': 35, 'J': 40},\n    OperationTime: Dict[str, int] = {'A': 8, 'B': 10, 'C': 6, 'D': 9, 'E': 7, 'F': 11, 'G': 8, 'H': 12, 'I': 5, 'J': 9},\n    Dependencies: List[Tuple[str, str]] = [('A', 'C'), ('D', 'E'), ('B', 'G'), ('H', 'I'), ('G', 'J')],\n    MaxTime: int = 72,\n    RapidTransshipmentBonus: int = 50000,\n    WaitingCost: int = 2000,\n    MaxTransshipmentGap: int = 2,\n    M: int = 1000\n):\n    \"\"\"\n    Solves the berth allocation problem using Gurobi.\n\n    Args:\n        Ships (List[str]): A list of ship identifiers.\n        Berths (List[str]): A list of available berth identifiers.\n        ArrivalTime (Dict[str, int]): A dictionary mapping each ship to its Estimated Time of Arrival (ETA) in hours.\n        OperationTime (Dict[str, int]): A dictionary mapping each ship to its required service time at the berth in hours.\n        Dependencies (List[Tuple[str, str]]): A list of tuples, where each tuple (i, j) means ship i must finish before ship j can start.\n        MaxTime (int): The total time window for scheduling, in hours.\n        RapidTransshipmentBonus (int): The monetary bonus for achieving a rapid transshipment.\n        WaitingCost (int): The cost incurred for each hour a ship waits before service.\n        MaxTransshipmentGap (int): The maximum time gap (in hours) between dependent tasks to qualify for the bonus.\n        M (int): A sufficiently large number used for \"big-M\" method in linear programming.\n    \"\"\"\n    \n    # --- Model Initialization ---\n    model = gp.Model(\"BerthAllocation\")\n\n    # --- Decision Variables ---\n    # StartTime_i: Start time of service for ship i\n    StartTime = model.addVars(Ships, name=\"StartTime\", vtype=GRB.CONTINUOUS, lb=0)\n    \n    # Assignment_ib: 1 if ship i is assigned to berth b, 0 otherwise\n    Assignment = model.addVars(Ships, Berths, name=\"Assignment\", vtype=GRB.BINARY)\n    \n    # Precedence_ij: 1 if ship i and j are on the same berth and i is first, 0 otherwise\n    Precedence = model.addVars(Ships, Ships, name=\"Precedence\", vtype=GRB.BINARY)\n\n    # DependencySatisfaction_p: 1 if precedence pair p=(i,j) gets the bonus, 0 otherwise\n    DependencySatisfaction = model.addVars(Dependencies, name=\"DependencySatisfaction\", vtype=GRB.BINARY)\n\n    # W_i: Waiting time for ship i (StartTime_i - ArrivalTime_i)\n    w = model.addVars(Ships, name=\"WaitTime\", vtype=GRB.CONTINUOUS, lb=0)\n\n\n    # --- Objective Function ---\n    total_bonus = gp.quicksum(RapidTransshipmentBonus * DependencySatisfaction[p] for p in Dependencies)\n    total_waiting_cost = gp.quicksum(WaitingCost * w[i] for i in Ships)\n\n    model.setObjective(total_bonus - total_waiting_cost, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    # Waiting time definition\n    model.addConstrs((w[i] == StartTime[i] - ArrivalTime[i] for i in Ships), \"DefWaitTime\")\n\n    # Constraint 1: Unique berth assignment for each ship\n    model.addConstrs((gp.quicksum(Assignment[i, b] for b in Berths) == 1 for i in Ships), \"UniqueBerth\")\n\n    # Constraint 2: Service must start after ETA\n    model.addConstrs((StartTime[i] >= ArrivalTime[i] for i in Ships), \"RespectETA\")\n\n    # Constraint 3: Service must finish within the planning horizon\n    model.addConstrs((StartTime[i] + OperationTime[i] <= MaxTime for i in Ships), \"Horizon\")\n\n    # Constraint 4: Precedence constraints for dependent ships\n    for i, j in Dependencies:\n        model.addConstr(StartTime[j] >= StartTime[i] + OperationTime[i], f\"Precedence_{i}_{j}\")\n\n    # Constraint 5: Berth non-overlapping constraints\n    for i in Ships:\n        for j in Ships:\n            if i == j:\n                continue\n            for b in Berths:\n                # If i and j are on the same berth b, one must precede the other.\n                # Precedence_ij + Precedence_ji = 1 if Assignment_ib=1 and Assignment_jb=1\n                model.addConstr(Precedence[i, j] + Precedence[j, i] >= Assignment[i, b] + Assignment[j, b] - 1, f\"RelativeOrder_{i}_{j}_{b}\")\n\n                # If Precedence_ij = 1 (i before j), enforce time separation\n                model.addConstr(StartTime[i] + OperationTime[i] <= StartTime[j] + M * (1 - Precedence[i, j]) + M * (2 - Assignment[i, b] - Assignment[j, b]), f\"NoOverlap_{i}_before_{j}_on_{b}\")\n\n    # Constraint 6: Bonus logic constraints\n    for p in Dependencies:\n        i, j = p\n        # If DependencySatisfaction_p is 1, then the gap must be <= MaxTransshipmentGap.\n        # StartTime_j - (StartTime_i + OperationTime_i) <= MaxTransshipmentGap + M * (1 - DependencySatisfaction_p)\n        model.addConstr(StartTime[j] - (StartTime[i] + OperationTime[i]) <= MaxTransshipmentGap + M * (1 - DependencySatisfaction[p]), f\"BonusLogic_{i}_{j}\")\n\n\n    # --- Solve the Model ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.Status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_berth_allocation()\n    print(result)\n",
    "ground_truth":194000.0
  }
]