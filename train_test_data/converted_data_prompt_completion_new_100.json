[
  {
    "prompt": "Please solve this optimization problem:\n\nIn a challenging and complex market, SwiftLogistics is at a crossroads to design an efficient distribution network to fulfill the needs of eight retail stores scattered across various locations. The company has the opportunity to choose from six potential distribution centers, each with its unique opening costs and capacities. The primary goal is to ensure all retail stores are adequately supplied while minimizing the total operational costs, which include both the opening of distribution centers and the transportation of goods.\n\nGiven Data:\n- Number of Potential Distribution Centers: 6\n- Number of Retail Stores Needing Supply: 8\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n- Center 6: $120,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $2 to Store 1, $3 to Store 2, $3 to Store 3, $3 to Store 4, $5 to Store 5, $4 to Store 6, $3 to Store 7, $5 to Store 8\n- From Center 2: $2 to Store 1, $4 to Store 2, $2 to Store 3, $4 to Store 4, $5 to Store 5, $1 to Store 6, $4 to Store 7, $2 to Store 8\n- From Center 3: $5 to Store 1, $4 to Store 2, $1 to Store 3, $1 to Store 4, $3 to Store 5, $3 to Store 6, $2 to Store 7, $4 to Store 8\n- From Center 4: $4 to Store 1, $3 to Store 2, $4 to Store 3, $4 to Store 4, $1 to Store 5, $3 to Store 6, $5 to Store 7, $3 to Store 8\n- From Center 5: $5 to Store 1, $1 to Store 2, $2 to Store 3, $4 to Store 4, $1 to Store 5, $4 to Store 6, $2 to Store 7, $2 to Store 8\n- From Center 6: $1 to Store 1, $2 to Store 2, $5 to Store 3, $2 to Store 4, $4 to Store 5, $4 to Store 6, $4 to Store 7, $4 to Store 8\n\nDemand of Each Retail Store (in units):\n- Store 1: 908 units\n- Store 2: 434 units\n- Store 3: 605 units\n- Store 4: 480 units\n- Store 5: 961 units\n- Store 6: 787 units\n- Store 7: 401 units\n- Store 8: 789 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1365 units\n- Center 2: 1929 units\n- Center 3: 1502 units\n- Center 4: 1201 units\n- Center 5: 1529 units\n- Center 6: 961 units\n\nSwiftLogistics now faces the intricate task of determining which distribution centers to open and how to distribute goods to meet the demands of all eight retail stores efficiently. The strategy must ensure that the total cost, including opening and transportation expenses, is minimized.\n\nQuestion:\nWhat is the optimal total cost for SwiftLogistics to open the necessary distribution centers and transport goods to satisfy the demands of all eight retail stores, keeping in mind the goal of minimizing the combined opening and transportation costs?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SwiftLogisticsOptimization\")\n\n# Sets\nI = range(1, 7)  # Distribution centers\nJ = range(1, 9)  # Retail stores\n\n# Parameters\nf = {1: 151000, 2: 192000, 3: 114000, 4: 171000, 5: 160000, 6: 120000}\nc = {\n    (1, 1): 2, (1, 2): 3, (1, 3): 3, (1, 4): 3, (1, 5): 5, (1, 6): 4, (1, 7): 3, (1, 8): 5,\n    (2, 1): 2, (2, 2): 4, (2, 3): 2, (2, 4): 4, (2, 5): 5, (2, 6): 1, (2, 7): 4, (2, 8): 2,\n    (3, 1): 5, (3, 2): 4, (3, 3): 1, (3, 4): 1, (3, 5): 3, (3, 6): 3, (3, 7): 2, (3, 8): 4,\n    (4, 1): 4, (4, 2): 3, (4, 3): 4, (4, 4): 4, (4, 5): 1, (4, 6): 3, (4, 7): 5, (4, 8): 3,\n    (5, 1): 5, (5, 2): 1, (5, 3): 2, (5, 4): 4, (5, 5): 1, (5, 6): 4, (5, 7): 2, (5, 8): 2,\n    (6, 1): 1, (6, 2): 2, (6, 3): 5, (6, 4): 2, (6, 5): 4, (6, 6): 4, (6, 7): 4, (6, 8): 4\n}\nd = {1: 908, 2: 434, 3: 605, 4: 480, 5: 961, 6: 787, 7: 401, 8: 789}\ns = {1: 1365, 2: 1929, 3: 1502, 4: 1201, 5: 1529, 6: 961}\n\n# Decision Variables\nx = model.addVars(I, J, name=\"x\", vtype=GRB.CONTINUOUS, lb=0)\ny = model.addVars(I, name=\"y\", vtype=GRB.BINARY)\n\n# Objective: Minimize total cost\nmodel.setObjective(\n    gp.quicksum(f[i] * y[i] for i in I) +\n    gp.quicksum(c[i, j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand satisfaction\nmodel.addConstrs((gp.quicksum(x[i, j] for i in I) == d[j] for j in J), name=\"Demand\")\n\n# Supply capacity\nmodel.addConstrs((gp.quicksum(x[i, j] for j in J) <= s[i] * y[i] for i in I), name=\"Supply\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 587428.0",
    "task_id": "E077",
    "ground_truth": 587428.0,
    "problem_domain": "Facility Location",
    "modeling_type": "MILP",
    "industry_sector": "Logistics"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA florist transports his flowers to stores in small bouquets and large bouquets. A small bouquet has 5 flowers while a large bouquet has 10 flowers. The florist can transport at most 80 small bouquets and 50 large bouquets. In total, he can transport at most 70 bouquets and he must transport at least 20 large bouquets. Since small bouquets are more popular, he must transport at least twice as many small bouquets as large bouquets. How many of each bouquet should he transport to maximize the total number of flowers that reach the stores?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_bouquets():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"FlowerBouquets\")\n\n    # Decision variables\n    S = m.addVar(vtype=GRB.INTEGER, name=\"SmallBouquets\")\n    L = m.addVar(vtype=GRB.INTEGER, name=\"LargeBouquets\")\n\n    # Set objective: maximize total flowers\n    m.setObjective(5 * S + 10 * L, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(S <= 80, name=\"MaxSmall\")\n    m.addConstr(L <= 50, name=\"MaxLarge\")\n    m.addConstr(S + L <= 70, name=\"TotalBouquets\")\n    m.addConstr(L >= 20, name=\"MinLarge\")\n    m.addConstr(S >= 2 * L, name=\"SmallAtLeastTwiceLarge\")\n    m.addConstr(S >= 0, name=\"NonNegSmall\")\n    m.addConstr(L >= 0, name=\"NonNegLarge\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum total number of flowers\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_flowers = optimize_bouquets()\n    if max_flowers is not None:\n        print(f\"Maximum Total Flowers: {max_flowers}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 465.0",
    "task_id": "A134",
    "ground_truth": 465.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA university research lab can make two types of diabetes medicine, medicine A and medicine B. Per dose, medicine A takes 30 units of imported material and 50 units of mRNA to make. Per dose, medicine B takes 40 units of imported material and 30 units of mRNA to take. The lab has available at most 300 units of imported material and 400 units of mRNA. The lab can make at most 5 doses of medicine A and the number of doses of medicine B must be larger than the number of dosed of medicine A. If one dose of medicine A can treat 12 people and one dose of medicine B can treat 8 people, how many doses of each should be made to maximize the number of people that can be treated?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_medicine_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MedicineProduction\")\n\n    # Decision variables\n    x = m.addVar(vtype=GRB.INTEGER, name=\"x\")  # Doses of medicine A\n    y = m.addVar(vtype=GRB.INTEGER, name=\"y\")  # Doses of medicine B\n\n    # Set objective: maximize total treated people\n    m.setObjective(12 * x + 8 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(30 * x + 40 * y <= 300, \"MaterialConstraint\")\n    m.addConstr(50 * x + 30 * y <= 400, \"mRNAConstraint\")\n    m.addConstr(x <= 5, \"MaxDosesA\")\n    m.addConstr(y >= x + 1, \"B_at_least_A\")\n    m.addConstr(x >= 0, \"NonNegX\")\n    m.addConstr(y >= 0, \"NonNegY\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum number of people treated\n        return m.objVal\n    else:\n        return None\n\nprint(optimize_medicine_production())\n```\n\nThe optimal value is: 76.0",
    "task_id": "A114",
    "ground_truth": 76.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "MILP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA lawn mowing service provides neighborhood services using small teams and large teams. A small team requires 3 employees and can mow 50 sq ft of lawn. A large team requires 5 employees and can mow 80 sq ft of lawn. The company has 150 employees available. Because most people have smaller lawns in the city, the number of small teams must be at least 3 times as much as the number of large teams. In addition, to make sure the company can meet all demands, there has to be at least 6 large teams and at least 10 small teams. How many of each team type should be used to maximize the amount of lawn that can be mowed?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"LawnMowingService\")\n\n# Parameters\ne_s = 3  # Number of employees in a small team\ne_l = 5  # Number of employees in a large team\nm_s = 50  # Area mowed by a small team (sq ft)\nm_l = 80  # Area mowed by a large team (sq ft)\nE = 150  # Total number of employees available\nr = 3  # Minimum ratio of small teams to large teams\nL_min = 6  # Minimum number of large teams\nS_min = 10  # Minimum number of small teams\n\n# Variables\nS = model.addVar(vtype=GRB.INTEGER, name=\"SmallTeams\")\nL = model.addVar(vtype=GRB.INTEGER, name=\"LargeTeams\")\n\n# Objective: Maximize the total area mowed\nmodel.setObjective(m_s * S + m_l * L, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(e_s * S + e_l * L <= E, \"EmployeeConstraint\")\nmodel.addConstr(S >= r * L, \"RatioConstraint\")\nmodel.addConstr(L >= L_min, \"MinLargeTeams\")\nmodel.addConstr(S >= S_min, \"MinSmallTeams\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 2480.0",
    "task_id": "F038",
    "ground_truth": 2480.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Service"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA meat processing plant uses two machines, a meat slicer and a meat packer, to make their hams and pork ribs. To produce one batch of hams requires 4 hours on the meat slicer and 2.5 hours on the meat packer. To produce one batch of pork ribs requires 2 hours on the meat slicer and 3.5 hours on the meat packer. Each machine runs for at most 4000 hours per year. If the profit per batch of hams is $150 and the profit per batch of pork ribs is $300, how many batches of each should be made to maximize profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\np_H = 150  # Profit per batch of hams\np_R = 300  # Profit per batch of pork ribs\nt_SH = 4   # Time on slicer per batch of hams\nt_PH = 2.5 # Time on packer per batch of hams\nt_SR = 2   # Time on slicer per batch of pork ribs\nt_PR = 3.5 # Time on packer per batch of pork ribs\nT_S = 4000 # Total slicer hours\nT_P = 4000 # Total packer hours\n\n# Decision Variables\nx_H = model.addVar(vtype=GRB.INTEGER, name=\"x_H\")\nx_R = model.addVar(vtype=GRB.INTEGER, name=\"x_R\")\n\n# Objective: Maximize profit\nmodel.setObjective(p_H * x_H + p_R * x_R, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(t_SH * x_H + t_SR * x_R <= T_S, \"C1\")  # Slicer capacity\nmodel.addConstr(t_PH * x_H + t_PR * x_R <= T_P, \"C2\")  # Packer capacity\nmodel.addConstr(x_H >= 0, \"C3_H\")  # Non-negativity for x_H\nmodel.addConstr(x_R >= 0, \"C3_R\")  # Non-negativity for x_R\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 342750.0",
    "task_id": "F083",
    "ground_truth": 342750.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA beverage factory produces a kind of beverage to meet market demand. According to market forecasts, the sales department of the factory has determined the demand for the beverage for the next 4 weeks. The planning department, based on the actual situation of the factory, has provided the production capacity and production cost for the next 4 weeks, as shown in Table 1. When there is a surplus of beverages after meeting the demand each week, a storage cost of 0.2 thousand yuan per week per thousand boxes of beverages needs to be paid. How should the production plan be arranged to minimize the total cost (the sum of production cost and storage cost) over the four weeks while meeting the weekly market demand?\n\nTable 1 Beverage Production and Demand Data:\n\n\\begin{tabular}{c|c|c|c}\n\\hline \nWeek & Demand/1000 boxes & Production Capacity/1000 boxes & Cost per 1000 boxes/1000 yuan \\\\\n\\hline \n1 & 15 & 30 & 5.0 \\\\\n\\hline \n2 & 25 & 40 & 5.1 \\\\\n\\hline \n3 & 35 & 45 & 5.4 \\\\\n\\hline \n4 & 25 & 20 & 5.5 \\\\\n\\hline \nTotal & 100 & 135 & \\\\\n\\hline\n\\end{tabular}",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_beverage_production():\n    from gurobipy import Model, GRB\n\n    # Data parameters\n    demand = [15, 25, 35, 25]  # demand for weeks 1-4\n    capacity = [30, 40, 45, 20]  # production capacity for weeks 1-4\n    cost = [5.0, 5.1, 5.4, 5.5]  # production cost per 1000 boxes\n    storage_cost = 0.2  # storage cost per 1000 boxes per week\n\n    # Create model\n    m = Model(\"BeverageProduction\")\n\n    # Decision variables\n    P = m.addVars(4, lb=0, name=\"Production\")  # production in each week\n    I = m.addVars(4, lb=0, name=\"Inventory\")  # inventory at end of each week\n\n    # Initial inventory constraint\n    # I_0 = 0 (not a variable, but initial condition)\n    # Inventory balance constraints\n    for t in range(4):\n        if t == 0:\n            m.addConstr(P[t] + 0 == demand[t] + I[t],\n                        name=f\"Balance_week_{t+1}\")\n        else:\n            m.addConstr(I[t - 1] + P[t] == demand[t] + I[t],\n                        name=f\"Balance_week_{t+1}\")\n\n    # Production capacity constraints\n    for t in range(4):\n        m.addConstr(P[t] <= capacity[t], name=f\"Cap_week_{t+1}\")\n\n    # Objective function\n    total_cost = 0\n    for t in range(4):\n        total_cost += cost[t] * P[t] + storage_cost * I[t]\n    m.setObjective(total_cost, GRB.MINIMIZE)\n\n    # Optimize\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":  # pragma: no cover\n    result = optimize_beverage_production()\n    if result is not None:\n        print(f\"Optimal total cost: {result}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 528.0",
    "task_id": "B094",
    "ground_truth": 528.0,
    "problem_domain": "Production Planning",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nYou're in charge of crafting a meal plan for a week, aiming to meet certain nutritional requirements while keeping your grocery bill to a minimum. There are seven food options you're considering: Chicken, Tuna, Eggs, Beef, Rice, Apples, and Bread. Each food item provides distinct amounts of protein, carbohydrates, and calories, and has a different price.\n\nHere are the details for each food:\n\n- Chicken: Provides 18 grams of protein, 23 grams of carbohydrates, and 217 calories for $3.\n- Tuna: Offers 12 grams of protein, 30 grams of carbohydrates, and 182 calories for $10.\n- Eggs: Contains 7 grams of protein, 16 grams of carbohydrates, and 79 calories for $10.\n- Beef: Delivers 17 grams of protein, 26 grams of carbohydrates, and 295 calories for $7.\n- Rice: Supplies 3 grams of protein, 30 grams of carbohydrates, and 264 calories for just $4.\n- Apples: Gives 4 grams of protein, 6 grams of carbohydrates, and 160 calories for $6.\n- Bread: Carries 4 grams of protein, 23 grams of carbohydrates, and 141 calories for $5.\n\nYour nutritional targets for the week are as follows: 59 grams of protein, 160 grams of carbohydrates, and 1809 calories.\n\nYour challenge is to find the most economical way of meeting these nutritional requirements with the food items available. What is the least possible amount you can spend to meet your nutritional goals for the week?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlanOptimization\")\n\n# Define the cost coefficients\ncosts = {\n    'chicken': 3,\n    'tuna': 10,\n    'eggs': 10,\n    'beef': 7,\n    'rice': 4,\n    'apples': 6,\n    'bread': 5\n}\n\n# Define the nutritional values for each food item\nprotein = {\n    'chicken': 18,\n    'tuna': 12,\n    'eggs': 7,\n    'beef': 17,\n    'rice': 3,\n    'apples': 4,\n    'bread': 4\n}\n\ncarbohydrates = {\n    'chicken': 23,\n    'tuna': 30,\n    'eggs': 16,\n    'beef': 26,\n    'rice': 30,\n    'apples': 6,\n    'bread': 23\n}\n\ncalories = {\n    'chicken': 217,\n    'tuna': 182,\n    'eggs': 79,\n    'beef': 295,\n    'rice': 264,\n    'apples': 160,\n    'bread': 141\n}\n\n# Define the targets\nprotein_target = 59\ncarbohydrates_target = 160\ncalories_target = 1809\n\n# Add variables\nx = model.addVars(costs.keys(), vtype=GRB.INTEGER, name=\"servings\", lb=0)\n\n# Set objective\nmodel.setObjective(gp.quicksum(costs[i] * x[i] for i in costs), GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in protein) >= protein_target, \"ProteinConstraint\")\nmodel.addConstr(gp.quicksum(carbohydrates[i] * x[i] for i in carbohydrates) >= carbohydrates_target, \"CarbohydratesConstraint\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in calories) >= calories_target, \"CaloriesConstraint\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 26.0",
    "task_id": "E030",
    "ground_truth": 26.0,
    "problem_domain": "Blending",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nCertain strategic bomber groups are tasked with destroying enemy military targets. It is known that the target has four key parts, and destroying any one of them will suffice. The fuel consumption limit for completing this task is 48,000 liters, with a maximum of 48 heavy bombs and 32 light bombs. When carrying heavy bombs, each liter of fuel allows a distance of 2 km, whereas with light bombs, each liter allows 3 km. Additionally, each aircraft can only carry one bomb per trip, and each bombing run requires fuel not only for the round trip (each liter of fuel allows 4 km when the aircraft is empty) but also 100 liters for both takeoff and landing per trip. Relevant data is shown in Table 1-17.\n\nTable 1-17\n| Key Part | Distance from Airport (km) | Probability of Destruction per Heavy Bomb | Probability of Destruction per Light Bomb |\n|----------|----------------------------|-----------------------------------------|------------------------------------------|\n|          |                            |                                         |                                          |\n| 1        | 450                        | 0.10                                    | 0.08                                     |\n| 2        | 480                        | 0.20                                    | 0.16                                     |\n| 3        | 540                        | 0.15                                    | 0.12                                     |\n| 4        | 600                        | 0.25                                    | 0.20                                     |\n\nTo maximize the probability of destroying the enemy military target, how should the bombing plan be determined? Establish a linear programming model for this problem.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_bomber_problem():\n    try:\n        # --- Problem Data ---\n        # Key Part | Distance (km) | P(Destroy | Heavy) | P(Destroy | Light)\n        # 1        | 450           | 0.10             | 0.08\n        # 2        | 480           | 0.20             | 0.16\n        # 3        | 540           | 0.15             | 0.12\n        # 4        | 600           | 0.25             | 0.20\n\n        num_parts = 4\n        parts = range(num_parts)\n\n        distances = [450, 480, 540, 600]  # km\n        prob_destroy_heavy = [0.10, 0.20, 0.15, 0.25]\n        prob_destroy_light = [0.08, 0.16, 0.12, 0.20]\n\n        # Resource Limits\n        max_fuel = 48000  # liters\n        max_heavy_bombs = 48\n        max_light_bombs = 32\n\n        # Fuel Consumption Parameters\n        eff_heavy_loaded = 2.0  # km/liter\n        eff_light_loaded = 3.0  # km/liter\n        eff_empty_return = 4.0  # km/liter (return trip)\n        fuel_takeoff_landing = 100  # liters per trip\n\n        # --- Pre-calculations ---\n\n        # Fuel per trip for each bomb type to each part\n        fuel_per_heavy_trip = []\n        for d in distances:\n            # Fuel to target (loaded) + Fuel return (empty) + Takeoff/Landing\n            fuel = (d / eff_heavy_loaded) + (\n                d / eff_empty_return) + fuel_takeoff_landing\n            fuel_per_heavy_trip.append(fuel)\n\n        fuel_per_light_trip = []\n        for d in distances:\n            # Fuel to target (loaded) + Fuel return (empty) + Takeoff/Landing\n            fuel = (d / eff_light_loaded) + (\n                d / eff_empty_return) + fuel_takeoff_landing\n            fuel_per_light_trip.append(fuel)\n\n        # Objective function coefficients: log(P(not destroyed by one bomb))\n        # log(1 - p) will be negative. We want to minimize this sum.\n        log_prob_not_destroy_heavy = []\n        for p in prob_destroy_heavy:\n            if p < 1.0:  # Ensure p is not 1 to avoid log(0)\n                log_prob_not_destroy_heavy.append(math.log(1 - p))\n            else:  # Should not happen with given data, but good for robustness\n                log_prob_not_destroy_heavy.append(\n                    -float('inf'))  # Effectively forces use if possible\n\n        log_prob_not_destroy_light = []\n        for p in prob_destroy_light:\n            if p < 1.0:\n                log_prob_not_destroy_light.append(math.log(1 - p))\n            else:\n                log_prob_not_destroy_light.append(-float('inf'))\n\n        # --- Model Creation ---\n        model = gp.Model(\"StrategicBomberPlanning\")\n\n        # --- Decision Variables ---\n        # x_h[i]: number of heavy bombs assigned to part i\n        x_h = model.addVars(num_parts,\n                            vtype=GRB.INTEGER,\n                            name=\"HeavyBombs\",\n                            lb=0)\n        # x_l[i]: number of light bombs assigned to part i\n        x_l = model.addVars(num_parts,\n                            vtype=GRB.INTEGER,\n                            name=\"LightBombs\",\n                            lb=0)\n\n        # --- Objective Function ---\n        # Minimize the sum of log probabilities of NOT destroying each part\n        # This is equivalent to maximizing the probability of destroying at least one part\n        objective = gp.quicksum(log_prob_not_destroy_heavy[i] * x_h[i] for i in parts) + \\\n                    gp.quicksum(log_prob_not_destroy_light[i] * x_l[i] for i in parts)\n        model.setObjective(objective, GRB.MINIMIZE)\n\n        # --- Constraints ---\n\n        # 1. Total heavy bombs constraint\n        model.addConstr(\n            gp.quicksum(x_h[i] for i in parts) <= max_heavy_bombs,\n            \"MaxHeavyBombs\")\n\n        # 2. Total light bombs constraint\n        model.addConstr(\n            gp.quicksum(x_l[i] for i in parts) <= max_light_bombs,\n            \"MaxLightBombs\")\n\n        # 3. Total fuel consumption constraint\n        total_fuel_consumed = gp.quicksum(fuel_per_heavy_trip[i] * x_h[i] for i in parts) + \\\n                              gp.quicksum(fuel_per_light_trip[i] * x_l[i] for i in parts)\n        model.addConstr(total_fuel_consumed <= max_fuel, \"MaxFuel\")\n\n        # --- Optimize Model ---\n        model.optimize()\n\n        # --- Results ---\n        print(\"-\" * 30)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found!\")\n            print(\n                f\"Objective Value (sum of log-probabilities of non-destruction): {model.objVal:.4f}\"\n            )\n\n            # Calculate overall probability of success\n            # P_success = 1 - exp(model.objVal) because model.objVal = ln(Q_total)\n            prob_success = 1 - math.exp(model.objVal)\n            print(\n                f\"Maximized Probability of Destroying at least one Target: {prob_success:.4%}\"\n            )\n            print(\"-\" * 30)\n\n            print(\"Bombing Plan:\")\n            total_h_bombs_used = 0\n            total_l_bombs_used = 0\n            actual_fuel_consumed = 0\n\n            for i in parts:\n                num_h = x_h[i].X\n                num_l = x_l[i].X\n                if num_h > 0.5 or num_l > 0.5:  # Check if any bombs assigned (due to float results)\n                    print(f\"  Key Part {i+1}:\")\n                    print(f\"    Heavy Bombs: {num_h:.0f}\")\n                    print(f\"    Light Bombs: {num_l:.0f}\")\n                total_h_bombs_used += num_h\n                total_l_bombs_used += num_l\n                actual_fuel_consumed += num_h * fuel_per_heavy_trip[\n                    i] + num_l * fuel_per_light_trip[i]\n\n            print(\"-\" * 30)\n            print(\"Resource Utilization:\")\n            print(\n                f\"  Total Heavy Bombs Used: {total_h_bombs_used:.0f} / {max_heavy_bombs}\"\n            )\n            print(\n                f\"  Total Light Bombs Used: {total_l_bombs_used:.0f} / {max_light_bombs}\"\n            )\n            print(\n                f\"  Total Fuel Consumed: {actual_fuel_consumed:.2f} / {max_fuel} liters\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists under the given constraints.\"\n            )\n        elif model.status == GRB.UNBOUNDED:\n            print(\"Model is unbounded.\")\n        else:\n            print(f\"Optimization was stopped with status {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Gurobi or one of its components is not available. Make sure Gurobi is installed and licensed.\"\n        )\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_bomber_problem()\n```\n\nThe optimal value is: 0.9999999992023356",
    "task_id": "B016",
    "ground_truth": 0.9999999992023356,
    "problem_domain": "Resource Allocation",
    "modeling_type": "MILP",
    "industry_sector": "Defense"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA clinical firm has two factories, a northern factory and a western factory, where they make expensive anti-itch injections and topical cream. Every hour, the northern factory makes 800 g of anti-itch injections and 700 g of topical cream. Every hour, the western factory makes 650 g of anti-itch injections and 750 g of topical cream. The northern factory requires 40 units of plastic per hour while the western factory requires 35 units of plastic to manufacture the packaging. The clinical firm has available 60,000 units of plastic. Further, they must make at least 800,000 g of anti-itch injections and 700,000 g of topical cream. How many hours should each factory be run to minimize the total time needed?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_factory_hours(\n    injection_target=800000,\n    cream_target=700000,\n    plastic_limit=60000,\n    rate_injection_north=800,\n    rate_cream_north=700,\n    rate_injection_west=650,\n    rate_cream_west=750,\n    plastic_north=40,\n    plastic_west=35\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Factory_Production_MinHours\")\n\n    # Decision variables: hours of operation for each factory\n    x_N = model.addVar(name=\"x_N\", lb=0)\n    x_W = model.addVar(name=\"x_W\", lb=0)\n    max_hour = model.addVar(name=\"max_hour\", lb=0)\n\n    # Set the objective: minimize total hours\n    model.setObjective(max_hour, GRB.MINIMIZE)\n\n    # Add constraints\n    # Anti-itch injections production constraint\n    model.addConstr(\n        rate_injection_north * x_N + rate_injection_west * x_W >= injection_target,\n        name=\"InjectionRequirement\"\n    )\n\n    # Topical cream production constraint\n    model.addConstr(\n        rate_cream_north * x_N + rate_cream_west * x_W >= cream_target,\n        name=\"CreamRequirement\"\n    )\n\n    # Plastic usage constraint\n    model.addConstr(\n        plastic_north * x_N + plastic_west * x_W <= plastic_limit,\n        name=\"PlasticLimit\"\n    )\n    \n    # Maximum hours constraint\n    model.addConstr(max_hour >= x_N, name=\"MaxHour_N\")\n    model.addConstr(max_hour >= x_W, name=\"MaxHour_W\")\n    \n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_hours = model.objVal\n        return total_hours\n    else:\n        return None\n    \n# Example usage\nprint(optimize_factory_hours())\n```\n\nThe optimal value is: 551.7241379310345",
    "task_id": "A236",
    "ground_truth": 551.7241379310345,
    "problem_domain": "Production Planning",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA lighting company makes desk-lamps and night-lamps. There is an expected demand of at least 30 desk-lamps and 50 night-lamps each day. However, due to the size of their factory, they can make at most 150 desk-lamps and 180 night-lamps per day. To satisfy a contract, a minimum of 100 lamps must be made each day. If the profit per desk-lamp sold is $5 and the profit per night-lamp sold is $8, how many lamps of each type should be made to maximize profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\np_d = 5  # Profit per desk-lamp ($)\np_n = 8  # Profit per night-lamp ($)\nD_d = 30  # Minimum demand for desk-lamps (units)\nD_n = 50  # Minimum demand for night-lamps (units)\nU_d = 150  # Maximum production capacity for desk-lamps (units)\nU_n = 180  # Maximum production capacity for night-lamps (units)\nT = 100  # Minimum total lamps to be produced (units)\n\n# Variables\nx_d = model.addVar(vtype=GRB.INTEGER, name=\"x_d\")\nx_n = model.addVar(vtype=GRB.INTEGER, name=\"x_n\")\n\n# Objective function\nmodel.setObjective(p_d * x_d + p_n * x_n, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_d >= D_d, \"C1\")\nmodel.addConstr(x_n >= D_n, \"C2\")\nmodel.addConstr(x_d <= U_d, \"C3\")\nmodel.addConstr(x_n <= U_n, \"C4\")\nmodel.addConstr(x_d + x_n >= T, \"C5\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 2190.0",
    "task_id": "F162",
    "ground_truth": 2190.0,
    "problem_domain": "Production Planning",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA breakfast joint makes two different sandwiches: a regular and a special. Both need eggs and bacon. Each regular sandwich requires 2 eggs and 3 slices of bacon. Each special sandwich requires 3 eggs and 5 slices of bacon. The joint has a total of 40 eggs and 70 slices of bacon. It makes a profit of $3 per regular sandwich and a profit of $4 per special sandwich. How many of each sandwich should be made to maximize profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nE = 40  # total number of eggs available\nB = 70  # total number of bacon slices available\nP_r = 3  # Profit per regular sandwich\nP_s = 4  # Profit per special sandwich\ne_r = 2  # Eggs required for regular sandwich\nb_r = 3  # Bacon required for regular sandwich\ne_s = 3  # Eggs required for special sandwich\nb_s = 5  # Bacon required for special sandwich\n\n# Variables\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n\n# Objective\nmodel.setObjective(P_r * x_r + P_s * x_s, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(e_r * x_r + e_s * x_s <= E, \"EggConstraint\")\nmodel.addConstr(b_r * x_r + b_s * x_s <= B, \"BaconConstraint\")\n\n# Non-negativity constraints are inherently handled by the variable definitions\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 60.0",
    "task_id": "F013",
    "ground_truth": 60.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Food Service"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nMaple Oil processes three types of crude oil: light oil, non-sticky oil and heavy oil. Each tank of light oil produces a net revenue of $550, each tank of non-sticky oil produces a net revenue of $750, and each tank of heavy oil produces a net revenue of $950. To process a tank of light oil, 3 units of compound A and 3 units of compound B are required. To process a tank of non-sticky oil, 6 units of compound A and 2 units of compound B are required. To process a tank of heavy oil, 9 units of compound A and 3 units of compound B are required. Currently the company has 250 units of compound A and 150 units of compound B to process. How many full or partial tanks of each oil should the company process so that net revenue is maximized?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_crude_processing(\n    revenue_light=550,\n    revenue_non_sticky=750,\n    revenue_heavy=950,\n    compound_A_total=250,\n    compound_B_total=150\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"CrudeOilProcessing\")\n\n    # Decision variables: number of tanks processed for each oil type\n    x_L = model.addVar(name=\"LightOil\", lb=0)\n    x_N = model.addVar(name=\"NonStickyOil\", lb=0)\n    x_H = model.addVar(name=\"HeavyOil\", lb=0)\n\n    # Set the objective: maximize total revenue\n    model.setObjective(\n        revenue_light * x_L + revenue_non_sticky * x_N + revenue_heavy * x_H,\n        GRB.MAXIMIZE\n    )\n\n    # Add resource constraints\n    # Compound A constraint\n    model.addConstr(\n        3 * x_L + 6 * x_N + 9 * x_H <= compound_A_total,\n        name=\"CompoundA\"\n    )\n\n    # Compound B constraint\n    model.addConstr(\n        3 * x_L + 2 * x_N + 3 * x_H <= compound_B_total,\n        name=\"CompoundB\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_revenue = optimize_crude_processing()\n    if max_revenue is not None:\n        print(f\"Maximum Revenue: ${max_revenue}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 37083.333333333336",
    "task_id": "A182",
    "ground_truth": 37083.333333333336,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA dog school trains labradors and golden retrievers to deliver newspaper. A labrador can deliver 7 newspapers at a time and requires 5 small bone treats for service. A golden retriever can deliver 10 newspapers at a time and requires 6 small bone treats per service. The school only has 1500 small bone treats available. In addition, at least 50 golden retrievers must be used and at most 60% of the dogs can be labradors. How many of each dog should be used to maximize the number of newspapers that can be delivered?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DogSchoolOptimization\")\n\n# Parameters\nt_L = 5\nt_G = 6\nn_L = 7\nn_G = 10\nT = 1500\nG_min = 50\np_L = 0.6\n\n# Variables\nL = model.addVar(vtype=GRB.INTEGER, name=\"L\")\nG = model.addVar(vtype=GRB.INTEGER, lb=G_min, name=\"G\")\n\n# Objective\nmodel.setObjective(n_L * L + n_G * G, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(t_L * L + t_G * G <= T, \"TotalTreats\")\nmodel.addConstr(G >= G_min, \"MinGoldenRetrievers\")\nmodel.addConstr(L <= p_L * (L + G), \"MaxLabradorsProportion\")\nmodel.addConstr(L >= 0, \"NonNegLabradors\")\nmodel.addConstr(G >= 0, \"NonNegGoldenRetrievers\")\n\n# Optimize\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 2500.0",
    "task_id": "F068",
    "ground_truth": 2500.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Animal Training/Services"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA candy company is making peach flavored candy and cherry flavored candy. Each pack of peach flavored candy requires 3 units of peach flavoring and 5 units of special syrup. Each pack of cherry flavored candy requires 5 units of cherry flavoring and 4 units of special syrup. The company has available 3000 units of peach flavoring and 4000 units of cherry flavoring. Peach candy is much more popular and thus the number of peach candy packs must be larger than the number of cherry candy packs. In addition, at least 30% of the pack must be cherry flavored. How many of each should be made to minimize the total amount of special syrup used?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_candy_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"CandyProduction\")\n\n    # Decision variables: number of peach and cherry packs\n    P = m.addVar(vtype=GRB.INTEGER, name=\"PeachPacks\", lb=0)\n    C = m.addVar(vtype=GRB.INTEGER, name=\"CherryPacks\", lb=0)\n\n    # Set the objective: minimize total syrup used\n    m.setObjective(5 * P + 4 * C, GRB.MINIMIZE)\n\n    # Flavoring constraints\n    m.addConstr(P <= 1000, \"PeachFlavorLimit\")\n    m.addConstr(C <= 800, \"CherryFlavorLimit\")\n\n    # Popularity constraint: peach packs > cherry packs\n    # Note: Gurobi does not support strict inequalities directly.\n    # To enforce P > C, we can model as P >= C + 1\n    m.addConstr(P >= C + 1, \"PopularityConstraint\")\n\n    # Cherry proportion constraint: C >= (3/7)*P\n    # To avoid fractional coefficients, multiply both sides by 7\n    m.addConstr(7 * C >= 3 * P, \"CherryProportion\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total syrup usage\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_syrup = optimize_candy_production()\n    if min_syrup is not None:\n        print(f\"Minimum Total Syrup Usage: {min_syrup}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 14.0",
    "task_id": "A077",
    "ground_truth": 14.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA toy store decides to deliver gifts using two shipping companies, a new one and an old one. The new company can deliver 50 gifts per trip while the old company can deliver 70 gifts per trip. The new company uses 30 liters of diesel per trip while the old company uses 40 liters of diesel per trip. The toy store needs to deliver at least 1000 gifts. There can be at most 15 trips made by the new company. In order to make sure that the old company does not go out of business, at least 40% of all trips must be made by the old company. How many trips should each company make to minimize the total amount of diesel used?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nC_n = 50  # gifts per trip by new company\nC_o = 70  # gifts per trip by old company\nD_n = 30  # liters of diesel per trip by new company\nD_o = 40  # liters of diesel per trip by old company\nG = 1000  # minimum number of gifts to be delivered\nT_n_max = 15  # maximum trips for new company\nalpha = 0.4  # minimum fraction of total trips by old company\n\n# Variables\nx_n = model.addVar(vtype=GRB.INTEGER, name=\"x_n\", lb=0)\nx_o = model.addVar(vtype=GRB.INTEGER, name=\"x_o\", lb=0)\n\n# Objective: Minimize total diesel used\nmodel.setObjective(D_n * x_n + D_o * x_o, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(C_n * x_n + C_o * x_o >= G, \"C1\")\nmodel.addConstr(x_n <= T_n_max, \"C2\")\nmodel.addConstr(x_o >= alpha * (x_n + x_o), \"C3\")\nmodel.addConstr(x_n >= 0, \"C4\")\nmodel.addConstr(x_o >= 0, \"C4\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 580.0",
    "task_id": "F046",
    "ground_truth": 580.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA man on a strict diet only drinks meal replacement drinks from two brands, alpha and omega. The alpha brand drink contains 30 grams of protein, 20 grams of sugar, and 350 calories per bottle. The omega brand drink contains 20 grams of protein, 15 grams of sugar, and 300 calories per bottle. The man wants to get at least 100 grams of protein and 2000 calories. In addition, because the omega brand drink contains tiny amounts of caffeine, at most 35% of the drink should be omega brand. How many bottles of each should he drink to minimize his sugar intake?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_meal_plan():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MealReplacementOptimization\")\n\n    # Decision variables: number of bottles of alpha and omega\n    x = m.addVar(name=\"alpha_bottles\", lb=0, vtype=GRB.INTEGER)\n    y = m.addVar(name=\"omega_bottles\", lb=0, vtype=GRB.INTEGER)\n\n    # Set the objective: minimize total sugar\n    m.setObjective(20 * x + 15 * y, GRB.MINIMIZE)\n\n    # Add protein constraint\n    m.addConstr(30 * x + 20 * y >= 100, name=\"protein_req\")\n\n    # Add calorie constraint\n    m.addConstr(350 * x + 300 * y >= 2000, name=\"calorie_req\")\n\n    # Add omega proportion constraint\n    # y <= (0.35/0.65) * x\n    m.addConstr(y <= (0.35 / 0.65) * x, name=\"omega_ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal sugar intake\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nprint(optimize_meal_plan())\n```\n\nThe optimal value is: 110.0",
    "task_id": "A079",
    "ground_truth": 110.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "MILP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA suspicious factory has 100 sq. feet of space. It makes bootleg phones and laptops. Phones require 2 hours of labor and cost $12 for each sq. foot of space allocated for phone production (cost of electricity and equipment). Laptops require 3 hours of labor and cost $15 for each sq. foot of space allocated for laptop production. Phones produce a net revenue of $50 per sq. foot while laptops produce a net revenue of $70 per sq. foot. The factory wants to spend at most $5000 and 2000 hours of labor. What is the optimal factory layout to maximize revenue?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_factory_layout(space_limit=100, max_cost=5000, max_labor=2000):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Factory_Layout_Maximize_Revenue\")\n\n    # Decision variables: space allocated to phones and laptops\n    x = model.addVar(name=\"Phones_Space\", lb=0)\n    y = model.addVar(name=\"Laptops_Space\", lb=0)\n\n    # Set the objective: maximize total revenue\n    model.setObjective(50 * x + 70 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Space constraint\n    model.addConstr(x + y <= space_limit, name=\"SpaceLimit\")\n    # Cost constraint\n    model.addConstr(12 * x + 15 * y <= max_cost, name=\"CostLimit\")\n    # Labor constraint\n    model.addConstr(2 * x + 3 * y <= max_labor, name=\"LaborLimit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal revenue\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_revenue = optimize_factory_layout()\n    if max_revenue is not None:\n        print(f\"Maximum Revenue: {max_revenue}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 7000.0",
    "task_id": "A018",
    "ground_truth": 7000.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nIn network communication services, bandwidth plays an important role. Below is a bandwidth communication table between several communication nodes, showing the bandwidth between any two nodes. If two nodes cannot be directly connected, the corresponding bandwidth is $0$. It is required to establish a link between node $A$ and node $E$ that must pass through service node $C$ (without loops). The bandwidth of this link is defined as the minimum bandwidth value on the link. Please propose a reasonable link arrangement to maximize the bandwidth of this link and find out the maximum bandwidth.\n\n\\begin{table}[h]\n    \\centering\n    \\begin{tabular}{|c|c|c|c|c|c|}\n        \\hline\n        & A & B & C & D & E \\\\\n        \\hline\n        A & 0 & 90 & 85 & 0 & 65 \\\\\n        \\hline\n        B & 95 & 0 & 70 & 65 & 34 \\\\\n        \\hline\n        C & 60 & 0 & 0 & 88 & 80 \\\\\n        \\hline\n        D & 67 & 30 & 25 & 0 & 84 \\\\\n        \\hline\n        E & 0 & 51 & 0 & 56 & 0 \\\\\n        \\hline\n    \\end{tabular}\n\\end{table}",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_max_bandwidth_path():\n    \"\"\"\n    Solves the problem of finding a path from node A to E via node C\n    that maximizes the bottleneck bandwidth.\n    \"\"\"\n    try:\n        # --- Data ---\n        nodes_map = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}\n        nodes_rev_map = {v: k for k, v in nodes_map.items()}\n        num_nodes = len(nodes_map)\n        all_nodes = range(num_nodes)\n\n        start_node = nodes_map['A']\n        intermediate_node = nodes_map['C']\n        end_node = nodes_map['E']\n\n        # Bandwidth matrix BW[i][j]\n        #       A   B   C   D   E\n        bw_data = [\n            [0, 90, 85, 0, 65],  # A\n            [95, 0, 70, 65, 34],  # B\n            [60, 0, 0, 88, 80],  # C\n            [67, 30, 25, 0, 84],  # D\n            [0, 51, 0, 56, 0]  # E\n        ]\n\n        max_possible_bandwidth = 0\n        for row in bw_data:\n            for val in row:\n                if val > max_possible_bandwidth:\n                    max_possible_bandwidth = val\n        if max_possible_bandwidth == 0:  # Should not happen with given data\n            max_possible_bandwidth = 1000  # A large number\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"MaxBandwidthPathViaC\")\n\n        # --- Decision Variables ---\n        # x[i,j]: 1 if link (i,j) is in path A to C\n        x = model.addVars(all_nodes,\n                          all_nodes,\n                          vtype=GRB.BINARY,\n                          name=\"x_path_AC\")\n        # y[i,j]: 1 if link (i,j) is in path C to E\n        y = model.addVars(all_nodes,\n                          all_nodes,\n                          vtype=GRB.BINARY,\n                          name=\"y_path_CE\")\n\n        # B_overall: Overall bottleneck bandwidth of the A-C-E path\n        B_overall = model.addVar(name=\"OverallBandwidth\",\n                                 lb=0.0,\n                                 vtype=GRB.CONTINUOUS)\n\n        # Remove self-loops and links with zero bandwidth\n        for i in all_nodes:\n            x[i, i].UB = 0\n            y[i, i].UB = 0\n            for j in all_nodes:\n                if i == j: continue\n                if bw_data[i][j] == 0:\n                    x[i, j].UB = 0\n                    y[i, j].UB = 0\n\n        # --- Objective Function: Maximize B_overall ---\n        model.setObjective(B_overall, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # Path A (start_node) to C (intermediate_node) using x_vars\n        # 1. Flow out of start_node A for path x\n        model.addConstr(\n            gp.quicksum(x[start_node, j] for j in all_nodes\n                        if j != start_node) == 1, \"FlowOut_A_x\")\n        # 2. No flow into start_node A for path x\n        model.addConstr(\n            gp.quicksum(x[j, start_node] for j in all_nodes\n                        if j != start_node) == 0, \"FlowIn_A_x\")\n        # 3. Flow into intermediate_node C for path x\n        model.addConstr(\n            gp.quicksum(x[i, intermediate_node] for i in all_nodes\n                        if i != intermediate_node) == 1, \"FlowIn_C_x\")\n        # 4. No flow out of intermediate_node C for path x\n        model.addConstr(\n            gp.quicksum(x[intermediate_node, j] for j in all_nodes\n                        if j != intermediate_node) == 0, \"FlowOut_C_x\")\n        # 5. Flow conservation for other nodes in path x\n        for k in all_nodes:\n            if k != start_node and k != intermediate_node:\n                model.addConstr(gp.quicksum(x[i, k] for i in all_nodes\n                                            if i != k) == gp.quicksum(\n                                                x[k, j] for j in all_nodes\n                                                if j != k),\n                                name=f\"FlowCons_x_{k}\")\n                # Ensure intermediate nodes are visited at most once\n                model.addConstr(\n                    gp.quicksum(x[i, k] for i in all_nodes if i != k) <= 1,\n                    f\"VisitOnce_x_{k}\")\n\n        # Path C (intermediate_node) to E (end_node) using y_vars\n        # 6. Flow out of intermediate_node C for path y\n        model.addConstr(\n            gp.quicksum(y[intermediate_node, j] for j in all_nodes\n                        if j != intermediate_node) == 1, \"FlowOut_C_y\")\n        # 7. No flow into intermediate_node C for path y\n        model.addConstr(\n            gp.quicksum(y[j, intermediate_node] for j in all_nodes\n                        if j != intermediate_node) == 0, \"FlowIn_C_y\")\n        # 8. Flow into end_node E for path y\n        model.addConstr(\n            gp.quicksum(y[i, end_node] for i in all_nodes\n                        if i != end_node) == 1, \"FlowIn_E_y\")\n        # 9. No flow out of end_node E for path y\n        model.addConstr(\n            gp.quicksum(y[end_node, j] for j in all_nodes\n                        if j != end_node) == 0, \"FlowOut_E_y\")\n        # 10. Flow conservation for other nodes in path y\n        for k in all_nodes:\n            if k != intermediate_node and k != end_node:\n                model.addConstr(gp.quicksum(y[i, k] for i in all_nodes\n                                            if i != k) == gp.quicksum(\n                                                y[k, j] for j in all_nodes\n                                                if j != k),\n                                name=f\"FlowCons_y_{k}\")\n                # Ensure intermediate nodes are visited at most once\n                model.addConstr(\n                    gp.quicksum(y[i, k] for i in all_nodes if i != k) <= 1,\n                    f\"VisitOnce_y_{k}\")\n\n        # 11. Node Disjointness (except at C)\n        # Nodes B, D (indices 1, 3) cannot be intermediate in both paths.\n        # Node A (0) cannot be in path y. Node E (4) cannot be in path x.\n        for k in all_nodes:\n            if k != intermediate_node:  # For all nodes except C\n                # If node k is entered in path x, it cannot be entered in path y\n                model.addConstr(gp.quicksum(x[i, k]\n                                            for i in all_nodes if i != k) +\n                                gp.quicksum(y[i, k]\n                                            for i in all_nodes if i != k) <= 1,\n                                name=f\"NodeDisjoint_{k}\")\n\n        # 12. Bandwidth Definition\n        for i in all_nodes:\n            for j in all_nodes:\n                if i == j or bw_data[i][j] == 0:\n                    continue  # Skip self-loops and zero-bandwidth links\n                # If x[i,j] is 1, then B_overall <= bw_data[i][j]\n                model.addConstr(B_overall <= bw_data[i][j] +\n                                max_possible_bandwidth * (1 - x[i, j]),\n                                name=f\"B_limit_x_{i}_{j}\")\n                # If y[i,j] is 1, then B_overall <= bw_data[i][j]\n                model.addConstr(B_overall <= bw_data[i][j] +\n                                max_possible_bandwidth * (1 - y[i, j]),\n                                name=f\"B_limit_y_{i}_{j}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n        model.setParam('MIPGap', 0.001)  # Set a small MIP gap\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal link arrangement found.\")\n            print(\n                f\"Maximum Path Bandwidth (A through C to E): {B_overall.X:.2f}\"\n            )\n\n            path_AC_str = nodes_rev_map[start_node]\n            curr = start_node\n            visited_in_ac = {start_node}\n            for _ in range(num_nodes):  # Max possible length\n                found_next = False\n                for j_node in all_nodes:\n                    if curr != j_node and x[curr, j_node].X > 0.5:\n                        path_AC_str += f\" -> {nodes_rev_map[j_node]}\"\n                        curr = j_node\n                        visited_in_ac.add(curr)\n                        found_next = True\n                        break\n                if curr == intermediate_node or not found_next:\n                    break\n            print(f\"  Path A to C: {path_AC_str}\")\n\n            path_CE_str = nodes_rev_map[intermediate_node]\n            curr = intermediate_node\n            visited_in_ce = {intermediate_node}\n            for _ in range(num_nodes):  # Max possible length\n                found_next = False\n                for j_node in all_nodes:\n                    if curr != j_node and y[curr, j_node].X > 0.5:\n                        path_CE_str += f\" -> {nodes_rev_map[j_node]}\"\n                        curr = j_node\n                        visited_in_ce.add(curr)\n                        found_next = True\n                        break\n                if curr == end_node or not found_next:\n                    break\n            print(f\"  Path C to E: {path_CE_str}\")\n\n            print(\"\\n  Links used in A-C path and their bandwidths:\")\n            for i in all_nodes:\n                for j in all_nodes:\n                    if i != j and x[i, j].X > 0.5:\n                        print(\n                            f\"    {nodes_rev_map[i]} -> {nodes_rev_map[j]} (BW: {bw_data[i][j]})\"\n                        )\n\n            print(\"  Links used in C-E path and their bandwidths:\")\n            for i in all_nodes:\n                for j in all_nodes:\n                    if i != j and y[i, j].X > 0.5:\n                        print(\n                            f\"    {nodes_rev_map[i]} -> {nodes_rev_map[j]} (BW: {bw_data[i][j]})\"\n                        )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No path from A to E via C could be found or satisfies constraints.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"bandwidth_path_iis.ilp\")\n            print(\"IIS written to bandwidth_path_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_max_bandwidth_path()\n```\n\nThe optimal value is: 84.0",
    "task_id": "B099",
    "ground_truth": 84.0,
    "problem_domain": "Network Flow",
    "modeling_type": "MILP",
    "industry_sector": "Telecommunications"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nTwo steel furnaces at a steel plant each use two methods of steelmaking simultaneously. The first method takes $a=2$ hours per furnace and costs $m=50$ in fuel expenses; the second method takes $b=3$ hours per furnace and costs $n=70$ in fuel expenses. Assuming each furnace produces $k=10$ tons of steel regardless of the method used, and that at least $d=30$ tons of steel must be produced within $c=12$ hours, how should these two methods be allocated to minimize fuel expenses? Formulate this problem as a linear programming model.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_steelmaking_allocation():\n    \"\"\"\n    Solves the steelmaking allocation problem to minimize fuel expenses\n    subject to furnace time and steel production constraints.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        # Method 1\n        time_m1 = 2.0  # hours per operation\n        cost_m1 = 50.0  # fuel expense per operation\n\n        # Method 2\n        time_m2 = 3.0  # hours per operation\n        cost_m2 = 70.0  # fuel expense per operation\n\n        # Production\n        steel_per_op = 10.0  # tons per operation (same for both methods)\n\n        # Constraints\n        min_total_steel = 30.0  # tons\n        max_furnace_hours = 12.0  # hours available per furnace\n\n        num_furnaces = 2\n        num_methods = 2\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"Steelmaking_Allocation\")\n\n        # --- Decision Variables ---\n        # x[f,m]: number of times furnace f uses method m\n        # f=0 for Furnace 1, f=1 for Furnace 2\n        # m=0 for Method 1, m=1 for Method 2\n        x = model.addVars(num_furnaces,\n                          num_methods,\n                          name=\"x\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # For easier reference using problem's notation:\n        # x11 = x[0,0] (Furnace 1, Method 1)\n        # x12 = x[0,1] (Furnace 1, Method 2)\n        # x21 = x[1,0] (Furnace 2, Method 1)\n        # x22 = x[1,1] (Furnace 2, Method 2)\n\n        # --- Objective Function: Minimize Total Fuel Expenses ---\n        objective = cost_m1 * (x[0,0] + x[1,0]) + \\\n                    cost_m2 * (x[0,1] + x[1,1])\n        model.setObjective(objective, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Time Constraint for Furnace 1 (f=0)\n        model.addConstr(time_m1 * x[0, 0] + time_m2 * x[0, 1]\n                        <= max_furnace_hours,\n                        name=\"Time_Furnace1\")\n\n        # 2. Time Constraint for Furnace 2 (f=1)\n        model.addConstr(time_m1 * x[1, 0] + time_m2 * x[1, 1]\n                        <= max_furnace_hours,\n                        name=\"Time_Furnace2\")\n\n        # 3. Steel Production Constraint\n        total_steel_produced = steel_per_op * (x[0, 0] + x[0, 1] + x[1, 0] +\n                                               x[1, 1])\n        model.addConstr(total_steel_produced >= min_total_steel,\n                        name=\"Min_Steel_Production\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal allocation found.\")\n            print(f\"Minimum Total Fuel Expenses: {model.ObjVal:.2f} Klunz\")\n\n            print(\n                \"\\nOptimal Allocation (Number of times each method is used):\")\n            print(f\"  Furnace 1, Method 1 (x11): {x[0,0].X:.2f} times\")\n            print(f\"  Furnace 1, Method 2 (x12): {x[0,1].X:.2f} times\")\n            print(f\"  Furnace 2, Method 1 (x21): {x[1,0].X:.2f} times\")\n            print(f\"  Furnace 2, Method 2 (x22): {x[1,1].X:.2f} times\")\n\n            # Verification of constraints\n            print(\"\\nVerification:\")\n            f1_hours = time_m1 * x[0, 0].X + time_m2 * x[0, 1].X\n            f2_hours = time_m1 * x[1, 0].X + time_m2 * x[1, 1].X\n            print(\n                f\"  Furnace 1 Hours Used: {f1_hours:.2f} / {max_furnace_hours}\"\n            )\n            print(\n                f\"  Furnace 2 Hours Used: {f2_hours:.2f} / {max_furnace_hours}\"\n            )\n\n            total_steel = steel_per_op * (x[0, 0].X + x[0, 1].X + x[1, 0].X +\n                                          x[1, 1].X)\n            print(\n                f\"  Total Steel Produced: {total_steel:.2f} tons (Min required: {min_total_steel})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and parameters.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"steel_allocation_iis.ilp\")\n            # print(\"IIS written to steel_allocation_iis.ilp\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_steelmaking_allocation()\n```\n\nThe optimal value is: 150.0",
    "task_id": "B041",
    "ground_truth": 150.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA science show preforms two different demonstrations, demonstration 1 and demonstration 2. In demonstration 1, 10 units of mint and 20 units of the active ingredient is used to make 25 units of minty foam. In demonstration 2, 12 units of mint and 15 units of the active ingredient is used to make 18 units of minty foam. In addition, demonstration 1 creates 5 units of black tar while demonstration 2 creates 3 units of black tar. The show has available 120 units of mint and 100 units of active ingredients. If at most 50 units of black tar can be produced, how many of each demonstration should be done to maximize the amount of minty foam produced?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_minty_foam():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    model = Model(\"MintyFoamOptimization\")\n    \n    # Decision variables: number of demonstrations\n    x1 = model.addVar(vtype=GRB.INTEGER, name=\"Demo1\")\n    x2 = model.addVar(vtype=GRB.INTEGER, name=\"Demo2\")\n    \n    # Set the objective: maximize total minty foam\n    model.setObjective(25 * x1 + 18 * x2, GRB.MAXIMIZE)\n    \n    # Add resource constraints\n    model.addConstr(10 * x1 + 12 * x2 <= 120, \"MintConstraint\")\n    model.addConstr(20 * x1 + 15 * x2 <= 100, \"ActiveIngredientConstraint\")\n    model.addConstr(5 * x1 + 3 * x2 <= 50, \"BlackTarConstraint\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_minty_foam = optimize_minty_foam()\n    if max_minty_foam is not None:\n        print(f\"Maximum Total Minty Foam Produced: {max_minty_foam}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 125.0",
    "task_id": "A090",
    "ground_truth": 125.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Entertainment"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nSuppose a certain animal needs at least $700 \\mathrm{~g}$ of protein, $30 \\mathrm{~g}$ of minerals, and $100 \\mathrm{mg}$ of vitamins daily. There are 5 types of feed available, and the nutritional content and price per gram of each type of feed are shown in Table 1-5:\nTry to formulate a linear programming model that meets the animal's growth needs while minimizing the cost of selecting the feed.\nTable 1-6\n| Feed | Protein (g) | Minerals (g) | Vitamins (mg) | Price (/kg) | Feed | Protein (g) | Minerals (g) | Vitamins (mg) | Price (/kg) |\n|------|-------------|--------------|---------------|--------------|------|-------------|--------------|---------------|--------------|\n| 1    | 3           | 1            | 0.5           | 0.2          | 4    | 6           | 2            | 2             | 0.3          |\n| 2    | 2           | 0.5          | 1             | 0.7          | 5    | 18          | 0.5          | 0.8           | 0.8          |\n| 3    | 1           | 0.2          | 0.2           | 0.4          |      |             |              |               |              |",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_feed_mix_problem():\n    \"\"\"\n    Solves the animal feed mix optimization problem using Gurobi.\n    The goal is to minimize the cost of feed while meeting daily nutritional requirements.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Nutritional content per kg of feed: (Protein (g), Minerals (g), Vitamins (mg))\n        # Price per kg of feed (/kg)\n\n        feeds_data = {\n            # Feed_ID: [Protein, Minerals, Vitamins, Price]\n            1: [3, 1, 0.5, 0.2],\n            2: [2, 0.5, 1, 0.7],\n            3: [1, 0.2, 0.2, 0.4],\n            4: [6, 2, 2, 0.3],\n            5: [18, 0.5, 0.8, 0.8]\n        }\n\n        feed_ids = list(feeds_data.keys())\n\n        # Daily nutritional requirements\n        min_protein = 700  # g\n        min_minerals = 30  # g\n        min_vitamins = 100  # mg\n\n        # --- Create a new model ---\n        model = gp.Model(\"FeedMixOptimization\")\n\n        # --- Decision Variables ---\n        # x[i]: amount of feed i to use, in kilograms (kg)\n        x = model.addVars(feed_ids, name=\"x\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function ---\n        # Minimize the total cost of the feed mixture\n        # Cost = sum(price_i * x_i for i in feeds)\n        total_cost = gp.quicksum(feeds_data[i][3] * x[i] for i in feed_ids)\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Protein Requirement\n        model.addConstr(\n            gp.quicksum(feeds_data[i][0] * x[i] for i in feed_ids)\n            >= min_protein, \"ProteinRequirement\")\n\n        # 2. Minerals Requirement\n        model.addConstr(\n            gp.quicksum(feeds_data[i][1] * x[i] for i in feed_ids)\n            >= min_minerals, \"MineralsRequirement\")\n\n        # 3. Vitamins Requirement\n        model.addConstr(\n            gp.quicksum(feeds_data[i][2] * x[i] for i in feed_ids)\n            >= min_vitamins, \"VitaminsRequirement\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal feed mix found.\")\n            print(f\"Minimum Cost: {model.objVal:.2f} \")\n            print(\"\\nAmount of each feed to use (kg):\")\n            total_feed_kg = 0\n            for i in feed_ids:\n                if x[i].X > 1e-6:  # Print only if the amount is significant\n                    print(f\"  Feed {i}: {x[i].X:.2f} kg\")\n                    total_feed_kg += x[i].X\n            print(f\"\\nTotal kilograms of feed: {total_feed_kg:.2f} kg\")\n\n            # Verification of nutritional intake\n            achieved_protein = sum(feeds_data[i][0] * x[i].X for i in feed_ids)\n            achieved_minerals = sum(feeds_data[i][1] * x[i].X\n                                    for i in feed_ids)\n            achieved_vitamins = sum(feeds_data[i][2] * x[i].X\n                                    for i in feed_ids)\n            print(\"\\nNutritional Intake with this mix:\")\n            print(\n                f\"  Protein: {achieved_protein:.2f} g (Required: >= {min_protein} g)\"\n            )\n            print(\n                f\"  Minerals: {achieved_minerals:.2f} g (Required: >= {min_minerals} g)\"\n            )\n            print(\n                f\"  Vitamins: {achieved_vitamins:.2f} mg (Required: >= {min_vitamins} mg)\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The nutritional requirements cannot be met with the given feeds under the specified constraints.\"\n            )\n            # You can compute and print IIS (Irreducible Inconsistent Subsystem) to help debug\n            # model.computeIIS()\n            # model.write(\"feed_mix_iis.ilp\")\n            # print(\"IIS written to feed_mix_iis.ilp. Review this file to find conflicting constraints.\")\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_feed_mix_problem()\n```\n\nThe optimal value is: 32.43589743589744",
    "task_id": "B029",
    "ground_truth": 32.43589743589744,
    "problem_domain": "Blending",
    "modeling_type": "LP",
    "industry_sector": "Agriculture"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA village delivers mail to nearby villages either by runners or canoers. Runners can carry three bags of mail each time and takes 4 hours. Canoers can carry ten bags of mail each time and takes 2 hours. At most 33% of deliveries can be by canoe. Additionally, the village can spare at most 200 total hours and at least 4 runners must be used. How many of each way to deliver must be used to maximize the total amount of mail that can be delivered?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MailDeliveryOptimization\")\n\n# Parameters\nBr = 3  # bags per delivery by runners\nTr = 4  # hours per delivery by runners\nBc = 10 # bags per delivery by canoers\nTc = 2  # hours per delivery by canoers\nPc = 0.33 # maximum proportion of deliveries by canoe\nH = 200  # maximum total hours available\nR_min = 4 # minimum number of runners to be used\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"runners\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"canoers\")\n\n# Objective: Maximize the total amount of mail delivered\nmodel.setObjective(Br * x + Bc * y, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(Tr * x + Tc * y <= H, \"TotalHours\") # C1\nmodel.addConstr(y <= Pc * (x + y), \"CanoeProportion\") # C2\nmodel.addConstr(x >= R_min, \"MinRunners\") # C3\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 310.0",
    "task_id": "F135",
    "ground_truth": 310.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Logistics"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nIn the bustling world of retail, SupplyChain Solutions is faced with the challenge of efficiently distributing products to eight eager retail stores. With four potential distribution centers to choose from, each with its own unique costs and capacities, the company aims to devise a strategic plan to minimize overall expenses. This plan must account for the initial cost of opening distribution centers and the ongoing expenses of transporting goods to stores. The objective is clear: to fulfill the demand of each retail store at the lowest possible total cost.\n\nGiven Data:\n- Number of Potential Distribution Centers: 4\n- Number of Retail Stores Needing Supply: 8\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $5 to Store 1, $5 to Store 2, $2 to Store 3, $3 to Store 4, $3 to Store 5, $3 to Store 6, $5 to Store 7, $4 to Store 8\n- From Center 2: $3 to Store 1, $5 to Store 2, $2 to Store 3, $4 to Store 4, $2 to Store 5, $4 to Store 6, $5 to Store 7, $1 to Store 8\n- From Center 3: $4 to Store 1, $2 to Store 2, $5 to Store 3, $4 to Store 4, $1 to Store 5, $1 to Store 6, $3 to Store 7, $3 to Store 8\n- From Center 4: $2 to Store 1, $4 to Store 2, $4 to Store 3, $3 to Store 4, $4 to Store 5, $4 to Store 6, $1 to Store 7, $3 to Store 8\n\nDemand of Each Retail Store (in units):\n- Store 1: 884 units\n- Store 2: 420 units\n- Store 3: 566 units\n- Store 4: 673 units\n- Store 5: 787 units\n- Store 6: 1000 units\n- Store 7: 715 units\n- Store 8: 413 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1041 units\n- Center 2: 1576 units\n- Center 3: 1364 units\n- Center 4: 1697 units\n\nQuestion:\nWhat is the optimal total cost for SupplyChain Solutions to open distribution centers and transport goods to meet all retail stores' demands? This cost includes both the opening costs of the centers and the transportation costs of supplying the stores.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nI = range(4)  # Distribution centers\nJ = range(8)  # Retail stores\n\n# Parameters\nF = [151000, 192000, 114000, 171000]  # Opening costs\nc = [\n    [5, 5, 2, 3, 3, 3, 5, 4],\n    [3, 5, 2, 4, 2, 4, 5, 1],\n    [4, 2, 5, 4, 1, 1, 3, 3],\n    [2, 4, 4, 3, 4, 4, 1, 3]\n]  # Transportation costs\nd = [884, 420, 566, 673, 787, 1000, 715, 413]  # Demands\nS = [1041, 1576, 1364, 1697]  # Supply capacities\n\n# Variables\nx = model.addVars(I, J, name=\"x\", vtype=GRB.CONTINUOUS, lb=0.0)\ny = model.addVars(I, name=\"y\", vtype=GRB.BINARY)\n\n# Objective\nmodel.setObjective(\n    gp.quicksum(F[i] * y[i] for i in I) +\n    gp.quicksum(c[i][j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Fulfill the demand at each retail store (C1)\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == d[j] for j in J),\n    name=\"Demand\"\n)\n\n# Do not exceed supply capacity of the distribution centers (C2)\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= S[i] * y[i] for i in I),\n    name=\"SupplyCapacity\"\n)\n\n# Ensure x_{ij} = 0 if the distribution center i is not open (C3)\nmodel.addConstrs(\n    (x[i, j] <= d[j] * y[i] for i in I for j in J),\n    name=\"OpenCenter\"\n)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 637573.0",
    "task_id": "E096",
    "ground_truth": 637573.0,
    "problem_domain": "Facility Location",
    "modeling_type": "MILP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nIn a science fair, there are two types of tables that can be used to display the childrens science experiments. At the circular tables, 4 poster boards and 5 participants can fit around the table to cater to 8 guests. At the rectangular tables, 4 poster boards and 4 participants can fit around the table to cater to 12 guests. However, each circular table takes up 15 units of space while each rectangular table takes up 20 units of space. The science fair has must be able to fit at least 500 participants and 300 poster boards. If the science fair has available 1900 units of space, how many of each type of table should be set up to maximize the number of catered guests?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nT_c = 15  # Space units taken by one circular table\nT_r = 20  # Space units taken by one rectangular table\nP_c = 5   # Participants per circular table\nP_r = 4   # Participants per rectangular table\nB_c = 4   # Poster boards per circular table\nB_r = 4   # Poster boards per rectangular table\nG_c = 8   # Guests catered by one circular table\nG_r = 12  # Guests catered by one rectangular table\nSpace = 1900  # Total available space units\nMin_Participants = 500  # Minimum number of participants needed\nMin_Boards = 300  # Minimum number of poster boards needed\n\n# Variables\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"x_c\")  # Number of circular tables\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")  # Number of rectangular tables\n\n# Objective\nmodel.setObjective(G_c * x_c + G_r * x_r, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(T_c * x_c + T_r * x_r <= Space, \"SpaceConstraint\")\nmodel.addConstr(P_c * x_c + P_r * x_r >= Min_Participants, \"MinParticipantsConstraint\")\nmodel.addConstr(B_c * x_c + B_r * x_r >= Min_Boards, \"MinBoardsConstraint\")\nmodel.addConstr(x_c >= 0, \"NonNegativityConstraint_Circular\")\nmodel.addConstr(x_r >= 0, \"NonNegativityConstraint_Rectangular\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 1080.0",
    "task_id": "F108",
    "ground_truth": 1080.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Event Management"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA bank can build small and large branches to serve their customers. A small branch can serve 50 customers per day and requires 10 bank tellers. A large branch can serve 100 customers per day and requires 15 bank tellers. The bank has available 200 bank tellers and needs to be able to serve at least 1200 customers per day. How many of each branch size should they build to minimize the total number of branches needed?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_branches():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"BankBranches\")\n\n    # Decision variables: number of small and large branches\n    x = m.addVar(vtype=GRB.INTEGER, name=\"small_branches\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"large_branches\", lb=0)\n\n    # Set the objective: minimize total number of branches\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add customer service constraint\n    m.addConstr(50 * x + 100 * y >= 1200, name=\"CustomerService\")\n\n    # Add teller constraint\n    m.addConstr(10 * x + 15 * y <= 200, name=\"TellerAvailability\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal value of the objective function\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_branches = optimize_branches()\n    if min_branches is not None:\n        print(f\"Minimum Total Number of Branches: {min_branches}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 12.0",
    "task_id": "A053",
    "ground_truth": 12.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Finance"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nAn amusement park has two types of games: throwing and climbing games. Throwing games attract 15 customers every hour and climbing games attract 8 customers every hour. Throwing games costs the amusement park $2 in prizes per hour whereas climbing games cost $3 in prizes per hour. Since throwing games yield the most profit, there must be at least twice as many throwing games as climbing games. However, at least 5 games must be climbing. If the amusement park can have at most $100 in prizes every hour, maximize the total number of customers attracted every hour.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_amusement_park():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"AmusementPark\")\n\n    # Decision variables\n    T = m.addVar(name=\"ThrowingGames\", vtype=GRB.INTEGER, lb=0)\n    C = m.addVar(name=\"ClimbingGames\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: maximize total customers\n    m.setObjective(15 * T + 8 * C, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(2 * T + 3 * C <= 100, name=\"PrizeLimit\")\n    m.addConstr(T >= 2 * C, name=\"ThrowingAtLeastTwiceClimbing\")\n    m.addConstr(C >= 5, name=\"MinimumClimbing\")\n    \n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum number of customers attracted\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_customers = optimize_amusement_park()\n    if max_customers is not None:\n        print(f\"Maximum Customers Attracted: {max_customers}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 670.0",
    "task_id": "A202",
    "ground_truth": 670.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Recreation & Entertainment"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA patient takes anxiety medication and anti-depressants one after the other. Each unit of anxiety medication takes 3 minutes to be effective while each unit of anti-depressant takes 5 minutes to be effective. The patient must take at least 100 units of medication and at least 30 should be anxiety medication. Since the anxiety medication is strong, the patient can take at most twice the amount of anxiety medication as anti-depressants. How many units of each should the patient take to minimize the total time it take for the medication to be effective?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nt_a = 3  # Time for anxiety medication\nt_d = 5  # Time for anti-depressant\nM = 100  # Minimum total units of medication\nA_min = 30  # Minimum units of anxiety medication\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Units of anxiety medication\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Units of anti-depressant\n\n# Objective: Minimize total time for medication to be effective\nmodel.setObjective(t_a * x + t_d * y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(x + y >= M, \"C1\")  # Total medication constraint\nmodel.addConstr(x >= A_min, \"C2\")  # Minimum anxiety medication constraint\nmodel.addConstr(x <= 2 * y, \"C3\")  # Ratio constraint for anxiety medication\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 368.0",
    "task_id": "F018",
    "ground_truth": 368.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA patient takes anxiety medication and anti-depressants one after the other. Each unit of anxiety medication takes 3 minutes to be effective while each unit of anti-depressant takes 5 minutes to be effective. The patient must take at least 100 units of medication and at least 30 should be anxiety medication. Since the anxiety medication is strong, the patient can take at most twice the amount of anxiety medication as anti-depressants. How many units of each should the patient take to minimize the total time it take for the medication to be effective?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_medication_time(\n    min_total_units=100,\n    min_anxiety_units=30,\n    max_ratio=2\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Medication_Minimize_Time\")\n\n    # Decision variables: number of units of each medication\n    x = model.addVar(name=\"x\", lb=0, vtype=GRB.INTEGER)  # anxiety medication\n    y = model.addVar(name=\"y\", lb=0, vtype=GRB.INTEGER)  # anti-depressants\n\n    # Set objective: minimize total time\n    model.setObjective(3 * x + 5 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    model.addConstr(x + y >= min_total_units, name=\"total_units\")\n    model.addConstr(x >= min_anxiety_units, name=\"min_anxiety\")\n    model.addConstr(x <= max_ratio * y, name=\"ratio_constraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the minimal total time\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_medication_time()\n    if min_time is not None:\n        print(f\"Minimum Total Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 368.0",
    "task_id": "A103",
    "ground_truth": 368.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "MILP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA food delivery person can either have shifts on bikes or scooters. A shift on a bike can deliver 10 orders, takes 5 units of energy, and brings in $50 on tips because it is faster. A shift on a scooter can deliver 7 orders, takes 6 units of energy, and brings in $43 on tips.  The delivery person has available 40 shifts a month and has 230 units of energy and must bring at least 320 orders. He must have at least 5 shifts on a scooter because bikes are harder to get. How many shifts on each type of transportation should the delivery person schedule to maximize tips received?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define parameters\nT_b = 50  # Tips per bike shift\nT_s = 43  # Tips per scooter shift\nO_b = 10  # Orders delivered per bike shift\nO_s = 7   # Orders delivered per scooter shift\nE_b = 5   # Energy consumed per bike shift\nE_s = 6   # Energy consumed per scooter shift\nS_total = 40  # Total available shifts\nE_total = 230 # Total available energy\nO_min = 320   # Minimum required orders\nS_s_min = 5   # Minimum required scooter shifts\n\n# Define variables\nx_b = model.addVar(vtype=GRB.INTEGER, name=\"x_b\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n\n# Set objective\nmodel.setObjective(T_b * x_b + T_s * x_s, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x_b + x_s <= S_total, name=\"TotalShifts\")          # C1\nmodel.addConstr(E_b * x_b + E_s * x_s <= E_total, name=\"TotalEnergy\") # C2\nmodel.addConstr(O_b * x_b + O_s * x_s >= O_min, name=\"MinOrders\")  # C3\nmodel.addConstr(x_s >= S_s_min, name=\"MinScooterShifts\")           # C4\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 1965.0",
    "task_id": "F111",
    "ground_truth": 1965.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Gig Economy"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA farmer decides to move his cows to a nearby farm using helicopters and trucks. A helicopter can take 3 cows per trip and creates 5 units of pollution. A truck can take 7 cows per trip and creates 10 units of pollution. The farmer needs to transport 80 cows and he only has enough money for at most 8 truck trips. How many of each type of trip should be taken to minimize the total amount of pollution produced?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_cow_transport():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"CowTransport\")\n\n    # Decision variables\n    h = m.addVar(vtype=GRB.INTEGER, name=\"HelicopterTrips\", lb=0)\n    t = m.addVar(vtype=GRB.INTEGER, name=\"TruckTrips\", lb=0)\n\n    # Set objective: minimize total pollution\n    m.setObjective(5 * h + 10 * t, GRB.MINIMIZE)\n\n    # Add constraints\n    # Ensure at least 80 cows are transported\n    m.addConstr(3 * h + 7 * t >= 80, \"CowsTransported\")\n    # Limit on number of truck trips\n    m.addConstr(t <= 8, \"TruckLimit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total pollution\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pollution = optimize_cow_transport()\n    if min_pollution is not None:\n        print(f\"Minimum Total Pollution: {min_pollution}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 120.0",
    "task_id": "A137",
    "ground_truth": 120.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Agriculture"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA construction company in the tropics uses cows and elephants to carry bricks. A cow can carry 20 bricks on its back while an elephant can carry 50 bricks on its back. To avoid having elephants create too much traffic, the number of elephant cannot exceed the number of cows. In addition, there can be at most twice the number of cows as elephants. If the company needs to transport at least 1000 bricks, find the minimum number of animals, cows and elephants, that can be used..",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef minimize_animals(\n    bricks_required=1000,\n    bricks_per_cow=20,\n    bricks_per_elephant=50\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Minimize Animals\")\n\n    # Decision variables: number of cows and elephants\n    x = model.addVar(vtype=GRB.INTEGER, name=\"cows\", lb=0)\n    y = model.addVar(vtype=GRB.INTEGER, name=\"elephants\", lb=0)\n\n    # Set the objective: minimize total animals\n    model.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Brick transportation constraint\n    model.addConstr(bricks_per_cow * x + bricks_per_elephant * y >= bricks_required, \"bricks_constraint\")\n    # Elephants cannot exceed cows\n    model.addConstr(y <= x, \"elephants_not_exceed_cows\")\n    # At most twice the number of cows as elephants\n    model.addConstr(x <= 2 * y, \"cows_at_most_twice_elephants\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_animals = x.X + y.X\n        return total_animals\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    total_animals = minimize_animals()\n    if total_animals is not None:\n        print(f\"Minimum total number of animals: {total_animals}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 29.0",
    "task_id": "A160",
    "ground_truth": 29.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Construction"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA factory produces three types of products, I, II, and III. Each product requires two processing stages, A and B. It is assumed that the factory has two types of equipment to complete the A processing stage, denoted as A1 and A2; and two types of equipment to complete the B processing stage, denoted as B1 and B2. Product I can be processed on any type of A equipment, but for the B processing stage, it can only be processed on B1 equipment; Product III can only be processed on A2 and B2 equipment. The processing time per piece, raw material cost, sales price of products, effective machine hours for various equipment, and costs of equipment at full capacity are given in Table 1-18. The requirement is to arrange the optimal production plan so that the factory's profit is maximized.\n\nTable 1-18\n| Equipment   | Product I | Product II | Product III | Effective Machine Hours | Cost of Equipment at Full Capacity (Yuan) |\n|-------------|-----------|------------|-------------|------------------------|-------------------------------------------|\n| A1          | 5         | 10         |             | 10000                 | 321                                       |\n| A2          | 7         | 9          | 12          | 4000                  | 250                                       |\n| B1          | 6         | 8          |             | 7000                  | 783                                       |\n| B2          | 4         |            | 11          | 4000                  | 200                                       |\n| B3          | 7         |            |             |                       |                                           |\n| Raw Material Cost (Yuan/Piece) | 0.25      | 0.35       | 0.50       |                        |                                           |\n| Unit Price (Yuan/Piece)        | 1.25      | 2.00       | 2.80       |                        |                                           |",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_factory_production_revised():\n    \"\"\"\n    Solves the revised factory production planning problem to maximize profit.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"FactoryProductionOptimizationRevised\")\n\n        # --- Data ---\n        # Processing times (hours/piece)\n        proc_times = {\n            ('I', 'A1'): 5,\n            ('I', 'A2'): 7,\n            ('II', 'A1'): 10,\n            ('II', 'A2'): 9,\n            ('III', 'A2'): 12,\n            ('I', 'B1'): 6,\n            ('II', 'B1'): 8,\n            ('III', 'B2'): 11\n        }\n\n        # Effective machine hours (capacity)\n        capacities = {'A1': 10000, 'A2': 4000, 'B1': 7000, 'B2': 4000}\n\n        # Operating costs at full capacity (Yuan)\n        ocfc = {'A1': 321, 'A2': 250, 'B1': 783, 'B2': 200}\n\n        # Variable operating costs per hour (Yuan/hr)\n        # It's good practice to calculate this precisely.\n        voc = {\n            m: ocfc[m] / capacities[m] if capacities[m] > 0 else 0\n            for m in capacities\n        }\n\n        # Raw material costs (Yuan/piece)\n        rmc = {'I': 0.25, 'II': 0.35, 'III': 0.50}\n\n        # Unit sale prices (Yuan/piece)\n        sp = {'I': 1.25, 'II': 2.00, 'III': 2.80}\n\n        products = ['I', 'II', 'III']\n\n        # --- Decision Variables ---\n        # X_p: Total pieces of product p to produce\n        X = model.addVars(products, name=\"X\", lb=0.0, vtype=GRB.INTEGER)\n\n        # x_pm: Quantity of product p processed on specific machine m, based on allowed routes\n        # Process A variables\n        x_IA1 = model.addVar(name=\"x_I_A1\", lb=0.0, vtype=GRB.INTEGER)\n        x_IA2 = model.addVar(name=\"x_I_A2\", lb=0.0, vtype=GRB.INTEGER)\n        x_IIA1 = model.addVar(name=\"x_II_A1\", lb=0.0, vtype=GRB.INTEGER)\n        x_IIA2 = model.addVar(name=\"x_II_A2\", lb=0.0, vtype=GRB.INTEGER)\n        x_IIIA2 = model.addVar(name=\"x_III_A2\", lb=0.0,\n                               vtype=GRB.INTEGER)  # Product III only on A2\n\n        # Process B variables\n        x_IB1 = model.addVar(name=\"x_I_B1\", lb=0.0,\n                             vtype=GRB.INTEGER)  # Product I only on B1\n        x_IIB1 = model.addVar(name=\"x_II_B1\", lb=0.0,\n                              vtype=GRB.INTEGER)  # Product II only on B1\n        x_IIIB2 = model.addVar(name=\"x_III_B2\", lb=0.0,\n                               vtype=GRB.INTEGER)  # Product III only on B2\n\n        # --- Objective Function: Maximize Profit ---\n        # Profit = Total Revenue - Total Raw Material Cost - Total Variable Operating Cost\n\n        total_revenue = gp.quicksum(sp[p] * X[p] for p in products)\n        total_rmc = gp.quicksum(rmc[p] * X[p] for p in products)\n\n        # Variable operating costs for each machine\n        op_cost_A1 = (proc_times[('I', 'A1')] * x_IA1 +\n                      proc_times[('II', 'A1')] * x_IIA1) * voc['A1']\n        op_cost_A2 = (proc_times[('I', 'A2')] * x_IA2 +\n                      proc_times[('II', 'A2')] * x_IIA2 +\n                      proc_times[('III', 'A2')] * x_IIIA2) * voc['A2']\n        op_cost_B1 = (proc_times[('I', 'B1')] * x_IB1 +\n                      proc_times[('II', 'B1')] * x_IIB1) * voc['B1']\n        op_cost_B2 = (proc_times[('III', 'B2')] * x_IIIB2) * voc['B2']\n\n        total_variable_op_cost = op_cost_A1 + op_cost_A2 + op_cost_B1 + op_cost_B2\n\n        profit = total_revenue - total_rmc - total_variable_op_cost\n        model.setObjective(profit, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Capacity Constraints\n        model.addConstr(\n            proc_times[('I', 'A1')] * x_IA1 + proc_times[('II', 'A1')] * x_IIA1\n            <= capacities['A1'], \"Cap_A1\")\n        model.addConstr(\n            proc_times[('I', 'A2')] * x_IA2 +\n            proc_times[('II', 'A2')] * x_IIA2 +\n            proc_times[('III', 'A2')] * x_IIIA2 <= capacities['A2'], \"Cap_A2\")\n        model.addConstr(\n            proc_times[('I', 'B1')] * x_IB1 + proc_times[('II', 'B1')] * x_IIB1\n            <= capacities['B1'], \"Cap_B1\")\n        model.addConstr(proc_times[('III', 'B2')] * x_IIIB2\n                        <= capacities['B2'], \"Cap_B2\")  # Only Prod III uses B2\n\n        # 2. Production Flow Conservation (linking total product X_p to machine allocations)\n        # Product I\n        model.addConstr(\n            x_IA1 + x_IA2 == X['I'],\n            \"Flow_I_A_Total\")  # Sum of A processing for I = Total I\n        model.addConstr(\n            x_IB1 == X['I'],\n            \"Flow_I_B_Total\")  # B processing for I (only on B1) = Total I\n\n        # Product II\n        model.addConstr(\n            x_IIA1 + x_IIA2 == X['II'],\n            \"Flow_II_A_Total\")  # Sum of A processing for II = Total II\n        model.addConstr(\n            x_IIB1 == X['II'],\n            \"Flow_II_B_Total\")  # B processing for II (only on B1) = Total II\n\n        # Product III\n        model.addConstr(x_IIIA2 == X['III'], \"Flow_III_A_Total\"\n                        )  # A processing for III (only on A2) = Total III\n        model.addConstr(x_IIIB2 == X['III'], \"Flow_III_B_Total\"\n                        )  # B processing for III (only on B2) = Total III\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Profit: {model.objVal:.2f} Yuan\")\n            print(\"\\nTotal pieces of each product to produce:\")\n            for p in products:\n                print(f\"  Product {p}: {X[p].X:.2f} pieces\")\n\n            print(\"\\nProduction allocation (pieces on each machine):\")\n            print(\"  Process A:\")\n            if x_IA1.X > 1e-6:\n                print(f\"    Product I on A1 (x_I_A1): {x_IA1.X:.2f}\")\n            if x_IA2.X > 1e-6:\n                print(f\"    Product I on A2 (x_I_A2): {x_IA2.X:.2f}\")\n            if x_IIA1.X > 1e-6:\n                print(f\"    Product II on A1 (x_II_A1): {x_IIA1.X:.2f}\")\n            if x_IIA2.X > 1e-6:\n                print(f\"    Product II on A2 (x_II_A2): {x_IIA2.X:.2f}\")\n            if x_IIIA2.X > 1e-6:\n                print(f\"    Product III on A2 (x_III_A2): {x_IIIA2.X:.2f}\")\n\n            print(\"  Process B:\")\n            if x_IB1.X > 1e-6:\n                print(f\"    Product I on B1 (x_I_B1): {x_IB1.X:.2f}\")\n            if x_IIB1.X > 1e-6:\n                print(f\"    Product II on B1 (x_II_B1): {x_IIB1.X:.2f}\")\n            if x_IIIB2.X > 1e-6:\n                print(f\"    Product III on B2 (x_III_B2): {x_IIIB2.X:.2f}\")\n\n            print(\n                \"\\nMachine Utilization (Hours Used / Capacity | % Utilization):\"\n            )\n            hours_A1 = proc_times.get(\n                ('I', 'A1'), 0) * x_IA1.X + proc_times.get(\n                    ('II', 'A1'), 0) * x_IIA1.X\n            hours_A2 = proc_times.get(\n                ('I', 'A2'), 0) * x_IA2.X + proc_times.get(\n                    ('II', 'A2'), 0) * x_IIA2.X + proc_times.get(\n                        ('III', 'A2'), 0) * x_IIIA2.X\n            hours_B1 = proc_times.get(\n                ('I', 'B1'), 0) * x_IB1.X + proc_times.get(\n                    ('II', 'B1'), 0) * x_IIB1.X\n            hours_B2 = proc_times.get(('III', 'B2'), 0) * x_IIIB2.X\n\n            util_A1 = (hours_A1 / capacities['A1'] *\n                       100) if capacities['A1'] > 0 else 0\n            util_A2 = (hours_A2 / capacities['A2'] *\n                       100) if capacities['A2'] > 0 else 0\n            util_B1 = (hours_B1 / capacities['B1'] *\n                       100) if capacities['B1'] > 0 else 0\n            util_B2 = (hours_B2 / capacities['B2'] *\n                       100) if capacities['B2'] > 0 else 0\n\n            print(\n                f\"  Machine A1: {hours_A1:.2f} / {capacities['A1']} hours | {util_A1:.1f}%\"\n            )\n            print(\n                f\"  Machine A2: {hours_A2:.2f} / {capacities['A2']} hours | {util_A2:.1f}%\"\n            )\n            print(\n                f\"  Machine B1: {hours_B1:.2f} / {capacities['B1']} hours | {util_B1:.1f}%\"\n            )\n            print(\n                f\"  Machine B2: {hours_B2:.2f} / {capacities['B2']} hours | {util_B2:.1f}%\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # To help debug, compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"factory_production_revised_iis.ilp\")\n            # print(\"IIS written to factory_production_revised_iis.ilp\")\n        else:\n            print(f\"Optimization was stopped with status {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_factory_production_revised()\n```\n\nThe optimal value is: 712.875",
    "task_id": "B030",
    "ground_truth": 712.875,
    "problem_domain": "Production Planning",
    "modeling_type": "MILP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA furniture store can choose to order chairs from three different manufacturers: A, B, and C. The cost of ordering each chair from manufacturer A is $50, from manufacturer B is $45, and from manufacturer C is $40. The store needs to minimize the total cost of the order.\n\nAdditionally, each order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The number of orders must be an integer. The store needs to order at least 100 chairs.\n\nEach order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The store needs to order at most 500 chairs.\n\nIf the store decides to order chairs from manufacturer A, it must also order at least 10 chairs from manufacturer B.\n\nFurthermore, if the store decides to order chairs from manufacturer B, it must also order chairs from manufacturer C.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_furniture_order_problem():\n    try:\n        # --- Problem Data ---\n        # Costs per chair\n        cost_per_chair_A = 50\n        cost_per_chair_B = 45\n        cost_per_chair_C = 40\n\n        # Chairs per order\n        chairs_per_order_A = 15\n        chairs_per_order_B = 10\n        chairs_per_order_C = 10\n\n        # Cost per order\n        cost_per_order_A = cost_per_chair_A * chairs_per_order_A\n        cost_per_order_B = cost_per_chair_B * chairs_per_order_B\n        cost_per_order_C = cost_per_chair_C * chairs_per_order_C\n\n        # Chair limits\n        min_total_chairs = 100\n        max_total_chairs = 500\n\n        # --- Model Creation ---\n        model = gp.Model(\"FurnitureOrderOptimization\")\n\n        # --- Decision Variables ---\n        # Number of orders from each manufacturer (must be integer)\n        orders_A = model.addVar(vtype=GRB.INTEGER, name=\"Orders_A\", lb=0)\n        orders_B = model.addVar(vtype=GRB.INTEGER, name=\"Orders_B\", lb=0)\n        orders_C = model.addVar(vtype=GRB.INTEGER, name=\"Orders_C\", lb=0)\n\n        # Binary variables to indicate if any order is placed with a manufacturer\n        # use_A = 1 if orders_A > 0, 0 otherwise\n        # use_B = 1 if orders_B > 0, 0 otherwise\n        use_A = model.addVar(vtype=GRB.BINARY, name=\"Use_A\")\n        use_B = model.addVar(vtype=GRB.BINARY, name=\"Use_B\")\n        # use_C is not strictly needed for the B->C condition if directly linking orders_C to use_B\n\n        # --- Objective Function ---\n        # Minimize the total cost of ordering\n        total_cost = (orders_A * cost_per_order_A +\n                      orders_B * cost_per_order_B +\n                      orders_C * cost_per_order_C)\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n\n        # 1. Calculate total number of chairs ordered\n        total_chairs = (orders_A * chairs_per_order_A +\n                        orders_B * chairs_per_order_B +\n                        orders_C * chairs_per_order_C)\n\n        # 2. Total chairs constraints\n        model.addConstr(total_chairs >= min_total_chairs, \"MinTotalChairs\")\n        model.addConstr(total_chairs <= max_total_chairs, \"MaxTotalChairs\")\n\n        # 3. Link binary 'use' variables to the number of orders\n        # If orders_A > 0, then use_A must be 1.\n        # If orders_A = 0, then use_A must be 0.\n        # Gurobi's indicator constraints are suitable here.\n        # (use_A == 1) => (orders_A >= 1)\n        # (use_A == 0) => (orders_A == 0)\n        model.addConstr((use_A == 1) >> (orders_A >= 1), \"Link_use_A_if_one\")\n        model.addConstr((use_A == 0) >> (orders_A == 0), \"Link_use_A_if_zero\")\n\n        # Similarly for use_B and orders_B\n        model.addConstr((use_B == 1) >> (orders_B >= 1), \"Link_use_B_if_one\")\n        model.addConstr((use_B == 0) >> (orders_B == 0), \"Link_use_B_if_zero\")\n\n        # 4. Conditional ordering constraints:\n        # \"If the store decides to order chairs from manufacturer A (orders_A > 0, so use_A = 1),\n        # it must also order at least 10 chairs from manufacturer B (orders_B * 10 >= 10, so orders_B >= 1).\"\n        model.addConstr((use_A == 1) >> (orders_B >= 1),\n                        \"Conditional_A_implies_B\")\n\n        # \"If the store decides to order chairs from manufacturer B (orders_B > 0, so use_B = 1),\n        # it must also order chairs from manufacturer C (orders_C >= 1).\"\n        model.addConstr((use_B == 1) >> (orders_C >= 1),\n                        \"Conditional_B_implies_C\")\n\n        # --- Optimize Model ---\n        model.optimize()\n\n        # --- Results ---\n        print(\"-\" * 40)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found!\")\n            print(f\"Minimum Total Cost: ${model.objVal:,.2f}\")\n            print(\"-\" * 40)\n            print(\"Order Plan:\")\n            print(f\"  Orders from Manufacturer A: {orders_A.X:.0f}\")\n            print(f\"    Chairs from A: {orders_A.X * chairs_per_order_A:.0f}\")\n            print(f\"  Orders from Manufacturer B: {orders_B.X:.0f}\")\n            print(f\"    Chairs from B: {orders_B.X * chairs_per_order_B:.0f}\")\n            print(f\"  Orders from Manufacturer C: {orders_C.X:.0f}\")\n            print(f\"    Chairs from C: {orders_C.X * chairs_per_order_C:.0f}\")\n            print(\"-\" * 40)\n\n            actual_total_chairs = (orders_A.X * chairs_per_order_A +\n                                   orders_B.X * chairs_per_order_B +\n                                   orders_C.X * chairs_per_order_C)\n            print(f\"Total Chairs Ordered: {actual_total_chairs:.0f}\")\n            print(\"-\" * 40)\n\n            print(\"Status of 'Use' Variables (for verification):\")\n            print(f\"  Use Manufacturer A (use_A): {use_A.X:.0f}\")\n            print(f\"  Use Manufacturer B (use_B): {use_B.X:.0f}\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists that satisfies all constraints.\"\n            )\n            print(\n                \"Consider reviewing the constraints, especially the conditional ones and chair limits.\"\n            )\n        elif model.status == GRB.UNBOUNDED:\n            print(\n                \"Model is unbounded. This typically means the objective can be improved indefinitely,\"\n            )\n            print(\n                \"which might indicate an issue with constraints or objective direction for minimization.\"\n            )\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_furniture_order_problem()\n```\n\nThe optimal value is: 4000.0",
    "task_id": "B018",
    "ground_truth": 4000.0,
    "problem_domain": "Purchasing & Procurement",
    "modeling_type": "MILP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA dentist has 3000 units of resin to fill cavities in both molars and canines. Molars require 20 units of resin and 3 units of pain killer. Canines require 15 units of resin and 2.3 units of pain killer. Since this dentist sees more cavities in canines, at least 60% of cavities filled must be in canines. In addition, the dentist must reserve materials to fill at least 45 molars. How many of each type of teeth should the dentist schedule to fill to minimize the amount of pain killer needed?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_cavity_filling():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"dentist_cavity_filling\")\n    \n    # Decision variables: number of molars and canines to fill\n    x_m = m.addVar(vtype=GRB.INTEGER, name=\"molars\")\n    x_c = m.addVar(vtype=GRB.INTEGER, name=\"canines\")\n    \n    # Set the objective: minimize total pain killer\n    m.setObjective(3 * x_m + 2.3 * x_c, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Resin constraint\n    m.addConstr(20 * x_m + 15 * x_c <= 3000, \"resin_limit\")\n    \n    # Canine proportion constraint: x_c >= 1.5 * x_m\n    m.addConstr(x_c >= 1.5 * x_m, \"canine_proportion\")\n    \n    # Minimum molars filled\n    m.addConstr(x_m >= 45, \"min_molars\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal pain killer usage\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pain_killer = optimize_cavity_filling()\n    if min_pain_killer is not None:\n        print(f\"Minimum Total Pain Killer Usage: {min_pain_killer}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 291.4",
    "task_id": "A205",
    "ground_truth": 291.4,
    "problem_domain": "Resource Allocation",
    "modeling_type": "MILP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nAn airport buys two types of vehicles, a 4-wheeler and 3-wheeler, to help move luggage. A 4-wheeler vehicle can move 60 luggage per day and produces 30 units of pollutant per day. A 3-wheeler vehicle can move 40 luggage per day and produces 15 units of pollutant per day. The airport needs to be able to move at least 1000 luggage per day. To avoid over-polluting the airport, they can produce at most 430 units of pollutant per day. How many of each vehicle should the airport buy to minimize the total number of vehicles needed.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"AirportVehicleOptimization\")\n\n# Parameters\nL_4 = 60  # luggage per 4-wheeler per day\nP_4 = 30  # pollution units per 4-wheeler per day\nL_3 = 40  # luggage per 3-wheeler per day\nP_3 = 15  # pollution units per 3-wheeler per day\nL_min = 1000  # minimum luggage to move per day\nP_max = 430  # maximum pollution per day\n\n# Variables\nx_4 = model.addVar(vtype=GRB.INTEGER, name=\"x_4\")  # number of 4-wheeler vehicles\nx_3 = model.addVar(vtype=GRB.INTEGER, name=\"x_3\")  # number of 3-wheeler vehicles\n\n# Objective: Minimize the total number of vehicles\nmodel.setObjective(x_4 + x_3, GRB.MINIMIZE)\n\n# Constraints\n# (C1) Luggage capacity constraint\nmodel.addConstr(L_4 * x_4 + L_3 * x_3 >= L_min, \"LuggageCapacity\")\n\n# (C2) Pollution constraint\nmodel.addConstr(P_4 * x_4 + P_3 * x_3 <= P_max, \"Pollution\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 22.0",
    "task_id": "F199",
    "ground_truth": 22.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Transportation"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA factory transports rice to the city in horse-drawn carts that are either medium or large size. A medium sized cart requires 2 horses and can carry 30 kg of rice. A large sized cart requires 4 horses and can carry 70 kg of rice.  The factory has 60 horses available. Because the horses don't get along well, the number of medium sized carts must be three times the number of large sized carts. In addition, there must be at least 5 medium sized carts and at least 5 large sized carts. How many of each cart size should be used to maximize the amount of rice that can be transported?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nh = 60  # Total number of horses available\nc_m = 30  # Capacity of a medium-sized cart in kg\nc_l = 70  # Capacity of a large-sized cart in kg\nh_m = 2  # Number of horses required for a medium-sized cart\nh_l = 4  # Number of horses required for a large-sized cart\n\n# Variables\nx_m = model.addVar(vtype=GRB.INTEGER, name=\"x_m\")  # Number of medium-sized carts\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")  # Number of large-sized carts\n\n# Objective: Maximize the total amount of rice transported\nmodel.setObjective(c_m * x_m + c_l * x_l, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(h_m * x_m + h_l * x_l <= h, \"HorseAvailability\")\nmodel.addConstr(x_m == 3 * x_l, \"CartRatio\")\nmodel.addConstr(x_m >= 5, \"MinMediumCarts\")\nmodel.addConstr(x_l >= 5, \"MinLargeCarts\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 960.0",
    "task_id": "F067",
    "ground_truth": 960.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nThere are two specialized containers, a small and large one, that are used to make a pharmaceutical paste. The small container requires 10 units of water and 15 units of the powdered pill to make 20 units of the paste. The large container requires 20 units of water and 20 units of the powdered pill to make 30 units of the paste. The pharmacy has available 500 units of water and 700 units of the powdered pill. How many of each container should be used to maximize the amount of paste that can be made?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nW_s = 10\nP_s = 15\nPaste_s = 20\nW_l = 20\nP_l = 20\nPaste_l = 30\nW_total = 500\nP_total = 700\n\n# Variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n# Objective\nmodel.setObjective(Paste_s * x_s + Paste_l * x_l, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(W_s * x_s + W_l * x_l <= W_total, \"WaterConstraint\")\nmodel.addConstr(P_s * x_s + P_l * x_l <= P_total, \"PillConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 950.0",
    "task_id": "F184",
    "ground_truth": 950.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA bakery uses a stand-mixer and a slow bake oven to make bread and cookies. Each machine can run for at most 3000 hours per year. To bake a loaf of bread takes 1 hour in the stand mixer and 3 hours in the oven. A batch of cookies requires 0.5 hours in the mixer and 1 hour in the oven. The profit per loaf of bread is $5 and the profit per batch of cookies is $3. How should the bakery operate to maximize total profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_bakery_production(\n    max_machine_hours=3000,\n    profit_bread=5,\n    profit_cookies=3,\n    bread_mixer_time=1,\n    cookies_mixer_time=0.5,\n    bread_oven_time=3,\n    cookies_oven_time=1\n):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"BakeryOptimization\")\n\n    # Decision variables: number of loaves of bread and batches of cookies\n    x = m.addVar(name=\"Bread\", lb=0)\n    y = m.addVar(name=\"Cookies\", lb=0)\n\n    # Set the objective: maximize profit\n    m.setObjective(profit_bread * x + profit_cookies * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Stand-mixer constraint\n    m.addConstr(bread_mixer_time * x + cookies_mixer_time * y <= max_machine_hours, \"MixerTime\")\n    # Oven constraint\n    m.addConstr(bread_oven_time * x + cookies_oven_time * y <= max_machine_hours, \"OvenTime\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_bakery_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 9000.0",
    "task_id": "A009",
    "ground_truth": 9000.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA farmer has 200 acres of land on which he must process hay using either a windrower or hay harvester. For each acre of land, the windrower can process 10 kg of hay while the hay harvester can process 8 kg of hay. Per acre, the windrower produces 5 kg of methane gas and requires 2 kg of fuel. On the other hand, the hay harvester produces 3 kg of methane gas per acre and requires 1 kg of fuel. There are 300 kg of fuel available and the farmer can produce at most 800 kg of methane gas. For how many acres should each machine be used to maximize the amount of hay processed?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_hay_processing():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"HayProcessing\")\n\n    # Decision variables: acres assigned to windrower (x) and harvester (y)\n    x = m.addVar(name=\"windrower_acres\", lb=0)\n    y = m.addVar(name=\"harvester_acres\", lb=0)\n\n    # Set the objective: maximize total hay processed\n    m.setObjective(10 * x + 8 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(x + y <= 200, name=\"land_constraint\")\n    m.addConstr(2 * x + y <= 300, name=\"fuel_constraint\")\n    m.addConstr(5 * x + 3 * y <= 800, name=\"methane_constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum hay processed\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_hay_processed = optimize_hay_processing()\n    if max_hay_processed is not None:\n        print(f\"Maximum Hay Processed: {max_hay_processed}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 1800.0",
    "task_id": "A040",
    "ground_truth": 1800.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Agriculture"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA car manufacturer ships their cars on large and small planes. A large plane can carry 30 cars while a small plane can carry 10 cars. Since large planes cause more pollution, the number of large planes must be less than the number of small planes. If the manufacturer wants to deliver at least 300 cars, find the minimum number of planes that can be used.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef minimize_planes():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MinimizePlanes\")\n\n    # Decision variables: number of large and small planes\n    L = m.addVar(vtype=GRB.INTEGER, name=\"LargePlanes\", lb=0)\n    S = m.addVar(vtype=GRB.INTEGER, name=\"SmallPlanes\", lb=0)\n\n    # Set the objective: minimize total number of planes\n    m.setObjective(L + S, GRB.MINIMIZE)\n\n    # Capacity constraint: at least 300 cars delivered\n    m.addConstr(30 * L + 10 * S >= 300, name=\"CapacityConstraint\")\n\n    # Relationship constraint: large planes less than small planes\n    m.addConstr(L <= S - 1, name=\"PlaneCountConstraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimum total number of planes\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_planes = minimize_planes()\n    if min_planes is not None:\n        print(f\"Minimum Total Planes: {min_planes}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 16.0",
    "task_id": "A140",
    "ground_truth": 16.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Transportation"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nThe Zhang family has 6 children: Harry, Hermione, Ron, Fred, George, and Ginny. The cost of taking Harry is $1200, Hermione is $1650, Ron is $750, Fred is $800, George is $800, and Ginny is $1500. Which children should the couple take to minimize the total cost of taking the children? They can take up to four children on the upcoming trip.\n\nGinny is the youngest, so the Zhang family will definitely take her.\n\nIf the couple takes Harry, they will not take Fred because Harry does not get along with him.\n\nIf the couple takes Harry, they will not take George because Harry does not get along with him.\n\nIf they take George, they must also take Fred.\n\nIf they take George, they must also take Hermione.\n\nEven though it will cost them a lot of money, the Zhang family has decided to take at least three children.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_children_trip():\n    from gurobipy import Model, GRB\n\n    # Costs\n    cost_Harry = 1200\n    cost_Hermione = 1650\n    cost_Ron = 750\n    cost_Fred = 800\n    cost_George = 800\n    cost_Ginny = 1500  # always taken\n\n    # Initialize model\n    m = Model(\"Children_Trip_Optimization\")\n    m.setParam('OutputFlag', 0)  # suppress output\n\n    # Decision variables\n    y_Harry = m.addVar(vtype=GRB.BINARY, name='Harry')\n    y_Hermione = m.addVar(vtype=GRB.BINARY, name='Hermione')\n    y_Ron = m.addVar(vtype=GRB.BINARY, name='Ron')\n    y_Fred = m.addVar(vtype=GRB.BINARY, name='Fred')\n    y_George = m.addVar(vtype=GRB.BINARY, name='George')\n    y_Ginny = 1  # always taken\n\n    # Set objective\n    m.setObjective(\n        cost_Harry * y_Harry + cost_Hermione * y_Hermione + cost_Ron * y_Ron +\n        cost_Fred * y_Fred + cost_George * y_George + cost_Ginny, GRB.MINIMIZE)\n\n    # Constraints\n    total_children = y_Harry + y_Hermione + y_Ron + y_Fred + y_George + y_Ginny\n    m.addConstr(total_children >= 3, name='MinChildren')\n    m.addConstr(total_children <= 4, name='MaxChildren')\n\n    # Harry-Fred exclusion\n    m.addConstr(y_Harry + y_Fred <= 1, name='HarryFredExcl')\n    # Harry-Gorge exclusion\n    m.addConstr(y_Harry + y_George <= 1, name='HarryGeorgeExcl')\n    # George-Fred relationship\n    m.addConstr(y_George <= y_Fred, name='GeorgeFred')\n    # George-Hermione relationship\n    m.addConstr(y_George <= y_Hermione, name='GeorgeHermione')\n\n    # Optimize\n    m.optimize()\n\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_children_trip()\n    if result is not None:\n        print(f\"Optimal total cost for the trip: {result}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 3050.0",
    "task_id": "B052",
    "ground_truth": 3050.0,
    "problem_domain": "Selection",
    "modeling_type": "MILP",
    "industry_sector": "Family/Personal"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA coffee shop sells mochas and regular coffees. Each mocha requires 3 units of coffee powder and 6 units of milk. Each regular coffee requires 6 units of coffee powder and 2 units of milk. The shop has available 400 units of coffee powder and 500 units of milk. Making a mocha takes 5 minutes and making a regular coffee takes 3 minutes. Since mochas are more popular among people, the shop must make at least 3 times as many mochas as regular coffees. How many of each should they make to minimize the total production time?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nc_m = 3  # Units of coffee powder required for one mocha\nm_m = 6  # Units of milk required for one mocha\nc_r = 6  # Units of coffee powder required for one regular coffee\nm_r = 2  # Units of milk required for one regular coffee\nP = 400  # Total available units of coffee powder\nM = 500  # Total available units of milk\nt_m = 5  # Time in minutes to make one mocha\nt_r = 3  # Time in minutes to make one regular coffee\nr = 3    # Ratio of mochas to regular coffees\n\n# Variables\nx_m = model.addVar(vtype=GRB.INTEGER, name=\"x_m\")  # Number of mochas\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")  # Number of regular coffees\n\n# Objective: Minimize the total production time\nmodel.setObjective(t_m * x_m + t_r * x_r, GRB.MINIMIZE)\n\n# Constraints\n# Coffee powder constraint\nmodel.addConstr(c_m * x_m + c_r * x_r <= P, \"C1\")\n\n# Milk constraint\nmodel.addConstr(m_m * x_m + m_r * x_r <= M, \"C2\")\n\n# Popularity ratio constraint\nmodel.addConstr(x_m >= r * x_r, \"C3\")\n\n# Non-negativity constraints are implicitly handled by variable definitions\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 0.0",
    "task_id": "F201",
    "ground_truth": 0.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA clinic administers two vaccines available for the public to take one at a time. One vaccine is taken as a pill and another is taken as a shot. The pill vaccine takes 10 minutes to administer while the shot takes 20 minutes to administer. Since the shot has been more thoroughly studied, the clinic must deliver at least 3 times as many shots as pill. In addition, the clinic must administer at least 30 pill vaccines. If the clinic only operates for 10000 minutes, maximize the number of patients that can be vaccinated.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_vaccination(max_time=10000, min_pills=30):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Vaccination_Optimization\")\n\n    # Decision variables: number of pills and shots\n    x = model.addVar(name=\"pill\", vtype=GRB.INTEGER, lb=0)\n    y = model.addVar(name=\"shot\", vtype=GRB.INTEGER, lb=0)\n\n    # Set the objective: maximize total vaccinated\n    model.setObjective(x + y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Time constraint\n    model.addConstr(10 * x + 20 * y <= max_time, name=\"time_limit\")\n    # Ratio constraint\n    model.addConstr(y >= 3 * x, name=\"ratio\")\n    # Minimum pills\n    model.addConstr(x >= min_pills, name=\"min_pills\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum number of patients vaccinated\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage \nif __name__ == \"__main__\":\n    max_vaccinated = optimize_vaccination()\n    if max_vaccinated is not None:\n        print(f\"Maximum Patients Vaccinated: {max_vaccinated}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 571.0",
    "task_id": "A122",
    "ground_truth": 571.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA corn farmer sends his corn to the city by either tractor or car.  A tractor can carry 40 kg of corn while a car can carry 20 kg of corn. Since tractors are very slow, the number of cars used has to be at least twice the number of tractors used. If at least 500 kg of corn need to be sent to the city, minimize the total number of tractors and cars needed.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nT = 40  # kg/tractor\nC = 20  # kg/car\nR = 2   # minimum ratio of cars to tractors\nQ = 500 # kg (minimum amount of corn to send)\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"tractors\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"cars\")\n\n# Objective\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(T * x + C * y >= Q, \"corn_requirement\")\nmodel.addConstr(y >= R * x, \"car_to_tractor_ratio\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 19.0",
    "task_id": "F059",
    "ground_truth": 19.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Agriculture"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA neighbourhood pizza restaurant has opened and sells pizzas in two sizes; large pizza and medium pizza. Large pizzas require 12 units of dough, and 5 units of toppings. Medium pizzas require 8 units of dough, and 4 units of toppings. While large pizzas take 12 minutes to bake, medium pizzas require 8 minutes to bake. The neighbourhood pizza restaurant must use at least 10000 units of dough and 4400 units of toppings. Medium pizzas are popular due to a promotion, therefore, at least 200 medium pizzas must be made. There are regulars that prefer large pizzas and at least two times as many large pizzas should be made than medium pizzas. How many of each size of pizzas should the neighbourhood pizza restaurant make to reduce time spent baking?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_pizza_baking():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Pizza_Baking_Minimize_Time\")\n\n    # Decision variables\n    L = m.addVar(vtype=GRB.INTEGER, name=\"Large_Pizzas\", lb=0)\n    M = m.addVar(vtype=GRB.INTEGER, name=\"Medium_Pizzas\", lb=0)\n\n    # Set objective: minimize total baking time\n    m.setObjective(12 * L + 8 * M, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(12 * L + 8 * M >= 10000, name=\"Dough_Constraint\")\n    m.addConstr(5 * L + 4 * M >= 4400, name=\"Toppings_Constraint\")\n    m.addConstr(M >= 200, name=\"Medium_Demand\")\n    m.addConstr(L >= 2 * M, name=\"Large_vs_Medium_Ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the total baking time of the optimal solution\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_baking_time = optimize_pizza_baking()\n    if min_baking_time is not None:\n        print(f\"Minimum Total Baking Time: {min_baking_time} minutes\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 10060.0",
    "task_id": "A208",
    "ground_truth": 10060.0,
    "problem_domain": "Production Planning",
    "modeling_type": "IP",
    "industry_sector": "Food Service"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA travelling salesman only eats ramen and fries. Each pack of ramen contains 400 calories, 20 grams of protein, and 100 mg of sodium. Each pack of fries contains 300 calories, 10 grams of protein, and 75 mg of sodium. Since fries are easier to eat while driving, at most 30% of his meals can be ramen. The salesman wants to ensure he eats at least 3000 calories and 80 grams of protein. How many of each should he eat to minimize his sodium intake?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nc_r = 400\np_r = 20\ns_r = 100\nc_f = 300\np_f = 10\ns_f = 75\nC = 3000\nP = 80\nalpha = 0.3\n\n# Variables\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")\nx_f = model.addVar(vtype=GRB.INTEGER, name=\"x_f\")\n\n# Objective\nmodel.setObjective(s_r * x_r + s_f * x_f, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(c_r * x_r + c_f * x_f >= C, \"CalorieConstraint\")\nmodel.addConstr(p_r * x_r + p_f * x_f >= P, \"ProteinConstraint\")\nmodel.addConstr(x_r <= alpha * (x_r + x_f), \"RamenFractionConstraint\")\nmodel.addConstr(x_r >= 0, \"NonNegativityRamen\")\nmodel.addConstr(x_f >= 0, \"NonNegativityFries\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 750.0",
    "task_id": "F015",
    "ground_truth": 750.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA man on a strict diet only drinks meal replacement drinks from two brands, alpha and omega. The alpha brand drink contains 30 grams of protein, 20 grams of sugar, and 350 calories per bottle. The omega brand drink contains 20 grams of protein, 15 grams of sugar, and 300 calories per bottle. The man wants to get at least 100 grams of protein and 2000 calories. In addition, because the omega brand drink contains tiny amounts of caffeine, at most 35% of the drink should be omega brand. How many bottles of each should he drink to minimize his sugar intake?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealReplacementOptimization\")\n\n# Parameters\np_a, s_a, c_a = 30, 20, 350\np_o, s_o, c_o = 20, 15, 300\nP, C, alpha_max = 100, 2000, 0.35\n\n# Variables\nx_a = model.addVar(vtype=GRB.INTEGER, name=\"x_a\")  # Number of alpha brand drinks\nx_o = model.addVar(vtype=GRB.INTEGER, name=\"x_o\")  # Number of omega brand drinks\n\n# Objective: Minimize sugar intake\nmodel.setObjective(s_a * x_a + s_o * x_o, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(p_a * x_a + p_o * x_o >= P, \"ProteinConstraint\")\nmodel.addConstr(c_a * x_a + c_o * x_o >= C, \"CalorieConstraint\")\nmodel.addConstr(x_o <= alpha_max * (x_a + x_o), \"ProportionConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 110.0",
    "task_id": "F002",
    "ground_truth": 110.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nCalcium and Magnesium are found in two health supplements, health supplement A and health supplement B. One serving of health supplement A contains 30 grams of Calcium and 50 grams of Magnesium. One serving of health supplement B contains 60 grams of Calcium and 10 grams of Magnesium. The cost per health supplement for health supplement A is $14 and the cost per health supplement for health supplement B is $25. A patient must consume these two health supplements every day to get at least 400 grams of Calcium and 50 grams of Magnesium. Determine how much servings of each supplement the patient needs to minimize her daily cost.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nc_A = 30\nm_A = 50\nc_B = 60\nm_B = 10\ncost_A = 14\ncost_B = 25\nC_min = 400\nM_min = 50\n\n# Variables\nx_A = model.addVar(vtype=GRB.INTEGER, name=\"x_A\")\nx_B = model.addVar(vtype=GRB.INTEGER, name=\"x_B\")\n\n# Objective\nmodel.setObjective(cost_A * x_A + cost_B * x_B, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(c_A * x_A + c_B * x_B >= C_min, \"CalciumRequirement\")\nmodel.addConstr(m_A * x_A + m_B * x_B >= M_min, \"MagnesiumRequirement\")\nmodel.addConstr(x_A >= 0, \"NonNegativity_x_A\")\nmodel.addConstr(x_B >= 0, \"NonNegativity_x_B\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 175.0",
    "task_id": "F088",
    "ground_truth": 175.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nAn appliance company sells and installs refrigerators and stoves. Each refrigerator takes 60 minutes of mover time and 20 minutes of setup time. Each stove takes 45 minutes of mover time and 25 minutes of setup time. The company has available 20000 minutes of mover time and 13000 minutes of setup time. If the profit per refrigerator is $400 and the profit per stove is $260, how many of each should they sell in order to maximize profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_appliances():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Appliance_Optimization\")\n\n    # Decision variables: number of refrigerators and stoves\n    # Both are integers and non-negative\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Refrigerators\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Stoves\", lb=0)\n\n    # Set the objective: maximize profit\n    m.setObjective(400 * x + 260 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(60 * x + 45 * y <= 20000, \"MoverTime\")\n    m.addConstr(20 * x + 25 * y <= 13000, \"SetupTime\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_appliances()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 133200.0",
    "task_id": "A173",
    "ground_truth": 133200.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA shoe company supplies shoes to stores via vans and trucks. A van can transport 50 pairs of shoes while a truck can transport 100 pairs of shoes. The company must supply a minimum of 2000 pairs of shoes around the city. Since most stores are small, the number of trucks used cannot exceed the number of vans used.  Find the minimum number of vans that can be used?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Shoe_Transport_Optimization\")\n\n# Parameters\nS_v = 50  # Pairs of shoes a van can transport\nS_t = 100  # Pairs of shoes a truck can transport\nD = 2000  # Minimum pairs of shoes to be supplied\n\n# Variables\nx_v = model.addVar(vtype=GRB.INTEGER, name=\"vans\")  # Number of vans used\nx_t = model.addVar(vtype=GRB.INTEGER, name=\"trucks\")  # Number of trucks used\n\n# Objective: Minimize the number of vans\nmodel.setObjective(x_v, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(S_v * x_v + S_t * x_t >= D, \"C1\")  # Meet the minimum supply requirement\nmodel.addConstr(x_t <= x_v, \"C2\")  # The number of trucks cannot exceed the number of vans\nmodel.addConstr(x_v >= 0, \"C3\")  # Non-negativity constraint for vans\nmodel.addConstr(x_t >= 0, \"C4\")  # Non-negativity constraint for trucks\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 14.0",
    "task_id": "F040",
    "ground_truth": 14.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA music company produces two types of digital keyboards, one is full-weighted and another is semi-weighted. Both keyboards are sold for $2800 and $2400 respectively. There are about 3500 oscillator chips available every day from which the full-weighted version requires 20 chips while the semi-weighted version requires 15 chips. The company has a total of 6 working hours a day. Both of these keyboards require a production time of 1.2 hours. What should be the manufacturing quantity for each of the keyboards to maximize the total revenue?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_keyboard_production(\n    price_full=2800,\n    price_semi=2400,\n    chips_available=3500,\n    hours_available=6,\n    production_time=1.2\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Keyboard_Production_Maximize_Revenue\")\n\n    # Decision variables: number of full-weighted and semi-weighted keyboards\n    x = model.addVar(vtype=GRB.INTEGER, name=\"Full_Weighted_Keyboard\")\n    y = model.addVar(vtype=GRB.INTEGER, name=\"Semi_Weighted_Keyboard\")\n\n    # Set objective: maximize total revenue\n    model.setObjective(price_full * x + price_semi * y, GRB.MAXIMIZE)\n\n    # Add chip constraint\n    model.addConstr(20 * x + 15 * y <= chips_available, \"Chip_Limit\")\n\n    # Add production time constraint\n    # Since each takes 1.2 hours, total hours for x and y\n    model.addConstr(production_time * (x + y) <= hours_available, \"Time_Limit\")\n\n    # Set non-negativity (implicit with variable type=GRB.INTEGER and default bounds)\n    # Solve the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal total revenue\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_revenue = optimize_keyboard_production()\n    if max_revenue is not None:\n        print(f\"Maximum Revenue: ${max_revenue}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 14000.0",
    "task_id": "A192",
    "ground_truth": 14000.0,
    "problem_domain": "Production Planning",
    "modeling_type": "MILP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA company produces two products (A and B), with a profit of 3 and 5 per unit sold, respectively. Each product must be assembled on a specific machine, requiring 12 minutes of assembly time per unit for product A and 25 minutes per unit for product B. The company's estimated effective machine working time per week is only 30 hours (due to maintenance or malfunctions). Technical constraints mean that for every five units of product A produced, at least two units of product B must be produced.\n\nTry to formulate a model for this problem.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_new_production_planning():\n    \"\"\"\n    Solves a production planning problem with a ratio constraint\n    to maximize weekly profit.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['A', 'B']\n\n        # Profit (/unit)\n        profit = {'A': 3, 'B': 5}\n\n        # Assembly time requirements (minutes/unit)\n        assembly_time_req = {'A': 12, 'B': 25}\n\n        # Available assembly time (minutes/week)\n        avail_assembly_time = 30 * 60  # 1800 minutes\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"NewProductionPlanning\")\n\n        # --- Decision Variables ---\n        # N[p]: Number of units of product p produced per week\n        N = model.addVars(products, name=\"Produce\", vtype=GRB.INTEGER, lb=0)\n\n        # --- Objective Function: Maximize Total Profit ---\n        model.setObjective(gp.quicksum(profit[p] * N[p] for p in products),\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Assembly Time Constraint\n        model.addConstr(gp.quicksum(assembly_time_req[p] * N[p]\n                                    for p in products) <= avail_assembly_time,\n                        name=\"AssemblyTimeLimit\")\n\n        # 2. Technical Ratio Constraint: For every 5 units of A, at least 2 units of B\n        # N_B >= (2/5) * N_A  =>  5 * N_B >= 2 * N_A  =>  2 * N_A - 5 * N_B <= 0\n        model.addConstr(2 * N['A'] - 5 * N['B'] <= 0, name=\"RatioConstraint\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Weekly Profit: {model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Production Quantities (units per week):\")\n            for p in products:\n                print(f\"  Product {p}: {N[p].X:.0f} units\")\n\n            print(\"\\nResource Utilization:\")\n            assembly_time_used = sum(assembly_time_req[p] * N[p].X\n                                     for p in products)\n            print(\n                f\"  Assembly Time Used: {assembly_time_used:.2f} / {avail_assembly_time} minutes \"\n                f\"({(assembly_time_used/avail_assembly_time*100) if avail_assembly_time > 0 else 0:.1f}%)\"\n            )\n\n            print(\"\\nRatio Constraint Check:\")\n            ratio_val = (2 * N['A'].X - 5 * N['B'].X)\n            print(f\"  2*N_A - 5*N_B = {ratio_val:.2f} (Constraint: <= 0)\")\n            if N['A'].X > 0:\n                print(\n                    f\"  Ratio N_B / N_A = {(N['B'].X / N['A'].X):.3f} (Constraint requires >= 2/5 = 0.4)\"\n                )\n            else:\n                print(\"  Ratio N_B / N_A: N/A (N_A = 0)\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and requirements.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"new_production_iis.ilp\")\n            # print(\"IIS written to new_production_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_new_production_planning()\n```\n\nThe optimal value is: 408.0",
    "task_id": "B090",
    "ground_truth": 408.0,
    "problem_domain": "Production Planning",
    "modeling_type": "MILP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA man  only eats vegetable and fruits. A serving of vegetables contains 2 units of vitamins and 3 units of minerals. A serving of fruit contains 4 units of vitamins and 1 unit of minerals. He wants to eat at least 20 units of vitamins and 30 units of minerals. If vegetables cost $3 per serving and fruits cost $5 per serving, how many servings of each should he eat to minimize his cost?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define variables\nx_v = model.addVar(vtype=GRB.INTEGER, name=\"x_v\")\nx_f = model.addVar(vtype=GRB.INTEGER, name=\"x_f\")\n\n# Set objective: Minimize cost\nmodel.setObjective(3 * x_v + 5 * x_f, GRB.MINIMIZE)\n\n# Add constraints\n# Vitamin requirement\nmodel.addConstr(2 * x_v + 4 * x_f >= 20, \"VitaminReq\")\n\n# Mineral requirement\nmodel.addConstr(3 * x_v + x_f >= 30, \"MineralReq\")\n\n# Non-negativity constraints\nmodel.addConstr(x_v >= 0, \"NonNeg_x_v\")\nmodel.addConstr(x_f >= 0, \"NonNeg_x_f\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 30.0",
    "task_id": "F168",
    "ground_truth": 30.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nChildren can go to school either by van or by minibus. A van can take 6 kids and produces 7 units of pollution. A minibus can take 10 kids and produced 10 units of pollution. There are at least 150 kids than need to go to school and at most 10 minibuses can be used. In addition, the number of vans used must exceed the number of minibuses. How many of each should be used to minimize the total amount of pollution produced?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_transportation(pollution_van=7, pollution_minibus=10, capacity_van=6, capacity_minibus=10, min_kids=150, max_minibuses=10):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"SchoolTransportPollutionMinimization\")\n    \n    # Decision variables\n    V = m.addVar(vtype=GRB.INTEGER, name=\"Vans\", lb=0)\n    M = m.addVar(vtype=GRB.INTEGER, name=\"Minibuses\", lb=0)\n    \n    # Set objective: minimize total pollution\n    m.setObjective(pollution_van * V + pollution_minibus * M, GRB.MINIMIZE)\n    \n    # Capacity constraint: at least 150 kids transported\n    m.addConstr(capacity_van * V + capacity_minibus * M >= min_kids, name=\"Capacity\")\n    \n    # Max number of minibuses\n    m.addConstr(M <= max_minibuses, name=\"MaxMinibuses\")\n    \n    # Vans must exceed minibuses: V > M\n    # Gurobi does not support strict inequalities directly, so we model V >= M + 1\n    m.addConstr(V >= M + 1, name=\"V_greater_than_M\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the total pollution of the optimal solution\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pollution = optimize_transportation()\n    if min_pollution is not None:\n        print(f\"Minimum Total Pollution: {min_pollution}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 160.0",
    "task_id": "A147",
    "ground_truth": 160.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "MILP",
    "industry_sector": "Education"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA chemistry teacher teaches her students two experiments, experiment 1 and experiment 2. In experiment 1, 3 units of the red liquid and 4 units of the blue liquid mix to create 5 units of green gas. In experiment 2, 5 units of the red liquid and 3 units of the blue liquid mix to create 6 units of the green gas. In addition, experiment 1 produces 1 units of smelly gas while experiment 2 produces 2 units of smelly gas.  The lab has available 80 units of red liquid and 70 units of blue liquid. If at most 10 units of smelly gas can be produced, how many experiments of each should be done to maximize the total amount of green gas produced?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nr1, b1, g1, s1 = 3, 4, 5, 1\nr2, b2, g2, s2 = 5, 3, 6, 2\nR, B, S = 80, 70, 10\n\n# Decision variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")\n\n# Objective function\nmodel.setObjective(g1 * x1 + g2 * x2, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(r1 * x1 + r2 * x2 <= R, \"RedLiquidConstraint\")\nmodel.addConstr(b1 * x1 + b2 * x2 <= B, \"BlueLiquidConstraint\")\nmodel.addConstr(s1 * x1 + s2 * x2 <= S, \"SmellyGasConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 50.0",
    "task_id": "F029",
    "ground_truth": 50.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Education"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nImagine you are on a mission to ensure you're eating healthily but also on a tight budget. You have five different food items to choose from: Chicken, Rice, Beans, Broccoli, and Fruit. Each of these foods has a specific amount of protein, carbohydrates, and calories, and each comes with its own cost.\n\nHere's an overview of what each food provides, along with its cost:\n\n- Chicken: Gives you 12 grams of protein, 2 grams of carbohydrates, and 186 calories for $6.\n- Rice: Provides 12 grams of protein, 24 grams of carbohydrates, and 250 calories for $6.\n- Beans: Offers 19 grams of protein, 18 grams of carbohydrates, and 134 calories for $6.\n- Broccoli: Supplies 19 grams of protein, 7 grams of carbohydrates, and 84 calories for $7.\n- Fruit: Gives you 4 grams of protein, a high 27 grams of carbohydrates, and 104 calories for $9.\n\nYour goal is to make sure you get at least 97 grams of protein, 163 grams of carbohydrates, and 2217 calories from the combination of these foods that you choose. Remember, youre trying to figure out the least expensive way to meet these nutritional goals with these five food options. \n\nSo, what is the minimal cost you need to spend to satisfy all these dietary requirements?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define the data\nfoods = [\"Chicken\", \"Rice\", \"Beans\", \"Broccoli\", \"Fruit\"]\nprotein = {\"Chicken\": 12, \"Rice\": 12, \"Beans\": 19, \"Broccoli\": 19, \"Fruit\": 4}\ncarbs = {\"Chicken\": 2, \"Rice\": 24, \"Beans\": 18, \"Broccoli\": 7, \"Fruit\": 27}\ncalories = {\"Chicken\": 186, \"Rice\": 250, \"Beans\": 134, \"Broccoli\": 84, \"Fruit\": 104}\ncosts = {\"Chicken\": 6, \"Rice\": 6, \"Beans\": 6, \"Broccoli\": 7, \"Fruit\": 9}\n\n# Define the decision variables\nx = model.addVars(foods, name=\"x\", vtype=GRB.INTEGER, lb=0)\n\n# Set the objective function\nmodel.setObjective(gp.quicksum(costs[i] * x[i] for i in foods), GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in foods) >= 97, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in foods) >= 163, \"CarbohydrateRequirement\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in foods) >= 2217, \"CalorieRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 54.0",
    "task_id": "E029",
    "ground_truth": 54.0,
    "problem_domain": "Blending",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA fire department employs regular and emergency fire fighters. A regular fire fighter works 10 hours per shift and earns $300. An emergency fire fighter works 6 hours per shift and earns $100. Due to wildfires in the region, the fire department needs at least 300 hours of fire fighter time. If the fire department has a budget of $7000, how many of each should the fire department hire to minimize the total number of fire fighters?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\ndef optimize_firefighters(\n    hours_required=300,\n    hours_regular=10,\n    hours_emergency=6,\n    cost_regular=300,\n    cost_emergency=100,\n    budget=7000\n):\n    # Create a new model\n    model = gp.Model(\"FireFighterOptimization\")\n    \n    # Add decision variables: number of regular and emergency fire fighters\n    R = model.addVar(vtype=GRB.INTEGER, name=\"Regular_Firefighters\", lb=0)\n    E = model.addVar(vtype=GRB.INTEGER, name=\"Emergency_Firefighters\", lb=0)\n    \n    # Set the objective: minimize total number of fire fighters\n    model.setObjective(R + E, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Hours constraint\n    model.addConstr(hours_regular * R + hours_emergency * E >= hours_required, \"HoursRequirement\")\n    \n    # Budget constraint\n    model.addConstr(cost_regular * R + cost_emergency * E <= budget, \"BudgetLimit\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the total number of fire fighters hired\n        total_firefighters = R.X + E.X\n        return total_firefighters\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    total_firefighters = optimize_firefighters()\n    if total_firefighters is not None:\n        print(f\"Total Fire Fighters Hired: {total_firefighters}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 40.0",
    "task_id": "A060",
    "ground_truth": 40.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Public Services"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA fabric dyeing plant has 3 dyeing vats. Each batch of fabric must be dyed in sequence in each vat: first, the second, and third vats. The plant must color five batches of fabric of different sizes. The time required in hours to dye batch $i$ in vat $j$ is given in the following matrix:\n\n$$\n\\left(\\begin{array}{ccc}\n3 & 1 & 1 \\\\\n2 & 1.5 & 1 \\\\\n3 & 1.2 & 1.3 \\\\\n2 & 2 & 2 \\\\\n2.1 & 2 & 3\n\\end{array}\\right)\n$$\n\nSchedule the dyeing operations in the vats to minimize the completion time of the last batch.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_dyeing_plant_scheduling():\n    \"\"\"\n    Solves the dyeing plant scheduling problem to minimize the makespan (completion time of the last batch).\n    This is a flow shop scheduling problem.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Processing times p[i][j] for batch i on vat j (hours)\n        # Rows: Batches (0 to 4), Columns: Vats (0 to 2)\n        processing_times = [\n            [3, 1, 1],  # Batch 0\n            [2, 1.5, 1],  # Batch 1\n            [3, 1.2, 1.3],  # Batch 2\n            [2, 2, 2],  # Batch 3\n            [2.1, 2, 3]  # Batch 4\n        ]\n\n        num_batches = len(processing_times)\n        num_vats = len(processing_times[0])\n\n        batches = range(num_batches)\n        vats = range(num_vats)\n\n        # Calculate Big-M: Sum of all processing times is a safe upper bound for L\n        # and also an upper bound for any start time or makespan.\n        L = sum(sum(row)\n                for row in processing_times) * 2  # A sufficiently large number\n\n        # --- Create a new model ---\n        model = gp.Model(\"DyeingPlantScheduling\")\n\n        # --- Decision Variables ---\n        # s[i,j]: start time of batch i on vat j\n        s = model.addVars(batches,\n                          vats,\n                          name=\"s\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # C_max: makespan (completion time of the last batch on the last vat)\n        C_max = model.addVar(name=\"C_max\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # x[i,k,j]: binary variable, 1 if batch i precedes batch k on vat j, 0 otherwise\n        # Defined for i < k to avoid redundant pairs\n        x = {}\n        for j in vats:\n            for i in batches:\n                for k in batches:\n                    if i < k:\n                        x[i, k, j] = model.addVar(vtype=GRB.BINARY,\n                                                  name=f\"x_{i}_{k}_{j}\")\n\n        # --- Objective Function ---\n        # Minimize the makespan\n        model.setObjective(C_max, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Job Precedence Constraints (operations within the same batch)\n        # s_ij >= s_i,(j-1) + p_i,(j-1)\n        for i in batches:\n            for j in vats:\n                if j > 0:  # For vats 1 and 2 (0-indexed)\n                    model.addConstr(s[i, j] >= s[i, j - 1] +\n                                    processing_times[i][j - 1],\n                                    name=f\"JobPrecedence_b{i}_v{j}\")\n\n        # 2. Machine Capacity Constraints (Disjunctive constraints for operations on the same vat)\n        # For each vat j, and for each pair of batches i, k where i < k:\n        # s_kj >= s_ij + p_ij - L * (1 - x_ikj)\n        # s_ij >= s_kj + p_kj - L * x_ikj\n        for j in vats:\n            for i in batches:\n                for k in batches:\n                    if i < k:\n                        model.addConstr(s[k, j]\n                                        >= s[i, j] + processing_times[i][j] -\n                                        L * (1 - x[i, k, j]),\n                                        name=f\"MachineCap1_v{j}_b{i}_b{k}\")\n                        model.addConstr(s[i, j]\n                                        >= s[k, j] + processing_times[k][j] -\n                                        L * x[i, k, j],\n                                        name=f\"MachineCap2_v{j}_b{i}_b{k}\")\n\n        # 3. Makespan Definition\n        # C_max >= completion time of batch i on the last vat\n        # C_max >= s_i,(M-1) + p_i,(M-1)\n        last_vat_idx = num_vats - 1\n        for i in batches:\n            model.addConstr(C_max >= s[i, last_vat_idx] +\n                            processing_times[i][last_vat_idx],\n                            name=f\"Makespan_b{i}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n        model.setParam('MIPGap',\n                       0.01)  # Set a MIP gap for faster convergence if needed\n        model.setParam('TimeLimit',\n                       120)  # Set a time limit (e.g., 120 seconds)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL or model.status == GRB.TIME_LIMIT and model.SolCount > 0:\n            if model.status == GRB.TIME_LIMIT:\n                print(\n                    \"Optimal solution not found within time limit. Displaying best solution found.\"\n                )\n            else:\n                print(\"Optimal solution found.\")\n\n            print(f\"\\nMinimum Makespan (C_max): {C_max.X:.2f} hours\")\n\n            print(\"\\nSchedule (Start Times s_ij):\")\n            for i in batches:\n                print(f\"  Batch {i+1}:\")\n                for j in vats:\n                    completion_time = s[i, j].X + processing_times[i][j]\n                    print(\n                        f\"    Vat {j+1}: Start = {s[i,j].X:.2f}, End = {completion_time:.2f} (Duration: {processing_times[i][j]})\"\n                    )\n\n            print(\"\\nSequence on Vats (derived from start times):\")\n            for j in vats:\n                vat_schedule = []\n                for i in batches:\n                    vat_schedule.append({\n                        'batch': i + 1,\n                        'start_time': s[i, j].X,\n                        'proc_time': processing_times[i][j]\n                    })\n\n                # Sort batches by start time on this vat\n                vat_schedule.sort(key=lambda e: e['start_time'])\n\n                sequence_str = \" -> \".join([\n                    f\"B{e['batch']}({e['start_time']:.2f}-{e['start_time']+e['proc_time']:.2f})\"\n                    for e in vat_schedule\n                ])\n                print(f\"  Vat {j+1} Sequence: {sequence_str}\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"dyeing_plant_iis.ilp\")\n            # print(\"IIS written to dyeing_plant_iis.ilp.\")\n        elif model.status == GRB.TIME_LIMIT and model.SolCount == 0:\n            print(\"No solution found within the time limit.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_dyeing_plant_scheduling()\n```\n\nThe optimal value is: 14.1",
    "task_id": "B034",
    "ground_truth": 14.1,
    "problem_domain": "Scheduling",
    "modeling_type": "MILP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nThere are 10 different parts, and they can all be processed on machine \\( A \\), machine \\( B \\), or machine \\( C \\). The unit processing costs are shown in Table 5-6. Additionally, as long as any part is processed on the aforementioned machines, a one-time setup cost will be incurred regardless of whether one or multiple types of parts are processed, with the respective costs being \\( d_A = 100 \\), \\( d_B = 135 \\), and \\( d_C = 200 \\) yuan. If the requirements are:\n\n1. One piece of each of the aforementioned 10 types of parts needs to be processed;\n2. If the 1st part is processed on machine \\( A \\), then the 2nd part must be processed on machine \\( B \\) or \\( C \\); conversely, if the 1st part is processed on machine \\( B \\) or \\( C \\), then the 2nd part must be processed on machine \\( A \\);\n3. Parts 3, 4, and 5 must be processed on machines A, B, and C respectively;\n4. The number of parts processed on machine \\( C \\) should not exceed 3 types.\n\nTry to establish an integer programming mathematical model for this problem with the objective of minimizing the total cost.\n\nTable 5-6\n| Machine/Part | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |\n|--------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| A            | $10$ | $20$ | $30$ | $40$ | $50$ | $60$ | $70$ | $80$ | $90$ | $100$ |\n| B            | $15$ | $25$ | $35$ | $45$ | $55$ | $65$ | $75$ | $85$ | $95$ | $105$ |\n| C            | $20$ | $30$ | $40$ | $50$ | $60$ | $70$ | $80$ | $90$ | $100$ | $110$ |",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_machine_assignment():\n    \"\"\"\n    Solves the machine assignment problem with fixed setup costs and constraints\n    to minimize the total cost.\n    \"\"\"\n    try:\n        # --- Data ---\n        parts = list(range(1, 11))  # Parts 1 to 10\n        machines = ['A', 'B', 'C']\n\n        # Processing costs c[part][machine]\n        # Note: Using part index p-1 for 0-based list access\n        processing_costs_data = [\n            # A   B    C   (Machine)\n            [10, 15, 20],  # Part 1\n            [20, 25, 30],  # Part 2\n            [30, 35, 40],  # Part 3\n            [40, 45, 50],  # Part 4\n            [50, 55, 60],  # Part 5\n            [60, 65, 70],  # Part 6\n            [70, 75, 80],  # Part 7\n            [80, 85, 90],  # Part 8\n            [90, 95, 100],  # Part 9\n            [100, 105, 110]  # Part 10\n        ]\n\n        # Create cost dictionary c[p,m] for easier access\n        proc_costs = {}\n        for p_idx, p in enumerate(parts):\n            for m_idx, m in enumerate(machines):\n                proc_costs[p, m] = processing_costs_data[p_idx][m_idx]\n\n        # Fixed setup costs d[m]\n        setup_costs = {'A': 100, 'B': 135, 'C': 200}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"MachineAssignmentFixedCost\")\n\n        # --- Decision Variables ---\n        # x[p,m]: 1 if part p is processed on machine m, 0 otherwise\n        x = model.addVars(parts, machines, vtype=GRB.BINARY, name=\"x_assign\")\n\n        # y[m]: 1 if machine m is used (setup cost incurred), 0 otherwise\n        y = model.addVars(machines, vtype=GRB.BINARY, name=\"y_setup\")\n\n        # --- Objective Function: Minimize Total Cost ---\n        total_processing_cost = gp.quicksum(proc_costs[p, m] * x[p, m]\n                                            for p in parts for m in machines)\n        total_setup_cost = gp.quicksum(setup_costs[m] * y[m] for m in machines)\n\n        model.setObjective(total_processing_cost + total_setup_cost,\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Process Each Part: Each part p processed on exactly one machine m\n        for p in parts:\n            model.addConstr(gp.quicksum(x[p, m] for m in machines) == 1,\n                            name=f\"ProcessPart_{p}\")\n\n        # 2. Conditional Assignment (Part 1 and Part 2)\n        # If x[1,'A'] = 1, then x[2,'B'] + x[2,'C'] = 1\n        model.addConstr(x[1, 'A'] <= x[2, 'B'] + x[2, 'C'],\n                        name=\"Cond_1A_implies_2BC\")\n        # If x[1,'B'] + x[1,'C'] = 1, then x[2,'A'] = 1\n        model.addConstr(x[1, 'B'] + x[1, 'C'] <= x[2, 'A'],\n                        name=\"Cond_1BC_implies_2A\")\n\n        # 3. Fixed Assignments (Parts 3, 4, 5)\n        model.addConstr(x[3, 'A'] == 1, name=\"Fixed_Part3_MachineA\")\n        model.addConstr(x[4, 'B'] == 1, name=\"Fixed_Part4_MachineB\")\n        model.addConstr(x[5, 'C'] == 1, name=\"Fixed_Part5_MachineC\")\n\n        # 4. Machine C Capacity Limit: No more than 3 parts on machine C\n        model.addConstr(gp.quicksum(x[p, 'C'] for p in parts) <= 3,\n                        name=\"Limit_MachineC\")\n\n        # 5. Linking Setup Cost: If any x[p,m] = 1, then y[m] must be 1\n        for m in machines:\n            for p in parts:\n                model.addConstr(x[p, m] <= y[m], name=f\"LinkSetup_{p}_{m}\")\n\n        # Alternative tighter linking constraint (optional, usually the one above is sufficient)\n        # for m in machines:\n        #     model.addConstr(gp.quicksum(x[p,m] for p in parts) <= len(parts) * y[m],\n        #                     name=f\"LinkSetupAggregate_{m}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal assignment found.\")\n            print(\n                f\"Minimum Total Cost (Processing + Setup): {model.ObjVal:.2f} Yuan\"\n            )\n\n            print(\"\\nMachine Setup Status:\")\n            for m in machines:\n                if y[m].X > 0.5:\n                    print(\n                        f\"  Machine {m}: Used (Setup Cost: {setup_costs[m]})\")\n                else:\n                    print(f\"  Machine {m}: Not Used\")\n\n            print(\"\\nPart Assignments (Part -> Machine):\")\n            assignments = {}\n            parts_on_machine = {m: [] for m in machines}\n            for p in parts:\n                for m in machines:\n                    if x[p, m].X > 0.5:  # Check if x[p,m] is 1\n                        print(\n                            f\"  Part {p} -> Machine {m} (Processing Cost: {proc_costs[p,m]})\"\n                        )\n                        assignments[p] = m\n                        parts_on_machine[m].append(p)\n                        break  # Move to next part once assigned\n\n            print(\"\\nParts processed on each machine:\")\n            for m in machines:\n                print(\n                    f\"  Machine {m}: {sorted(parts_on_machine[m])} (Count: {len(parts_on_machine[m])})\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and data for contradictions.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"machine_assignment_iis.ilp\")\n            print(\n                \"IIS written to machine_assignment_iis.ilp. Review this file to find conflicting constraints.\"\n            )\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_machine_assignment()\n```\n\nThe optimal value is: 1005.0",
    "task_id": "B076",
    "ground_truth": 1005.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "MILP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA company produces two kinds of products. A product of the first type requires 1/4 hours of assembly labor, 1/8 hours of testing, and $1.2 worth of raw materials. A product of the second type requires 1/3 hours of assembly, 1/3 hours of testing, and $0.9 worth of raw materials. Given the current personnel of the company, there can be at most 90 hours of assembly labor and 80 hours of testing each day. Suppose that up to 50 hours of overtime assembly labor can be scheduled, at a cost of $9 per hour. Products of the first and second type have a market value of $9 and $8 respectively. Try to maximize the daily profit of the company. Provide your answer rounded to the nearest dollar.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\na1, a2 = 1/4, 1/3\nt1, t2 = 1/8, 1/3\nm1, m2 = 1.2, 0.9\nv1, v2 = 9, 8\nA_max, T_max = 90, 80\nO_max = 50\nc_o = 9\n\n# Decision Variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")\no = model.addVar(vtype=GRB.CONTINUOUS, name=\"o\")\n\n# Objective Function\nmodel.setObjective((v1 - m1) * x1 + (v2 - m2) * x2 - c_o * o, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(a1 * x1 + a2 * x2 <= A_max + o, \"Assembly_Constraint\")\nmodel.addConstr(t1 * x1 + t2 * x2 <= T_max, \"Testing_Constraint\")\nmodel.addConstr(o <= O_max, \"Overtime_Constraint\")\n\n# Non-negativity and Integrality Constraints are automatically handled by variable types\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 3918.0",
    "task_id": "E105",
    "ground_truth": 3918.0,
    "problem_domain": "Production Planning",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nMrs. Watson wants to invest in the real-estate market and has a total budget of at most $760000. She has two choices which include condos and detached houses. Each dollar invested in condos yields a $0.50 profit and each dollar invested in detached houses yields a $1 profit. A minimum of 20% of all money invested must be in condos, and at least $20000 must be in detached houses. Formulate an LP that can be used to maximize total profit earned from Mrs. Watson's investment.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"InvestmentOptimization\")\n\n# Parameters\nB = 760000\nr_c = 0.50\nr_d = 1.0\nalpha = 0.20\nM_d = 20000\n\n# Variables\nx_c = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_c\", lb=0)\nx_d = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_d\", lb=0)\n\n# Objective: Maximize profit\nmodel.setObjective(r_c * x_c + r_d * x_d, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_c + x_d <= B, name=\"TotalInvestmentConstraint\")  # C1\nmodel.addConstr(x_c >= alpha * (x_c + x_d), name=\"MinCondosConstraint\")  # C2\nmodel.addConstr(x_d >= M_d, name=\"MinDetachedHousesConstraint\")  # C3\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 684000.0",
    "task_id": "F007",
    "ground_truth": 684000.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Finance"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA shipping company can purchase regular and hybrid vans to make deliveries. A regular van can deliver 500 packages per day and produces 200 units of pollutants. A hybrid van can deliver 300 packages per day and produces 100 units of pollutants. Due to a new environmental law, they can produce at most 7000 units of pollutants per day. However, the company needs to be able to deliver at least 20000 packages per day. How many of each type of van should they buy to minimize the total number of vans needed?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nR = 500  # Packages per day delivered by a regular van\nH = 300  # Packages per day delivered by a hybrid van\nP_R = 200  # Pollutants produced by a regular van\nP_H = 100  # Pollutants produced by a hybrid van\nD = 20000  # Minimum packages to be delivered per day\nP_max = 7000  # Maximum pollutants allowed per day\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of regular vans\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of hybrid vans\n\n# Objective: Minimize the total number of vans\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(R * x + H * y >= D, \"C1\")  # Minimum packages constraint\nmodel.addConstr(P_R * x + P_H * y <= P_max, \"C2\")  # Maximum pollutants constraint\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 60.0",
    "task_id": "F191",
    "ground_truth": 60.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Transportation"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nImagine you're on a mission to optimize your daily meal plan. You're aiming to fulfill your daily nutritional intake while keeping your expenses as low as possible. In front of you, you have a selection of nine different food items: Beef, Pasta, Broccoli, Chicken, Apple, Pork, Lentils, Eggs, and Cheese. Each of these foods has its own cost, protein, carbohydrate, and calorie content.\n\nLet's take a look at the nutritional details and price of each food item:\n\n- Beef: For a cost of $5, serves you with 18 grams of protein, 13 grams of carbohydrates, and 233 calories. \n- Pasta: Comes at $6, but it provides 2 grams of protein, 25 grams of carbohydrates, and 251 calories. \n- Broccoli: Costs $5, and gives 7 grams of protein, 30 grams of carbohydrates, and 191 calories. \n- Chicken: Offers 20 grams of protein, 16 grams of carbohydrates, and 231 calories at a cost of $4. \n- Apple: At $1, provides 5 grams of protein, 6 grams of carbohydrates, and 111 calories. \n- Pork: Priced at $6, gives you 13 grams of protein, 9 grams of carbohydrates, and 275 calories. \n- Lentils: Costing $1, it provides 15 grams of protein, 18 grams of carbohydrates, and 99 calories. \n- Eggs: For $2, they serve 20 grams of protein, 18 grams of carbohydrates, and 210 calories. \n- Cheese: At $7, it provides 9 grams of protein, 14 grams of carbohydrates, and 74 calories. \n\nYour daily dietary requirements are to consume at least 68 grams of protein, 151 grams of carbohydrates, and 1900 calories. The question before you is: How can you meet these nutritional targets in the most cost-effective way using the food options provided? In other words, what is the least amount of money you need to spend in order to fulfill your daily nutritional requirements?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nfoods = ['Beef', 'Pasta', 'Broccoli', 'Chicken', 'Apple', 'Pork', 'Lentils', 'Eggs', 'Cheese']\n\n# Parameters\ncosts = {'Beef': 5, 'Pasta': 6, 'Broccoli': 5, 'Chicken': 4, 'Apple': 1, 'Pork': 6, 'Lentils': 1, 'Eggs': 2, 'Cheese': 7}\nproteins = {'Beef': 18, 'Pasta': 2, 'Broccoli': 7, 'Chicken': 20, 'Apple': 5, 'Pork': 13, 'Lentils': 15, 'Eggs': 20, 'Cheese': 9}\ncarbohydrates = {'Beef': 13, 'Pasta': 25, 'Broccoli': 30, 'Chicken': 16, 'Apple': 6, 'Pork': 9, 'Lentils': 18, 'Eggs': 18, 'Cheese': 14}\ncalories = {'Beef': 233, 'Pasta': 251, 'Broccoli': 191, 'Chicken': 231, 'Apple': 111, 'Pork': 275, 'Lentils': 99, 'Eggs': 210, 'Cheese': 74}\n\n# Nutritional requirements\nP_min = 68\nC_min = 151\nK_min = 1900\n\n# Decision variables\nx = model.addVars(foods, name=\"x\", lb=0, vtype=GRB.INTEGER)\n\n# Objective function\nmodel.setObjective(gp.quicksum(costs[f] * x[f] for f in foods), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(proteins[f] * x[f] for f in foods) >= P_min, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carbohydrates[f] * x[f] for f in foods) >= C_min, \"CarbohydrateRequirement\")\nmodel.addConstr(gp.quicksum(calories[f] * x[f] for f in foods) >= K_min, \"CalorieRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 18.0",
    "task_id": "E025",
    "ground_truth": 18.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA pharmacy makes eye cream and foot cream using two different machines, machine 1 and machine 2. Machine 1 can  make 30 ml of eye cream and 60 ml of foot cream per hour. Machine 2 can make 45 ml of eye cream and 30 ml of foot cream per hour. Furthermore, machine 1 requires 20 ml of distilled water per hour while machine 2 requires 15 ml of distilled water per hour. The pharmacy has available 1200 ml of distilled water. If the pharmacy needs to make at least 1300 ml of eye cream and 1500 ml of foot cream, how many hours should each machine be used to minimize the total time needed?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_machine_hours(\n    production_eye_target=1300,\n    production_foot_target=1500,\n    water_available=1200\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Machine_Usage_Minimization\")\n\n    # Decision variables: hours of machine 1 and machine 2\n    x1 = model.addVar(name=\"x1\", lb=0)\n    x2 = model.addVar(name=\"x2\", lb=0)\n    max_hour = model.addVar(name=\"max_hour\", lb=0)\n\n    # Set objective: minimize total hours\n    model.setObjective(max_hour, GRB.MINIMIZE)\n\n    # Add production constraints\n    model.addConstr(30 * x1 + 45 * x2 >= production_eye_target, name=\"EyeCream\")\n    model.addConstr(60 * x1 + 30 * x2 >= production_foot_target, name=\"FootCream\")\n\n    # Add water constraint\n    model.addConstr(20 * x1 + 15 * x2 <= water_available, name=\"WaterLimit\")\n\n    # Add maximum hour constraints\n    model.addConstr(max_hour >= x1, name=\"MaxHour_x1\")\n    model.addConstr(max_hour >= x2, name=\"MaxHour_x2\")\n    \n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the minimal total time\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nprint(optimize_machine_hours())\n```\n\nThe optimal value is: 17.333333333333332",
    "task_id": "A104",
    "ground_truth": 17.333333333333332,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nIn a science club, there are two tables that can be set up to make slime. At table 1, 3 units of powder and 5 units of glue are used to make 4 units of slime. At table 2, 8 units of powder and 6 units of glue are used to make 5 units of slime. However, table 1 produces 2 units of mess while table 2 produces 4 units of mess. The science club has available 100 units of powder and 90 units of glue.  If at most 30 units of mess can be made, how many of each table should be set up to maximize the amount of slime produced?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SlimeProductionOptimization\")\n\n# Parameters\np1, g1, s1, m1 = 3, 5, 4, 2\np2, g2, s2, m2 = 8, 6, 5, 4\nP, G, M = 100, 90, 30\n\n# Variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")\n\n# Objective: Maximize the total slime produced\nmodel.setObjective(s1 * x1 + s2 * x2, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(p1 * x1 + p2 * x2 <= P, \"PowderConstraint\")\nmodel.addConstr(g1 * x1 + g2 * x2 <= G, \"GlueConstraint\")\nmodel.addConstr(m1 * x1 + m2 * x2 <= M, \"MessConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 60.0",
    "task_id": "F024",
    "ground_truth": 60.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Education"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nIn the bustling world of retail and distribution, a major company, GlobalSupply, is facing a strategic challenge. It needs to efficiently supply its products to eight different retail stores, each with its own demand for goods. To achieve this, GlobalSupply is considering opening up to eight different distribution centers, but each center comes with its own set of opening costs and has a specific capacity limit. Additionally, the cost of transporting goods from these distribution centers to the retail stores varies, adding another layer of complexity to the decision-making process. GlobalSupply's primary objective is to fulfill the demand at each retail store while minimizing the total cost, which includes both the opening costs of the distribution centers and the transportation costs of the goods.\n\nGiven Data:\n- Number of Potential Distribution Centers: 8\n- Number of Retail Stores Needing Supply: 8\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n- Center 6: $120,000\n- Center 7: $182,000\n- Center 8: $186,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1 to Stores: $3 to Store 1, $3 to Store 2, $5 to Store 3, $4 to Store 4, $3 to Store 5, $5 to Store 6, $2 to Store 7, $4 to Store 8\n- From Center 2 to Stores: $2 to Store 1, $4 to Store 2, $5 to Store 3, $1 to Store 4, $4 to Store 5, $2 to Store 6, $5 to Store 7, $4 to Store 8\n- From Center 3 to Stores: $1 to Store 1, $1 to Store 2, $3 to Store 3, $3 to Store 4, $2 to Store 5, $4 to Store 6, $4 to Store 7, $3 to Store 8\n- From Center 4 to Stores: $4 to Store 1, $4 to Store 2, $1 to Store 3, $3 to Store 4, $5 to Store 5, $3 to Store 6, $5 to Store 7, $1 to Store 8\n- From Center 5 to Stores: $2 to Store 1, $4 to Store 2, $1 to Store 3, $4 to Store 4, $2 to Store 5, $2 to Store 6, $1 to Store 7, $2 to Store 8\n- From Center 6 to Stores: $5 to Store 1, $2 to Store 2, $4 to Store 3, $4 to Store 4, $4 to Store 5, $4 to Store 6, $5 to Store 7, $3 to Store 8\n- From Center 7 to Stores: $1 to Store 1, $4 to Store 2, $2 to Store 3, $4 to Store 4, $2 to Store 5, $2 to Store 6, $4 to Store 7, $5 to Store 8\n- From Center 8 to Stores: $2 to Store 1, $2 to Store 2, $4 to Store 3, $2 to Store 4, $2 to Store 5, $4 to Store 6, $4 to Store 7, $1 to Store 8\n\nDemand of Each Retail Store (in units):\n- Store 1: 695 units\n- Store 2: 737 units\n- Store 3: 452 units\n- Store 4: 616 units\n- Store 5: 587 units\n- Store 6: 779 units\n- Store 7: 892 units\n- Store 8: 440 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1980 units\n- Center 2: 814 units\n- Center 3: 864 units\n- Center 4: 1320 units\n- Center 5: 1952 units\n- Center 6: 1447 units\n- Center 7: 1886 units\n- Center 8: 1962 units\n\nQuestion:\nConsidering these details, what is the optimal total cost for GlobalSupply to open distribution centers and transport goods to meet all retail stores' demands? This cost includes both the opening costs of the centers and the transportation costs of supplying the stores.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"GlobalSupplyOptimization\")\n\n# Sets\nI = range(1, 9)  # Distribution centers\nJ = range(1, 9)  # Retail stores\n\n# Parameters\nopening_costs = {\n    1: 151000, 2: 192000, 3: 114000, 4: 171000,\n    5: 160000, 6: 120000, 7: 182000, 8: 186000\n}\n\ntransportation_costs = {\n    (1, 1): 3, (1, 2): 3, (1, 3): 5, (1, 4): 4, (1, 5): 3, (1, 6): 5, (1, 7): 2, (1, 8): 4,\n    (2, 1): 2, (2, 2): 4, (2, 3): 5, (2, 4): 1, (2, 5): 4, (2, 6): 2, (2, 7): 5, (2, 8): 4,\n    (3, 1): 1, (3, 2): 1, (3, 3): 3, (3, 4): 3, (3, 5): 2, (3, 6): 4, (3, 7): 4, (3, 8): 3,\n    (4, 1): 4, (4, 2): 4, (4, 3): 1, (4, 4): 3, (4, 5): 5, (4, 6): 3, (4, 7): 5, (4, 8): 1,\n    (5, 1): 2, (5, 2): 4, (5, 3): 1, (5, 4): 4, (5, 5): 2, (5, 6): 2, (5, 7): 1, (5, 8): 2,\n    (6, 1): 5, (6, 2): 2, (6, 3): 4, (6, 4): 4, (6, 5): 4, (6, 6): 4, (6, 7): 5, (6, 8): 3,\n    (7, 1): 1, (7, 2): 4, (7, 3): 2, (7, 4): 4, (7, 5): 2, (7, 6): 2, (7, 7): 4, (7, 8): 5,\n    (8, 1): 2, (8, 2): 2, (8, 3): 4, (8, 4): 2, (8, 5): 2, (8, 6): 4, (8, 7): 4, (8, 8): 1\n}\n\ndemand = {\n    1: 695, 2: 737, 3: 452, 4: 616,\n    5: 587, 6: 779, 7: 892, 8: 440\n}\n\ncapacity = {\n    1: 1980, 2: 814, 3: 864, 4: 1320,\n    5: 1952, 6: 1447, 7: 1886, 8: 1962\n}\n\n# Decision Variables\nx = model.addVars(I, J, vtype=GRB.CONTINUOUS, name=\"x\", lb=0)\ny = model.addVars(I, vtype=GRB.BINARY, name=\"y\")\n\n# Objective Function\nmodel.setObjective(\n    gp.quicksum(opening_costs[i] * y[i] for i in I) +\n    gp.quicksum(transportation_costs[i, j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Supply capacity constraints\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= capacity[i] * y[i] for i in I),\n    name=\"SupplyCapacity\"\n)\n\n# Demand satisfaction constraints\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == demand[j] for j in J),\n    name=\"DemandSatisfaction\"\n)\n\n# Optimize\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 443177.0",
    "task_id": "E086",
    "ground_truth": 443177.0,
    "problem_domain": "Facility Location",
    "modeling_type": "MILP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA post office is buying stamping machines and they can buy a dual or single model stamping machine. A dual model stamping machine can stamp 50 letters per minute while a single model stamping machine can stamp 30 letters per minute. The dual model stamping machine requires 20 units of glue per minute while the single model stamping machine requires 15 units of glue per minute. Since the single model stamping machine is quieter, the number of single model stamping machines must be more than the number of dual model stamping machines. Further, the post office wants to make sure they can stamp at least 300 letters per minute and use at most 135 units of glue per minute. How many of each stamping machine should they purchase to minimize the total number of stamping machines?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"PostOfficeStampingMachines\")\n\n# Parameters\np_d = 50  # Stamping rate of dual model\np_s = 30  # Stamping rate of single model\ng_d = 20  # Glue consumption rate of dual model\ng_s = 15  # Glue consumption rate of single model\nL = 300   # Minimum letters to be stamped\nG = 135   # Maximum glue units available\n\n# Variables\nx_d = model.addVar(vtype=GRB.INTEGER, name=\"x_d\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n\n# Objective: Minimize total number of stamping machines\nmodel.setObjective(x_d + x_s, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(p_d * x_d + p_s * x_s >= L, \"C1\")  # Ensure at least 300 letters are stamped\nmodel.addConstr(g_d * x_d + g_s * x_s <= G, \"C2\")  # Ensure glue consumption does not exceed 135 units\nmodel.addConstr(x_s >= x_d + 1, \"C3\")  # Ensure the number of single model machines is more than dual model machines\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 8.0",
    "task_id": "F195",
    "ground_truth": 8.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Logistics"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nDistribution Dynamics Inc. has a strategic challenge to efficiently supply its seven retail stores from a choice of five potential distribution centers. This operation has to manage not only the differing opening costs of each distribution center but also the variability in their capacity to meet demands and the transportation costs involved in shipping goods to each retail store. The company aims to fulfill the demand at each retail location while minimizing the total cost involved, which encompasses the opening costs of the distribution centers and the transportation costs of the goods.\n\nGiven Data:\n- Number of Potential Distribution Centers: 5\n- Number of Retail Stores Needing Supply: 7\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $5 to Store 1, $2 to Store 2, $3 to Store 3, $3 to Store 4, $3 to Store 5, $5 to Store 6, $4 to Store 7\n- From Center 2: $3 to Store 1, $5 to Store 2, $2 to Store 3, $4 to Store 4, $2 to Store 5, $4 to Store 6, $5 to Store 7\n- From Center 3: $1 to Store 1, $4 to Store 2, $2 to Store 3, $5 to Store 4, $4 to Store 5, $1 to Store 6, $1 to Store 7\n- From Center 4: $3 to Store 1, $3 to Store 2, $2 to Store 3, $4 to Store 4, $4 to Store 5, $3 to Store 6, $4 to Store 7\n- From Center 5: $4 to Store 1, $1 to Store 2, $3 to Store 3, $5 to Store 4, $3 to Store 5, $5 to Store 6, $1 to Store 7\n\nDemand of Each Retail Store (in units):\n- Store 1: 566 units\n- Store 2: 673 units\n- Store 3: 787 units\n- Store 4: 1000 units\n- Store 5: 715 units\n- Store 6: 413 units\n- Store 7: 641 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1576 units\n- Center 2: 1364 units\n- Center 3: 1697 units\n- Center 4: 891 units\n- Center 5: 1755 units\n\nQuestion:\nWhat is the optimal total cost for Distribution Dynamics Inc. to open the necessary distribution centers and transport goods in order to meet all retail stores' demands at the lowest possible cost, taking into account both the opening costs of the centers and the transportation costs of supplying the stores?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DistributionDynamics\")\n\n# Sets\nM = 5  # Number of distribution centers\nN = 7  # Number of retail stores\n\n# Parameters\nopening_costs = [151000, 192000, 114000, 171000, 160000]\ntransportation_costs = [\n    [5, 2, 3, 3, 3, 5, 4],\n    [3, 5, 2, 4, 2, 4, 5],\n    [1, 4, 2, 5, 4, 1, 1],\n    [3, 3, 2, 4, 4, 3, 4],\n    [4, 1, 3, 5, 3, 5, 1]\n]\ndemands = [566, 673, 787, 1000, 715, 413, 641]\nsupply_capacities = [1576, 1364, 1697, 891, 1755]\n\n# Decision Variables\nx = model.addVars(M, N, vtype=GRB.INTEGER, name=\"x\")\ny = model.addVars(M, vtype=GRB.BINARY, name=\"y\")\n\n# Objective Function\nmodel.setObjective(\n    gp.quicksum(opening_costs[i] * y[i] for i in range(M)) +\n    gp.quicksum(transportation_costs[i][j] * x[i, j] for i in range(M) for j in range(N)),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# (C1) Demand fulfillment at each retail store\nfor j in range(N):\n    model.addConstr(gp.quicksum(x[i, j] for i in range(M)) == demands[j], f\"demand_fulfillment_{j}\")\n\n# (C2) Supply capacity constraint at each distribution center\nfor i in range(M):\n    model.addConstr(gp.quicksum(x[i, j] for j in range(N)) <= supply_capacities[i] * y[i], f\"supply_capacity_{i}\")\n\n# (C3) Binary constraints on y_i are automatically handled by the vtype=GRB.BINARY\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 434081.0",
    "task_id": "E088",
    "ground_truth": 434081.0,
    "problem_domain": "Facility Location",
    "modeling_type": "MILP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA souvenir shop makes wooden elephants and tigers with plastic ornaments. Each elephant requires 50 grams of wood and 20 grams of plastic. Each tiger requires 40 grams of wood and 30 grams of plastic. In a week, 5000 grams of wood and 4000 grams of plastic are available. The profit per elephant sold is $5 and the profit per tiger sold is $4. How many of each should be made in order to maximize profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nW = 5000  # grams of wood available per week\nP = 4000  # grams of plastic available per week\nw_e = 50  # grams of wood required per elephant\np_e = 20  # grams of plastic required per elephant\nw_t = 40  # grams of wood required per tiger\np_t = 30  # grams of plastic required per tiger\npi_e = 5  # dollars profit per elephant\npi_t = 4  # dollars profit per tiger\n\n# Variables\nx_e = model.addVar(vtype=GRB.INTEGER, name=\"elephants\")\nx_t = model.addVar(vtype=GRB.INTEGER, name=\"tigers\")\n\n# Objective\nmodel.setObjective(pi_e * x_e + pi_t * x_t, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(w_e * x_e + w_t * x_t <= W, \"wood_limit\")\nmodel.addConstr(p_e * x_e + p_t * x_t <= P, \"plastic_limit\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 500.0",
    "task_id": "F105",
    "ground_truth": 500.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nPlatinum in combination with palladium has been used as a catalyst in cars and it changes carbon monoxide, which is toxic, into carbon dioxide. An automotive company is comparing two different catalysts, a palladium-heavy catalyst and a platinum-heavy catalyst. The process with a palladium-heavy catalyst requires 15 units of platinum and 25 units of palladium and can perform the conversion to carbon dioxide at a rate of 5 units per second. A platinum-heavy catalyst requires 20 units of platinum and 14 units of palladium and converts to carbon dioxide at a rate of 4 units per second. There are 450 units of platinum and 390 units of palladium available. How many of each catalyst should be used to maximize the amount converted into carbon dioxide?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"CatalystOptimization\")\n\n# Add variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")  # Number of palladium-heavy catalysts\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")  # Number of platinum-heavy catalysts\n\n# Set objective\nmodel.setObjective(5 * x1 + 4 * x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(15 * x1 + 20 * x2 <= 450, \"C1\")  # Platinum usage constraint\nmodel.addConstr(25 * x1 + 14 * x2 <= 390, \"C2\")  # Palladium usage constraint\nmodel.addConstr(x1 >= 0, \"C3\")  # Non-negativity constraint for x1\nmodel.addConstr(x2 >= 0, \"C4\")  # Non-negativity constraint for x2\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 98.0",
    "task_id": "F126",
    "ground_truth": 98.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA body builder buys pre prepared meals, a turkey dinner and a tuna salad sandwich. The turkey dinner contains 20 grams of protein, 30 grams of carbs, and 12 grams of fat. The tuna salad sandwich contains 18 grams of protein, 25 grams of carbs, and 8 grams of fat. The bodybuilder wants to get at least 150 grams of protein and 200 grams of carbs. In addition because the turkey dinner is expensive, at most 40% of the meals should be turkey dinner. How many of each meal should he eat if he wants to minimize his fat intake?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nmodel = gp.Model(\"MinimizeFatIntake\")\n\n# Parameters\np_d = 20  # Protein in grams per turkey dinner\nc_d = 30  # Carbs in grams per turkey dinner\nf_d = 12  # Fat in grams per turkey dinner\np_s = 18  # Protein in grams per tuna salad sandwich\nc_s = 25  # Carbs in grams per tuna salad sandwich\nf_s = 8   # Fat in grams per tuna salad sandwich\nP = 150   # Minimum required grams of protein\nC = 200   # Minimum required grams of carbs\nalpha = 0.4  # Maximum proportion of turkey dinners\n\n# Decision variables\nx_d = model.addVar(vtype=GRB.INTEGER, name=\"turkey_dinners\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"tuna_salad_sandwiches\")\n\n# Objective: Minimize fat intake\nmodel.setObjective(f_d * x_d + f_s * x_s, GRB.MINIMIZE)\n\n# Constraints\n# (C1) Protein constraint\nmodel.addConstr(p_d * x_d + p_s * x_s >= P, \"ProteinRequirement\")\n\n# (C2) Carbs constraint\nmodel.addConstr(c_d * x_d + c_s * x_s >= C, \"CarbsRequirement\")\n\n# (C3) Proportion of turkey dinners\nmodel.addConstr(x_d <= alpha * (x_d + x_s), \"TurkeyDinnerProportion\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 72.0",
    "task_id": "F028",
    "ground_truth": 72.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA sand company delivers sand for playgrounds in small and large containers. A small container requires 1 person to unload and can hold 20 units of sand. A large container requires 3 people to unload and can hold 50 units of sand. Since most playgrounds are small, the number of small containers used must be thrice the number of large containers used. In addition, there must be at least 5 small containers and 3 large containers used. If the company has 100 people available, maximize the amount of sand that they can deliver.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_sand_delivery():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"SandDelivery\")\n\n    # Decision variables\n    # x_s: number of small containers\n    # x_l: number of large containers\n    x_s = m.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n    x_l = m.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n    # Set objective: maximize total sand\n    m.setObjective(20 * x_s + 50 * x_l, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Container ratio constraint\n    m.addConstr(x_s == 3 * x_l, \"ratio\")\n    # Minimum containers\n    m.addConstr(x_s >= 5, \"min_small\")\n    m.addConstr(x_l >= 3, \"min_large\")\n    # Labor constraint\n    m.addConstr(x_s + 3 * x_l <= 100, \"labor\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum amount of sand delivered\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_sand = optimize_sand_delivery()\n    if max_sand is not None:\n        print(f\"Maximum Amount of Sand Delivered: {max_sand}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 1760.0",
    "task_id": "A138",
    "ground_truth": 1760.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Logistics"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA car manufacturer makes two versions of the same car, a regular model and a premium model. They make x1 regular models per day and x2 premium models per day. The profit per regular model is $5000 and the profit per premium model is $8500 (x1 and x2 are unknown values both greater than or equal to 0). The daily demand for these cars is limited to and most 8 regular models and 6 premium models. In addition, the manufacturer can make a maximum of 12 cars of either type per day. How many cars of each model should the manufacturer make in order to maximize profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_car_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Car_Production_Maximize_Profit\")\n\n    # Decision variables: number of regular and premium cars\n    # Assuming production quantities are continuous; set vtype=GRB.CONTINUOUS\n    x1 = m.addVar(name=\"Regular\", vtype=GRB.CONTINUOUS, lb=0)\n    x2 = m.addVar(name=\"Premium\", vtype=GRB.CONTINUOUS, lb=0)\n\n    # Set the objective: maximize profit\n    profit_regular = 5000\n    profit_premium = 8500\n    m.setObjective(profit_regular * x1 + profit_premium * x2, GRB.MAXIMIZE)\n\n    # Add demand constraints\n    m.addConstr(x1 <= 8, name=\"Demand_Regular\")\n    m.addConstr(x2 <= 6, name=\"Demand_Premium\")\n\n    # Add production capacity constraint\n    m.addConstr(x1 + x2 <= 12, name=\"Total_Capacity\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit value\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_car_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 81000.0",
    "task_id": "A020",
    "ground_truth": 81000.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nAn artisan makes two types of terracotta jars: a thin jar and a stubby jar. Each thin jar requires 50 minutes of shaping time and 90 minutes of baking time. Each stubby jar requires 30 minutes of shaping time and 150 minutes of baking time. Per week, there are 3000 minutes available for shaping and 4000 minutes available for baking. The profit per thin jar is $5 and the profit per stubby jar is $9. How many jars of each type should the artisan make to maximize profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nt_t = 50  # Shaping time for thin jar\nb_t = 90  # Baking time for thin jar\nt_s = 30  # Shaping time for stubby jar\nb_s = 150 # Baking time for stubby jar\nT = 3000  # Total shaping time available\nB = 4000  # Total baking time available\np_t = 5   # Profit for thin jar\np_s = 9   # Profit for stubby jar\n\n# Variables\nx_t = model.addVar(vtype=GRB.INTEGER, name=\"x_t\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n\n# Objective: Maximize profit\nmodel.setObjective(p_t * x_t + p_s * x_s, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(t_t * x_t + t_s * x_s <= T, \"ShapingTimeConstraint\")\nmodel.addConstr(b_t * x_t + b_s * x_s <= B, \"BakingTimeConstraint\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 239.0",
    "task_id": "F072",
    "ground_truth": 239.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA tourist spot in the mountains allows visitors to travel to the top either by hot-air balloon or gondola lift. A hot air balloon can carry 4 visitors while a gondola lift can carry 6 visitors. Each hot air balloon produces 10 units of pollution while each gondola lift produces 15 units of pollution. There can be at most 10 hot-air balloon rides and at least 70 visitors need to be transported. How many of each type of transport method should be taken to minimize the total pollution produced?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef minimize_pollution():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TouristTransportPollution\")\n\n    # Decision variables\n    # x: number of hot-air balloon rides\n    # y: number of gondola lift rides\n    x = m.addVar(vtype=GRB.INTEGER, name=\"hot_air_balloons\", lb=0, ub=10)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"gondola_lifts\", lb=0)\n\n    # Set objective: minimize total pollution\n    m.setObjective(10 * x + 15 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Capacity constraint\n    m.addConstr(4 * x + 6 * y >= 70, \"capacity\")\n    # Hot-air balloon ride limit\n    m.addConstr(x <= 10, \"max_balloons\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pollution = minimize_pollution()\n    if min_pollution is not None:\n        print(f\"Minimum Total Pollution: {min_pollution}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 175.0",
    "task_id": "A157",
    "ground_truth": 175.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Tourism"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA patient is undergoing radiation treatment involving two beams, Beam 1 and Beam 2. Beam 1 delivers a dose of 0.3 units of medicine per minute to the benign area of the pancreas and 0.2 units of medicine per minute to the benign area of the skin. Beam 2 delivers 0.2 units of medicine per minute to the benign area of the pancreas and 0.1 units of medicine per minute to the benign area of the skin.  In addition, beam 1 delivers 0.6 units of medicine per minute to the tumor and beam 2 delivers 0.4 units of medicine per minute to the tumor. At most 4 units of medicine should be received by the skin and at least 3 units of medicine should be delivered to the tumor.  How many minutes of each beam should be used to minimize the total radiation received by the pancreas?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"RadiationTreatmentOptimization\")\n\n# Parameters\nd_p1 = 0.3  # Dose to pancreas by Beam 1\nd_p2 = 0.2  # Dose to pancreas by Beam 2\nd_s1 = 0.2  # Dose to skin by Beam 1\nd_s2 = 0.1  # Dose to skin by Beam 2\nd_t1 = 0.6  # Dose to tumor by Beam 1\nd_t2 = 0.4  # Dose to tumor by Beam 2\nS_max = 4   # Max dose to skin\nT_min = 3   # Min dose to tumor\n\n# Variables\nx1 = model.addVar(vtype=GRB.CONTINUOUS, name=\"x1\", lb=0)\nx2 = model.addVar(vtype=GRB.CONTINUOUS, name=\"x2\", lb=0)\n\n# Objective: Minimize the total radiation received by the pancreas\nmodel.setObjective(d_p1 * x1 + d_p2 * x2, GRB.MINIMIZE)\n\n# Constraints\n# Skin dose constraint\nmodel.addConstr(d_s1 * x1 + d_s2 * x2 <= S_max, \"SkinDose\")\n\n# Tumor dose constraint\nmodel.addConstr(d_t1 * x1 + d_t2 * x2 >= T_min, \"TumorDose\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 1.5",
    "task_id": "F027",
    "ground_truth": 1.5,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nAyse produces a plant growth compound by mixing two types of fertilizer: C and Y. This growth compound must contain at least 5 units of nitrous oxide and 8 units of vitamin mix. Fertilizer C and Y cost $2 and $3 per kg respectively. Fertilizer C contains 1.5 units of nitrous oxide per kg and 3 units of vitamin mix per kg. Fertilizer Y contains 5 units of nitrous oxide per kg and 1 unit of vitamin mix per kg. Determine the minimum cost of Ayse's compound.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Add variables\nx_C = model.addVar(name=\"x_C\", lb=0, vtype=GRB.CONTINUOUS)\nx_Y = model.addVar(name=\"x_Y\", lb=0, vtype=GRB.CONTINUOUS)\n\n# Set objective\nmodel.setObjective(2 * x_C + 3 * x_Y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(1.5 * x_C + 5 * x_Y >= 5, \"NitrousOxideRequirement\")\nmodel.addConstr(3 * x_C + 1 * x_Y >= 8, \"VitaminMixRequirement\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 5.85185186",
    "task_id": "F157",
    "ground_truth": 5.85185186,
    "problem_domain": "Blending",
    "modeling_type": "LP",
    "industry_sector": "Agriculture"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA clinic is conducting a throat or nasal swabs on each patient. A throat swab takes 5 minutes while a nasal swab takes 3 minutes. The clinic must administer at least 30 nasal swabs. Since the nasal swab is more uncomfortable, at least 4 times as many throat swabs must be done as nasal swabs. If the clinic is only operational for 20000 minutes, how many of each swab should be done to maximize the number of patients seen?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_swabs(time_limit=20000, min_nasal=30, ratio=4):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Swab Optimization\")\n    \n    # Decision variables: number of throat and nasal swabs\n    T = model.addVar(name=\"ThroatSwabs\", vtype=GRB.INTEGER, lb=0)\n    N = model.addVar(name=\"NasalSwabs\", vtype=GRB.INTEGER, lb=0)\n    \n    # Set the objective: maximize total number of patients (swabs)\n    model.setObjective(T + N, GRB.MAXIMIZE)\n    \n    # Add constraints\n    # Time constraint\n    model.addConstr(5 * T + 3 * N <= time_limit, name=\"TimeLimit\")\n    # Minimum nasal swabs\n    model.addConstr(N >= min_nasal, name=\"MinNasal\")\n    # Throat to nasal ratio\n    model.addConstr(T >= ratio * N, name=\"ThroatNasalRatio\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total number of patients served\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_patients = optimize_swabs()\n    if max_patients is not None:\n        print(f\"Maximum Number of Patients Served: {max_patients}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 4347.0",
    "task_id": "A107",
    "ground_truth": 4347.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nDue to an accident, at least 550 locals must be moved across a lake. They can either be transported over the lake by a kayak or a motorboat. Kayaks can transport 4 people every trip and motorboats can transport 5 people every trip. Kayaks take 5 minutes per trip whereas motorboats take 3 minutes per trip. Due to the limited number of motorboats available to the locals, there can be at most 25 motorboat trips and at least 75% of the trips should be by kayak. How many of each transportation method should be used to minimize the total amount of time needed to transport all the locals?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_transportation(min_people=550, max_motor_trips=25, kayak_time=5, motor_time=3, min_kayak_ratio=0.75):\n    from gurobipy import Model, GRB\n    \n    # Create a new model\n    m = Model(\"LakeTransport\")\n    \n    # Decision variables\n    # k: number of kayak trips\n    # m_trips: number of motorboat trips\n    k = m.addVar(vtype=GRB.INTEGER, name=\"kayak_trips\", lb=0)\n    m_trips = m.addVar(vtype=GRB.INTEGER, name=\"motorboat_trips\", lb=0)\n    \n    # Set objective: minimize total time\n    m.setObjective(kayak_time * k + motor_time * m_trips, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Capacity constraint: at least min_people transported\n    m.addConstr(4 * k + 5 * m_trips >= min_people, \"capacity\")\n    \n    # Motorboat trip limit\n    m.addConstr(m_trips <= max_motor_trips, \"max_motor_trips\")\n    \n    # Trip ratio constraint: at least 75% trips are by kayak\n    m.addConstr(k >= 3 * m_trips, \"trip_ratio\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_time = m.objVal\n        return total_time\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_transportation()\n    if min_time is not None:\n        print(f\"Minimum Total Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 610.0",
    "task_id": "A227",
    "ground_truth": 610.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Transportation"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA company sells custom scooters and bikes for customers. The profit per scooter is $200 and the profit per bike is $300. Each product requires time with the design team and engineering team. Each scooter needs 2 hours with the design team and 3 hours with the engineering team. Each bike needs 4 hours with the design team and 5 hours with the engineering team. Per month, there are 5000 hours available on the design team and 6000 hours available on the engineering team. How many of each should the company make per month to maximize profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Scooters_and_Bikes_Optimization\")\n\n# Parameters\np_s = 200  # Profit per scooter\np_b = 300  # Profit per bike\nt_ds = 2   # Design team hours per scooter\nt_db = 4   # Design team hours per bike\nt_es = 3   # Engineering team hours per scooter\nt_eb = 5   # Engineering team hours per bike\nH_d = 5000  # Total design team hours available\nH_e = 6000  # Total engineering team hours available\n\n# Variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_b = model.addVar(vtype=GRB.INTEGER, name=\"x_b\")\n\n# Objective function\nmodel.setObjective(p_s * x_s + p_b * x_b, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(t_ds * x_s + t_db * x_b <= H_d, \"DesignTeamHours\")\nmodel.addConstr(t_es * x_s + t_eb * x_b <= H_e, \"EngineeringTeamHours\")\nmodel.addConstr(x_s >= 0, \"NonNegativity_s\")\nmodel.addConstr(x_b >= 0, \"NonNegativity_b\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 400000.0",
    "task_id": "F166",
    "ground_truth": 400000.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nConsider a scenario where a tour guide is planning a bus tour across five cities, named E, F, G, H, and I. The tour must start and end in the same city, and each city should be visited exactly once. The objective is to minimize the total cost of the tour, which could be influenced by factors such as distance, tolls, and fuel expenses.\n\nHere are the travel costs between the cities:\n\nFrom City E, it costs 37 units to travel to F, 72 units to G, 66 units to H, and 33 units to I.\nTravelling from City F, the costs are 37 units to E, 26 units to G, 56 units to H, and a whopping 100 units to I.\nIf the journey starts from City G, it takes 72 units to reach E, 26 units to F, 49 units to H, and 32 units to I.\nFrom City H, it costs 66 units to get to E, 56 units to F, 49 units to G, and a mere 13 units to I.\nLastly, from City I, the travel costs are 33 units to E, 100 units to F, 32 units to G, and 13 units to H.\n\nKeeping these costs in mind, what is the minimum total travel cost for the tour guide to take the bus to each city exactly once and return to the starting city?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"TourOptimization\")\n\n# Set of cities\ncities = ['E', 'F', 'G', 'H', 'I']\n\n# Costs of travel between cities\ncosts = {\n    ('E', 'F'): 37, ('E', 'G'): 72, ('E', 'H'): 66, ('E', 'I'): 33,\n    ('F', 'E'): 37, ('F', 'G'): 26, ('F', 'H'): 56, ('F', 'I'): 100,\n    ('G', 'E'): 72, ('G', 'F'): 26, ('G', 'H'): 49, ('G', 'I'): 32,\n    ('H', 'E'): 66, ('H', 'F'): 56, ('H', 'G'): 49, ('H', 'I'): 13,\n    ('I', 'E'): 33, ('I', 'F'): 100, ('I', 'G'): 32, ('I', 'H'): 13\n}\n\n# Decision variables\nx = model.addVars(cities, cities, vtype=GRB.BINARY, name=\"x\")\n\n# Set objective\nmodel.setObjective(gp.quicksum(costs[i, j] * x[i, j] for i in cities for j in cities if i != j), GRB.MINIMIZE)\n\n# Constraints: Each city must be departed from exactly once\nfor i in cities:\n    model.addConstr(gp.quicksum(x[i, j] for j in cities if i != j) == 1, name=f\"depart_{i}\")\n\n# Constraints: Each city must be arrived at exactly once\nfor j in cities:\n    model.addConstr(gp.quicksum(x[i, j] for i in cities if i != j) == 1, name=f\"arrive_{j}\")\n\n# Subtour elimination constraints: Add lazy constraints\ndef subtour_elimination(model, where):\n    if where == GRB.Callback.MIPSOL:\n        selected = []\n        for i in cities:\n            for j in cities:\n                if i != j and model.cbGetSolution(x[i, j]) > 0.5:\n                    selected.append((i, j))\n        \n        # Find the shortest subtour\n        tour = subtour(selected)\n        \n        if len(tour) < len(cities):\n            model.cbLazy(gp.quicksum(x[i, j] for i in tour for j in tour if i != j) <= len(tour) - 1)\n\ndef subtour(edges):\n    unvisited = set(cities)\n    cycles = []\n    lengths = []\n    while unvisited:\n        thiscycle = []\n        neighbors = unvisited.pop()\n        while neighbors:\n            thiscycle.append(neighbors)\n            unvisited.remove(neighbors)\n            neighbors = [j for i, j in edges if i == neighbors and j in unvisited]\n            neighbors = neighbors[0] if neighbors else None\n        cycles.append(thiscycle)\n        lengths.append(len(thiscycle))\n    return cycles[lengths.index(min(lengths))]\n\n# Add start and end constraints (x[i,i] = 0)\nfor i in cities:\n    model.addConstr(x[i, i] == 0, name=f\"no_loop_{i}\")\n\n# Optimize model with the subtour elimination callback\nmodel.Params.LazyConstraints = 1\nmodel.optimize(subtour_elimination)\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 158.0",
    "task_id": "E043",
    "ground_truth": 158.0,
    "problem_domain": "Routing",
    "modeling_type": "IP",
    "industry_sector": "Transportation"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA flooring company produces engineered hardwood and vinyl planks. Their sales forecasts show an expected demand of at least 20,000 square foot of hardwood and 10,000 square feet of vinyl planks each week. To satisfy a shipping contract, a total of at least 60,000 square feet of flooring much be shipped each week. Due to a labor shortage issue, no more than 50,000 square feet of hardwood and 30,000  square feet of vinyl  can be produced weekly. If a square foot of hardwood flooring yields a profit of $2.5 and a square foot of vinyl planks produces a $3 profit, how many of each type of flooring should be made weekly to maximize the company's profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define the variables\nx_h = model.addVar(vtype=GRB.INTEGER, name=\"x_h\", lb=0)\nx_v = model.addVar(vtype=GRB.INTEGER, name=\"x_v\", lb=0)\n\n# Set the objective function\nmodel.setObjective(2.5 * x_h + 3 * x_v, GRB.MAXIMIZE)\n\n# Add the constraints\nmodel.addConstr(x_h >= 20000, \"C1\")\nmodel.addConstr(x_v >= 10000, \"C2\")\nmodel.addConstr(x_h + x_v >= 60000, \"C3\")\nmodel.addConstr(x_h <= 50000, \"C4\")\nmodel.addConstr(x_v <= 30000, \"C5\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 215000.0",
    "task_id": "F164",
    "ground_truth": 215000.0,
    "problem_domain": "Production Planning",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nAn office company makes desks and drawers. Each desk requires 40 minutes of assembly and 20 minutes of sanding. Each drawer requires 30 minutes of assembly and 10 minutes of sanding. The company has available 4000 minutes for assembly and 3500 minutes for sanding. If the profit per desk is $100 and the profit per drawer is $90, how many of each should the company make to maximize profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_desks_drawers():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Desks_and_Drawers\")\n\n    # Decision variables: number of desks and drawers\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Desks\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Drawers\")\n\n    # Set the objective: maximize profit\n    m.setObjective(100 * x + 90 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(40 * x + 30 * y <= 4000, \"AssemblyTime\")\n    m.addConstr(20 * x + 10 * y <= 3500, \"SandingTime\")\n    m.addConstr(x >= 0, \"NonNegDesks\")\n    m.addConstr(y >= 0, \"NonNegDrawers\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_desks_drawers()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 11980.0",
    "task_id": "A174",
    "ground_truth": 11980.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA company uses steel and aluminum as raw materials to produce two products (A and B). A single unit of product A requires 6 kg of steel, 8 kg of aluminum, 11 hours of labor, and yields a profit of 5000 yuan (excluding worker overtime pay). A single unit of product B requires 12 kg of steel, 20 kg of aluminum, 24 hours of labor, and yields a profit of 11000 yuan (excluding worker overtime pay). The company currently has 200 kg of steel, 300 kg of aluminum, and 300 hours of labor available. If workers need to work overtime, the overtime pay is 100 yuan per hour. Please develop a production plan to maximize the company's profit and minimize worker overtime.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_production_planning_with_overtime():\n    \"\"\"\n    Solves the production planning problem to maximize net profit,\n    considering resource constraints and overtime pay.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['A', 'B']\n\n        # Profit per unit (excluding worker overtime pay) (yuan/unit)\n        gross_profit = {'A': 5000, 'B': 11000}\n\n        # Resource requirements per unit\n        steel_req = {'A': 6, 'B': 12}  # kg/unit\n        aluminum_req = {'A': 8, 'B': 20}  # kg/unit\n        labor_req = {'A': 11, 'B': 24}  # hours/unit\n\n        # Resource availability\n        avail_steel = 200  # kg\n        avail_aluminum = 300  # kg\n        avail_labor_regular = 300  # hours\n\n        # Overtime pay (yuan/hour)\n        overtime_pay_per_hour = 100\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ProductionPlanningOvertime\")\n\n        # --- Decision Variables ---\n        # X[p]: Number of units of product p to produce\n        X = model.addVars(products, name=\"Produce\", vtype=GRB.INTEGER, lb=0)\n\n        # OT: Total overtime hours used\n        OT = model.addVar(name=\"OvertimeHours\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Net Profit ---\n        # Net Profit = Gross Profit from Products - Cost of Overtime\n        total_gross_profit = gp.quicksum(gross_profit[p] * X[p]\n                                         for p in products)\n        total_overtime_cost = overtime_pay_per_hour * OT\n\n        model.setObjective(total_gross_profit - total_overtime_cost,\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Steel Constraint\n        model.addConstr(gp.quicksum(steel_req[p] * X[p] for p in products)\n                        <= avail_steel,\n                        name=\"SteelLimit\")\n\n        # 2. Aluminum Constraint\n        model.addConstr(gp.quicksum(aluminum_req[p] * X[p] for p in products)\n                        <= avail_aluminum,\n                        name=\"AluminumLimit\")\n\n        # 3. Labor Constraint\n        # Total labor hours required can be met by regular hours + overtime hours\n        # TotalLaborRequired <= RegularLaborAvailable + Overtime\n        # TotalLaborRequired - Overtime <= RegularLaborAvailable\n        total_labor_needed = gp.quicksum(labor_req[p] * X[p] for p in products)\n        model.addConstr(total_labor_needed <= avail_labor_regular + OT,\n                        name=\"LaborAvailability\")\n\n        # Alternative for Labor Constraint (explicitly defines OT if positive):\n        # model.addConstr(total_labor_needed - OT <= avail_labor_regular, name=\"LaborConstraint\")\n        # This is equivalent to the one above given OT >= 0.\n        # The objective function will naturally try to minimize OT if it costs money.\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Net Profit: {model.ObjVal:.2f} Yuan\")\n\n            print(\"\\nOptimal Production Quantities (units):\")\n            for p in products:\n                print(f\"  Product {p}: {X[p].X:.0f} units\")\n\n            print(f\"\\nOvertime Hours Used: {OT.X:.2f} hours\")\n            print(\n                f\"Cost of Overtime: {(overtime_pay_per_hour * OT.X):.2f} Yuan\")\n\n            print(\"\\nResource Utilization:\")\n            steel_used = sum(steel_req[p] * X[p].X for p in products)\n            aluminum_used = sum(aluminum_req[p] * X[p].X for p in products)\n            labor_needed_val = sum(labor_req[p] * X[p].X for p in products)\n\n            print(\n                f\"  Steel Used: {steel_used:.2f} / {avail_steel} kg \"\n                f\"({(steel_used/avail_steel*100) if avail_steel > 0 else 0:.1f}%)\"\n            )\n            print(\n                f\"  Aluminum Used: {aluminum_used:.2f} / {avail_aluminum} kg \"\n                f\"({(aluminum_used/avail_aluminum*100) if avail_aluminum > 0 else 0:.1f}%)\"\n            )\n            print(f\"  Total Labor Needed: {labor_needed_val:.2f} hours\")\n            print(\n                f\"    Met by Regular Hours: {min(labor_needed_val, avail_labor_regular):.2f} / {avail_labor_regular} hours\"\n            )\n            if OT.X > 1e-6:\n                print(f\"    Met by Overtime Hours: {OT.X:.2f} hours\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and resource availability.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"production_overtime_iis.ilp\")\n            # print(\"IIS written to production_overtime_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_production_planning_with_overtime()\n```\n\nThe optimal value is: 165900.0",
    "task_id": "B097",
    "ground_truth": 165900.0,
    "problem_domain": "Production Planning",
    "modeling_type": "MILP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA dietician recommends her client eat blueberries and strawberries to meet her anti-oxidant and mineral requirement. A pack of blueberries contains 3 units of anti-oxidants and 5 units of minerals. A pack of strawberries contains 1 unit of anti-oxidants and 7 units of minerals. The client must get at least 90 units of anti-oxidants and 100 units of minerals. In addition, because blueberries are not in season, the dietician recommend she eats at least 3 times as many packs of strawberries as blueberries. If a pack of blueberries contains 5 grams of sugar and a pack of strawberries contains 7 grams of sugar, how many of packs of each should she consume to minimize her sugar intake?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_fruit_packs():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Fruit_Packs_Minimize_Sugar\")\n\n    # Decision variables: number of blueberry and strawberry packs\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Blueberry_Packs\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Strawberry_Packs\", lb=0)\n\n    # Set objective: minimize total sugar intake\n    m.setObjective(5 * x + 7 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(3 * x + y >= 90, \"AntiOxidant_Requirement\")\n    m.addConstr(5 * x + 7 * y >= 100, \"Mineral_Requirement\")\n    m.addConstr(y >= 3 * x, \"Strawberry_to_Blueberry_Ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimum sugar intake\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_sugar = optimize_fruit_packs()\n    if min_sugar is not None:\n        print(f\"Minimum Sugar Intake: {min_sugar}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 390.0",
    "task_id": "A120",
    "ground_truth": 390.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA dog school trains labradors and golden retrievers to deliver newspaper. A labrador can deliver 7 newspapers at a time and requires 5 small bone treats for service. A golden retriever can deliver 10 newspapers at a time and requires 6 small bone treats per service. The school only has 1500 small bone treats available. In addition, at least 50 golden retrievers must be used and at most 60% of the dogs can be labradors. How many of each dog should be used to maximize the number of newspapers that can be delivered?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_dogs(max_treats=1500, min_golden=50, max_lab_ratio=0.6):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"DogSchoolOptimization\")\n    m.setParam('OutputFlag', 0)  # Silence Gurobi output\n\n    # Decision variables\n    L = m.addVar(name=\"Labradors\", vtype=GRB.INTEGER, lb=0)\n    G = m.addVar(name=\"Goldens\", vtype=GRB.INTEGER, lb=min_golden)\n\n    # Objective: Maximize total newspapers delivered\n    m.setObjective(7 * L + 10 * G, GRB.MAXIMIZE)\n\n    # Constraints\n    # Bone treat constraint\n    m.addConstr(5 * L + 6 * G <= max_treats, name=\"TreatsLimit\")\n    # Golden retriever minimum\n    m.addConstr(G >= min_golden, name=\"MinGoldens\")\n    # Labrador proportion constraint: L <= 0.6 * (L + G)\n    # Rearranged: 2L <= 3G\n    m.addConstr(2 * L <= 3 * G, name=\"LabradorProportion\")\n\n    # Optimize\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_newspapers = m.objVal\n        return total_newspapers\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_newspapers = optimize_dogs()\n    if max_newspapers is not None:\n        print(f\"Maximum Newspapers Delivered: {max_newspapers}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 2500.0",
    "task_id": "A159",
    "ground_truth": 2500.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Education"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA lawn mowing service provides neighborhood services using small teams and large teams. A small team requires 3 employees and can mow 50 sq ft of lawn. A large team requires 5 employees and can mow 80 sq ft of lawn. The company has 150 employees available. Because most people have smaller lawns in the city, the number of small teams must be at least 3 times as much as the number of large teams. In addition, to make sure the company can meet all demands, there has to be at least 6 large teams and at least 10 small teams. How many of each team type should be used to maximize the amount of lawn that can be mowed?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_lawn_mowing(small_team_min=10, large_team_min=6, total_employees=150):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"LawnMowingOptimization\")\n    m.setParam('OutputFlag', 0)  # Suppress Gurobi output\n\n    # Decision variables\n    s = m.addVar(vtype=GRB.INTEGER, name=\"small_teams\")\n    l = m.addVar(vtype=GRB.INTEGER, name=\"large_teams\")\n\n    # Set objective: maximize total lawn area\n    m.setObjective(50 * s + 80 * l, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Employee constraint\n    m.addConstr(3 * s + 5 * l <= total_employees, name=\"employee_limit\")\n    # Ratio constraint\n    m.addConstr(s >= 3 * l, name=\"ratio_constraint\")\n    # Minimum number of small teams\n    m.addConstr(s >= small_team_min, name=\"min_small_teams\")\n    # Minimum number of large teams\n    m.addConstr(l >= large_team_min, name=\"min_large_teams\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum lawn area\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_lawn_area = optimize_lawn_mowing()\n    if max_lawn_area is not None:\n        print(f\"Maximum Lawn Area: {max_lawn_area}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 2480.0",
    "task_id": "A128",
    "ground_truth": 2480.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "MILP",
    "industry_sector": "Services"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nIn the strategic planning of WareCo's distribution network, the company is evaluating how to efficiently supply seven retail stores from seven available distribution centers. Each distribution center has a unique opening cost and capacity that limits the volume of goods it can distribute. Additionally, the cost to transport goods from these centers to each retail store varies, making the task of minimizing the overall operational cost a complex puzzle. The goal is to determine the optimal setup that satisfies the demand at each retail store while incurring the lowest possible total cost, including both the opening of selected distribution centers and the transportation of goods.\n\nGiven Data:\n\n- Number of Potential Distribution Centers: 7\n- Number of Retail Stores to be Supplied: 7\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n- Center 6: $120,000\n- Center 7: $182,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $3 to Store 1, $3 to Store 2, $5 to Store 3, $4 to Store 4, $3 to Store 5, $5 to Store 6, $2 to Store 7\n- From Center 2: $4 to Store 1, $2 to Store 2, $4 to Store 3, $5 to Store 4, $1 to Store 5, $4 to Store 6, $2 to Store 7\n- From Center 3: $5 to Store 1, $4 to Store 2, $1 to Store 3, $1 to Store 4, $3 to Store 5, $3 to Store 6, $2 to Store 7\n- From Center 4: $4 to Store 1, $4 to Store 2, $3 to Store 3, $4 to Store 4, $4 to Store 5, $1 to Store 6, $3 to Store 7\n- From Center 5: $5 to Store 1, $3 to Store 2, $5 to Store 3, $1 to Store 4, $2 to Store 5, $4 to Store 6, $1 to Store 7\n- From Center 6: $4 to Store 1, $2 to Store 2, $2 to Store 3, $1 to Store 4, $2 to Store 5, $5 to Store 6, $2 to Store 7\n- From Center 7: $4 to Store 1, $4 to Store 2, $4 to Store 3, $4 to Store 4, $5 to Store 5, $3 to Store 6, $1 to Store 7\n\nDemand of Each Retail Store (in units):\n- Store 1: 961\n- Store 2: 787\n- Store 3: 401\n- Store 4: 789\n- Store 5: 965\n- Store 6: 505\n- Store 7: 876\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1502\n- Center 2: 1201\n- Center 3: 1529\n- Center 4: 961\n- Center 5: 1001\n- Center 6: 1795\n- Center 7: 1069\n\nQuestion:\nWhat is the optimal total cost for WareCo to meet the demand at all seven retail stores, considering both the opening costs of the distribution centers and the transportation costs of supplying the stores?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"WareCo_Distribution_Network\")\n\n# Sets\nI = range(7)  # Distribution centers\nJ = range(7)  # Retail stores\n\n# Parameters\nf = [151000, 192000, 114000, 171000, 160000, 120000, 182000]  # Opening costs\nc = [  # Transportation costs\n    [3, 3, 5, 4, 3, 5, 2],\n    [4, 2, 4, 5, 1, 4, 2],\n    [5, 4, 1, 1, 3, 3, 2],\n    [4, 4, 3, 4, 4, 1, 3],\n    [5, 3, 5, 1, 2, 4, 1],\n    [4, 2, 2, 1, 2, 5, 2],\n    [4, 4, 4, 4, 5, 3, 1]\n]\nd = [961, 787, 401, 789, 965, 505, 876]  # Demands\ns = [1502, 1201, 1529, 961, 1001, 1795, 1069]  # Supply capacities\n\n# Variables\nx = model.addVars(I, J, vtype=GRB.CONTINUOUS, name=\"x\")  # Shipment quantities\ny = model.addVars(I, vtype=GRB.BINARY, name=\"y\")  # Center open/close\n\n# Objective: Minimize total cost\nmodel.setObjective(\n    gp.quicksum(f[i] * y[i] for i in I) +\n    gp.quicksum(c[i][j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand satisfaction\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == d[j] for j in J),\n    name=\"Demand\"\n)\n\n# Supply capacity\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= s[i] * y[i] for i in I),\n    name=\"Supply\"\n)\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 554968.0",
    "task_id": "E074",
    "ground_truth": 554968.0,
    "problem_domain": "Facility Location",
    "modeling_type": "MILP",
    "industry_sector": "Logistics"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA woman on a diet needs to eat two types of meal preps, a smoothie and a protein bar. Each smoothie contains 2 units of protein and 300 calories. Each protein bar contains 7 units of protein and 250 calories. The woman must eat 2 times more protein bars than smoothies. If the woman can consume at most 2000 calories, how many of each should she eat or drink to maximize her protein intake?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_meal_preps(max_calories=2000, protein_smoothie=2, protein_bar=7,\n                          calories_smoothie=300, calories_bar=250):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"MealPrepsMaxProtein\")\n\n    # Decision variables: number of smoothies (x) and protein bars (y)\n    # Since quantities are discrete, define as integer variables\n    x = model.addVar(name=\"smoothies\", vtype=GRB.INTEGER, lb=0)\n    y = model.addVar(name=\"bars\", vtype=GRB.INTEGER, lb=0)\n\n    # Add the relationship constraint: y = 2x\n    model.addConstr(y >= 2 * x, name=\"relation\")\n\n    # Add caloric constraint\n    model.addConstr(\n        calories_smoothie * x + calories_bar * y <= max_calories,\n        name=\"calorie_limit\"\n    )\n\n    # Set the objective: maximize total protein\n    total_protein = protein_smoothie * x + protein_bar * y\n    model.setObjective(total_protein, GRB.MAXIMIZE)\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total protein\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_protein = optimize_meal_preps()\n    if max_protein is not None:\n        print(f\"Maximum protein intake: {max_protein:.2f} grams\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 56.0",
    "task_id": "A235",
    "ground_truth": 56.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA car manufacturer makes two versions of the same car, a regular model and a premium model. They make x1 regular models per day and x2 premium models per day. The profit per regular model is $5000 and the profit per premium model is $8500 (x1 and x2 are unknown values both greater than or equal to 0). The daily demand for these cars is limited to and most 8 regular models and 6 premium models. In addition, the manufacturer can make a maximum of 12 cars of either type per day. How many cars of each model should the manufacturer make in order to maximize profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"CarProductionOptimization\")\n\n# Add variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")  # Number of regular models\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")  # Number of premium models\n\n# Set objective\nmodel.setObjective(5000 * x1 + 8500 * x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 8, \"C1\")  # Demand constraint for regular models\nmodel.addConstr(x2 <= 6, \"C2\")  # Demand constraint for premium models\nmodel.addConstr(x1 + x2 <= 12, \"C3\")  # Total production capacity constraint\nmodel.addConstr(x1 >= 0, \"C4\")  # Non-negativity constraint for x1\nmodel.addConstr(x2 >= 0, \"C5\")  # Non-negativity constraint for x2\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 81000.0",
    "task_id": "F155",
    "ground_truth": 81000.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA park is designing their trails and can either create a wide trail or a narrow trail. A wide trail can take 50 visitors every day while the narrow trail expects 20 visitors every day. The wide trail will introduce 6 units of garbage and the narrow trail will introduce 3 units of garbage. There can be at most 3 wide trails and the park hopes to have at most 225 visitors every day. How many of each type of trail should the park construct to minimize the total amount of garbage produced.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nV_w = 50  # Number of visitors per day for a wide trail\nV_n = 20  # Number of visitors per day for a narrow trail\nG_w = 6   # Units of garbage produced by a wide trail\nG_n = 3   # Units of garbage produced by a narrow trail\nW_max = 3  # Maximum number of wide trails\nV_max = 225  # Maximum number of visitors allowed per day\n\n# Variables\nx_w = model.addVar(vtype=GRB.INTEGER, name=\"x_w\")  # Number of wide trails\nx_n = model.addVar(vtype=GRB.INTEGER, name=\"x_n\")  # Number of narrow trails\n\n# Objective: Minimize the total amount of garbage produced\nmodel.setObjective(G_w * x_w + G_n * x_n, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(V_w * x_w + V_n * x_n <= V_max, \"VisitorConstraint\")\nmodel.addConstr(x_w <= W_max, \"MaxWideTrailsConstraint\")\nmodel.addConstr(x_w >= 0, \"NonNegativityWide\")\nmodel.addConstr(x_n >= 0, \"NonNegativityNarrow\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 0.0",
    "task_id": "F149",
    "ground_truth": 0.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Environment"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA researcher is outsourcing annotations and has two options: a specialized third-party or a common third-party annotation company. The specialized company can annotate at a rate of 60 images per hour whereas the common company can annotate at a rate of 40 images per hour. However, the specialized company charges $100 per hour and the common company charges $72 per hour. The researcher has deadlines to meet and must complete a dataset of at least 10,000 images. They also have some special images that only the specialized company can annotate. Therefore, at least a third of work must be allocated to the specialized company. How should the researcher distribute the annotations to the two companies to minimize the cost of annotating the whole dataset?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nn = 10000  # Total images to annotate\nr_s = 60   # Rate of annotation for specialized company (images/hour)\nr_c = 40   # Rate of annotation for common company (images/hour)\nc_s = 100  # Cost per hour for specialized company ($/hour)\nc_c = 72   # Cost per hour for common company ($/hour)\np_s = 1/3  # Minimum proportion of work for specialized company\n\n# Variables\nx_s = model.addVar(name=\"x_s\", lb=0)  # Number of images annotated by the specialized company\nx_c = model.addVar(name=\"x_c\", lb=0)  # Number of images annotated by the common company\n\n# Objective: Minimize the total cost\nmodel.setObjective((x_s / r_s) * c_s + (x_c / r_c) * c_c, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(x_s + x_c >= n, \"TotalImagesConstraint\")  # C1: Total images constraint\nmodel.addConstr(x_s >= p_s * n, \"SpecializedWorkConstraint\")  # C2: Minimum work allocation to specialized company\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 16666.667",
    "task_id": "F131",
    "ground_truth": 16666.667,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Services"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nAn oil and gas company is sending their oil to the port using containers and trucks. A container can hold 30 units of oil while a truck can hold 40 units of oil. Due to government restrictions, the number of trucks used has to at most half the number of containers used. If at least 2000 units of oil need to be sent to the port and at least 15 containers need to be used, minimize the total number of containers and trucks needed.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OilAndGasTransportation\")\n\n# Create variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"containers\")  # Number of containers\ny = model.addVar(vtype=GRB.INTEGER, name=\"trucks\")      # Number of trucks\n\n# Set objective\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(30 * x + 40 * y >= 2000, \"OilCapacity\")  # Constraint C1\nmodel.addConstr(y <= 0.5 * x, \"TruckToContainerRatio\")   # Constraint C2\nmodel.addConstr(x >= 15, \"MinContainers\")                # Constraint C3\nmodel.addConstr(x >= 0, \"NonNegativityX\")                # Constraint C4 (part of non-negativity)\nmodel.addConstr(y >= 0, \"NonNegativityY\")                # Constraint C4 (part of non-negativity)\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 60.0",
    "task_id": "F041",
    "ground_truth": 60.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Oil and Gas"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA honey farmer sells his honey in glass and plastic jars. A glass jar can hold 250 ml of honey while a plastic jar can hold 300 ml of honey. Since glass jars are more expensive, at least twice as many plastic jars must be filled as glass jars. However, at least 20 glass jars should be filled. If the farmer has 20000 ml of honey, how many jars of each should be filled to maximize the total number of bottles filled?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nV_g = 250  # Volume of honey a glass jar can hold (ml)\nV_p = 300  # Volume of honey a plastic jar can hold (ml)\nH = 20000  # Total volume of honey available (ml)\n\n# Variables\nx_g = model.addVar(vtype=GRB.INTEGER, name=\"x_g\")  # Number of glass jars filled\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")  # Number of plastic jars filled\n\n# Objective: Maximize the total number of jars filled\nmodel.setObjective(x_g + x_p, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(V_g * x_g + V_p * x_p <= H, \"C1\")  # Total honey used cannot exceed available honey\nmodel.addConstr(x_p >= 2 * x_g, \"C2\")              # At least twice as many plastic jars as glass jars\nmodel.addConstr(x_g >= 20, \"C3\")                   # At least 20 glass jars should be filled\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 70.0",
    "task_id": "F179",
    "ground_truth": 70.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Agriculture"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA chicken farmer has sold his chicken and they need to be transported either by bus or by car. A bus can take 100 chicken and takes 2 hours per trip. A car can take 40 chicken and takes 1.5 hours per trip. There can be at most 10 bus trips and at least 60% of the trips must be by car. If the farmer needs to transport 1200 chicken, how many trips of each should be done to minimize the total time needed to transport the chicken?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"ChickenTransport\")\n\n    # Decision variables\n    x = m.addVar(vtype=GRB.INTEGER, name=\"bus_trips\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"car_trips\")\n\n    # Set objective: minimize total time\n    m.setObjective(2 * x + 1.5 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Capacity constraint\n    m.addConstr(100 * x + 40 * y >= 1200, name=\"capacity\")\n    # Bus trip limit\n    m.addConstr(x <= 10, name=\"max_bus_trips\")\n    # Trip ratio constraint (at least 60% by car)\n    m.addConstr(y >= 1.5 * x, name=\"car_ratio\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total time\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_transportation()\n    if min_time is not None:\n        print(f\"Minimum Total Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 33.5",
    "task_id": "A146",
    "ground_truth": 33.5,
    "problem_domain": "Resource Allocation",
    "modeling_type": "MILP",
    "industry_sector": "Agriculture"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA fashion company sells regular handbags and premium handbags made of higher quality material. They can sell regular handbags at a profit of $30 each and premium handbags at a profit of $180 each. The total monthly cost of manufacturing is $200 per regular handbag and $447 per premium handbag. The company has a total budget of $250000 and can sell at most 475 handbags of either type per month. How many of each handbag should they sell to maximize its monthly profit?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\np_r = 30\np_p = 180\nc_r = 200\nc_p = 447\nB = 250000\nH_max = 475\n\n# Variables\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")\n\n# Objective function\nmodel.setObjective(p_r * x_r + p_p * x_p, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(c_r * x_r + c_p * x_p <= B, \"BudgetConstraint\")\nmodel.addConstr(x_r + x_p <= H_max, \"SalesLimitConstraint\")\nmodel.addConstr(x_r >= 0, \"NonNegativityConstraint_x_r\")\nmodel.addConstr(x_p >= 0, \"NonNegativityConstraint_x_p\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 85500.0",
    "task_id": "F094",
    "ground_truth": 85500.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nIn order to make carbon dioxide, wood is burned using two processes, with a catalyst and without a catalyst. The process with a catalyst requires 10 units of wood and 20 units of oxygen to make 15 units of carbon dioxide. The process without a catalyst requires 15 units of wood and 12 units of oxygen to make 18 units of carbon dioxide. There are 300 units of wood and 300 units of oxygen available. How many of each process should be used to maximize the amount of carbon dioxide produced?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Add variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")\n\n# Set objective\nmodel.setObjective(15 * x1 + 18 * x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(10 * x1 + 15 * x2 <= 300, \"WoodConstraint\")\nmodel.addConstr(20 * x1 + 12 * x2 <= 300, \"OxygenConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 369.0",
    "task_id": "F192",
    "ground_truth": 369.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "LP",
    "industry_sector": "Manufacturing"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nA sandwich company can open two types of stores, a dine-in place and a food-truck. A dine-in place can make 100 sandwiches per day and requires 8 employees to operate. A food-truck can make 50 sandwiches per day and requires 3 employees to operate. The company must make at least 500 sandwiches per day but they only have available 35 employees. How many of each type of store should the company open to minimize the total number of stores?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\ndef optimize_stores():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Minimize_Stores\")\n\n    # Decision variables: number of dine-in stores and food-trucks\n    x = m.addVar(vtype=GRB.INTEGER, name=\"dine_in\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"food_truck\")\n\n    # Set the objective: minimize total number of stores\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Sandwich production constraint\n    m.addConstr(100 * x + 50 * y >= 500, \"sandwich_requirement\")\n    # Employee constraint\n    m.addConstr(8 * x + 3 * y <= 35, \"employee_limit\")\n    # Non-negativity constraints are implicit in variable definitions\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of stores\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_stores = optimize_stores()\n    if min_stores is not None:\n        print(f\"Minimum Number of Stores: {min_stores}\")\n    else:\n        print(\"No feasible solution found.\")\n```\n\nThe optimal value is: 8.0",
    "task_id": "A037",
    "ground_truth": 8.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "IP",
    "industry_sector": "Retail"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nImagine you are in charge of planning a week's worth of meals for a small group and need to ensure everyone gets the right amount of nutrients without overspending. You have four different food items to choose from, each with its own nutritional content and cost.\n\nHere's what each food item offers:\n- Food_1: Provides 19 grams of protein, 9 grams of carbohydrates, and 83 calories for $7.\n- Food_2: Offers 4 grams of protein, 16 grams of carbohydrates, and 166 calories for $7.\n- Food_3: Contains 3 grams of protein, 11 grams of carbohydrates, and 71 calories for $10.\n- Food_4: Delivers 8 grams of protein, 7 grams of carbohydrates, and 56 calories for $2.\n\nYour goal is to meet the following nutritional requirements for the group:\n- At least 84 grams of protein,\n- At least 132 grams of carbohydrates,\n- At least 1990 calories.\n\nYour challenge is to determine the most cost-effective way to purchase these food items to meet or exceed the nutritional requirements. What is the minimal cost to meet these dietary needs?",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a Gurobi model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define the cost coefficients for the objective function\ncosts = [7, 7, 10, 2]\n\n# Define the nutrient coefficients for the constraints\nprotein = [19, 4, 3, 8]\ncarbs = [9, 16, 11, 7]\ncalories = [83, 166, 71, 56]\n\n# Define the minimum nutritional requirements\nP_min = 84\nC_min = 132\nCal_min = 1990\n\n# Add variables for the quantities of each food item\nx = model.addVars(4, vtype=GRB.INTEGER, name=\"x\")\n\n# Set the objective function: Minimize cost\nmodel.setObjective(gp.quicksum(costs[i] * x[i] for i in range(4)), GRB.MINIMIZE)\n\n# Add constraints for nutritional requirements\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in range(4)) >= P_min, \"Protein\")\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in range(4)) >= C_min, \"Carbohydrates\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in range(4)) >= Cal_min, \"Calories\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n\n```\n\nThe optimal value is: 72.0",
    "task_id": "E001",
    "ground_truth": 72.0,
    "problem_domain": "Blending",
    "modeling_type": "LP",
    "industry_sector": "Health"
  },
  {
    "prompt": "Please solve this optimization problem:\n\nVicky and David have just bought a farm in the Yarra Valley, and they are considering using it to grow apples, pears, oranges, and lemons. The profit for growing one acre of apples is $2000, for one acre of pears is $1800, for one acre of oranges is $2200, and for one acre of lemons is $3000. To achieve maximum profit, how many acres of land should they use to grow each type of fruit? Vicky and David have just bought a farm in the Yarra Valley with a total area of 120 acres.\n\nThe land used to grow apples should be at least twice the land used to grow pears.\n\nThe land used to grow apples should be at least three times the land used to grow lemons.\n\nThe land used to grow oranges must be twice the land used to grow lemons.\n\nVicky and David are unwilling to grow more than two types of fruit.",
    "completion": "Here's the solution to this optimization problem:\n\n```python\nfrom gurobipy import Model, GRB, quicksum\n\n# Create a new model\nmodel = Model(\"Farm_Optimization\")\n\n# Define parameters\nM = 120  # Maximum possible acres\n\n# Decision variables: Acres planted\nx_A = model.addVar(name=\"Acres_Apples\", lb=0)\nx_P = model.addVar(name=\"Acres_Pears\", lb=0)\nx_O = model.addVar(name=\"Acres_Oranges\", lb=0)\nx_L = model.addVar(name=\"Acres_Lemons\", lb=0)\n\n# Binary variables: Whether to plant a certain type of fruit    \ny_A = model.addVar(vtype=GRB.BINARY, name=\"Use_Apples\")\ny_P = model.addVar(vtype=GRB.BINARY, name=\"Use_Pears\")\ny_O = model.addVar(vtype=GRB.BINARY, name=\"Use_Oranges\")\ny_L = model.addVar(vtype=GRB.BINARY, name=\"Use_Lemons\")\n\n# Set objective function\nmodel.setObjective(2000 * x_A + 1800 * x_P + 2200 * x_O + 3000 * x_L,\n                   GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x_A + x_P + x_O + x_L <= 120, \"Total_Area_Constraint\")  # Total area constraint\nmodel.addConstr(x_A >= 2 * x_P, \"Apples_vs_Pears\")  # Apples  2Pears\nmodel.addConstr(x_A >= 3 * x_L, \"Apples_vs_Lemons\")  # Apples  3Lemons\nmodel.addConstr(x_O == 2 * x_L, \"Oranges_vs_Lemons\")  # Oranges = 2Lemons\nmodel.addConstr(y_A + y_P + y_O + y_L <= 2, \"Max_Two_Crops\")  # At most two types of fruits\n\n# Big-M constraints: Link area planted to whether a fruit is planted    \nmodel.addConstr(x_A <= M * y_A, \"Link_Apples\")\nmodel.addConstr(x_P <= M * y_P, \"Link_Pears\")\nmodel.addConstr(x_O <= M * y_O, \"Link_Oranges\")\nmodel.addConstr(x_L <= M * y_L, \"Link_Lemons\")\n\n# Solve the model\nmodel.optimize()\n\n# Output results\nif model.status == GRB.OPTIMAL:\n    print(\"Optimal solution found!\")\n    print(f\"Apples: {x_A.X:.2f} acres\")\n    print(f\"Pears: {x_P.X:.2f} acres\")\n    print(f\"Oranges: {x_O.X:.2f} acres\")\n    print(f\"Lemons: {x_L.X:.2f} acres\")\n    print(f\"Total profit: ${model.objVal:,.2f}\")\nelse:\n    print(\"No optimal solution found.\")\n```\n\nThe optimal value is: 240000.0",
    "task_id": "B057",
    "ground_truth": 240000.0,
    "problem_domain": "Resource Allocation",
    "modeling_type": "MILP",
    "industry_sector": "Agriculture"
  }
]