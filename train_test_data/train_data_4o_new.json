[
  {
    "task_id": "A171",
    "description": "A car manufacturing company makes hamburgers and chicken wraps for workers. They need to ensure workers get at least 2200 calories, 50 grams of protein, and 70 grams of carbs. One hamburger costs $6.5 and contains 800 calories, 19 grams of protein, and 20 grams of carbs. One chicken wrap costs $4 and contains 450 calories, 12 grams of protein, and 10 grams of carbs. What is the minimum cost diet that the company can provide for its workers?",
    "ground_truth": 22.75,
    "formulation": null,
    "correct_program": "def optimize_diet(\n    calorie_req=2200,\n    protein_req=50,\n    carbs_req=70,\n    cost_hamburger=6.5,\n    cost_wrap=4,\n    calories_hamburger=800,\n    calories_wrap=450,\n    protein_hamburger=19,\n    protein_wrap=12,\n    carbs_hamburger=20,\n    carbs_wrap=10\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"DietOptimization\")\n\n    # Decision variables: number of hamburgers and wraps\n    x = model.addVar(name=\"Hamburgers\", lb=0)\n    y = model.addVar(name=\"Wraps\", lb=0)\n\n    # Set the objective: minimize total cost\n    model.setObjective(cost_hamburger * x + cost_wrap * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Calorie constraint\n    model.addConstr(calories_hamburger * x + calories_wrap * y >= calorie_req, name=\"Calories\")\n    # Protein constraint\n    model.addConstr(protein_hamburger * x + protein_wrap * y >= protein_req, name=\"Protein\")\n    # Carbohydrate constraint\n    model.addConstr(carbs_hamburger * x + carbs_wrap * y >= carbs_req, name=\"Carbohydrates\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the minimum cost\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    min_cost = optimize_diet()\n    if min_cost is not None:\n        print(f\"Minimum Cost: {min_cost}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "A006",
    "description": "A farmer wants to mix his animal feeds, Feed A and Feed B, in such a way that the mixture will contain a minimum of 30 units of protein and 50 units of fat. Feed A costs $100 per kilogram and contains 10 units of protein and 8 units of fat. Feed B costs $80 per kilogram and contains 7 units of protein and 15 units of fat. Determine the minimum cost of the mixture.",
    "ground_truth": 327.6595744680851,
    "formulation": null,
    "correct_program": "def optimize_feed_mixture():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Feed_Mixture_Min_Cost\")\n\n    # Decision variables: amount of Feed A and Feed B\n    x = m.addVar(name=\"Feed_A\", lb=0)\n    y = m.addVar(name=\"Feed_B\", lb=0)\n\n    # Set the objective: minimize total cost\n    m.setObjective(100 * x + 80 * y, GRB.MINIMIZE)\n\n    # Add protein constraint\n    m.addConstr(10 * x + 7 * y >= 30, name=\"ProteinConstraint\")\n\n    # Add fat constraint\n    m.addConstr(8 * x + 15 * y >= 50, name=\"FatConstraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal cost\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cost = optimize_feed_mixture()\n    if min_cost is not None:\n        print(f\"Minimum Cost of Feed Mixture: {min_cost}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "B029",
    "description": "Suppose a certain animal needs at least $700 \\mathrm{~g}$ of protein, $30 \\mathrm{~g}$ of minerals, and $100 \\mathrm{mg}$ of vitamins daily. There are 5 types of feed available, and the nutritional content and price per gram of each type of feed are shown in Table 1-5:\nTry to formulate a linear programming model that meets the animal's growth needs while minimizing the cost of selecting the feed.\nTable 1-6\n| Feed | Protein (g) | Minerals (g) | Vitamins (mg) | Price (¥/kg) | Feed | Protein (g) | Minerals (g) | Vitamins (mg) | Price (¥/kg) |\n|------|-------------|--------------|---------------|--------------|------|-------------|--------------|---------------|--------------|\n| 1    | 3           | 1            | 0.5           | 0.2          | 4    | 6           | 2            | 2             | 0.3          |\n| 2    | 2           | 0.5          | 1             | 0.7          | 5    | 18          | 0.5          | 0.8           | 0.8          |\n| 3    | 1           | 0.2          | 0.2           | 0.4          |      |             |              |               |              |",
    "ground_truth": 32.43589743589744,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_feed_mix_problem():\n    \"\"\"\n    Solves the animal feed mix optimization problem using Gurobi.\n    The goal is to minimize the cost of feed while meeting daily nutritional requirements.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Nutritional content per kg of feed: (Protein (g), Minerals (g), Vitamins (mg))\n        # Price per kg of feed (¥/kg)\n\n        feeds_data = {\n            # Feed_ID: [Protein, Minerals, Vitamins, Price]\n            1: [3, 1, 0.5, 0.2],\n            2: [2, 0.5, 1, 0.7],\n            3: [1, 0.2, 0.2, 0.4],\n            4: [6, 2, 2, 0.3],\n            5: [18, 0.5, 0.8, 0.8]\n        }\n\n        feed_ids = list(feeds_data.keys())\n\n        # Daily nutritional requirements\n        min_protein = 700  # g\n        min_minerals = 30  # g\n        min_vitamins = 100  # mg\n\n        # --- Create a new model ---\n        model = gp.Model(\"FeedMixOptimization\")\n\n        # --- Decision Variables ---\n        # x[i]: amount of feed i to use, in kilograms (kg)\n        x = model.addVars(feed_ids, name=\"x\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function ---\n        # Minimize the total cost of the feed mixture\n        # Cost = sum(price_i * x_i for i in feeds)\n        total_cost = gp.quicksum(feeds_data[i][3] * x[i] for i in feed_ids)\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Protein Requirement\n        model.addConstr(\n            gp.quicksum(feeds_data[i][0] * x[i] for i in feed_ids)\n            >= min_protein, \"ProteinRequirement\")\n\n        # 2. Minerals Requirement\n        model.addConstr(\n            gp.quicksum(feeds_data[i][1] * x[i] for i in feed_ids)\n            >= min_minerals, \"MineralsRequirement\")\n\n        # 3. Vitamins Requirement\n        model.addConstr(\n            gp.quicksum(feeds_data[i][2] * x[i] for i in feed_ids)\n            >= min_vitamins, \"VitaminsRequirement\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal feed mix found.\")\n            print(f\"Minimum Cost: {model.objVal:.2f} ¥\")\n            print(\"\\nAmount of each feed to use (kg):\")\n            total_feed_kg = 0\n            for i in feed_ids:\n                if x[i].X > 1e-6:  # Print only if the amount is significant\n                    print(f\"  Feed {i}: {x[i].X:.2f} kg\")\n                    total_feed_kg += x[i].X\n            print(f\"\\nTotal kilograms of feed: {total_feed_kg:.2f} kg\")\n\n            # Verification of nutritional intake\n            achieved_protein = sum(feeds_data[i][0] * x[i].X for i in feed_ids)\n            achieved_minerals = sum(feeds_data[i][1] * x[i].X\n                                    for i in feed_ids)\n            achieved_vitamins = sum(feeds_data[i][2] * x[i].X\n                                    for i in feed_ids)\n            print(\"\\nNutritional Intake with this mix:\")\n            print(\n                f\"  Protein: {achieved_protein:.2f} g (Required: >= {min_protein} g)\"\n            )\n            print(\n                f\"  Minerals: {achieved_minerals:.2f} g (Required: >= {min_minerals} g)\"\n            )\n            print(\n                f\"  Vitamins: {achieved_vitamins:.2f} mg (Required: >= {min_vitamins} mg)\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The nutritional requirements cannot be met with the given feeds under the specified constraints.\"\n            )\n            # You can compute and print IIS (Irreducible Inconsistent Subsystem) to help debug\n            # model.computeIIS()\n            # model.write(\"feed_mix_iis.ilp\")\n            # print(\"IIS written to feed_mix_iis.ilp. Review this file to find conflicting constraints.\")\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_feed_mix_problem()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E023",
    "description": "Imagine you're trying to balance your nutritional intake and budget for the week. You have an array of eight different food items to choose from: Chicken, Rice, Eggs, Beans, Spinach, Corn, Beef, and Broccoli. These foods each offer different levels of protein, carbohydrates, and calories and come with various price tags. \n\nHere's the nutritional breakdown and cost of each food item:\n\n- Chicken: Provides 5 grams of protein, 15 grams of carbohydrates, and 162 calories at a cost of $8.\n- Rice: Supplies 8 grams of protein, 17 grams of carbohydrates, and 282 calories for $4.\n- Eggs: Deliver a solid 18 grams of protein, 20 grams of carbohydrates, and 234 calories for just $1.\n- Beans: Offer 16 grams of protein, 15 grams of carbohydrates, and 85 calories for $4.\n- Spinach: Adds 3 grams of protein, 28 grams of carbohydrates, and 194 calories for $7.\n- Corn: Gives 3 grams of protein, 19 grams of carbohydrates, and 153 calories for a modest $2.\n- Beef: Brings in 6 grams of protein, 24 grams of carbohydrates, and 167 calories for $9.\n- Broccoli: Offers 17 grams of protein, 9 grams of carbohydrates, and 192 calories for just $3.\n\nYour dietary goal for the week is to consume at least 68 grams of protein, 189 grams of carbohydrates, and 1840 calories. What is the least amount of money you need to spend to meet these nutritional requirements by choosing from these eight food items?",
    "ground_truth": 10.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nprotein = [5, 8, 18, 16, 3, 3, 6, 17]\ncarbs = [15, 17, 20, 15, 28, 19, 24, 9]\ncalories = [162, 282, 234, 85, 194, 153, 167, 192]\ncost = [8, 4, 1, 4, 7, 2, 9, 3]\nprotein_req = 68\ncarbs_req = 189\ncalories_req = 1840\n\n# Number of food items\nn = len(protein)\n\n# Decision variables: quantities of each food item to purchase\nx = model.addVars(n, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: Minimize the total cost\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in range(n)), GRB.MINIMIZE)\n\n# Constraints\n# Protein intake constraint\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in range(n)) >= protein_req, \"ProteinConstraint\")\n\n# Carbohydrate intake constraint\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in range(n)) >= carbs_req, \"CarbsConstraint\")\n\n# Calorie intake constraint\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in range(n)) >= calories_req, \"CaloriesConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E029",
    "description": "Imagine you are on a mission to ensure you're eating healthily but also on a tight budget. You have five different food items to choose from: Chicken, Rice, Beans, Broccoli, and Fruit. Each of these foods has a specific amount of protein, carbohydrates, and calories, and each comes with its own cost.\n\nHere's an overview of what each food provides, along with its cost:\n\n- Chicken: Gives you 12 grams of protein, 2 grams of carbohydrates, and 186 calories for $6.\n- Rice: Provides 12 grams of protein, 24 grams of carbohydrates, and 250 calories for $6.\n- Beans: Offers 19 grams of protein, 18 grams of carbohydrates, and 134 calories for $6.\n- Broccoli: Supplies 19 grams of protein, 7 grams of carbohydrates, and 84 calories for $7.\n- Fruit: Gives you 4 grams of protein, a high 27 grams of carbohydrates, and 104 calories for $9.\n\nYour goal is to make sure you get at least 97 grams of protein, 163 grams of carbohydrates, and 2217 calories from the combination of these foods that you choose. Remember, you’re trying to figure out the least expensive way to meet these nutritional goals with these five food options. \n\nSo, what is the minimal cost you need to spend to satisfy all these dietary requirements?",
    "ground_truth": 54.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define the data\nfoods = [\"Chicken\", \"Rice\", \"Beans\", \"Broccoli\", \"Fruit\"]\nprotein = {\"Chicken\": 12, \"Rice\": 12, \"Beans\": 19, \"Broccoli\": 19, \"Fruit\": 4}\ncarbs = {\"Chicken\": 2, \"Rice\": 24, \"Beans\": 18, \"Broccoli\": 7, \"Fruit\": 27}\ncalories = {\"Chicken\": 186, \"Rice\": 250, \"Beans\": 134, \"Broccoli\": 84, \"Fruit\": 104}\ncosts = {\"Chicken\": 6, \"Rice\": 6, \"Beans\": 6, \"Broccoli\": 7, \"Fruit\": 9}\n\n# Define the decision variables\nx = model.addVars(foods, name=\"x\", vtype=GRB.INTEGER, lb=0)\n\n# Set the objective function\nmodel.setObjective(gp.quicksum(costs[i] * x[i] for i in foods), GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in foods) >= 97, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in foods) >= 163, \"CarbohydrateRequirement\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in foods) >= 2217, \"CalorieRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E021",
    "description": "Imagine you're trying to put together a meal plan that ticks all the boxes: it meets all your nutritional needs and it doesn't break the bank. You're considering six different food items: Chicken, Rice, Eggs, Broccoli, Lentils, and Apples. Each of these foods provides different amounts of protein, carbohydrates, and calories, and they all come at different prices.\n\nHere's a rundown of what each food offers and how much it costs:\n\n- Chicken: It gives you 18 grams of protein, 5 grams of carbohydrates, and 202 calories for just $1.\n- Rice: With 14 grams of protein, 13 grams of carbs, and 234 calories, Rice is a bit pricier at $7.\n- Eggs: Like Chicken, Eggs also offer 18 grams of protein, along with 4 grams of carbs and 220 calories for $4.\n- Broccoli: A great source of protein at 7 grams, with 15 grams of carbs and 247 calories, this vegetable will cost you $3.\n- Lentils: They provide 15 grams of protein, 17 grams of carbs, and 88 calories for only $1.\n- Apples: They offer 8 grams of protein, 13 grams of carbohydrates, and 77 calories for $2.\n\nYou know that your meal plan needs to give you at least 70 grams of protein, 187 grams of carbohydrates, and 2181 calories. Your challenge is to determine the least expensive way to get all the nutrients you need from this group of six food items.\n\nSo, what is the minimum total cost you would need to spend to meet all your dietary requirements for the day?",
    "ground_truth": 16.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlanOptimization\")\n\n# Parameters\nprotein_content = {\n    \"Chicken\": 18, \"Rice\": 14, \"Eggs\": 18, \n    \"Broccoli\": 7, \"Lentils\": 15, \"Apples\": 8\n}\ncarbs_content = {\n    \"Chicken\": 5, \"Rice\": 13, \"Eggs\": 4, \n    \"Broccoli\": 15, \"Lentils\": 17, \"Apples\": 13\n}\ncaloric_content = {\n    \"Chicken\": 202, \"Rice\": 234, \"Eggs\": 220, \n    \"Broccoli\": 247, \"Lentils\": 88, \"Apples\": 77\n}\ncost = {\n    \"Chicken\": 1, \"Rice\": 7, \"Eggs\": 4, \n    \"Broccoli\": 3, \"Lentils\": 1, \"Apples\": 2\n}\n\n# Nutritional requirements\nP_min = 70\nC_min = 187\nK_min = 2181\n\n# Decision variables\nx = model.addVars(protein_content.keys(), vtype=GRB.INTEGER, name=\"x\")\n\n# Objective function: Minimize total cost\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in protein_content.keys()), GRB.MINIMIZE)\n\n# Constraints\n# Protein constraint\nmodel.addConstr(gp.quicksum(protein_content[i] * x[i] for i in protein_content.keys()) >= P_min, \"ProteinRequirement\")\n\n# Carbohydrates constraint\nmodel.addConstr(gp.quicksum(carbs_content[i] * x[i] for i in carbs_content.keys()) >= C_min, \"CarbsRequirement\")\n\n# Calories constraint\nmodel.addConstr(gp.quicksum(caloric_content[i] * x[i] for i in caloric_content.keys()) >= K_min, \"CaloriesRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E019",
    "description": "Imagine you're planning your meals for the week and you want to keep everything balanced: enough nutrients for a healthy lifestyle but also manageable costs. You have six food options to consider: Chicken, Rice, Vegetables, Bread, Almonds, and Salmon. Each of these foods has its own nutritional content in terms of proteins, carbs, and calories, and also its own cost.\n\nHere's a summary of what each food offers and its cost:\n\n- Chicken: Offers 16 grams of protein, 8 grams of carbohydrates, and 50 calories for $2.\n- Rice: Provides 11 grams of protein, 24 grams of carbohydrates, and 90 calories for $3.\n- Vegetables: Gives you 1 gram of protein, 5 grams of carbohydrates, and a hefty 164 calories for $3.\n- Bread: Packs in 6 grams of protein, 26 grams of carbohydrates, and 165 calories for $2.\n- Almonds: Offer 2 grams of protein, 11 grams of carbohydrates, and 51 calories for $4.\n- Salmon: Packs in a big punch with 19 grams of protein, 20 grams of carbohydrates, and provides 238 calories for $10.\n\nYou aim to hit at least 58 grams of protein, 150 grams of carbohydrates, and 2392 calories from whichever combination of these foods you choose. Your challenge is to determine the most affordable way to meet these nutritional targets with the six food options at your disposal. What is the minimum cost to satisfy all your nutritional needs for the week? Remember, your answer should indicate only the optimal cost value.",
    "ground_truth": 30.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlanning\")\n\n# Create variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"Chicken\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"Rice\")\nx3 = model.addVar(vtype=GRB.INTEGER, name=\"Vegetables\")\nx4 = model.addVar(vtype=GRB.INTEGER, name=\"Bread\")\nx5 = model.addVar(vtype=GRB.INTEGER, name=\"Almonds\")\nx6 = model.addVar(vtype=GRB.INTEGER, name=\"Salmon\")\n\n# Set objective: Minimize total cost\nmodel.setObjective(2*x1 + 3*x2 + 3*x3 + 2*x4 + 4*x5 + 10*x6, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(16*x1 + 11*x2 + 1*x3 + 6*x4 + 2*x5 + 19*x6 >= 58, \"ProteinRequirement\")\nmodel.addConstr(8*x1 + 24*x2 + 5*x3 + 26*x4 + 11*x5 + 20*x6 >= 150, \"CarbohydrateRequirement\")\nmodel.addConstr(50*x1 + 90*x2 + 164*x3 + 165*x4 + 51*x5 + 238*x6 >= 2392, \"CaloricRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E003",
    "description": "Imagine you are tasked with planning a nutritious and cost-effective meal plan for the day, ensuring that you meet specific nutritional targets. You have a selection of six different food items, each with unique nutritional values and costs. Your goal is to meet the daily dietary requirements for protein, carbohydrates, and calories without overspending.\n\nHere's a breakdown of the food items available:\n\n- Food_1: Costs $4, provides 17 grams of protein, 8 grams of carbohydrates, and 237 calories.\n- Food_2: Costs $2, provides 4 grams of protein, 24 grams of carbohydrates, and 213 calories.\n- Food_3: Costs $6, provides 7 grams of protein, 27 grams of carbohydrates, and 133 calories.\n- Food_4: Costs $2, provides 14 grams of protein, 16 grams of carbohydrates, and 118 calories.\n- Food_5: Costs $6, provides 13 grams of protein, 1 gram of carbohydrates, and 136 calories.\n- Food_6: Costs $8, provides 1 gram of protein, 13 grams of carbohydrates, and 225 calories.\n\nThe dietary requirements you need to meet are at least 76 grams of protein, 173 grams of carbohydrates, and 1751 calories for the day.\n\nWhat is the minimum cost required to meet these nutritional needs using any combination of these food items?",
    "ground_truth": 22.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlanning\")\n\n# Parameters\ncosts = [4, 2, 6, 2, 6, 8]\nproteins = [17, 4, 7, 14, 13, 1]\ncarbs = [8, 24, 27, 16, 1, 13]\ncalories = [237, 213, 133, 118, 136, 225]\nmin_protein = 76\nmin_carbs = 173\nmin_calories = 1751\n\n# Decision variables\nx = model.addVars(6, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective function: Minimize total cost\nmodel.setObjective(gp.quicksum(costs[i] * x[i] for i in range(6)), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(proteins[i] * x[i] for i in range(6)) >= min_protein, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in range(6)) >= min_carbs, \"CarbRequirement\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in range(6)) >= min_calories, \"CalorieRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E017",
    "description": "Suppose you are a student on a budget, trying to balance the need for good nutrition with your financial constraints. You have identified four different food items that you could include in your meals: Eggs, Rice, Chicken, and Broccoli. Each of these items provides different amounts of protein, carbohydrates, and calories, and also has a different cost.\n\nHere's a rundown of what each food item offers and its cost:\n\n- Eggs: For a cost of $6, you get 4 grams of protein, 13 grams of carbohydrates, and 238 calories.\n- Rice: For $10, you can get 1 gram of protein, 13 grams of carbohydrates, and 85 calories.\n- Chicken: A true bargain at only $1, it offers 10 grams of protein, 29 grams of carbohydrates, and 146 calories.\n- Broccoli: Costs $7 and provides 8 grams of protein, 26 grams of carbohydrates, and 139 calories.\n\nYour daily dietary goal is to consume at least 93 grams of protein, 165 grams of carbohydrates, and 1553 calories. Your ultimate goal is to work out the least expensive way to meet all these nutritional targets with the four food options you have. What is the cheapest cost to meet your nutrition requirements?",
    "ground_truth": 11.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nP_e, P_r, P_c, P_b = 4, 1, 10, 8\nC_e, C_r, C_c, C_b = 13, 13, 29, 26\nCal_e, Cal_r, Cal_c, Cal_b = 238, 85, 146, 139\nCost_e, Cost_r, Cost_c, Cost_b = 6, 10, 1, 7\nR_p, R_c, R_cal = 93, 165, 1553\n\n# Variables\nx_e = model.addVar(vtype=GRB.INTEGER, name=\"x_e\")\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"x_c\")\nx_b = model.addVar(vtype=GRB.INTEGER, name=\"x_b\")\n\n# Objective\nmodel.setObjective(Cost_e * x_e + Cost_r * x_r + Cost_c * x_c + Cost_b * x_b, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(P_e * x_e + P_r * x_r + P_c * x_c + P_b * x_b >= R_p, \"ProteinRequirement\")\nmodel.addConstr(C_e * x_e + C_r * x_r + C_c * x_c + C_b * x_b >= R_c, \"CarbohydrateRequirement\")\nmodel.addConstr(Cal_e * x_e + Cal_r * x_r + Cal_c * x_c + Cal_b * x_b >= R_cal, \"CaloriesRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E014",
    "description": "You have been assigned as the personal dietitian for a professional athlete, who is intent on maintaining a strict diet while also minimizing their grocery bill. You have six different food items to utilize: Eggs, Chicken, Tofu, Salmon, Brown Rice, and Spinach. Each of these food items provides specific amounts of protein, carbohydrates, and calories, and each comes at a different cost.\n\nHere's a quick breakdown of what each food offers and its cost:\n\n- Eggs: Provide 1 gram of protein, 13 grams of carbohydrates, and 211 calories for $10.\n- Chicken: Offers 4 grams of protein, 10 grams of carbohydrates, and 256 calories for $9.\n- Tofu: Delivers a whopping 13 grams of protein, 9 grams of carbohydrates, and 273 calories for just $2.\n- Salmon: Gives 8 grams of protein, 3 grams of carbohydrates, and 54 calories for $10.\n- Brown Rice: Provides 7 grams of protein, 13 grams of carbohydrates, and 93 calories for $8.\n- Spinach: Packs in 8 grams of protein, 16 grams of carbohydrates, and 52 calories for only $1.\n\nThe athlete's nutritional goals are at least 60 grams of protein, 122 grams of carbohydrates, and 2028 calories daily. \n\nYour challenge is to design the most cost-effective daily meal plan that meets all these nutritional targets using these six food options. What is the least amount of money the athlete would have to spend to meet their nutritional requirements?",
    "ground_truth": 18.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DietOptimization\")\n\n# Set of food items\nfoods = ['Eggs', 'Chicken', 'Tofu', 'Salmon', 'Brown Rice', 'Spinach']\n\n# Parameters\nprotein = {'Eggs': 1, 'Chicken': 4, 'Tofu': 13, 'Salmon': 8, 'Brown Rice': 7, 'Spinach': 8}\ncarbs = {'Eggs': 13, 'Chicken': 10, 'Tofu': 9, 'Salmon': 3, 'Brown Rice': 13, 'Spinach': 16}\ncalories = {'Eggs': 211, 'Chicken': 256, 'Tofu': 273, 'Salmon': 54, 'Brown Rice': 93, 'Spinach': 52}\ncosts = {'Eggs': 10, 'Chicken': 9, 'Tofu': 2, 'Salmon': 10, 'Brown Rice': 8, 'Spinach': 1}\n\n# Decision variables: number of servings of each food item (non-negative integers)\nx = model.addVars(foods, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: Minimize total cost\nmodel.setObjective(gp.quicksum(costs[i] * x[i] for i in foods), GRB.MINIMIZE)\n\n# Constraints:\n# Protein requirement\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in foods) >= 60, \"ProteinRequirement\")\n\n# Carbohydrate requirement\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in foods) >= 122, \"CarbohydrateRequirement\")\n\n# Calorie requirement\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in foods) >= 2028, \"CalorieRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E001",
    "description": "Imagine you are in charge of planning a week's worth of meals for a small group and need to ensure everyone gets the right amount of nutrients without overspending. You have four different food items to choose from, each with its own nutritional content and cost.\n\nHere's what each food item offers:\n- Food_1: Provides 19 grams of protein, 9 grams of carbohydrates, and 83 calories for $7.\n- Food_2: Offers 4 grams of protein, 16 grams of carbohydrates, and 166 calories for $7.\n- Food_3: Contains 3 grams of protein, 11 grams of carbohydrates, and 71 calories for $10.\n- Food_4: Delivers 8 grams of protein, 7 grams of carbohydrates, and 56 calories for $2.\n\nYour goal is to meet the following nutritional requirements for the group:\n- At least 84 grams of protein,\n- At least 132 grams of carbohydrates,\n- At least 1990 calories.\n\nYour challenge is to determine the most cost-effective way to purchase these food items to meet or exceed the nutritional requirements. What is the minimal cost to meet these dietary needs?",
    "ground_truth": 72.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a Gurobi model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define the cost coefficients for the objective function\ncosts = [7, 7, 10, 2]\n\n# Define the nutrient coefficients for the constraints\nprotein = [19, 4, 3, 8]\ncarbs = [9, 16, 11, 7]\ncalories = [83, 166, 71, 56]\n\n# Define the minimum nutritional requirements\nP_min = 84\nC_min = 132\nCal_min = 1990\n\n# Add variables for the quantities of each food item\nx = model.addVars(4, vtype=GRB.INTEGER, name=\"x\")\n\n# Set the objective function: Minimize cost\nmodel.setObjective(gp.quicksum(costs[i] * x[i] for i in range(4)), GRB.MINIMIZE)\n\n# Add constraints for nutritional requirements\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in range(4)) >= P_min, \"Protein\")\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in range(4)) >= C_min, \"Carbohydrates\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in range(4)) >= Cal_min, \"Calories\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E030",
    "description": "You're in charge of crafting a meal plan for a week, aiming to meet certain nutritional requirements while keeping your grocery bill to a minimum. There are seven food options you're considering: Chicken, Tuna, Eggs, Beef, Rice, Apples, and Bread. Each food item provides distinct amounts of protein, carbohydrates, and calories, and has a different price.\n\nHere are the details for each food:\n\n- Chicken: Provides 18 grams of protein, 23 grams of carbohydrates, and 217 calories for $3.\n- Tuna: Offers 12 grams of protein, 30 grams of carbohydrates, and 182 calories for $10.\n- Eggs: Contains 7 grams of protein, 16 grams of carbohydrates, and 79 calories for $10.\n- Beef: Delivers 17 grams of protein, 26 grams of carbohydrates, and 295 calories for $7.\n- Rice: Supplies 3 grams of protein, 30 grams of carbohydrates, and 264 calories for just $4.\n- Apples: Gives 4 grams of protein, 6 grams of carbohydrates, and 160 calories for $6.\n- Bread: Carries 4 grams of protein, 23 grams of carbohydrates, and 141 calories for $5.\n\nYour nutritional targets for the week are as follows: 59 grams of protein, 160 grams of carbohydrates, and 1809 calories.\n\nYour challenge is to find the most economical way of meeting these nutritional requirements with the food items available. What is the least possible amount you can spend to meet your nutritional goals for the week?",
    "ground_truth": 26.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlanOptimization\")\n\n# Define the cost coefficients\ncosts = {\n    'chicken': 3,\n    'tuna': 10,\n    'eggs': 10,\n    'beef': 7,\n    'rice': 4,\n    'apples': 6,\n    'bread': 5\n}\n\n# Define the nutritional values for each food item\nprotein = {\n    'chicken': 18,\n    'tuna': 12,\n    'eggs': 7,\n    'beef': 17,\n    'rice': 3,\n    'apples': 4,\n    'bread': 4\n}\n\ncarbohydrates = {\n    'chicken': 23,\n    'tuna': 30,\n    'eggs': 16,\n    'beef': 26,\n    'rice': 30,\n    'apples': 6,\n    'bread': 23\n}\n\ncalories = {\n    'chicken': 217,\n    'tuna': 182,\n    'eggs': 79,\n    'beef': 295,\n    'rice': 264,\n    'apples': 160,\n    'bread': 141\n}\n\n# Define the targets\nprotein_target = 59\ncarbohydrates_target = 160\ncalories_target = 1809\n\n# Add variables\nx = model.addVars(costs.keys(), vtype=GRB.INTEGER, name=\"servings\", lb=0)\n\n# Set objective\nmodel.setObjective(gp.quicksum(costs[i] * x[i] for i in costs), GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in protein) >= protein_target, \"ProteinConstraint\")\nmodel.addConstr(gp.quicksum(carbohydrates[i] * x[i] for i in carbohydrates) >= carbohydrates_target, \"CarbohydratesConstraint\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in calories) >= calories_target, \"CaloriesConstraint\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E012",
    "description": "Imagine you are on a mission to take control of your diet, meeting all your nutritional needs without breaking the bank. As a savvy shopper, you've narrowed down your food options to five different items, each providing different amounts of nutrients at varying costs. \n\nHere is a summary of what each food option offers and their respective costs:\n\n- Chicken: It provides 18 grams of protein, 6 grams of carbohydrates, and 142 calories at a cost of $4.\n- Rice: This food item gives you 12 grams of protein, 28 grams of carbohydrates, and 88 calories for $8.\n- Broccoli: For $7, it offers 13 grams of protein, 19 grams of carbohydrates, and 137 calories.\n- Tofu: At a cost of $10, you get 5 grams of protein, 16 grams of carbohydrates, and 141 calories.\n- Beans: This item provides an impressive 10 grams of protein, 20 grams of carbohydrates, and 150 calories for only $1.\n\nYour daily nutritional targets are to consume at least 56 grams of protein, 194 grams of carbohydrates, and 2012 calories. The key challenge here is to meet these dietary requirements in the most cost-effective way possible, using any combination of the food items listed above. \n\nNow, the question is, what is the minimal cost to meet your daily nutritional requirements using these food items?",
    "ground_truth": 14.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DietOptimization\")\n\n# Create variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"Chicken\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"Rice\")\nx3 = model.addVar(vtype=GRB.INTEGER, name=\"Broccoli\")\nx4 = model.addVar(vtype=GRB.INTEGER, name=\"Tofu\")\nx5 = model.addVar(vtype=GRB.INTEGER, name=\"Beans\")\n\n# Set objective\nmodel.setObjective(4*x1 + 8*x2 + 7*x3 + 10*x4 + x5, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(18*x1 + 12*x2 + 13*x3 + 5*x4 + 10*x5 >= 56, \"Protein\")\nmodel.addConstr(6*x1 + 28*x2 + 19*x3 + 16*x4 + 20*x5 >= 194, \"Carbohydrates\")\nmodel.addConstr(142*x1 + 88*x2 + 137*x3 + 141*x4 + 150*x5 >= 2012, \"Calories\")\n\n# Ensure non-negativity of variables\nmodel.addConstr(x1 >= 0, \"NonNeg_Chicken\")\nmodel.addConstr(x2 >= 0, \"NonNeg_Rice\")\nmodel.addConstr(x3 >= 0, \"NonNeg_Broccoli\")\nmodel.addConstr(x4 >= 0, \"NonNeg_Tofu\")\nmodel.addConstr(x5 >= 0, \"NonNeg_Beans\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E005",
    "description": "Imagine you're a college student aiming to balance your diet and budget. You have identified nine different food items from your local grocery store that you can include in your menu: Chicken, Rice, Apples, Steak, Lentils, Fish, Tofu, Cheese, and Bread. Each of these foods provides varying amounts of protein, carbohydrates, and calories, and each comes with its own price.\n\nHere is the detailed nutritional content and cost for each food item:\n\n- Chicken: Gives you 15 grams of protein, 18 grams of carbohydrates, and 300 calories for $4.\n- Rice: Offers 1 gram of protein, 25 grams of carbohydrates, and 267 calories for $2.\n- Apples: Provide 1 gram of protein, 21 grams of carbohydrates, and 266 calories for $5.\n- Steak: Contains 6 grams of protein, 3 grams of carbohydrates, and 119 calories for a higher cost of $10.\n- Lentils: These give 3 grams of protein, 7 grams of carbohydrates, and 166 calories for just $2.\n- Fish: Delivers 17 grams of protein, 13 grams of carbohydrates, and 129 calories for $8.\n- Tofu: Offers a substantial 18 grams of protein, 27 grams of carbohydrates, and 216 calories for $10.\n- Cheese: Gives 12 grams of protein, 17 grams of carbohydrates, and 76 calories for $9.\n- Bread: Provides 2 grams of protein, a massive 30 grams of carbohydrates, and 258 calories for $4.\n\nYour daily dietary goal is to consume at least 90 grams of protein, 105 grams of carbohydrates, and 1805 calories. Your challenge is to figure out how to meet these nutritional requirements from the food options mentioned above while spending the least amount of money. So, what is the least amount of money you need to spend to meet your daily dietary requirements? Please note that the response should be a single answer, asking for only the optimal value.",
    "ground_truth": 26.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DietOptimization\")\n\n# Food items\nfoods = ['Chicken', 'Rice', 'Apples', 'Steak', 'Lentils', 'Fish', 'Tofu', 'Cheese', 'Bread']\n\n# Parameters\nprotein = {'Chicken': 15, 'Rice': 1, 'Apples': 1, 'Steak': 6, 'Lentils': 3, \n           'Fish': 17, 'Tofu': 18, 'Cheese': 12, 'Bread': 2}\ncarbs = {'Chicken': 18, 'Rice': 25, 'Apples': 21, 'Steak': 3, 'Lentils': 7, \n         'Fish': 13, 'Tofu': 27, 'Cheese': 17, 'Bread': 30}\ncalories = {'Chicken': 300, 'Rice': 267, 'Apples': 266, 'Steak': 119, 'Lentils': 166, \n            'Fish': 129, 'Tofu': 216, 'Cheese': 76, 'Bread': 258}\ncost = {'Chicken': 4, 'Rice': 2, 'Apples': 5, 'Steak': 10, 'Lentils': 2, \n        'Fish': 8, 'Tofu': 10, 'Cheese': 9, 'Bread': 4}\n\n# Nutritional requirements\nprotein_min = 90\ncarbs_min = 105\ncalories_min = 1805\n\n# Decision variables\nx = model.addVars(foods, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: Minimize the total cost\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in foods), GRB.MINIMIZE)\n\n# Constraints\n# Protein constraint\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in foods) >= protein_min, \"ProteinRequirement\")\n\n# Carbohydrates constraint\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in foods) >= carbs_min, \"CarbsRequirement\")\n\n# Calorie constraint\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in foods) >= calories_min, \"CaloriesRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E004",
    "description": "Let's say you're on a mission to create the perfect meal plan for yourself. You're focused on getting the right balance of nutrients without digging too deep into your pockets. You have six different food options to consider: Chicken, Oats, Tofu, Rice, Beef, and Salmon. Each of these foods provides a certain amount of protein, carbohydrates, and calories, and they all come with their own distinct prices.\n\nHere's a detailed breakdown of the nutritional content and cost of each food item:\n\n- Chicken: Delivers 14 grams of protein, a single gram of carbohydrates, and 164 calories at a cost of $6.\n- Oats: Gives you 11 grams of protein, 6 grams of carbohydrates, and 210 calories for just $2.\n- Tofu: Offers 8 grams of protein, 12 grams of carbohydrates, and 98 calories at a cost of $9.\n- Rice: Provides 1 gram of protein, a generous 17 grams of carbohydrates, and 92 calories for $3.\n- Beef: Comes packed with 16 grams of protein, 11 grams of carbohydrates, and 211 calories, priced at $7.\n- Salmon: Brings a hefty 19 grams of protein, 13 grams of carbohydrates, and 211 calories but costs $9.\n\nYou want to make sure your meal plan meets the following nutritional targets: at least 70 grams of protein, 117 grams of carbohydrates, and 1837 calories. Considering these six foods, what is the least amount of money you need to spend to meet these dietary needs?\nRemember, your response should only contain the optimal value of the cost to meet the requirements.",
    "ground_truth": 29.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlanOptimization\")\n\n# Sets and parameters\nfoods = [\"Chicken\", \"Oats\", \"Tofu\", \"Rice\", \"Beef\", \"Salmon\"]\nprotein = {\"Chicken\": 14, \"Oats\": 11, \"Tofu\": 8, \"Rice\": 1, \"Beef\": 16, \"Salmon\": 19}\ncarbs = {\"Chicken\": 1, \"Oats\": 6, \"Tofu\": 12, \"Rice\": 17, \"Beef\": 11, \"Salmon\": 13}\ncalories = {\"Chicken\": 164, \"Oats\": 210, \"Tofu\": 98, \"Rice\": 92, \"Beef\": 211, \"Salmon\": 211}\ncost = {\"Chicken\": 6, \"Oats\": 2, \"Tofu\": 9, \"Rice\": 3, \"Beef\": 7, \"Salmon\": 9}\n\n# Nutritional targets\nP_target = 70\nC_target = 117\nK_target = 1837\n\n# Variables: number of units of each food item\nx = model.addVars(foods, lb=0, vtype=GRB.INTEGER, name=\"x\")  # Changed to integer\n\n# Objective: Minimize the total cost\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in foods), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in foods) >= P_target, \"ProteinConstraint\")\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in foods) >= C_target, \"CarbsConstraint\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in foods) >= K_target, \"CalorieConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E027",
    "description": "Imagine yourself as a dedicated fitness enthusiast on a strict diet and you're trying to plan your meals for an entire day. You aim to meet specific nutritional goals without burning a hole in your pocket. You have five different food items to choose from: Chicken, Pasta, Apples, Tuna, and Rice. Each food item contributes different amounts of proteins, carbohydrates, and calories, and each one has a different price.\n\nHere is an overview of the nutritional values and cost of each food:\n\n- Chicken: Provides 8 grams of protein, 8 grams of carbohydrates, and 118 calories for $6.\n- Pasta: Delivers a hefty 10 grams of protein, a substantial 30 grams of carbohydrates, and 131 calories for $10.\n- Apples: Offer a modest 3 grams of protein, 10 grams of carbohydrates, and a surprising 151 calories for just $1.\n- Tuna: Packs a stunning 16 grams of protein, 29 grams of carbohydrates, and a whopping 235 calories for $9.\n- Rice: Supplies 4 grams of protein, a solid 24 grams of carbohydrates, and 101 calories for a mere $4.\n\nYour dietary goal for the day is to consume at least 93 grams of protein, 181 grams of carbohydrates, and 1620 calories. Your challenge is to figure out the most cost-effective way to achieve these nutritional targets using a combination of these five food options. What is the minimum cost required to meet your daily nutritional requirements? Please note that your response should provide only the optimal value in the context of food selection.",
    "ground_truth": 31.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DietOptimization\")\n\n# Parameters\nprotein = [8, 10, 3, 16, 4]\ncarbs = [8, 30, 10, 29, 24]\ncalories = [118, 131, 151, 235, 101]\ncost = [6, 10, 1, 9, 4]\nP = 93\nC = 181\nCal = 1620\n\n# Variables\nx = model.addVars(5, lb=0, name=\"x\")\n\n# Objective\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in range(5)), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in range(5)) >= P, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in range(5)) >= C, \"CarbsRequirement\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in range(5)) >= Cal, \"CaloriesRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E033",
    "description": "You've decided to take control of your health and focus on your nutritional intake. After researching and consulting with a dietitian, you've determined that your daily requirements are 78 grams of protein, 140 grams of carbs, and 1537 calories. Now, the next challenge is to meet these daily requirements in the most cost-effective way possible.\n\nYour local supermarket offers a variety of food items, each with its own cost and nutritional content. Here's what you have to choose from:\n\n- Chicken Breast: For $4, you'll get 14 grams of protein, 4 grams of carbohydrates, and 275 calories.\n- Brown Rice: A $10 serving gives you 11 grams of protein, 17 grams of carbohydrates, and 151 calories. \n- Tofu: For $6, you can get 20 grams of protein, 12 carbs, and 155 calories. \n- Spinach: At only $1, you get 6 grams of protein, 20 carbs, and 106 calories. This is the cheapest option but also the least calorie-dense. \n- Almonds: For $8, you get 9 grams of protein, 11 grams of carbohydrates, and 279 calories. \n- Salmon: Finally, for $6, you get a whopping 20 grams of protein, 19 grams of carbohydrates, and 93 calories. \n\nWith these food options available, your task is to figure out how to meet your daily nutritional requirements while keeping your costs to a minimum. So what is the least amount of money you need to spend to meet your daily nutritional needs?",
    "ground_truth": 15.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DietOptimization\")\n\n# Define the coefficients\nprotein = {'chicken': 14, 'rice': 11, 'tofu': 20, 'spinach': 6, 'almonds': 9, 'salmon': 20}\ncarbs = {'chicken': 4, 'rice': 17, 'tofu': 12, 'spinach': 20, 'almonds': 11, 'salmon': 19}\ncalories = {'chicken': 275, 'rice': 151, 'tofu': 155, 'spinach': 106, 'almonds': 279, 'salmon': 93}\ncost = {'chicken': 4, 'rice': 10, 'tofu': 6, 'spinach': 1, 'almonds': 8, 'salmon': 6}\n\n# Required daily intake\nR_P = 78\nR_C = 140\nR_Cal = 1537\n\n# Add decision variables\nx = model.addVars(protein.keys(), vtype=GRB.INTEGER, name=\"x\")\n\n# Set objective function: Minimize the total cost\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in protein.keys()), GRB.MINIMIZE)\n\n# Add constraints\n# Protein constraint\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in protein.keys()) >= R_P, \"Protein\")\n\n# Carbohydrate constraint\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in carbs.keys()) >= R_C, \"Carbs\")\n\n# Caloric constraint\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in calories.keys()) >= R_Cal, \"Calories\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E007",
    "description": "Imagine you're a college student living off-campus with a tight budget, but you're committed to maintaining a healthy diet. You have identified a set of nine different food items available in your local supermarket. Each of these items provides specific amounts of protein, carbohydrates, and calories and has its own price. \n\nHere is the breakdown of what each food item provides along with its cost:\n\n1. Chicken (Cost: $10): Gives you 7 grams of protein, 17 grams of carbohydrates, and 95 calories.\n2. Tofu (Cost: $2): Provides 12 grams of protein, 12 grams of carbohydrates, and 233 calories.\n3. Brown Rice (Cost: $7): Contains 14 grams of protein, 27 grams of carbohydrates, and 134 calories.\n4. Fish (Cost: $8): Offers 9 grams of protein, 6 grams of carbohydrates, and 109 calories.\n5. Lentils (Cost: $4): Deliver 11 grams of protein, 19 grams of carbohydrates, and 202 calories.\n6. Quinoa (Cost: $9): Packs 10 grams of protein, 23 grams of carbohydrates, and 148 calories.\n7. Eggs (Cost: $2): Provides 10 grams of protein, 6 grams of carbohydrates, and 184 calories.\n8. Beef (Cost: $9): Contains 9 grams of protein, 16 grams of carbohydrates, and 136 calories.\n9. Beans (Cost: $9): Offers 8 grams of protein, 25 grams of carbohydrates, and 229 calories.\n\nYour daily dietary requirements are that you need at least 71 grams of protein, 107 grams of carbohydrates, and 1623 calories. Your challenge is to meet these nutritional targets by choosing from these nine food items and spending as little money as possible. How much is the minimum cost you need to spend to meet your nutritional needs? Remember, your response should only provide the optimal value.",
    "ground_truth": 18.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets and Parameters\nF = range(1, 10)  # Food items indexed from 1 to 9\ncost = {1: 10, 2: 2, 3: 7, 4: 8, 5: 4, 6: 9, 7: 2, 8: 9, 9: 9}\nprotein = {1: 7, 2: 12, 3: 14, 4: 9, 5: 11, 6: 10, 7: 10, 8: 9, 9: 8}\ncarbohydrates = {1: 17, 2: 12, 3: 27, 4: 6, 5: 19, 6: 23, 7: 6, 8: 16, 9: 25}\ncalories = {1: 95, 2: 233, 3: 134, 4: 109, 5: 202, 6: 148, 7: 184, 8: 136, 9: 229}\n\n# Decision variables\nx = model.addVars(F, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: Minimize total cost\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in F), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in F) >= 71, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carbohydrates[i] * x[i] for i in F) >= 107, \"CarbohydrateRequirement\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in F) >= 1623, \"CalorieRequirement\")\n\n# Non-negativity constraints are inherent due to the integer type\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E028",
    "description": "Imagine you are planning your meals for the week, and you need to make sure you're receiving the right amount of nutrients without breaking the bank. You're considering six different food items, namely Pasta, Avocado, Chicken, Tofu, Spinach, and Cheese. Each of these foods offers a certain amount of protein, carbohydrates, and calories, and each comes with its own cost.\n\nHere's what each food offers and its cost:\n\n- Pasta: Gives you 15 grams of protein, 30 grams of carbohydrates, and 154 calories for $3.\n- Avocado: Offers 20 grams of protein, 16 grams of carbohydrates, and 111 calories for $8.\n- Chicken: Packs 15 grams of protein, 8 grams of carbohydrates, and 211 calories for $7.\n- Tofu: Delivers 19 grams of protein, 5 grams of carbohydrates, and 87 calories for only $2.\n- Spinach: Provides 19 grams of protein, 28 grams of carbohydrates, and 98 calories for $9.\n- Cheese: Contributes 12 grams of protein, 17 grams of carbohydrates, and 231 calories for $10.\n\nYour goal is to ensure that you get at least 73 grams of protein, 111 grams of carbohydrates, and 2196 calories from whatever combination of these foods you choose. The challenge is to figure out the most cost-effective way to hit all these nutritional targets with these six food options. What is the minimum cost to meet your nutritional needs?\nNote: your response should be a single answer question, asking for only the optimal value. The scenario revolves around the selection of food.",
    "ground_truth": 44.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlanning\")\n\n# Food items and their respective properties\nfoods = [\"Pasta\", \"Avocado\", \"Chicken\", \"Tofu\", \"Spinach\", \"Cheese\"]\nprotein = [15, 20, 15, 19, 19, 12]\ncarbohydrates = [30, 16, 8, 5, 28, 17]\ncalories = [154, 111, 211, 87, 98, 231]\ncosts = [3, 8, 7, 2, 9, 10]\n\n# Decision variables: Number of servings of each food\nx = model.addVars(foods, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: Minimize the total cost\nmodel.setObjective(gp.quicksum(costs[i] * x[foods[i]] for i in range(len(foods))), GRB.MINIMIZE)\n\n# Constraints\n# Protein constraint\nmodel.addConstr(gp.quicksum(protein[i] * x[foods[i]] for i in range(len(foods))) >= 73, \"Protein\")\n\n# Carbohydrates constraint\nmodel.addConstr(gp.quicksum(carbohydrates[i] * x[foods[i]] for i in range(len(foods))) >= 111, \"Carbohydrates\")\n\n# Calorie constraint\nmodel.addConstr(gp.quicksum(calories[i] * x[foods[i]] for i in range(len(foods))) >= 2196, \"Calories\")\n\n# Non-negative constraint\nmodel.addConstrs((x[foods[i]] >= 0 for i in range(len(foods))), \"NonNegativity\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "F062",
    "description": "A farmer wants to mix his animal feeds, Feed A and Feed B, in such a way that the mixture will contain a minimum of 30 units of protein and 50 units of fat. Feed A costs $100 per kilogram and contains 10 units of protein and 8 units of fat. Feed B costs $80 per kilogram and contains 7 units of protein and 15 units of fat. Determine the minimum cost of the mixture.",
    "ground_truth": 327.659572,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"AnimalFeedOptimization\")\n\n# Define the decision variables\nx_A = model.addVar(name=\"x_A\", lb=0, vtype=GRB.CONTINUOUS)  # Kilograms of Feed A\nx_B = model.addVar(name=\"x_B\", lb=0, vtype=GRB.CONTINUOUS)  # Kilograms of Feed B\n\n# Define the objective function\nmodel.setObjective(100 * x_A + 80 * x_B, GRB.MINIMIZE)\n\n# Add the constraints\nmodel.addConstr(10 * x_A + 7 * x_B >= 30, \"ProteinRequirement\")  # Protein constraint\nmodel.addConstr(8 * x_A + 15 * x_B >= 50, \"FatRequirement\")     # Fat constraint\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "F089",
    "description": "Lucy has a dog and she wants his food to be mixed.  In order to keep the dog healthy but also keep the food tasty, the mix needs to have a minimum of 15 units of calcium, 20 units of vitamin mix, and 20 units of protein. A regular brand costs $20 per bag and contains 4 units of calcium, 7 units of vitamin mix, and 10 units of protein. A premium brand costs $35 per bag and contains 12 units of calcium, 10 units of vitamin mix, and 16 units of protein. How many bags of each brand should Lucy mix in order to minimize cost while also meeting the taste and health requirements.",
    "ground_truth": 70.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DogFoodMixOptimization\")\n\n# Parameters\nc_r = 20  # Cost per bag of regular brand\nc_p = 35  # Cost per bag of premium brand\na_r = 4   # Units of calcium per bag of regular brand\na_p = 12  # Units of calcium per bag of premium brand\nv_r = 7   # Units of vitamin mix per bag of regular brand\nv_p = 10  # Units of vitamin mix per bag of premium brand\np_r = 10  # Units of protein per bag of regular brand\np_p = 16  # Units of protein per bag of premium brand\ncalcium_req = 15  # Minimum units of calcium required\nvitamin_req = 20  # Minimum units of vitamin mix required\nprotein_req = 20  # Minimum units of protein required\n\n# Variables\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\", lb=0)  # Number of bags of regular brand\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\", lb=0)  # Number of bags of premium brand\n\n# Objective\nmodel.setObjective(c_r * x_r + c_p * x_p, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(a_r * x_r + a_p * x_p >= calcium_req, \"CalciumConstraint\")\nmodel.addConstr(v_r * x_r + v_p * x_p >= vitamin_req, \"VitaminConstraint\")\nmodel.addConstr(p_r * x_r + p_p * x_p >= protein_req, \"ProteinConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Consumer Goods"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "A189",
    "description": "Super Shop sells cat paw snacks and gold shark snacks in bulk. It plans to sell them into two snack mix products. The first mix contains 20% cat paw snacks and 80% gold shark snacks. The second mix contains 35% cat paw snacks and 65% gold shark snacks. The store has on hand 20 kg of cat paw snacks and 50 kg of gold shark snacks. If the profit per kg of the first mix is $12 and the profit per kg of the second mix is $15, how many kg of each should be prepared to maximize profit?",
    "ground_truth": 960.0,
    "formulation": null,
    "correct_program": "def optimize_snacks():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"SnackMixOptimization\")\n\n    # Decision variables: amount of each mix to produce\n    x1 = m.addVar(name=\"x1\", lb=0)  # first mix\n    x2 = m.addVar(name=\"x2\", lb=0)  # second mix\n\n    # Set the objective: maximize profit\n    profit = 12 * x1 + 15 * x2\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Cat paw snack constraint\n    m.addConstr(0.20 * x1 + 0.35 * x2 <= 20, name=\"CatPawConstraint\")\n    # Gold shark snack constraint\n    m.addConstr(0.80 * x1 + 0.65 * x2 <= 50, name=\"GoldSharkConstraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_snacks()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A017",
    "description": "A candy store mixes regular candy and sour candy to prepare two products, regular mix and sour surprise mix. Each kilogram of the regular mix contains 0.8 kg of regular candy and 0.2 kg of sour candy. The profit per kilogram of the regular mix is $3. Each kilogram of the sour surprise mix contains 0.1 kg of regular candy and 0.9 kg of sour candy. The profit per kilogram of the sour surprise mix is $5. The candy store has 80 kg of regular candy and 60 kg of sour candy available. How many kilograms of each type of candy mix should be created to maximize profits?",
    "ground_truth": 511.4285714285714,
    "formulation": null,
    "correct_program": "def optimize_candy_mixes(\n    regular_candy_available=80,\n    sour_candy_available=60,\n    profit_regular_mix=3,\n    profit_sour_surprise=5\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Candy_Mix_Optimization\")\n\n    # Decision variables: amount of each mix to produce\n    x = model.addVar(name=\"Regular_Mix\", lb=0)\n    y = model.addVar(name=\"Sour_Surprise_Mix\", lb=0)\n\n    # Set objective: maximize profit\n    model.setObjective(profit_regular_mix * x + profit_sour_surprise * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Regular candy constraint\n    model.addConstr(0.8 * x + 0.1 * y <= regular_candy_available, name=\"Regular_Candy_Constraint\")\n    # Sour candy constraint\n    model.addConstr(0.2 * x + 0.9 * y <= sour_candy_available, name=\"Sour_Candy_Constraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal profit value\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_candy_mixes()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Food & Beverage"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F001",
    "description": "A farmer wants to manufacture a special plant nutrition using fertilizers A and B. Each kg of fertilizer A contains 13 units of nitrogen, 5 units of phosphoric acid, 6 units of vitamin A and 5 units of vitamin D. Each kg of fertilizer B contains 8 units of nitrogen, 14 units of phosphoric acid, 6 units of vitamin A and 9 units of vitamin D. To be effective, the plant nutrition requires a minimum 220 units of nitrogen, a minimum of 160 units of phosphoric acid, and no more than 350 units of vitamin A. How many kg of each fertilizer should be used to minimize the amount of vitamin D in the nutrition? What is the minimum amount of vitamin D?",
    "ground_truth": 125.4929565,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nN_A = 13  # Units of nitrogen per kg of fertilizer A\nP_A = 5   # Units of phosphoric acid per kg of fertilizer A\nV_A = 6   # Units of vitamin A per kg of fertilizer A\nD_A = 5   # Units of vitamin D per kg of fertilizer A\n\nN_B = 8   # Units of nitrogen per kg of fertilizer B\nP_B = 14  # Units of phosphoric acid per kg of fertilizer B\nV_B = 6   # Units of vitamin A per kg of fertilizer B\nD_B = 9   # Units of vitamin D per kg of fertilizer B\n\nN_min = 220  # Minimum required units of nitrogen\nP_min = 160  # Minimum required units of phosphoric acid\nV_max = 350  # Maximum allowed units of vitamin A\n\n# Variables\nx_A = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_A\", lb=0)\nx_B = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_B\", lb=0)\n\n# Objective: Minimize vitamin D\nmodel.setObjective(D_A * x_A + D_B * x_B, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(N_A * x_A + N_B * x_B >= N_min, \"NitrogenConstraint\")\nmodel.addConstr(P_A * x_A + P_B * x_B >= P_min, \"PhosphoricAcidConstraint\")\nmodel.addConstr(V_A * x_A + V_B * x_B <= V_max, \"VitaminAConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "A180",
    "description": "Calcium and Magnesium are found in two health supplements, health supplement A and health supplement B. One serving of health supplement A contains 30 grams of Calcium and 50 grams of Magnesium. One serving of health supplement B contains 60 grams of Calcium and 10 grams of Magnesium. The cost per health supplement for health supplement A is $14 and the cost per health supplement for health supplement B is $25. A patient must consume these two health supplements every day to get at least 400 grams of Calcium and 50 grams of Magnesium. Determine how much servings of each supplement the patient needs to minimize her daily cost.",
    "ground_truth": 166.66666666666669,
    "formulation": null,
    "correct_program": "def optimize_supplements():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"SupplementsOptimization\")\n\n    # Decision variables: servings of supplement A and B\n    x = m.addVar(name=\"A_servings\", lb=0)\n    y = m.addVar(name=\"B_servings\", lb=0)\n\n    # Set the objective: minimize total cost\n    m.setObjective(14 * x + 25 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Calcium constraint\n    m.addConstr(30 * x + 60 * y >= 400, name=\"CalciumRequirement\")\n    # Magnesium constraint\n    m.addConstr(50 * x + 10 * y >= 50, name=\"MagnesiumRequirement\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal cost\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cost = optimize_supplements()\n    if min_cost is not None:\n        print(f\"Minimum Cost: {min_cost}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 47,
    "retrieved_insights": []
  },
  {
    "task_id": "A022",
    "description": "Ayse produces a plant growth compound by mixing two types of fertilizer: C and Y. This growth compound must contain at least 5 units of nitrous oxide and 8 units of vitamin mix. Fertilizer C and Y cost $2 and $3 per kg respectively. Fertilizer C contains 1.5 units of nitrous oxide per kg and 3 units of vitamin mix per kg. Fertilizer Y contains 5 units of nitrous oxide per kg and 1 unit of vitamin mix per kg. Determine the minimum cost of Ayse's compound.",
    "ground_truth": 5.851851851851852,
    "formulation": null,
    "correct_program": "def optimize_fertilizer_cost():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Fertilizer_Optimization\")\n\n    # Decision variables: amount of fertilizers C and Y\n    x = m.addVar(name=\"C\", lb=0)  # fertilizer C in kg\n    y = m.addVar(name=\"Y\", lb=0)  # fertilizer Y in kg\n\n    # Set the objective: minimize total cost\n    m.setObjective(2 * x + 3 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(1.5 * x + 5 * y >= 5, name=\"NitrousOxide\")\n    m.addConstr(3 * x + y >= 8, name=\"VitaminMix\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cost = optimize_fertilizer_cost()\n    if min_cost is not None:\n        print(f\"Minimum Cost of Fertilizer Mixture: {min_cost}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 29,
    "retrieved_insights": []
  },
  {
    "task_id": "F157",
    "description": "Ayse produces a plant growth compound by mixing two types of fertilizer: C and Y. This growth compound must contain at least 5 units of nitrous oxide and 8 units of vitamin mix. Fertilizer C and Y cost $2 and $3 per kg respectively. Fertilizer C contains 1.5 units of nitrous oxide per kg and 3 units of vitamin mix per kg. Fertilizer Y contains 5 units of nitrous oxide per kg and 1 unit of vitamin mix per kg. Determine the minimum cost of Ayse's compound.",
    "ground_truth": 5.85185186,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Add variables\nx_C = model.addVar(name=\"x_C\", lb=0, vtype=GRB.CONTINUOUS)\nx_Y = model.addVar(name=\"x_Y\", lb=0, vtype=GRB.CONTINUOUS)\n\n# Set objective\nmodel.setObjective(2 * x_C + 3 * x_Y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(1.5 * x_C + 5 * x_Y >= 5, \"NitrousOxideRequirement\")\nmodel.addConstr(3 * x_C + 1 * x_Y >= 8, \"VitaminMixRequirement\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 29,
    "retrieved_insights": []
  },
  {
    "task_id": "B058",
    "description": "A candy factory uses raw materials A, B, and C to process three different brands of candies, A, B, and C. It is known that the content of A, B, and C in each brand of candy, the cost of raw materials, the monthly limit of each raw material, and the unit processing fee and selling price of the three brands of candies are shown in Table 1-7.\n\nTable 1-7\n\n| Item            | A               | B               | C               | Raw Material Cost (Yuan/kg) | Monthly Limit (kg) |\n|:----------------|:---------------|:---------------|:---------------|:-----------------------------|:-------------------|\n| A               | ≥ 60%          | ≥ 15%          |                | 2.00                        | 2000               |\n| B               |                |                |                | 1.50                        | 2500               |\n| C               | ≤ 20%          | ≤ 60%          | ≤ 50%          | 1.00                        | 1200               |\n| Processing Fee (Yuan/kg) | 0.50         | 0.40           | 0.30           |                             |                     |\n| Selling Price (Yuan/kg)   | 3.40         | 2.85           | 2.25           |                             |                     |\n\nHow many kilograms of each of the three brands of candies should the factory produce each month to maximize the profit?",
    "ground_truth": 6160.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_candy_production():\n    \"\"\"\n    Solves the candy factory production planning problem to maximize profit.\n    \"\"\"\n    try:\n        # --- Data ---\n        candy_brands = ['CandyA', 'CandyB', 'CandyC']\n        raw_materials = ['RawA', 'RawB', 'RawC']\n\n        # Selling prices (Yuan/kg)\n        selling_prices = {'CandyA': 3.40, 'CandyB': 2.85, 'CandyC': 2.25}\n\n        # Processing fees (Yuan/kg)\n        processing_fees = {'CandyA': 0.50, 'CandyB': 0.40, 'CandyC': 0.30}\n\n        # Raw material costs (Yuan/kg)\n        raw_material_costs = {'RawA': 2.00, 'RawB': 1.50, 'RawC': 1.00}\n\n        # Monthly limits of raw materials (kg)\n        raw_material_limits = {'RawA': 2000, 'RawB': 2500, 'RawC': 1200}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"CandyFactoryOptimization\")\n\n        # --- Decision Variables ---\n        # X[j]: total kilograms of candy brand j produced\n        X = model.addVars(candy_brands,\n                          name=\"X_prod\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # R[i,j]: kilograms of raw material i used in candy brand j\n        R = model.addVars(raw_materials,\n                          candy_brands,\n                          name=\"R_raw_in_candy\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = (Sales Revenue - Processing Cost) - Raw Material Cost\n\n        revenue_minus_processing = gp.quicksum(\n            (selling_prices[j] - processing_fees[j]) * X[j]\n            for j in candy_brands)\n\n        total_raw_material_cost = gp.quicksum(raw_material_costs[i] * R[i, j]\n                                              for i in raw_materials\n                                              for j in candy_brands)\n\n        model.setObjective(revenue_minus_processing - total_raw_material_cost,\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Mass Balance for Each Candy Brand: Sum of raw materials = Total candy produced\n        for j in candy_brands:\n            model.addConstr(gp.quicksum(R[i, j]\n                                        for i in raw_materials) == X[j],\n                            name=f\"MassBalance_{j}\")\n\n        # 2. Raw Material Availability Limits\n        for i in raw_materials:\n            model.addConstr(gp.quicksum(R[i, j] for j in candy_brands)\n                            <= raw_material_limits[i],\n                            name=f\"Limit_{i}\")\n\n        # 3. Content Percentage Requirements\n        # Candy A\n        model.addConstr(R['RawA', 'CandyA'] >= 0.60 * X['CandyA'],\n                        name=\"Content_CandyA_RawA_min\")\n        model.addConstr(R['RawC', 'CandyA'] <= 0.20 * X['CandyA'],\n                        name=\"Content_CandyA_RawC_max\")\n\n        # Candy B\n        model.addConstr(R['RawA', 'CandyB'] >= 0.15 * X['CandyB'],\n                        name=\"Content_CandyB_RawA_min\")\n        model.addConstr(R['RawC', 'CandyB'] <= 0.60 * X['CandyB'],\n                        name=\"Content_CandyB_RawC_max\")\n\n        # Candy C\n        model.addConstr(R['RawC', 'CandyC'] <= 0.50 * X['CandyC'],\n                        name=\"Content_CandyC_RawC_max\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Total Profit: {model.ObjVal:.2f} Yuan\")\n\n            print(\"\\nOptimal Production Quantities (kg):\")\n            for j in candy_brands:\n                if X[j].X > 1e-6:\n                    print(f\"  {j}: {X[j].X:.2f} kg\")\n                    print(f\"    Composition:\")\n                    for i in raw_materials:\n                        if R[i, j].X > 1e-6:\n                            percentage = (R[i, j].X / X[j].X *\n                                          100) if X[j].X > 1e-6 else 0\n                            print(\n                                f\"      {i}: {R[i,j].X:.2f} kg ({percentage:.1f}%)\"\n                            )\n                else:\n                    print(f\"  {j}: 0.00 kg\")\n\n            print(\"\\nTotal Raw Material Usage (kg):\")\n            for i in raw_materials:\n                total_used = sum(R[i, j].X for j in candy_brands)\n                print(\n                    f\"  {i}: {total_used:.2f} / {raw_material_limits[i]} kg used\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and data for contradictions.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"candy_factory_iis.ilp\")\n            # print(\"IIS written to candy_factory_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_candy_production()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B096",
    "description": "A company mixes four types of liquid raw materials with different sulfur contents (denoted as A, B, C, and D, respectively) to produce two products (denoted as \\( \\mathrm{A} \\) and \\( \\mathrm{B} \\)). According to the production process requirements, raw materials A, B, and D must first be mixed in a mixing tank, and then the mixed liquid is further mixed with raw material C to produce \\( \\mathrm{A} \\) and \\( \\mathrm{B} \\). The sulfur contents of raw materials A, B, C, and D are \\( 3\\%, 1\\%, 2\\%, 1\\% \\) respectively, and their purchase prices are 6, 16, 10, 15 (thousand yuan per ton) respectively. The sulfur content of products \\( \\mathrm{A} \\) and \\( \\mathrm{B} \\) must not exceed \\( 2.5\\% \\) and \\( 1.5\\% \\) respectively, and their selling prices are 9.15 (thousand yuan per ton). According to market information, there is no limit to the supply of raw materials A, B, and C, but the supply of raw material D is limited to a maximum of 50 tons. The market demand for products \\( \\mathrm{A} \\) and \\( \\mathrm{B} \\) is 100 tons and 200 tons respectively. How should the production be arranged?",
    "ground_truth": 115.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_liquid_blending():\n    \"\"\"\n    Solves the liquid blending problem to maximize profit, subject to\n    raw material supply, product demand, and quality (sulfur) constraints.\n    \"\"\"\n    try:\n        # --- Data ---\n        raw_materials = ['A', 'B', 'C', 'D']\n        gasolines = ['GasA', 'GasB']\n\n        # Sulfur content (%)\n        sulfur_content = {'A': 0.03, 'B': 0.01, 'C': 0.02, 'D': 0.01}\n\n        # Purchase prices (thousand yuan per ton)\n        purchase_price = {'A': 6, 'B': 16, 'C': 10, 'D': 15}\n\n        # Selling prices (thousand yuan per ton) - Same for both\n        selling_price = {'GasA': 9.15, 'GasB': 9.15}\n\n        # Max sulfur content allowed in products (%)\n        max_sulfur = {'GasA': 0.025, 'GasB': 0.015}\n\n        # Supply limits (tons) - Only D is limited\n        supply_limit = {'D': 50}\n\n        # Demand limits (tons)\n        demand_limit = {'GasA': 100, 'GasB': 200}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"LiquidBlending\")\n\n        # --- Decision Variables ---\n        # x[i, j]: amount (tons) of raw material i used in gasoline j\n        x = model.addVars(raw_materials,\n                          gasolines,\n                          name=\"Blend\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # --- Intermediate Expressions (Total Production) ---\n        # Total amount of each gasoline produced\n        GasProduced = {\n            g: gp.quicksum(x[i, g] for i in raw_materials)\n            for g in gasolines\n        }\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = Total Revenue - Total Cost of Raw Materials\n        total_revenue = gp.quicksum(selling_price[g] * GasProduced[g]\n                                    for g in gasolines)\n\n        total_cost = gp.quicksum(purchase_price[i] * x[i, g]\n                                 for i in raw_materials for g in gasolines)\n\n        model.setObjective(total_revenue - total_cost, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Raw Material D Supply Limit\n        model.addConstr(gp.quicksum(x['D', g] for g in gasolines)\n                        <= supply_limit['D'],\n                        name=\"SupplyLimit_D\")\n\n        # 2. Product Demand Limits\n        for g in gasolines:\n            model.addConstr(GasProduced[g] <= demand_limit[g],\n                            name=f\"DemandLimit_{g}\")\n\n        # 3. Sulfur Content Limits\n        for g in gasolines:\n            total_sulfur_in_g = gp.quicksum(sulfur_content[i] * x[i, g]\n                                            for i in raw_materials)\n            # total_sulfur_in_g <= max_sulfur[g] * GasProduced[g]\n            model.addConstr(total_sulfur_in_g\n                            <= max_sulfur[g] * GasProduced[g],\n                            name=f\"SulfurLimit_{g}\")\n\n            # Alternative formulation (avoids division by zero if GasProduced[g] could be 0):\n            # (total_sulfur_in_g - max_sulfur[g] * GasProduced[g]) <= 0\n            # model.addConstr(gp.quicksum((sulfur_content[i] - max_sulfur[g]) * x[i, g]\n            #                             for i in raw_materials) <= 0,\n            #                 name=f\"SulfurLimit_{g}_alt\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal blending plan found.\")\n            # Convert profit back to yuan from thousand yuan\n            print(f\"Maximum Profit: {model.ObjVal * 1000:.2f} Yuan\")\n\n            print(\"\\nOptimal Production Quantities (tons):\")\n            total_revenue_val = 0\n            for g in gasolines:\n                prod_qty = GasProduced[g].getValue()\n                total_revenue_val += selling_price[g] * prod_qty\n                print(f\"  Gasoline {g}: {prod_qty:.2f} tons\")\n                if prod_qty > 1e-6:  # Avoid division by zero\n                    print(f\"    Composition:\")\n                    actual_sulfur_g = 0\n                    for i in raw_materials:\n                        if x[i, g].X > 1e-6:\n                            percentage = (x[i, g].X / prod_qty * 100)\n                            actual_sulfur_g += sulfur_content[i] * x[i, g].X\n                            print(\n                                f\"      Raw Material {i}: {x[i,g].X:.2f} tons ({percentage:.1f}%)\"\n                            )\n                    actual_sulfur_percent = (actual_sulfur_g / prod_qty *\n                                             100) if prod_qty > 1e-6 else 0\n                    print(\n                        f\"    -> Actual Sulfur Content: {actual_sulfur_percent:.3f}% (Max: {max_sulfur[g]*100:.1f}%)\"\n                    )\n\n            print(\"\\nRaw Material Usage (tons):\")\n            total_cost_val = 0\n            for i in raw_materials:\n                usage = sum(x[i, g].X for g in gasolines)\n                cost_i = purchase_price[i] * usage\n                total_cost_val += cost_i\n                limit_str = f\"(Limit: {supply_limit[i]})\" if i in supply_limit else \"\"\n                print(f\"  Raw Material {i}: {usage:.2f} tons {limit_str}\")\n\n            print(\"\\nFinancial Summary (Thousand Yuan):\")\n            print(f\"  Total Revenue: {total_revenue_val:.3f}\")\n            print(f\"  Total Raw Material Cost: {total_cost_val:.3f}\")\n            print(\n                f\"  Calculated Profit: {(total_revenue_val - total_cost_val):.3f}\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints, demands, supply, and quality requirements.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"liquid_blending_iis.ilp\")\n            # print(\"IIS written to liquid_blending_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_liquid_blending()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 28,
    "retrieved_insights": []
  },
  {
    "task_id": "A079",
    "description": "A man on a strict diet only drinks meal replacement drinks from two brands, alpha and omega. The alpha brand drink contains 30 grams of protein, 20 grams of sugar, and 350 calories per bottle. The omega brand drink contains 20 grams of protein, 15 grams of sugar, and 300 calories per bottle. The man wants to get at least 100 grams of protein and 2000 calories. In addition, because the omega brand drink contains tiny amounts of caffeine, at most 35% of the drink should be omega brand. How many bottles of each should he drink to minimize his sugar intake?",
    "ground_truth": 110.0,
    "formulation": null,
    "correct_program": "def optimize_meal_plan():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MealReplacementOptimization\")\n\n    # Decision variables: number of bottles of alpha and omega\n    x = m.addVar(name=\"alpha_bottles\", lb=0, vtype=GRB.INTEGER)\n    y = m.addVar(name=\"omega_bottles\", lb=0, vtype=GRB.INTEGER)\n\n    # Set the objective: minimize total sugar\n    m.setObjective(20 * x + 15 * y, GRB.MINIMIZE)\n\n    # Add protein constraint\n    m.addConstr(30 * x + 20 * y >= 100, name=\"protein_req\")\n\n    # Add calorie constraint\n    m.addConstr(350 * x + 300 * y >= 2000, name=\"calorie_req\")\n\n    # Add omega proportion constraint\n    # y <= (0.35/0.65) * x\n    m.addConstr(y <= (0.35 / 0.65) * x, name=\"omega_ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal sugar intake\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nprint(optimize_meal_plan())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "A095",
    "description": "A doctor recommends that a man eat burgers and pizza in order to put on weight. Each burger contains 10 units of fat and 300 calories. Each slice of pizza contains 8 units of fat and 250 calories. The man must get at least 130 units of fat and 3000 calories. Further, each burger contains 12 units of cholesterol while each slice of pizza contains 10 units of cholesterol. Since burgers are slightly more expensive, the man decides to eat at least twice as many slices of pizza as burgers. How many of each should he eat to minimize his cholesterol intake?",
    "ground_truth": 160.0,
    "formulation": null,
    "correct_program": "def optimize_cholesterol():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Minimize Cholesterol Intake\")\n\n    # Decision variables: number of burgers (x) and slices of pizza (y)\n    # Both are integers and >= 0\n    x = m.addVar(name=\"burgers\", vtype=GRB.INTEGER, lb=0)\n    y = m.addVar(name=\"pizza_slices\", vtype=GRB.INTEGER, lb=0)\n\n    # Set the objective: minimize total cholesterol\n    m.setObjective(12 * x + 10 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(10 * x + 8 * y >= 130, name=\"fat_constraint\")\n    m.addConstr(300 * x + 250 * y >= 3000, name=\"calorie_constraint\")\n    m.addConstr(y >= 2 * x, name=\"pizza_burger_ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cholesterol = optimize_cholesterol()\n    if min_cholesterol is not None:\n        print(f\"Minimum Cholesterol Intake: {min_cholesterol}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "A235",
    "description": "A woman on a diet needs to eat two types of meal preps, a smoothie and a protein bar. Each smoothie contains 2 units of protein and 300 calories. Each protein bar contains 7 units of protein and 250 calories. The woman must eat 2 times more protein bars than smoothies. If the woman can consume at most 2000 calories, how many of each should she eat or drink to maximize her protein intake?",
    "ground_truth": 56.0,
    "formulation": null,
    "correct_program": "def optimize_meal_preps(max_calories=2000, protein_smoothie=2, protein_bar=7,\n                          calories_smoothie=300, calories_bar=250):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"MealPrepsMaxProtein\")\n\n    # Decision variables: number of smoothies (x) and protein bars (y)\n    # Since quantities are discrete, define as integer variables\n    x = model.addVar(name=\"smoothies\", vtype=GRB.INTEGER, lb=0)\n    y = model.addVar(name=\"bars\", vtype=GRB.INTEGER, lb=0)\n\n    # Add the relationship constraint: y = 2x\n    model.addConstr(y >= 2 * x, name=\"relation\")\n\n    # Add caloric constraint\n    model.addConstr(\n        calories_smoothie * x + calories_bar * y <= max_calories,\n        name=\"calorie_limit\"\n    )\n\n    # Set the objective: maximize total protein\n    total_protein = protein_smoothie * x + protein_bar * y\n    model.setObjective(total_protein, GRB.MAXIMIZE)\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total protein\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_protein = optimize_meal_preps()\n    if max_protein is not None:\n        print(f\"Maximum protein intake: {max_protein:.2f} grams\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E013",
    "description": "Imagine you're a nutrition-conscious shopper who is trying to meet specific dietary requirements without breaking the bank. You have eight food items to choose from: Eggs, Grains, Berries, Nuts, Salmon, Vegetables, Rice, and Meat. Each of these foods has its own nutritional content and cost.\n\nLet's break down the nutritional content and cost of each food item:\n\n- Eggs: For $4, you get 2 grams of protein, 4 grams of carbohydrates, and 282 calories.\n- Grains: For $3, you get 7 grams of protein, 9 grams of carbohydrates, and 104 calories.\n- Berries: For $2, you get 6 grams of protein, 18 grams of carbohydrates, and 71 calories.\n- Nuts: For $4, you get 16 grams of protein, 3 grams of carbohydrates, and 116 calories.\n- Salmon: For $9, you get 20 grams of protein, 11 grams of carbohydrates, and 175 calories.\n- Vegetables: For $3, you get 6 grams of protein, 27 grams of carbohydrates, and 132 calories.\n- Rice: For $6, you get 6 grams of protein, 30 grams of carbohydrates, and 251 calories.\n- Meat: For $6, you get 5 grams of protein, 1 gram of carbohydrates, and 74 calories.\n\nYour goal is to get at least 84 grams of protein, 195 grams of carbohydrates, and 1941 calories within a day from a combination of these food items. The challenge here is to figure out the least expensive way to meet these nutritional targets with the given food options. So, what is the minimum cost you need to spend to meet your daily nutritional requirements? Keep in mind, the answer should be the optimal value under the scenario of food selection.",
    "ground_truth": 40.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define the cost coefficients\ncosts = {\n    'Eggs': 4,\n    'Grains': 3,\n    'Berries': 2,\n    'Nuts': 4,\n    'Salmon': 9,\n    'Vegetables': 3,\n    'Rice': 6,\n    'Meat': 6\n}\n\n# Define the nutritional content for protein, carbohydrates, and calories\nprotein_content = {\n    'Eggs': 2,\n    'Grains': 7,\n    'Berries': 6,\n    'Nuts': 16,\n    'Salmon': 20,\n    'Vegetables': 6,\n    'Rice': 6,\n    'Meat': 5\n}\n\ncarb_content = {\n    'Eggs': 4,\n    'Grains': 9,\n    'Berries': 18,\n    'Nuts': 3,\n    'Salmon': 11,\n    'Vegetables': 27,\n    'Rice': 30,\n    'Meat': 1\n}\n\ncalorie_content = {\n    'Eggs': 282,\n    'Grains': 104,\n    'Berries': 71,\n    'Nuts': 116,\n    'Salmon': 175,\n    'Vegetables': 132,\n    'Rice': 251,\n    'Meat': 74\n}\n\n# Define the minimum nutritional requirements\nmin_protein = 84\nmin_carbs = 195\nmin_calories = 1941\n\n# Add variables for each food item\nfood_items = costs.keys()\nvariables = model.addVars(food_items, lb=0, vtype=GRB.INTEGER, name=\"x\")\n\n# Set the objective to minimize cost\nmodel.setObjective(gp.quicksum(costs[i] * variables[i] for i in food_items), GRB.MINIMIZE)\n\n# Add constraints for protein, carbohydrates, and calories\nmodel.addConstr(gp.quicksum(protein_content[i] * variables[i] for i in food_items) >= min_protein, \"ProteinConstraint\")\nmodel.addConstr(gp.quicksum(carb_content[i] * variables[i] for i in food_items) >= min_carbs, \"CarbConstraint\")\nmodel.addConstr(gp.quicksum(calorie_content[i] * variables[i] for i in food_items) >= min_calories, \"CalorieConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E020",
    "description": "Imagine you're a dietitian crafting a meal plan for someone with specific nutritional goals. The challenge is not just to meet these nutritional needs but to do so in the most cost-effective way possible. The individual requires a precise amount of protein, carbohydrates, and calories each day, but the budget is tight, making it crucial to minimize the cost of the meal plan.\n\nYou have a list of eight food items to choose from, each with distinct nutritional content and associated cost:\n\n- Food_1: A modest source of protein and carbs with 1 gram of protein, 4 grams of carbohydrates, and 93 calories at a cost of $6.\n- Food_2: Rich in protein with 18 grams of protein, 2 grams of carbohydrates, and 219 calories, priced at $4.\n- Food_3: A balanced choice providing 19 grams of protein, 26 grams of carbs, and 155 calories for $4.\n- Food_4: High in protein with 19 grams of protein, 10 grams of carbs, and 105 calories, costing $3.\n- Food_5: Carb-heavy with 3 grams of protein, 24 grams of carbohydrates, and 255 calories at just $2.\n- Food_6: A good mix with 8 grams of protein, 26 grams of carbs, and 182 calories for $7.\n- Food_7: Impressive protein and carb content with 15 grams of protein, 27 grams of carbohydrates, and 173 calories, all for $3.\n- Food_8: Carb-rich with 3 grams of protein, 30 grams of carbohydrates, and 191 calories, also at $3.\n\nThe daily dietary requirements for the individual are:\n\n- Protein: At least 98 grams\n- Carbohydrates: At least 113 grams\n- Calories: At least 1768\n\nWith these food options and nutritional needs in mind, what is the minimum cost required to meet the daily protein, carbohydrate, and calorie requirements?",
    "ground_truth": 24.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DietOptimization\")\n\n# Parameters\nprotein_content = [1, 18, 19, 19, 3, 8, 15, 3]\ncarb_content = [4, 2, 26, 10, 24, 26, 27, 30]\ncalorie_content = [93, 219, 155, 105, 255, 182, 173, 191]\ncost = [6, 4, 4, 3, 2, 7, 3, 3]\nprotein_requirement = 98\ncarb_requirement = 113\ncalorie_requirement = 1768\n\n# Variables\nx = model.addVars(8, name=\"x\", lb=0, vtype=GRB.INTEGER)\n\n# Objective\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in range(8)), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(protein_content[i] * x[i] for i in range(8)) >= protein_requirement, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carb_content[i] * x[i] for i in range(8)) >= carb_requirement, \"CarbRequirement\")\nmodel.addConstr(gp.quicksum(calorie_content[i] * x[i] for i in range(8)) >= calorie_requirement, \"CalorieRequirement\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E025",
    "description": "Imagine you're on a mission to optimize your daily meal plan. You're aiming to fulfill your daily nutritional intake while keeping your expenses as low as possible. In front of you, you have a selection of nine different food items: Beef, Pasta, Broccoli, Chicken, Apple, Pork, Lentils, Eggs, and Cheese. Each of these foods has its own cost, protein, carbohydrate, and calorie content.\n\nLet's take a look at the nutritional details and price of each food item:\n\n- Beef: For a cost of $5, serves you with 18 grams of protein, 13 grams of carbohydrates, and 233 calories. \n- Pasta: Comes at $6, but it provides 2 grams of protein, 25 grams of carbohydrates, and 251 calories. \n- Broccoli: Costs $5, and gives 7 grams of protein, 30 grams of carbohydrates, and 191 calories. \n- Chicken: Offers 20 grams of protein, 16 grams of carbohydrates, and 231 calories at a cost of $4. \n- Apple: At $1, provides 5 grams of protein, 6 grams of carbohydrates, and 111 calories. \n- Pork: Priced at $6, gives you 13 grams of protein, 9 grams of carbohydrates, and 275 calories. \n- Lentils: Costing $1, it provides 15 grams of protein, 18 grams of carbohydrates, and 99 calories. \n- Eggs: For $2, they serve 20 grams of protein, 18 grams of carbohydrates, and 210 calories. \n- Cheese: At $7, it provides 9 grams of protein, 14 grams of carbohydrates, and 74 calories. \n\nYour daily dietary requirements are to consume at least 68 grams of protein, 151 grams of carbohydrates, and 1900 calories. The question before you is: How can you meet these nutritional targets in the most cost-effective way using the food options provided? In other words, what is the least amount of money you need to spend in order to fulfill your daily nutritional requirements?",
    "ground_truth": 18.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nfoods = ['Beef', 'Pasta', 'Broccoli', 'Chicken', 'Apple', 'Pork', 'Lentils', 'Eggs', 'Cheese']\n\n# Parameters\ncosts = {'Beef': 5, 'Pasta': 6, 'Broccoli': 5, 'Chicken': 4, 'Apple': 1, 'Pork': 6, 'Lentils': 1, 'Eggs': 2, 'Cheese': 7}\nproteins = {'Beef': 18, 'Pasta': 2, 'Broccoli': 7, 'Chicken': 20, 'Apple': 5, 'Pork': 13, 'Lentils': 15, 'Eggs': 20, 'Cheese': 9}\ncarbohydrates = {'Beef': 13, 'Pasta': 25, 'Broccoli': 30, 'Chicken': 16, 'Apple': 6, 'Pork': 9, 'Lentils': 18, 'Eggs': 18, 'Cheese': 14}\ncalories = {'Beef': 233, 'Pasta': 251, 'Broccoli': 191, 'Chicken': 231, 'Apple': 111, 'Pork': 275, 'Lentils': 99, 'Eggs': 210, 'Cheese': 74}\n\n# Nutritional requirements\nP_min = 68\nC_min = 151\nK_min = 1900\n\n# Decision variables\nx = model.addVars(foods, name=\"x\", lb=0, vtype=GRB.INTEGER)\n\n# Objective function\nmodel.setObjective(gp.quicksum(costs[f] * x[f] for f in foods), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(proteins[f] * x[f] for f in foods) >= P_min, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carbohydrates[f] * x[f] for f in foods) >= C_min, \"CarbohydrateRequirement\")\nmodel.addConstr(gp.quicksum(calories[f] * x[f] for f in foods) >= K_min, \"CalorieRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E024",
    "description": "Imagine you're on a mission to plan your meals to meet specific dietary needs for the day, but you also want to keep your spending within limits. You have four types of food items on your list: Chicken, Rice, Broccoli, and Eggs. Each of these foods has its own nutritional value in terms of protein, carbohydrates, and calories, and also comes at a different price.\n\nHere's a quick overview of what each food item offers and how much they cost:\n\n- Chicken: Provides 17 grams of protein, 6 grams of carbohydrates, and 94 calories for $7.\n- Rice: Offers 20 grams of protein, 13 grams of carbohydrates, and 74 calories for $10.\n- Broccoli: Comes with 3 grams of protein, a high 25 grams of carbohydrates, and 73 calories for $9.\n- Eggs: Are a budget-friendly option providing 18 grams of protein, 20 grams of carbohydrates, and 119 calories for only $2.\n\nYou need to ensure that your daily intake should consist of at least 84 grams of protein, 117 grams of carbohydrates, and 1554 calories. Your task is to figure out the most cost-effective way to meet these nutritional targets with the available food options. So, what is the minimal cost you need to incur to satisfy your dietary requirements? Remember, your response should indicate the optimal cost value, under the scenario of food selection.",
    "ground_truth": 28.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlanning\")\n\n# Define variables\nx_chicken = model.addVar(vtype=GRB.INTEGER, name=\"x_chicken\")\nx_rice = model.addVar(vtype=GRB.INTEGER, name=\"x_rice\")\nx_broccoli = model.addVar(vtype=GRB.INTEGER, name=\"x_broccoli\")\nx_eggs = model.addVar(vtype=GRB.INTEGER, name=\"x_eggs\")\n\n# Set objective\nmodel.setObjective(\n    7 * x_chicken + 10 * x_rice + 9 * x_broccoli + 2 * x_eggs, GRB.MINIMIZE\n)\n\n# Add constraints\nmodel.addConstr(17 * x_chicken + 20 * x_rice + 3 * x_broccoli + 18 * x_eggs >= 84, \"Protein\")\nmodel.addConstr(6 * x_chicken + 13 * x_rice + 25 * x_broccoli + 20 * x_eggs >= 117, \"Carbohydrates\")\nmodel.addConstr(94 * x_chicken + 74 * x_rice + 73 * x_broccoli + 119 * x_eggs >= 1554, \"Calories\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E034",
    "description": "Imagine you're a dietitian, tasked with crafting a healthy and balanced meal plan for a client on a budget. The tricky part is that you must choose from a list of nine food items, each with their own cost and nutritional values for protein, carbohydrates, and calories.\n\nHere's the rundown of what each food item provides and its cost:\n\n- Chicken Breast: Delivers 17 grams of protein, 28 grams of carbohydrates, and 136 calories for $3.\n- Tofu: Yields 15 grams of protein, 11 grams of carbohydrates, and 198 calories for $2.\n- Brown Rice: Offers just 1 gram of protein, 11 grams of carbohydrates, and 93 calories for $2.\n- Salmon: Gives you 11 grams of protein, 3 grams of carbohydrates, and a hefty 269 calories for $6.\n- Greek Yogurt: Provides 15 grams of protein, 27 grams of carbohydrates, and 121 calories for $6.\n- Steak: Comes with 12 grams of protein, 3 grams of carbohydrates, and 80 calories for a steeper price of $10.\n- Avocado: Provides 4 grams of protein, 8 grams of carbohydrates, and a whopping 300 calories for $7.\n- Eggs: Offer 16 grams of protein, 25 grams of carbohydrates, and 99 calories for $5.\n- Quinoa: Comes with 11 grams of protein, 20 grams of carbohydrates, and 87 calories for just $2.\n\nYour goal is to make sure your client gets at least 72 grams of protein, 158 grams of carbohydrates, and 1896 calories from the combination of foods you choose. But you also need to keep costs to a minimum. What is the least amount of money you would need to spend to meet all of these nutritional targets from these nine food options?",
    "ground_truth": 24.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlanOptimization\")\n\n# Parameters\nprotein = [17, 15, 1, 11, 15, 12, 4, 16, 11]\ncarbohydrates = [28, 11, 11, 3, 27, 3, 8, 25, 20]\ncalories = [136, 198, 93, 269, 121, 80, 300, 99, 87]\ncosts = [3, 2, 2, 6, 6, 10, 7, 5, 2]\n\n# Nutritional requirements\nprotein_req = 72\ncarbohydrates_req = 158\ncalories_req = 1896\n\n# Number of food items\nn_items = len(protein)\n\n# Variables\nx = model.addVars(n_items, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: Minimize total cost\nmodel.setObjective(gp.quicksum(costs[i] * x[i] for i in range(n_items)), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in range(n_items)) >= protein_req, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carbohydrates[i] * x[i] for i in range(n_items)) >= carbohydrates_req, \"CarbohydratesRequirement\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in range(n_items)) >= calories_req, \"CalorieRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "F165",
    "description": "Jordan is a chef. He wants to design a diet consisting of Kebabs and Rice.  Assume that each serving of Rice costs $3 and contains 300 calories and 4.5 grams of protein. Assume that each serving of Kebab costs $2 and contains 200 calories and 4 grams of protein. He's interested in spending as little money as possible but he wants to ensure that his meals have at least 2200 calories and at least 30 grams of protein per day. Formulate a linear programming problem that will help minimize the cost of the diet.",
    "ground_truth": 22.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nc_R = 3  # Cost per serving of Rice\nc_K = 2  # Cost per serving of Kebab\ncalories_R = 300  # Calories per serving of Rice\ncalories_K = 200  # Calories per serving of Kebab\nprotein_R = 4.5  # Protein per serving of Rice\nprotein_K = 4  # Protein per serving of Kebab\nmin_calories = 2200  # Minimum total daily calories required\nmin_protein = 30  # Minimum total daily protein required\n\n# Variables\nx_R = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_R\")\nx_K = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_K\")\n\n# Objective: Minimize cost\nmodel.setObjective(c_R * x_R + c_K * x_K, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(calories_R * x_R + calories_K * x_K >= min_calories, \"calories\")\nmodel.addConstr(protein_R * x_R + protein_K * x_K >= min_protein, \"protein\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "F028",
    "description": "A body builder buys pre prepared meals, a turkey dinner and a tuna salad sandwich. The turkey dinner contains 20 grams of protein, 30 grams of carbs, and 12 grams of fat. The tuna salad sandwich contains 18 grams of protein, 25 grams of carbs, and 8 grams of fat. The bodybuilder wants to get at least 150 grams of protein and 200 grams of carbs. In addition because the turkey dinner is expensive, at most 40% of the meals should be turkey dinner. How many of each meal should he eat if he wants to minimize his fat intake?",
    "ground_truth": 72.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\nmodel = gp.Model(\"MinimizeFatIntake\")\n\n# Parameters\np_d = 20  # Protein in grams per turkey dinner\nc_d = 30  # Carbs in grams per turkey dinner\nf_d = 12  # Fat in grams per turkey dinner\np_s = 18  # Protein in grams per tuna salad sandwich\nc_s = 25  # Carbs in grams per tuna salad sandwich\nf_s = 8   # Fat in grams per tuna salad sandwich\nP = 150   # Minimum required grams of protein\nC = 200   # Minimum required grams of carbs\nalpha = 0.4  # Maximum proportion of turkey dinners\n\n# Decision variables\nx_d = model.addVar(vtype=GRB.INTEGER, name=\"turkey_dinners\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"tuna_salad_sandwiches\")\n\n# Objective: Minimize fat intake\nmodel.setObjective(f_d * x_d + f_s * x_s, GRB.MINIMIZE)\n\n# Constraints\n# (C1) Protein constraint\nmodel.addConstr(p_d * x_d + p_s * x_s >= P, \"ProteinRequirement\")\n\n# (C2) Carbs constraint\nmodel.addConstr(c_d * x_d + c_s * x_s >= C, \"CarbsRequirement\")\n\n# (C3) Proportion of turkey dinners\nmodel.addConstr(x_d <= alpha * (x_d + x_s), \"TurkeyDinnerProportion\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "F002",
    "description": "A man on a strict diet only drinks meal replacement drinks from two brands, alpha and omega. The alpha brand drink contains 30 grams of protein, 20 grams of sugar, and 350 calories per bottle. The omega brand drink contains 20 grams of protein, 15 grams of sugar, and 300 calories per bottle. The man wants to get at least 100 grams of protein and 2000 calories. In addition, because the omega brand drink contains tiny amounts of caffeine, at most 35% of the drink should be omega brand. How many bottles of each should he drink to minimize his sugar intake?",
    "ground_truth": 110.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealReplacementOptimization\")\n\n# Parameters\np_a, s_a, c_a = 30, 20, 350\np_o, s_o, c_o = 20, 15, 300\nP, C, alpha_max = 100, 2000, 0.35\n\n# Variables\nx_a = model.addVar(vtype=GRB.INTEGER, name=\"x_a\")  # Number of alpha brand drinks\nx_o = model.addVar(vtype=GRB.INTEGER, name=\"x_o\")  # Number of omega brand drinks\n\n# Objective: Minimize sugar intake\nmodel.setObjective(s_a * x_a + s_o * x_o, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(p_a * x_a + p_o * x_o >= P, \"ProteinConstraint\")\nmodel.addConstr(c_a * x_a + c_o * x_o >= C, \"CalorieConstraint\")\nmodel.addConstr(x_o <= alpha_max * (x_a + x_o), \"ProportionConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "F116",
    "description": "A macro-counting fitness guru only eats salmon and eggs. Each bowl of salmon contains 300 calories, 15 grams of protein, and 80 mg of sodium. Each bowl of eggs contains 200 calories, 8 grams of protein, and 20 mg of sodium. Since the fitness guru has a limit to how many eggs he would like to eat, at most 40% of his meals can be eggs. The fitness guru needs to eat at least 2000 calories and 90 grams of protein. How many of each type of meal should he eat to minimize his sodium intake?",
    "ground_truth": 460.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nc_s = 300  # calories per bowl of salmon\nc_e = 200  # calories per bowl of eggs\np_s = 15   # grams of protein per bowl of salmon\np_e = 8    # grams of protein per bowl of eggs\ns_s = 80   # mg of sodium per bowl of salmon\ns_e = 20   # mg of sodium per bowl of eggs\nC = 2000   # minimum required calories\nP = 90     # minimum required protein\nalpha = 0.4 # maximum fraction of meals that can be eggs\n\n# Variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")  # Number of bowls of salmon\nx_e = model.addVar(vtype=GRB.INTEGER, name=\"x_e\")  # Number of bowls of eggs\n\n# Objective: Minimize sodium intake\nmodel.setObjective(s_s * x_s + s_e * x_e, GRB.MINIMIZE)\n\n# Constraints\n# Calorie constraint\nmodel.addConstr(c_s * x_s + c_e * x_e >= C, \"CalorieConstraint\")\n\n# Protein constraint\nmodel.addConstr(p_s * x_s + p_e * x_e >= P, \"ProteinConstraint\")\n\n# Egg meal fraction constraint\nmodel.addConstr(x_e <= alpha * (x_s + x_e), \"EggFractionConstraint\")\n\n# Non-negativity constraints are implicit in integer variable declaration\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "F015",
    "description": "A travelling salesman only eats ramen and fries. Each pack of ramen contains 400 calories, 20 grams of protein, and 100 mg of sodium. Each pack of fries contains 300 calories, 10 grams of protein, and 75 mg of sodium. Since fries are easier to eat while driving, at most 30% of his meals can be ramen. The salesman wants to ensure he eats at least 3000 calories and 80 grams of protein. How many of each should he eat to minimize his sodium intake?",
    "ground_truth": 750.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nc_r = 400\np_r = 20\ns_r = 100\nc_f = 300\np_f = 10\ns_f = 75\nC = 3000\nP = 80\nalpha = 0.3\n\n# Variables\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")\nx_f = model.addVar(vtype=GRB.INTEGER, name=\"x_f\")\n\n# Objective\nmodel.setObjective(s_r * x_r + s_f * x_f, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(c_r * x_r + c_f * x_f >= C, \"CalorieConstraint\")\nmodel.addConstr(p_r * x_r + p_f * x_f >= P, \"ProteinConstraint\")\nmodel.addConstr(x_r <= alpha * (x_r + x_f), \"RamenFractionConstraint\")\nmodel.addConstr(x_r >= 0, \"NonNegativityRamen\")\nmodel.addConstr(x_f >= 0, \"NonNegativityFries\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "A026",
    "description": "Mark has 50 acres of land available to grow potatoes and cucumbers that he sells at a farmers' market. He must grow at least 12 acres of potatoes and 15 acres of cucumbers to meet his contract. Mark prefers to grow more cucumbers than potatoes, but he only has enough resources to grow at most twice the amount of cucumbers as potatoes. If the profit per acre of potatoes is $500 and the profit per acre of cucumbers is $650, how many acres of each should he grow to maximize his profit? What is that profit?",
    "ground_truth": 30000.0,
    "formulation": null,
    "correct_program": "def optimize_crops():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Crop_Optimization\")\n\n    # Decision variables\n    # Acres of potatoes\n    x = m.addVar(name=\"Potatoes\", lb=0)\n    # Acres of cucumbers\n    y = m.addVar(name=\"Cucumbers\", lb=0)\n\n    # Set the objective: maximize profit\n    profit = 500 * x + 650 * y\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(x + y <= 50, name=\"Total_land\")\n    m.addConstr(x >= 12, name=\"Min_potatoes\")\n    m.addConstr(y >= 15, name=\"Min_cucumbers\")\n    m.addConstr(y <= 2 * x, name=\"Cucumber_limit\")\n    m.addConstr(y >= x, name=\"Preference_cucumbers_more_or_equal_potatoes\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage \nif __name__ == \"__main__\":\n    max_profit = optimize_crops()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A018",
    "description": "A suspicious factory has 100 sq. feet of space. It makes bootleg phones and laptops. Phones require 2 hours of labor and cost $12 for each sq. foot of space allocated for phone production (cost of electricity and equipment). Laptops require 3 hours of labor and cost $15 for each sq. foot of space allocated for laptop production. Phones produce a net revenue of $50 per sq. foot while laptops produce a net revenue of $70 per sq. foot. The factory wants to spend at most $5000 and 2000 hours of labor. What is the optimal factory layout to maximize revenue?",
    "ground_truth": 7000.0,
    "formulation": null,
    "correct_program": "def optimize_factory_layout(space_limit=100, max_cost=5000, max_labor=2000):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Factory_Layout_Maximize_Revenue\")\n\n    # Decision variables: space allocated to phones and laptops\n    x = model.addVar(name=\"Phones_Space\", lb=0)\n    y = model.addVar(name=\"Laptops_Space\", lb=0)\n\n    # Set the objective: maximize total revenue\n    model.setObjective(50 * x + 70 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Space constraint\n    model.addConstr(x + y <= space_limit, name=\"SpaceLimit\")\n    # Cost constraint\n    model.addConstr(12 * x + 15 * y <= max_cost, name=\"CostLimit\")\n    # Labor constraint\n    model.addConstr(2 * x + 3 * y <= max_labor, name=\"LaborLimit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal revenue\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_revenue = optimize_factory_layout()\n    if max_revenue is not None:\n        print(f\"Maximum Revenue: {max_revenue}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A175",
    "description": "A milk tea shop owner would like to sell two different milk teas: black milk tea and matcha milk tea. Each contains both milk and honey. A bottle of black milk tea contains 600 grams of milk and 10 grams of honey, whereas a bottle of matcha milk tea contains 525 grams of milk and 5 grams of honey. The profit from each bottle of black milk tea sold is $7.5 and the profit from each bottle of matcha milk tea sold is $5. If his total production must not exceed his available stock of 30000 grams of milk and 500 grams of honey, how many bottles of each type of milk tea should be made to maximize profits?",
    "ground_truth": 375.0,
    "formulation": null,
    "correct_program": "def optimize_milk_tea_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MilkTeaOptimization\")\n\n    # Decision variables: number of bottles of black and matcha milk tea\n    x = m.addVar(vtype=GRB.INTEGER, name=\"BlackMilkTea\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"MatchaMilkTea\")\n\n    # Set the objective: maximize profit\n    m.setObjective(7.5 * x + 5 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Milk constraint\n    m.addConstr(600 * x + 525 * y <= 30000, \"MilkConstraint\")\n    # Honey constraint\n    m.addConstr(10 * x + 5 * y <= 500, \"HoneyConstraint\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_milk_tea_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Food and Beverage"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A173",
    "description": "An appliance company sells and installs refrigerators and stoves. Each refrigerator takes 60 minutes of mover time and 20 minutes of setup time. Each stove takes 45 minutes of mover time and 25 minutes of setup time. The company has available 20000 minutes of mover time and 13000 minutes of setup time. If the profit per refrigerator is $400 and the profit per stove is $260, how many of each should they sell in order to maximize profit?",
    "ground_truth": 133200.0,
    "formulation": null,
    "correct_program": "def optimize_appliances():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Appliance_Optimization\")\n\n    # Decision variables: number of refrigerators and stoves\n    # Both are integers and non-negative\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Refrigerators\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Stoves\", lb=0)\n\n    # Set the objective: maximize profit\n    m.setObjective(400 * x + 260 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(60 * x + 45 * y <= 20000, \"MoverTime\")\n    m.addConstr(20 * x + 25 * y <= 13000, \"SetupTime\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_appliances()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A007",
    "description": "An artisan makes two types of terracotta jars: a thin jar and a stubby jar. Each thin jar requires 50 minutes of shaping time and 90 minutes of baking time. Each stubby jar requires 30 minutes of shaping time and 150 minutes of baking time. Per week, there are 3000 minutes available for shaping and 4000 minutes available for baking. The profit per thin jar is $5 and the profit per stubby jar is $9. How many jars of each type should the artisan make to maximize profit?",
    "ground_truth": 239.0,
    "formulation": null,
    "correct_program": "def optimize_jar_production(shaping_time=3000, baking_time=4000,\n                            profit_thin=5, profit_stubby=9,\n                            shaping_time_thin=50, baking_time_thin=90,\n                            shaping_time_stubby=30, baking_time_stubby=150):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Terracotta_Jars_Optimization\")\n    \n    # Decision variables: number of thin and stubby jars\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Thin_Jars\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Stubby_Jars\")\n    \n    # Set objective: maximize profit\n    m.setObjective(profit_thin * x + profit_stubby * y, GRB.MAXIMIZE)\n    \n    # Add constraints\n    m.addConstr(shaping_time_thin * x + shaping_time_stubby * y <= shaping_time, \"Shaping_Time\")\n    m.addConstr(baking_time_thin * x + baking_time_stubby * y <= baking_time, \"Baking_Time\")\n    m.addConstr(x >= 0, \"NonNeg_x\")\n    m.addConstr(y >= 0, \"NonNeg_y\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_jar_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A033",
    "description": "A bakery bakes bagels and croissants. A batch of bagels can be made using 2 hours of oven time and 0.25 hours of pastry chef time. A batch of croissants is more complicated, so while they take 1 hour of oven time, they take 2 hours of pastry chef time. In a day, the bakery has at most 70 hours available for the oven and 32 pastry chef hours available. Using all the available capacity, what is the maximum profit the bakery can generate assuming the profit per batch is $20 and $40 respectively for a batch of bagels and a batch of croissants.",
    "ground_truth": 1072.0,
    "formulation": null,
    "correct_program": "def optimize_bakery_profit(oven_hours=70, pastry_hours=32,\n                           profit_bagels=20, profit_croissants=40,\n                           max_bagels=None, max_croissants=None):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"BakeryOptimization\")\n    \n    # Decision variables: number of batches of bagels and croissants\n    x = model.addVar(name=\"Bagels\")\n    y = model.addVar(name=\"Croissants\")\n    \n    # Set the objective: maximize profit\n    model.setObjective(profit_bagels * x + profit_croissants * y, GRB.MAXIMIZE)\n    \n    # Add oven time constraint\n    model.addConstr(2 * x + y <= oven_hours, \"OvenTime\")\n    \n    # Add pastry chef time constraint\n    model.addConstr(0.25 * x + 2 * y <= pastry_hours, \"PastryTime\")\n    \n    # Optional: add upper bounds if specified\n    if max_bagels is not None:\n        model.addConstr(x <= max_bagels, \"MaxBagels\")\n    if max_croissants is not None:\n        model.addConstr(y <= max_croissants, \"MaxCroissants\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_bakery_profit()\n    if max_profit is not None:\n        print(f\"Maximum profit from bakery operations: ${max_profit:.2f}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A190",
    "description": "A taco stand sells regular tacos and deluxe tacos with extra meat. The stand makes x1 regular tacos at a profit of $2.50 each and x2 deluxe tacos at a profit of $3.55 each (x1 and x2 are unknown variables both greater than or equal to 0). There is a demand for at most 50 regular tacos and at most 40 deluxe tacos. The stand only has enough supplies to sell at most 70 tacos of either type. How many of each taco should the stand make to maximize profit?",
    "ground_truth": 217.0,
    "formulation": null,
    "correct_program": "def optimize_taco_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Taco_Stand_Profit_Maximization\")\n\n    # Decision variables\n    x1 = m.addVar(name=\"Regular_Tacos\", lb=0)\n    x2 = m.addVar(name=\"Deluxe_Tacos\", lb=0)\n\n    # Set objective: maximize profit\n    profit = 2.50 * x1 + 3.55 * x2\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(x1 <= 50, name=\"Demand_Regular\")\n    m.addConstr(x2 <= 40, name=\"Demand_Deluxe\")\n    m.addConstr(x1 + x2 <= 70, name=\"Total_Tacos\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_taco_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit:.2f}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A025",
    "description": "A food truck owner can spend at most $20000 on mangos and guavas. A mango costs the food truck owner $5 and a guava costs him $3. Spices are added and each mango is sold for a profit of $3 while each guava is sold for a profit of $4. The owner estimates that at least 100 mangos but at the most 150 are sold each month. He also estimates that the number of guavas sold is at most a third of the mangos sold. How many mangos and guavas should be sold in order to maximize the profit?",
    "ground_truth": 650.0,
    "formulation": null,
    "correct_program": "def optimize_food_truck_profit(\n    max_budget=20000,\n    min_mangos=100,\n    max_mangos=150,\n    mango_cost=5,\n    guava_cost=3,\n    mango_profit=3,\n    guava_profit=4\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"FoodTruckOptimization\")\n\n    # Decision variables\n    x = model.addVar(vtype=GRB.INTEGER, lb=min_mangos, ub=max_mangos, name=\"mangos\")\n    y = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"guavas\")\n\n    # Set objective: maximize profit\n    model.setObjective(mango_profit * x + guava_profit * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Budget constraint\n    model.addConstr(mango_cost * x + guava_cost * y <= max_budget, \"budget\")\n    # Guava sales relative to mangos\n    model.addConstr(y <= (1/3) * x, \"guava_mango_ratio\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_food_truck_profit()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A020",
    "description": "A car manufacturer makes two versions of the same car, a regular model and a premium model. They make x1 regular models per day and x2 premium models per day. The profit per regular model is $5000 and the profit per premium model is $8500 (x1 and x2 are unknown values both greater than or equal to 0). The daily demand for these cars is limited to and most 8 regular models and 6 premium models. In addition, the manufacturer can make a maximum of 12 cars of either type per day. How many cars of each model should the manufacturer make in order to maximize profit?",
    "ground_truth": 81000.0,
    "formulation": null,
    "correct_program": "def optimize_car_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Car_Production_Maximize_Profit\")\n\n    # Decision variables: number of regular and premium cars\n    # Assuming production quantities are continuous; set vtype=GRB.CONTINUOUS\n    x1 = m.addVar(name=\"Regular\", vtype=GRB.CONTINUOUS, lb=0)\n    x2 = m.addVar(name=\"Premium\", vtype=GRB.CONTINUOUS, lb=0)\n\n    # Set the objective: maximize profit\n    profit_regular = 5000\n    profit_premium = 8500\n    m.setObjective(profit_regular * x1 + profit_premium * x2, GRB.MAXIMIZE)\n\n    # Add demand constraints\n    m.addConstr(x1 <= 8, name=\"Demand_Regular\")\n    m.addConstr(x2 <= 6, name=\"Demand_Premium\")\n\n    # Add production capacity constraint\n    m.addConstr(x1 + x2 <= 12, name=\"Total_Capacity\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit value\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_car_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A004",
    "description": "A company is deciding where to promote their product. Some options include z-tube, soorchle engine, and wassa advertisements. The cost for each option and the number of viewers they each attract is given. On z-tube, each ad costs $1000 and attracts 400,000 viewers. On soorchle, each ad costs $200 and attracts 5,000 viewers. On wassa, each ad costs $100 and attracts 3,000 viewers. Soorchle limits the number of advertisements from a single company to fifteen. Moreover, in order to balance the advertising among the three types of media, at most a third of the total number of advertisements should occur on wassa. And at least 5% should occur on z-tube. The weekly advertising budget is $10000. How many advertisements should be run in each of the three types of media to maximize the total audience?",
    "ground_truth": 4000000.0,
    "formulation": null,
    "correct_program": "def optimize_ad_campaign(\n    budget=10000,\n    max_soorchle=15,\n    min_z_ratio=0.05,\n    max_wassa_ratio=1/3\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Advertising_Optimization\")\n\n    # Decision variables: number of ads for each media type\n    x_z = model.addVar(vtype=GRB.INTEGER, name=\"z_tube\")\n    x_s = model.addVar(vtype=GRB.INTEGER, name=\"soorchle\")\n    x_w = model.addVar(vtype=GRB.INTEGER, name=\"wassa\")\n\n    # Set objective: maximize total viewers\n    model.setObjective(\n        400000 * x_z + 5000 * x_s + 3000 * x_w,\n        GRB.MAXIMIZE\n    )\n\n    # Add constraints\n    # Budget constraint\n    model.addConstr(1000 * x_z + 200 * x_s + 100 * x_w <= budget, \"Budget\")\n    # Soorchle limit\n    model.addConstr(x_s <= max_soorchle, \"SoorchleLimit\")\n    # Wassa at most a third of total ads\n    model.addConstr(2 * x_w <= x_z + x_s, \"WassaRatio\")\n    # Z-tube at least 5% of total ads\n    # 19 * x_z >= x_s + x_w\n    model.addConstr(19 * x_z >= x_s + x_w, \"ZMinRatio\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_viewers = model.objVal\n        return total_viewers\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_viewers = optimize_ad_campaign()\n    if max_viewers is not None:\n        print(f\"Maximum Total Viewers: {max_viewers}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Marketing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A030",
    "description": "A company sells custom scooters and bikes for customers. The profit per scooter is $200 and the profit per bike is $300. Each product requires time with the design team and engineering team. Each scooter needs 2 hours with the design team and 3 hours with the engineering team. Each bike needs 4 hours with the design team and 5 hours with the engineering team. Per month, there are 5000 hours available on the design team and 6000 hours available on the engineering team. How many of each should the company make per month to maximize profit?",
    "ground_truth": 400000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef optimize_production():\n    # Create a new model\n    model = gp.Model(\"ProductionOptimization\")\n\n    # Add decision variables\n    # The original model does not specify integrality, so use continuous variables (default)\n    x = model.addVar(name=\"Scooters\", lb=0)\n    y = model.addVar(name=\"Bikes\", lb=0)\n\n    # Set the objective function\n    model.setObjective(200 * x + 300 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    model.addConstr(2 * x + 4 * y <= 5000, name=\"Constraint1\")\n    model.addConstr(3 * x + 5 * y <= 6000, name=\"Constraint2\")\n\n    # Optimize the model\n    model.optimize()\n    return model.objVal if model.status == GRB.OPTIMAL else None\n\nprint(optimize_production())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A174",
    "description": "An office company makes desks and drawers. Each desk requires 40 minutes of assembly and 20 minutes of sanding. Each drawer requires 30 minutes of assembly and 10 minutes of sanding. The company has available 4000 minutes for assembly and 3500 minutes for sanding. If the profit per desk is $100 and the profit per drawer is $90, how many of each should the company make to maximize profit?",
    "ground_truth": 11980.0,
    "formulation": null,
    "correct_program": "def optimize_desks_drawers():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Desks_and_Drawers\")\n\n    # Decision variables: number of desks and drawers\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Desks\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Drawers\")\n\n    # Set the objective: maximize profit\n    m.setObjective(100 * x + 90 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(40 * x + 30 * y <= 4000, \"AssemblyTime\")\n    m.addConstr(20 * x + 10 * y <= 3500, \"SandingTime\")\n    m.addConstr(x >= 0, \"NonNegDesks\")\n    m.addConstr(y >= 0, \"NonNegDrawers\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_desks_drawers()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A011",
    "description": "A souvenir shop makes wooden elephants and tigers with plastic ornaments. Each elephant requires 50 grams of wood and 20 grams of plastic. Each tiger requires 40 grams of wood and 30 grams of plastic. In a week, 5000 grams of wood and 4000 grams of plastic are available. The profit per elephant sold is $5 and the profit per tiger sold is $4. How many of each should be made in order to maximize profit?",
    "ground_truth": 500.0,
    "formulation": null,
    "correct_program": "def optimize_souvenirs():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Souvenir_Production\")\n\n    # Decision variables: number of elephants and tigers\n    # Both are integers and non-negative\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Elephants\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Tigers\", lb=0)\n\n    # Set the objective: maximize profit\n    m.setObjective(5 * x + 4 * y, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    m.addConstr(50 * x + 40 * y <= 5000, \"WoodConstraint\")\n    m.addConstr(20 * x + 30 * y <= 4000, \"PlasticConstraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_souvenirs()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A182",
    "description": "Maple Oil processes three types of crude oil: light oil, non-sticky oil and heavy oil. Each tank of light oil produces a net revenue of $550, each tank of non-sticky oil produces a net revenue of $750, and each tank of heavy oil produces a net revenue of $950. To process a tank of light oil, 3 units of compound A and 3 units of compound B are required. To process a tank of non-sticky oil, 6 units of compound A and 2 units of compound B are required. To process a tank of heavy oil, 9 units of compound A and 3 units of compound B are required. Currently the company has 250 units of compound A and 150 units of compound B to process. How many full or partial tanks of each oil should the company process so that net revenue is maximized?",
    "ground_truth": 37083.333333333336,
    "formulation": null,
    "correct_program": "def optimize_crude_processing(\n    revenue_light=550,\n    revenue_non_sticky=750,\n    revenue_heavy=950,\n    compound_A_total=250,\n    compound_B_total=150\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"CrudeOilProcessing\")\n\n    # Decision variables: number of tanks processed for each oil type\n    x_L = model.addVar(name=\"LightOil\", lb=0)\n    x_N = model.addVar(name=\"NonStickyOil\", lb=0)\n    x_H = model.addVar(name=\"HeavyOil\", lb=0)\n\n    # Set the objective: maximize total revenue\n    model.setObjective(\n        revenue_light * x_L + revenue_non_sticky * x_N + revenue_heavy * x_H,\n        GRB.MAXIMIZE\n    )\n\n    # Add resource constraints\n    # Compound A constraint\n    model.addConstr(\n        3 * x_L + 6 * x_N + 9 * x_H <= compound_A_total,\n        name=\"CompoundA\"\n    )\n\n    # Compound B constraint\n    model.addConstr(\n        3 * x_L + 2 * x_N + 3 * x_H <= compound_B_total,\n        name=\"CompoundB\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_revenue = optimize_crude_processing()\n    if max_revenue is not None:\n        print(f\"Maximum Revenue: ${max_revenue}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A038",
    "description": "There are two processes, process A and process B, to plate a coin with gold. Process A requires 3 units of gold, 2 wires, and can plate 5 coins. Process B requires 5 units of gold, 3 wires, and can plate 7 coins. There are 500 units of gold and 300 wires available. How many processes of each type should be run to maximize the total number of coins that can be plated?",
    "ground_truth": 750.0,
    "formulation": null,
    "correct_program": "def optimize_coins(gold_available=500, wires_available=300):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Coin_Plation_Optimization\")\n\n    # Decision variables: number of processes A and B\n    x_A = model.addVar(vtype=GRB.INTEGER, name=\"Process_A\")\n    x_B = model.addVar(vtype=GRB.INTEGER, name=\"Process_B\")\n\n    # Set the objective: maximize total coins\n    model.setObjective(5 * x_A + 7 * x_B, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    model.addConstr(3 * x_A + 5 * x_B <= gold_available, \"GoldConstraint\")\n    model.addConstr(2 * x_A + 3 * x_B <= wires_available, \"WiresConstraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total number of coins\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_coins = optimize_coins()\n    if max_coins is not None:\n        print(f\"Maximum Total Coins: {max_coins}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A179",
    "description": "Forest Paper makes two types of products: graph paper and music paper. Each type of paper requires the use of two machines, a printing machine and a scanning machine. It takes 3 minutes on the printing machine and 5.5 minutes on the scanning machine to make a ream of graph paper. On the other hand, it takes 1.5 minutes on the printing machine and 3 minutes on the scanning machine to make a ream of music paper. Each machine is available for a maximum of 350 minutes per day. The company sells a package of graph paper at a profit of $4 and a package of music paper at a profit of $2.5. The company can sell all the paper it makes. How many reams of each type should the company produce in a day in order to maximize profit? What is that profit?",
    "ground_truth": 290.5,
    "formulation": null,
    "correct_program": "def optimize_paper_production(\n    profit_graph=4,\n    profit_music=2.5,\n    time_print_graph=3,\n    time_scan_graph=5.5,\n    time_print_music=1.5,\n    time_scan_music=3,\n    machine_time_limit=350\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Paper_Production_Maximize_Profit\")\n\n    # Decision variables: number of reams of each product\n    x = model.addVar(name=\"Graph_Paper\", lb=0, vtype=GRB.INTEGER)\n    y = model.addVar(name=\"Music_Paper\", lb=0, vtype=GRB.INTEGER)\n\n    # Set objective: maximize profit\n    model.setObjective(profit_graph * x + profit_music * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Printing machine constraint\n    model.addConstr(time_print_graph * x + time_print_music * y <= machine_time_limit, \"Printing_Time\")\n    # Scanning machine constraint\n    model.addConstr(time_scan_graph * x + time_scan_music * y <= machine_time_limit, \"Scanning_Time\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_paper_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A002",
    "description": "There is 1000 mg of gold available that is needed to make long and short cables. Long cables require 10 mg of gold while short cables require 7 mg of gold. Because of their compact size, at least 5 times the number of short cables are needed than the long cables. In addition, there needs to be at least 10 long cables made. If each long cable sold results in a $12 profit and each short cable sold results in a $5 profit, how many of each type of cable should be made to maximize profit?",
    "ground_truth": 819.0,
    "formulation": null,
    "correct_program": "def optimize_cable_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"CableProduction\")\n\n    # Decision variables\n    # Number of long cables\n    L = m.addVar(name=\"LongCables\", vtype=GRB.INTEGER, lb=10)\n    # Number of short cables\n    S = m.addVar(name=\"ShortCables\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: maximize profit\n    profit = 12 * L + 5 * S\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Gold constraint\n    m.addConstr(10 * L + 7 * S <= 1000, name=\"GoldLimit\")\n    # Ratio constraint\n    m.addConstr(S >= 5 * L, name=\"RatioConstraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage \nif __name__ == \"__main__\":\n    max_profit = optimize_cable_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A009",
    "description": "A bakery uses a stand-mixer and a slow bake oven to make bread and cookies. Each machine can run for at most 3000 hours per year. To bake a loaf of bread takes 1 hour in the stand mixer and 3 hours in the oven. A batch of cookies requires 0.5 hours in the mixer and 1 hour in the oven. The profit per loaf of bread is $5 and the profit per batch of cookies is $3. How should the bakery operate to maximize total profit?",
    "ground_truth": 9000.0,
    "formulation": null,
    "correct_program": "def optimize_bakery_production(\n    max_machine_hours=3000,\n    profit_bread=5,\n    profit_cookies=3,\n    bread_mixer_time=1,\n    cookies_mixer_time=0.5,\n    bread_oven_time=3,\n    cookies_oven_time=1\n):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"BakeryOptimization\")\n\n    # Decision variables: number of loaves of bread and batches of cookies\n    x = m.addVar(name=\"Bread\", lb=0)\n    y = m.addVar(name=\"Cookies\", lb=0)\n\n    # Set the objective: maximize profit\n    m.setObjective(profit_bread * x + profit_cookies * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Stand-mixer constraint\n    m.addConstr(bread_mixer_time * x + cookies_mixer_time * y <= max_machine_hours, \"MixerTime\")\n    # Oven constraint\n    m.addConstr(bread_oven_time * x + cookies_oven_time * y <= max_machine_hours, \"OvenTime\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_bakery_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A172",
    "description": "A meat processing plant uses two machines, a meat slicer and a meat packer, to make their hams and pork ribs. To produce one batch of hams requires 4 hours on the meat slicer and 2.5 hours on the meat packer. To produce one batch of pork ribs requires 2 hours on the meat slicer and 3.5 hours on the meat packer. Each machine runs for at most 4000 hours per year. If the profit per batch of hams is $150 and the profit per batch of pork ribs is $300, how many batches of each should be made to maximize profit?",
    "ground_truth": 342857.14285714284,
    "formulation": null,
    "correct_program": "def optimize_meat_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Meat_Processing_Optimization\")\n\n    # Decision variables: number of batches of hams and pork ribs\n    x = m.addVar(name=\"Hams\", lb=0)\n    y = m.addVar(name=\"Pork_Ribs\", lb=0)\n\n    # Set the objective: maximize profit\n    m.setObjective(150 * x + 300 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Meat slicer constraint\n    m.addConstr(4 * x + 2 * y <= 4000, name=\"Slicer_Time\")\n    # Meat packer constraint\n    m.addConstr(2.5 * x + 3.5 * y <= 4000, name=\"Packer_Time\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_meat_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A024",
    "description": "A car manufacturer makes two types of car oils: Oil Max and Oil Max Pro. A container of Oil Max contains 46 grams of substance A, 43 grams of substance B and 56 grams of substance C. A container of Oil Max Pro contains 13 grams of substance A, 4 grams of substance B and 45 grams of substance C. The car manufacturer has 1345 grams of substance A, 346 grams of substance B, 1643 grams of substance C. In addition, the profit per container of Oil Max is $10 and the profit per container of Oil Max Pro is $15. How many containers of each of oil should the car manufacturer make to maximize profit?",
    "ground_truth": 540.0,
    "formulation": null,
    "correct_program": "def optimize_car_oil_production(\n    max_A=1345, max_B=346, max_C=1643,\n    profit_max=10, profit_pro=15,\n    content_A_max=(46, 13), content_B_max=(43, 4), content_C_max=(56, 45)\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"OilProductionMaximizeProfit\")\n\n    # Decision variables: number of containers for each oil type\n    x = model.addVar(vtype=GRB.INTEGER, name=\"OilMax\")\n    y = model.addVar(vtype=GRB.INTEGER, name=\"OilMaxPro\")\n\n    # Set objective: maximize profit\n    model.setObjective(profit_max * x + profit_pro * y, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    model.addConstr(content_A_max[0] * x + content_A_max[1] * y <= max_A, \"ResourceA\")\n    model.addConstr(content_B_max[0] * x + content_B_max[1] * y <= max_B, \"ResourceB\")\n    model.addConstr(content_C_max[0] * x + content_C_max[1] * y <= max_C, \"ResourceC\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_car_oil_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A188",
    "description": "A small bakery has 20000 grams of batter and 14000 grams of milk to make their crepe cakes, sponge cakes, and birthday cakes. A crepe cake needs 400 grams of batter and 200 grams of milk. A sponge cake requires 500 grams of batter and 300 grams of milk. A birthday cake requires 450 grams of batter and 350 grams of milk. If the profit per crepe cake is $12, the profit per sponge cake is $10, and the profit per birthday cake is $15, how many of each should the bakery make to maximize their profit?",
    "ground_truth": 648.0,
    "formulation": null,
    "correct_program": "def optimize_cake_production(\n    batter_available=20000,\n    milk_available=14000,\n    profit_crepe=12,\n    profit_sponge=10,\n    profit_birthday=15,\n    batter_crepe=400,\n    milk_crepe=200,\n    batter_sponge=500,\n    milk_sponge=300,\n    batter_birthday=450,\n    milk_birthday=350\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Cake_Production_Maximize_Profit\")\n\n    # Decision variables: number of each cake type (integer, >= 0)\n    x1 = model.addVar(vtype=GRB.INTEGER, name=\"Crepe\", lb=0)\n    x2 = model.addVar(vtype=GRB.INTEGER, name=\"Sponge\", lb=0)\n    x3 = model.addVar(vtype=GRB.INTEGER, name=\"Birthday\", lb=0)\n\n    # Set objective: maximize total profit\n    model.setObjective(\n        profit_crepe * x1 + profit_sponge * x2 + profit_birthday * x3,\n        GRB.MAXIMIZE\n    )\n\n    # Add resource constraints\n    model.addConstr(\n        batter_crepe * x1 + batter_sponge * x2 + batter_birthday * x3 <= batter_available,\n        name=\"BatterConstraint\"\n    )\n    model.addConstr(\n        milk_crepe * x1 + milk_sponge * x2 + milk_birthday * x3 <= milk_available,\n        name=\"MilkConstraint\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal profit\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_cake_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A178",
    "description": "A toy store sells plush toys and dolls. Each plush toy costs the store $3 and each doll costs the store $2. The store owner can spend at most $700 on inventory. Each plush toy is then sold for a profit of $4 while each doll is sold for a profit of $2. The owner estimates that at least 90 plush toys but at most 190 plush toys are sold each month. He also estimates that the number of dolls sold is at most twice the amount of plush toys sold. How many of each should be bought and sold to maximize profit?",
    "ground_truth": 890.0,
    "formulation": null,
    "correct_program": "def optimize_toy_store(\n    max_budget=700,\n    min_plush=90,\n    max_plush=190,\n    plush_cost=3,\n    doll_cost=2,\n    plush_profit=4,\n    doll_profit=2\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"ToyStoreProfitMaximization\")\n\n    # Decision variables\n    x = model.addVar(vtype=GRB.INTEGER, name=\"PlushToys\")\n    y = model.addVar(vtype=GRB.INTEGER, name=\"Dolls\")\n\n    # Set objective: maximize profit\n    model.setObjective(plush_profit * x + doll_profit * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Budget constraint\n    model.addConstr(plush_cost * x + doll_cost * y <= max_budget, \"BudgetLimit\")\n    # Plush toy sales bounds\n    model.addConstr(x >= min_plush, \"MinPlush\")\n    model.addConstr(x <= max_plush, \"MaxPlush\")\n    # Dolls sold constraint\n    model.addConstr(y <= 2 * x, \"DollsLimit\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_toy_store()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "B089",
    "description": "A store wants to clear out 200 shirts and 100 pairs of pants from last season. They decide to introduce two promotional packages, A and B. Package A includes one shirt and two pairs of pants, priced at £30. Package B includes three shirts and one pair of pants, priced at £50. The store does not want to sell fewer than 20 A packages and 10 B packages. How many of each package do they need to sell to maximize the revenue from the promotion?\n\nTry to establish a model for this problem.",
    "ground_truth": 3600.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_promotional_packages():\n    \"\"\"\n    Solves the promotional package problem to maximize revenue,\n    subject to inventory and minimum sales constraints.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        packages = ['A', 'B']\n\n        # Inventory available\n        avail_shirts = 200\n        avail_pants = 100\n\n        # Package composition (units per package)\n        # composition[package][item]\n        composition = {\n            'A': {\n                'shirts': 1,\n                'pants': 2\n            },\n            'B': {\n                'shirts': 3,\n                'pants': 1\n            }\n        }\n\n        # Package prices (£ per package)\n        prices = {'A': 30, 'B': 50}\n\n        # Minimum sales requirements (packages)\n        min_sales = {'A': 20, 'B': 10}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"PromotionalPackages\")\n\n        # --- Decision Variables ---\n        # N[p]: Number of packages of type p to sell\n        N = model.addVars(packages,\n                          name=\"NumPackages\",\n                          vtype=GRB.INTEGER,\n                          lb=0)\n\n        # --- Objective Function: Maximize Total Revenue ---\n        model.setObjective(gp.quicksum(prices[p] * N[p] for p in packages),\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Shirt Availability Constraint\n        model.addConstr(gp.quicksum(composition[p]['shirts'] * N[p]\n                                    for p in packages) <= avail_shirts,\n                        name=\"ShirtLimit\")\n\n        # 2. Pants Availability Constraint\n        model.addConstr(gp.quicksum(composition[p]['pants'] * N[p]\n                                    for p in packages) <= avail_pants,\n                        name=\"PantsLimit\")\n\n        # 3. Minimum Sales Requirements\n        for p in packages:\n            model.addConstr(N[p] >= min_sales[p], name=f\"MinSales_{p}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal package sales plan found.\")\n            print(f\"Maximum Total Revenue: £{model.ObjVal:.2f}\")\n\n            print(\"\\nNumber of Packages to Sell:\")\n            for p in packages:\n                print(f\"  Package {p}: {N[p].X:.0f} units\")\n\n            print(\"\\nResource Utilization:\")\n            shirts_used = sum(composition[p]['shirts'] * N[p].X\n                              for p in packages)\n            pants_used = sum(composition[p]['pants'] * N[p].X\n                             for p in packages)\n            print(f\"  Shirts Used: {shirts_used:.0f} / {avail_shirts}\")\n            print(f\"  Pants Used: {pants_used:.0f} / {avail_pants}\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints, inventory, and minimum sales requirements.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"promo_package_iis.ilp\")\n            # print(\"IIS written to promo_package_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_promotional_packages()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "B057",
    "description": "Vicky and David have just bought a farm in the Yarra Valley, and they are considering using it to grow apples, pears, oranges, and lemons. The profit for growing one acre of apples is $2000, for one acre of pears is $1800, for one acre of oranges is $2200, and for one acre of lemons is $3000. To achieve maximum profit, how many acres of land should they use to grow each type of fruit? Vicky and David have just bought a farm in the Yarra Valley with a total area of 120 acres.\n\nThe land used to grow apples should be at least twice the land used to grow pears.\n\nThe land used to grow apples should be at least three times the land used to grow lemons.\n\nThe land used to grow oranges must be twice the land used to grow lemons.\n\nVicky and David are unwilling to grow more than two types of fruit.",
    "ground_truth": 240000.0,
    "formulation": null,
    "correct_program": "from gurobipy import Model, GRB, quicksum\n\n# Create a new model\nmodel = Model(\"Farm_Optimization\")\n\n# Define parameters\nM = 120  # Maximum possible acres\n\n# Decision variables: Acres planted\nx_A = model.addVar(name=\"Acres_Apples\", lb=0)\nx_P = model.addVar(name=\"Acres_Pears\", lb=0)\nx_O = model.addVar(name=\"Acres_Oranges\", lb=0)\nx_L = model.addVar(name=\"Acres_Lemons\", lb=0)\n\n# Binary variables: Whether to plant a certain type of fruit    \ny_A = model.addVar(vtype=GRB.BINARY, name=\"Use_Apples\")\ny_P = model.addVar(vtype=GRB.BINARY, name=\"Use_Pears\")\ny_O = model.addVar(vtype=GRB.BINARY, name=\"Use_Oranges\")\ny_L = model.addVar(vtype=GRB.BINARY, name=\"Use_Lemons\")\n\n# Set objective function\nmodel.setObjective(2000 * x_A + 1800 * x_P + 2200 * x_O + 3000 * x_L,\n                   GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x_A + x_P + x_O + x_L <= 120, \"Total_Area_Constraint\")  # Total area constraint\nmodel.addConstr(x_A >= 2 * x_P, \"Apples_vs_Pears\")  # Apples ≥ 2×Pears\nmodel.addConstr(x_A >= 3 * x_L, \"Apples_vs_Lemons\")  # Apples ≥ 3×Lemons\nmodel.addConstr(x_O == 2 * x_L, \"Oranges_vs_Lemons\")  # Oranges = 2×Lemons\nmodel.addConstr(y_A + y_P + y_O + y_L <= 2, \"Max_Two_Crops\")  # At most two types of fruits\n\n# Big-M constraints: Link area planted to whether a fruit is planted    \nmodel.addConstr(x_A <= M * y_A, \"Link_Apples\")\nmodel.addConstr(x_P <= M * y_P, \"Link_Pears\")\nmodel.addConstr(x_O <= M * y_O, \"Link_Oranges\")\nmodel.addConstr(x_L <= M * y_L, \"Link_Lemons\")\n\n# Solve the model\nmodel.optimize()\n\n# Output results\nif model.status == GRB.OPTIMAL:\n    print(\"Optimal solution found!\")\n    print(f\"Apples: {x_A.X:.2f} acres\")\n    print(f\"Pears: {x_P.X:.2f} acres\")\n    print(f\"Oranges: {x_O.X:.2f} acres\")\n    print(f\"Lemons: {x_L.X:.2f} acres\")\n    print(f\"Total profit: ${model.objVal:,.2f}\")\nelse:\n    print(\"No optimal solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F166",
    "description": "A company sells custom scooters and bikes for customers. The profit per scooter is $200 and the profit per bike is $300. Each product requires time with the design team and engineering team. Each scooter needs 2 hours with the design team and 3 hours with the engineering team. Each bike needs 4 hours with the design team and 5 hours with the engineering team. Per month, there are 5000 hours available on the design team and 6000 hours available on the engineering team. How many of each should the company make per month to maximize profit?",
    "ground_truth": 400000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Scooters_and_Bikes_Optimization\")\n\n# Parameters\np_s = 200  # Profit per scooter\np_b = 300  # Profit per bike\nt_ds = 2   # Design team hours per scooter\nt_db = 4   # Design team hours per bike\nt_es = 3   # Engineering team hours per scooter\nt_eb = 5   # Engineering team hours per bike\nH_d = 5000  # Total design team hours available\nH_e = 6000  # Total engineering team hours available\n\n# Variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_b = model.addVar(vtype=GRB.INTEGER, name=\"x_b\")\n\n# Objective function\nmodel.setObjective(p_s * x_s + p_b * x_b, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(t_ds * x_s + t_db * x_b <= H_d, \"DesignTeamHours\")\nmodel.addConstr(t_es * x_s + t_eb * x_b <= H_e, \"EngineeringTeamHours\")\nmodel.addConstr(x_s >= 0, \"NonNegativity_s\")\nmodel.addConstr(x_b >= 0, \"NonNegativity_b\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F175",
    "description": "There are two processes, process A and process B, to plate a coin with gold. Process A requires 3 units of gold, 2 wires, and can plate 5 coins. Process B requires 5 units of gold, 3 wires, and can plate 7 coins. There are 500 units of gold and 300 wires available. How many processes of each type should be run to maximize the total number of coins that can be plated?",
    "ground_truth": 750.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"CoinPlatingOptimization\")\n\n# Parameters\ng_A = 3\nw_A = 2\nc_A = 5\ng_B = 5\nw_B = 3\nc_B = 7\nG = 500\nW = 300\n\n# Variables\nx_A = model.addVar(vtype=GRB.INTEGER, name=\"x_A\")\nx_B = model.addVar(vtype=GRB.INTEGER, name=\"x_B\")\n\n# Objective: Maximize the total number of coins plated\nmodel.setObjective(c_A * x_A + c_B * x_B, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(g_A * x_A + g_B * x_B <= G, \"GoldConstraint\")\nmodel.addConstr(w_A * x_A + w_B * x_B <= W, \"WireConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F013",
    "description": "A breakfast joint makes two different sandwiches: a regular and a special. Both need eggs and bacon. Each regular sandwich requires 2 eggs and 3 slices of bacon. Each special sandwich requires 3 eggs and 5 slices of bacon. The joint has a total of 40 eggs and 70 slices of bacon. It makes a profit of $3 per regular sandwich and a profit of $4 per special sandwich. How many of each sandwich should be made to maximize profit?",
    "ground_truth": 60.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nE = 40  # total number of eggs available\nB = 70  # total number of bacon slices available\nP_r = 3  # Profit per regular sandwich\nP_s = 4  # Profit per special sandwich\ne_r = 2  # Eggs required for regular sandwich\nb_r = 3  # Bacon required for regular sandwich\ne_s = 3  # Eggs required for special sandwich\nb_s = 5  # Bacon required for special sandwich\n\n# Variables\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n\n# Objective\nmodel.setObjective(P_r * x_r + P_s * x_s, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(e_r * x_r + e_s * x_s <= E, \"EggConstraint\")\nmodel.addConstr(b_r * x_r + b_s * x_s <= B, \"BaconConstraint\")\n\n# Non-negativity constraints are inherently handled by the variable definitions\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Food Service"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F194",
    "description": "A grilled cheese shop sells a light and heavy grilled cheese sandwich. A light grilled cheese sandwich requires 2 slices of bread and 3 slices of cheese. A heavy grilled cheese sandwich requires 3 slices of bread and 5 slices of cheese. Since most people who come to the store love grilled cheese, the store must make at least 3 times as many heavy grilled cheese sandwiches as light grilled cheese sandwiches. The store has available 300 slices of bread and 500 slices of cheese. If a light grilled cheese sandwich takes 10 minutes to make and a heavy grilled cheese sandwich takes 15 minutes to make, how many of each should they make to minimize the total production time?",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"GrilledCheeseOptimization\")\n\n# Parameters\nb_L = 2  # bread slices for light sandwich\nc_L = 3  # cheese slices for light sandwich\nb_H = 3  # bread slices for heavy sandwich\nc_H = 5  # cheese slices for heavy sandwich\nB = 300  # total available bread slices\nC = 500  # total available cheese slices\nt_L = 10  # time to make a light sandwich\nt_H = 15  # time to make a heavy sandwich\n\n# Variables\nx_L = model.addVar(vtype=GRB.INTEGER, name=\"x_L\", lb=0)  # Number of light sandwiches\nx_H = model.addVar(vtype=GRB.INTEGER, name=\"x_H\", lb=0)  # Number of heavy sandwiches\n\n# Objective\nmodel.setObjective(t_L * x_L + t_H * x_H, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(b_L * x_L + b_H * x_H <= B, \"BreadConstraint\")\nmodel.addConstr(c_L * x_L + c_H * x_H <= C, \"CheeseConstraint\")\nmodel.addConstr(x_H >= 3 * x_L, \"RatioConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Food Service"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F044",
    "description": "A company is deciding where to promote their product. Some options include z-tube, soorchle engine, and wassa advertisements. The cost for each option and the number of viewers they each attract is given. On z-tube, each ad costs $1000 and attracts 400,000 viewers. On soorchle, each ad costs $200 and attracts 5,000 viewers. On wassa, each ad costs $100 and attracts 3,000 viewers. Soorchle limits the number of advertisements from a single company to fifteen. Moreover, in order to balance the advertising among the three types of media, at most a third of the total number of advertisements should occur on wassa. And at least 5% should occur on z-tube. The weekly advertising budget is $10000. How many advertisements should be run in each of the three types of media to maximize the total audience?",
    "ground_truth": 4000000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"AdvertisingOptimization\")\n\n# Parameters\nC_z = 1000  # Cost of each ad on z-tube (dollars)\nC_s = 200   # Cost of each ad on soorchle (dollars)\nC_w = 100   # Cost of each ad on wassa (dollars)\nV_z = 400000  # Viewers attracted per ad on z-tube\nV_s = 5000    # Viewers attracted per ad on soorchle\nV_w = 3000    # Viewers attracted per ad on wassa\nB = 10000     # Total advertising budget (dollars)\nL_s = 15      # Maximum number of ads allowed on soorchle\n\n# Variables\nz = model.addVar(vtype=GRB.INTEGER, name=\"z\")  # Number of ads on z-tube\ns = model.addVar(vtype=GRB.INTEGER, name=\"s\")  # Number of ads on soorchle\nw = model.addVar(vtype=GRB.INTEGER, name=\"w\")  # Number of ads on wassa\n\n# Objective: Maximize total number of viewers attracted\nmodel.setObjective(V_z * z + V_s * s + V_w * w, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(C_z * z + C_s * s + C_w * w <= B, \"BudgetConstraint\")\nmodel.addConstr(s <= L_s, \"SoorchleAdLimit\")\nmodel.addConstr(w <= (z + s + w) / 3, \"WassaAdBalance\")\nmodel.addConstr(z >= 0.05 * (z + s + w), \"ZTubeMinimum\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Marketing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F096",
    "description": "A small bakery has 20000 grams of batter and 14000 grams of milk to make their crepe cakes, sponge cakes, and birthday cakes. A crepe cake needs 400 grams of batter and 200 grams of milk. A sponge cake requires 500 grams of batter and 300 grams of milk. A birthday cake requires 450 grams of batter and 350 grams of milk. If the profit per crepe cake is $12, the profit per sponge cake is $10, and the profit per birthday cake is $15, how many of each should the bakery make to maximize their profit?",
    "ground_truth": 648.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nB = 20000  # Total available batter in grams\nM = 14000  # Total available milk in grams\nb_c = 400  # Batter needed per crepe cake in grams\nm_c = 200  # Milk needed per crepe cake in grams\nb_s = 500  # Batter needed per sponge cake in grams\nm_s = 300  # Milk needed per sponge cake in grams\nb_b = 450  # Batter needed per birthday cake in grams\nm_b = 350  # Milk needed per birthday cake in grams\np_c = 12   # Profit per crepe cake in dollars\np_s = 10   # Profit per sponge cake in dollars\np_b = 15   # Profit per birthday cake in dollars\n\n# Variables\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"x_c\")  # Number of crepe cakes\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")  # Number of sponge cakes\nx_b = model.addVar(vtype=GRB.INTEGER, name=\"x_b\")  # Number of birthday cakes\n\n# Objective function\nmodel.setObjective(p_c * x_c + p_s * x_s + p_b * x_b, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(b_c * x_c + b_s * x_s + b_b * x_b <= B, \"BatterConstraint\")\nmodel.addConstr(m_c * x_c + m_s * x_s + m_b * x_b <= M, \"MilkConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Food & Beverage"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F155",
    "description": "A car manufacturer makes two versions of the same car, a regular model and a premium model. They make x1 regular models per day and x2 premium models per day. The profit per regular model is $5000 and the profit per premium model is $8500 (x1 and x2 are unknown values both greater than or equal to 0). The daily demand for these cars is limited to and most 8 regular models and 6 premium models. In addition, the manufacturer can make a maximum of 12 cars of either type per day. How many cars of each model should the manufacturer make in order to maximize profit?",
    "ground_truth": 81000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"CarProductionOptimization\")\n\n# Add variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")  # Number of regular models\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")  # Number of premium models\n\n# Set objective\nmodel.setObjective(5000 * x1 + 8500 * x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x1 <= 8, \"C1\")  # Demand constraint for regular models\nmodel.addConstr(x2 <= 6, \"C2\")  # Demand constraint for premium models\nmodel.addConstr(x1 + x2 <= 12, \"C3\")  # Total production capacity constraint\nmodel.addConstr(x1 >= 0, \"C4\")  # Non-negativity constraint for x1\nmodel.addConstr(x2 >= 0, \"C5\")  # Non-negativity constraint for x2\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F082",
    "description": "A grocery store wants to liquidate its stock of 10 apples, 20 bananas, and 80 grapes. Given past experience, the store knows that they can propose a banana-haters package with 6 apples and 30 grapes and that this package will bring a profit of six euros. Similarly, they can prepare a combo package with 5 apples, 6 bananas, and 20 grapes, yielding a profit of seven euros. They know they can sell any quantity of these two packages within the availability of its stock. What quantity of each package, banana-haters packages and combo packages, should the store prepare to maximize net profit?",
    "ground_truth": 14.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\na = 10  # Total number of apples available\nb = 20  # Total number of bananas available\ng = 80  # Total number of grapes available\np1 = 6  # Profit in euros from one banana-haters package\np2 = 7  # Profit in euros from one combo package\na1 = 6  # Apples required for one banana-haters package\ng1 = 30 # Grapes required for one banana-haters package\na2 = 5  # Apples required for one combo package\nb2 = 6  # Bananas required for one combo package\ng2 = 20 # Grapes required for one combo package\n\n# Decision variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")  # Banana-haters packages\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")  # Combo packages\n\n# Objective function\nmodel.setObjective(p1 * x1 + p2 * x2, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(a1 * x1 + a2 * x2 <= a, \"ApplesConstraint\")  # C1\nmodel.addConstr(b2 * x2 <= b, \"BananasConstraint\")           # C2\nmodel.addConstr(g1 * x1 + g2 * x2 <= g, \"GrapesConstraint\")  # C3\nmodel.addConstr(x1 >= 0, \"NonNegativity_x1\")                 # C4\nmodel.addConstr(x2 >= 0, \"NonNegativity_x2\")                 # C4\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F117",
    "description": "A restaurant has two combos available to their customers, an original and an experimental meal. The original meal typically generates 20 units of food waste and 45 units of wrapping waste and takes 10 minutes to cook. In comparison, the experimental meal generates 25 units of food waste and 35 units of wrapping waste and takes 15 minutes to cook. The restaurant can have at most 900 units of wrapping waste and can have at most 800 units of food waste as regulated by the government. How many of each combo should be pushed for by the waiting staff to minimize the cooking time?",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nw_o = 20\nw_e = 25\nr_o = 45\nr_e = 35\nt_o = 10\nt_e = 15\nW_max = 800\nR_max = 900\n\n# Variables\nx_o = model.addVar(vtype=GRB.INTEGER, name=\"x_o\", lb=0)\nx_e = model.addVar(vtype=GRB.INTEGER, name=\"x_e\", lb=0)\n\n# Objective\nmodel.setObjective(t_o * x_o + t_e * x_e, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(w_o * x_o + w_e * x_e <= W_max, \"FoodWasteConstraint\")\nmodel.addConstr(r_o * x_o + r_e * x_e <= R_max, \"WrappingWasteConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Food Service"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F105",
    "description": "A souvenir shop makes wooden elephants and tigers with plastic ornaments. Each elephant requires 50 grams of wood and 20 grams of plastic. Each tiger requires 40 grams of wood and 30 grams of plastic. In a week, 5000 grams of wood and 4000 grams of plastic are available. The profit per elephant sold is $5 and the profit per tiger sold is $4. How many of each should be made in order to maximize profit?",
    "ground_truth": 500.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nW = 5000  # grams of wood available per week\nP = 4000  # grams of plastic available per week\nw_e = 50  # grams of wood required per elephant\np_e = 20  # grams of plastic required per elephant\nw_t = 40  # grams of wood required per tiger\np_t = 30  # grams of plastic required per tiger\npi_e = 5  # dollars profit per elephant\npi_t = 4  # dollars profit per tiger\n\n# Variables\nx_e = model.addVar(vtype=GRB.INTEGER, name=\"elephants\")\nx_t = model.addVar(vtype=GRB.INTEGER, name=\"tigers\")\n\n# Objective\nmodel.setObjective(pi_e * x_e + pi_t * x_t, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(w_e * x_e + w_t * x_t <= W, \"wood_limit\")\nmodel.addConstr(p_e * x_e + p_t * x_t <= P, \"plastic_limit\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F094",
    "description": "A fashion company sells regular handbags and premium handbags made of higher quality material. They can sell regular handbags at a profit of $30 each and premium handbags at a profit of $180 each. The total monthly cost of manufacturing is $200 per regular handbag and $447 per premium handbag. The company has a total budget of $250000 and can sell at most 475 handbags of either type per month. How many of each handbag should they sell to maximize its monthly profit?",
    "ground_truth": 85500.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\np_r = 30\np_p = 180\nc_r = 200\nc_p = 447\nB = 250000\nH_max = 475\n\n# Variables\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")\n\n# Objective function\nmodel.setObjective(p_r * x_r + p_p * x_p, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(c_r * x_r + c_p * x_p <= B, \"BudgetConstraint\")\nmodel.addConstr(x_r + x_p <= H_max, \"SalesLimitConstraint\")\nmodel.addConstr(x_r >= 0, \"NonNegativityConstraint_x_r\")\nmodel.addConstr(x_p >= 0, \"NonNegativityConstraint_x_p\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F072",
    "description": "An artisan makes two types of terracotta jars: a thin jar and a stubby jar. Each thin jar requires 50 minutes of shaping time and 90 minutes of baking time. Each stubby jar requires 30 minutes of shaping time and 150 minutes of baking time. Per week, there are 3000 minutes available for shaping and 4000 minutes available for baking. The profit per thin jar is $5 and the profit per stubby jar is $9. How many jars of each type should the artisan make to maximize profit?",
    "ground_truth": 239.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nt_t = 50  # Shaping time for thin jar\nb_t = 90  # Baking time for thin jar\nt_s = 30  # Shaping time for stubby jar\nb_s = 150 # Baking time for stubby jar\nT = 3000  # Total shaping time available\nB = 4000  # Total baking time available\np_t = 5   # Profit for thin jar\np_s = 9   # Profit for stubby jar\n\n# Variables\nx_t = model.addVar(vtype=GRB.INTEGER, name=\"x_t\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n\n# Objective: Maximize profit\nmodel.setObjective(p_t * x_t + p_s * x_s, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(t_t * x_t + t_s * x_s <= T, \"ShapingTimeConstraint\")\nmodel.addConstr(b_t * x_t + b_s * x_s <= B, \"BakingTimeConstraint\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F136",
    "description": "A hobbyist makes model trains and planes using wood and paint. A model train requires 3 units of wood and 3 units of paint. A model plane requires 4 units of wood and 2 units of paint. The hobbyist has available 120 units of wood and 90 units of paint. If the profit per model train is $8 and the profit per model plane is $10, how many of each should be made to maximize his profit?",
    "ground_truth": 310.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nW = 120\nP = 90\nw_t = 3\np_t = 3\nw_p = 4\np_p = 2\npi_t = 8\npi_p = 10\n\n# Variables\nx_t = model.addVar(vtype=GRB.INTEGER, name=\"x_t\")\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")\n\n# Objective\nmodel.setObjective(pi_t * x_t + pi_p * x_p, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(w_t * x_t + w_p * x_p <= W, \"WoodConstraint\")\nmodel.addConstr(p_t * x_t + p_p * x_p <= P, \"PaintConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F163",
    "description": "Mark has 50 acres of land available to grow potatoes and cucumbers that he sells at a farmers' market. He must grow at least 12 acres of potatoes and 15 acres of cucumbers to meet his contract. Mark prefers to grow more cucumbers than potatoes, but he only has enough resources to grow at most twice the amount of cucumbers as potatoes. If the profit per acre of potatoes is $500 and the profit per acre of cucumbers is $650, how many acres of each should he grow to maximize his profit? What is that profit?",
    "ground_truth": 29950.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "run_error"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F169",
    "description": "A bakery bakes bagels and croissants. A batch of bagels can be made using 2 hours of oven time and 0.25 hours of pastry chef time. A batch of croissants is more complicated, so while they take 1 hour of oven time, they take 2 hours of pastry chef time. In a day, the bakery has at most 70 hours available for the oven and 32 pastry chef hours available. Using all the available capacity, what is the maximum profit the bakery can generate assuming the profit per batch is $20 and $40 respectively for a batch of bagels and a batch of croissants.",
    "ground_truth": 1060.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nP_b = 20  # Profit per batch of bagels\nP_c = 40  # Profit per batch of croissants\nT_o_b = 2  # Oven time per batch of bagels\nT_c_b = 0.25  # Pastry chef time per batch of bagels\nT_o_c = 1  # Oven time per batch of croissants\nT_c_c = 2  # Pastry chef time per batch of croissants\nT_o = 70  # Total available oven time\nT_c = 32  # Total available pastry chef time\n\n# Decision variables\nx_b = model.addVar(vtype=GRB.INTEGER, name=\"x_b\")  # Batches of bagels\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"x_c\")  # Batches of croissants\n\n# Objective function\nmodel.setObjective(P_b * x_b + P_c * x_c, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(T_o_b * x_b + T_o_c * x_c <= T_o, \"OvenTime\")\nmodel.addConstr(T_c_b * x_b + T_c_c * x_c <= T_c, \"ChefTime\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Food & Beverage"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F152",
    "description": "Ben is growing apples and pears on his orchard. He has 50 acres available on which he must grow a minimum of 5 acres of apples and a minimum of 10 acres of pears to meet demands. The profit per apple is $2 and the profit per pear is $4. He prefers to grow more pears than apples but limitations in his workforce allow him to grow at most twice the amount of pears as apples. How many of each fruit should Ben grow in order to maximize his profit? What is that profit?",
    "ground_truth": 166.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F154",
    "description": "A electronics store sells premium desktops with more power as well as regular desktops for everyday use. Each premium desktop costs the store $2000 to make and yields a profit of $500. Each regular desktop costs the store $1000 to make and yields a profit of $300. The store sells at most 200 desktops each month and wants to spend at most $300000 on making the desktops. How many of each should be made and sold to maximize profit?",
    "ground_truth": 80000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define parameters\nc_p = 2000  # Cost to make a premium desktop\nc_r = 1000  # Cost to make a regular desktop\np_p = 500   # Profit from selling a premium desktop\np_r = 300   # Profit from selling a regular desktop\nD = 200     # Maximum number of desktops sold\nB = 300000  # Maximum budget for making desktops\n\n# Define variables\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")  # Number of premium desktops\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")  # Number of regular desktops\n\n# Set objective: Maximize profit\nmodel.setObjective(p_p * x_p + p_r * x_r, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(c_p * x_p + c_r * x_r <= B, \"BudgetConstraint\")  # Budget constraint\nmodel.addConstr(x_p + x_r <= D, \"SalesConstraint\")  # Sales constraint\nmodel.addConstr(x_p >= 0, \"NonNegativity_x_p\")  # Non-negativity constraint for x_p\nmodel.addConstr(x_r >= 0, \"NonNegativity_x_r\")  # Non-negativity constraint for x_r\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F115",
    "description": "An art store makes large and small art pieces. The store has available 100 units of paint, 50 units of glitter, and 70 units of glue. To make a large art piece requires 4 units of paint, 3 units of glitter, and 5 units of glue. To make a small art piece requires 2 units of paint, 1 unit of glitter, and 2 units of glue. The store must make at least 5 units of each large and small art pieces. If the profit per large art piece is $30 and the profit per small art piece is $15, how many of each should be made to maximize profit?",
    "ground_truth": 480.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nP = 100  # Total units of paint available\nG = 50   # Total units of glitter available\nL = 70   # Total units of glue available\n\np_l = 4  # Units of paint required per large art piece\ng_l = 3  # Units of glitter required per large art piece\nl_l = 5  # Units of glue required per large art piece\n\np_s = 2  # Units of paint required per small art piece\ng_s = 1  # Units of glitter required per small art piece\nl_s = 2  # Units of glue required per small art piece\n\nprofit_l = 30  # Profit per large art piece\nprofit_s = 15  # Profit per small art piece\n\nmin_l = 5  # Minimum number of large art pieces to be made\nmin_s = 5  # Minimum number of small art pieces to be made\n\n# Variables\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n\n# Objective: Maximize profit\nmodel.setObjective(profit_l * x_l + profit_s * x_s, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(p_l * x_l + p_s * x_s <= P, \"PaintConstraint\")\nmodel.addConstr(g_l * x_l + g_s * x_s <= G, \"GlitterConstraint\")\nmodel.addConstr(l_l * x_l + l_s * x_s <= L, \"GlueConstraint\")\nmodel.addConstr(x_l >= min_l, \"MinLargeArtPieces\")\nmodel.addConstr(x_s >= min_s, \"MinSmallArtPieces\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F085",
    "description": "An office company makes desks and drawers. Each desk requires 40 minutes of assembly and 20 minutes of sanding. Each drawer requires 30 minutes of assembly and 10 minutes of sanding. The company has available 4000 minutes for assembly and 3500 minutes for sanding. If the profit per desk is $100 and the profit per drawer is $90, how many of each should the company make to maximize profit?",
    "ground_truth": 11980.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define variables\nx_d = model.addVar(vtype=GRB.INTEGER, name=\"x_d\")  # Number of desks\nx_w = model.addVar(vtype=GRB.INTEGER, name=\"x_w\")  # Number of drawers\n\n# Set objective\nmodel.setObjective(100 * x_d + 90 * x_w, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(40 * x_d + 30 * x_w <= 4000, \"C1\")  # Assembly time constraint\nmodel.addConstr(20 * x_d + 10 * x_w <= 3500, \"C2\")  # Sanding time constraint\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F153",
    "description": "A suspicious factory has 100 sq. feet of space. It makes bootleg phones and laptops. Phones require 2 hours of labor and cost $12 for each sq. foot of space allocated for phone production (cost of electricity and equipment). Laptops require 3 hours of labor and cost $15 for each sq. foot of space allocated for laptop production. Phones produce a net revenue of $50 per sq. foot while laptops produce a net revenue of $70 per sq. foot. The factory wants to spend at most $5000 and 2000 hours of labor. What is the optimal factory layout to maximize revenue?",
    "ground_truth": 7000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"FactoryLayoutOptimization\")\n\n# Define the decision variables\nx_p = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_p\", lb=0)  # Space for phones\nx_l = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_l\", lb=0)  # Space for laptops\n\n# Set the objective function\nmodel.setObjective(50 * x_p + 70 * x_l, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x_p + x_l <= 100, \"SpaceConstraint\")\nmodel.addConstr(12 * x_p + 15 * x_l <= 5000, \"CostConstraint\")\nmodel.addConstr(2 * x_p + 3 * x_l <= 2000, \"LaborConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F090",
    "description": "A bakery uses a stand-mixer and a slow bake oven to make bread and cookies. Each machine can run for at most 3000 hours per year. To bake a loaf of bread takes 1 hour in the stand mixer and 3 hours in the oven. A batch of cookies requires 0.5 hours in the mixer and 1 hour in the oven. The profit per loaf of bread is $5 and the profit per batch of cookies is $3. How should the bakery operate to maximize total profit?",
    "ground_truth": 9000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"BakeryOptimization\")\n\n# Define variables\nx_b = model.addVar(vtype=GRB.INTEGER, name=\"Bread\")\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"Cookies\")\n\n# Set objective\nmodel.setObjective(5 * x_b + 3 * x_c, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x_b + 0.5 * x_c <= 3000, \"MixerConstraint\")\nmodel.addConstr(3 * x_b + x_c <= 3000, \"OvenConstraint\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Food & Beverage"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F091",
    "description": "Maple Oil processes three types of crude oil: light oil, non-sticky oil and heavy oil. Each tank of light oil produces a net revenue of $550, each tank of non-sticky oil produces a net revenue of $750, and each tank of heavy oil produces a net revenue of $950. To process a tank of light oil, 3 units of compound A and 3 units of compound B are required. To process a tank of non-sticky oil, 6 units of compound A and 2 units of compound B are required. To process a tank of heavy oil, 9 units of compound A and 3 units of compound B are required. Currently the company has 250 units of compound A and 150 units of compound B to process. How many full or partial tanks of each oil should the company process so that net revenue is maximized?",
    "ground_truth": 36900.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F083",
    "description": "A meat processing plant uses two machines, a meat slicer and a meat packer, to make their hams and pork ribs. To produce one batch of hams requires 4 hours on the meat slicer and 2.5 hours on the meat packer. To produce one batch of pork ribs requires 2 hours on the meat slicer and 3.5 hours on the meat packer. Each machine runs for at most 4000 hours per year. If the profit per batch of hams is $150 and the profit per batch of pork ribs is $300, how many batches of each should be made to maximize profit?",
    "ground_truth": 342750.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\np_H = 150  # Profit per batch of hams\np_R = 300  # Profit per batch of pork ribs\nt_SH = 4   # Time on slicer per batch of hams\nt_PH = 2.5 # Time on packer per batch of hams\nt_SR = 2   # Time on slicer per batch of pork ribs\nt_PR = 3.5 # Time on packer per batch of pork ribs\nT_S = 4000 # Total slicer hours\nT_P = 4000 # Total packer hours\n\n# Decision Variables\nx_H = model.addVar(vtype=GRB.INTEGER, name=\"x_H\")\nx_R = model.addVar(vtype=GRB.INTEGER, name=\"x_R\")\n\n# Objective: Maximize profit\nmodel.setObjective(p_H * x_H + p_R * x_R, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(t_SH * x_H + t_SR * x_R <= T_S, \"C1\")  # Slicer capacity\nmodel.addConstr(t_PH * x_H + t_PR * x_R <= T_P, \"C2\")  # Packer capacity\nmodel.addConstr(x_H >= 0, \"C3_H\")  # Non-negativity for x_H\nmodel.addConstr(x_R >= 0, \"C3_R\")  # Non-negativity for x_R\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F160",
    "description": "A food truck owner can spend at most $20000 on mangos and guavas. A mango costs the food truck owner $5 and a guava costs him $3. Spices are added and each mango is sold for a profit of $3 while each guava is sold for a profit of $4. The owner estimates that at least 100 mangos but at the most 150 are sold each month. He also estimates that the number of guavas sold is at most a third of the mangos sold. How many mangos and guavas should be sold in order to maximize the profit?",
    "ground_truth": 650.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nC_m = 5  # Cost of one mango\nC_g = 3  # Cost of one guava\nP_m = 3  # Profit from one mango\nP_g = 4  # Profit from one guava\nB = 20000  # Budget\nM_min = 100  # Minimum number of mangos\nM_max = 150  # Maximum number of mangos\nR = 1 / 3  # Maximum ratio of guavas to mangos\n\n# Variables\nx_m = model.addVar(vtype=GRB.INTEGER, name=\"x_m\")\nx_g = model.addVar(vtype=GRB.INTEGER, name=\"x_g\")\n\n# Objective: Maximize profit\nmodel.setObjective(P_m * x_m + P_g * x_g, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(C_m * x_m + C_g * x_g <= B, \"BudgetConstraint\")\nmodel.addConstr(M_min <= x_m, \"MangoMinConstraint\")\nmodel.addConstr(x_m <= M_max, \"MangoMaxConstraint\")\nmodel.addConstr(x_g <= R * x_m, \"GuavaRatioConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F159",
    "description": "A car manufacturer makes two types of car oils: Oil Max and Oil Max Pro. A container of Oil Max contains 46 grams of substance A, 43 grams of substance B and 56 grams of substance C. A container of Oil Max Pro contains 13 grams of substance A, 4 grams of substance B and 45 grams of substance C. The car manufacturer has 1345 grams of substance A, 346 grams of substance B, 1643 grams of substance C. In addition, the profit per container of Oil Max is $10 and the profit per container of Oil Max Pro is $15. How many containers of each of oil should the car manufacturer make to maximize profit?",
    "ground_truth": 540.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OilProduction\")\n\n# Add variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")  # Oil Max\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")  # Oil Max Pro\n\n# Set objective: Maximize 10*x1 + 15*x2\nmodel.setObjective(10*x1 + 15*x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(46*x1 + 13*x2 <= 1345, \"c1\")  # Substance A constraint\nmodel.addConstr(43*x1 + 4*x2 <= 346, \"c2\")   # Substance B constraint\nmodel.addConstr(56*x1 + 45*x2 <= 1643, \"c3\") # Substance C constraint\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A090",
    "description": "A science show preforms two different demonstrations, demonstration 1 and demonstration 2. In demonstration 1, 10 units of mint and 20 units of the active ingredient is used to make 25 units of minty foam. In demonstration 2, 12 units of mint and 15 units of the active ingredient is used to make 18 units of minty foam. In addition, demonstration 1 creates 5 units of black tar while demonstration 2 creates 3 units of black tar. The show has available 120 units of mint and 100 units of active ingredients. If at most 50 units of black tar can be produced, how many of each demonstration should be done to maximize the amount of minty foam produced?",
    "ground_truth": 125.0,
    "formulation": null,
    "correct_program": "def optimize_minty_foam():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    model = Model(\"MintyFoamOptimization\")\n    \n    # Decision variables: number of demonstrations\n    x1 = model.addVar(vtype=GRB.INTEGER, name=\"Demo1\")\n    x2 = model.addVar(vtype=GRB.INTEGER, name=\"Demo2\")\n    \n    # Set the objective: maximize total minty foam\n    model.setObjective(25 * x1 + 18 * x2, GRB.MAXIMIZE)\n    \n    # Add resource constraints\n    model.addConstr(10 * x1 + 12 * x2 <= 120, \"MintConstraint\")\n    model.addConstr(20 * x1 + 15 * x2 <= 100, \"ActiveIngredientConstraint\")\n    model.addConstr(5 * x1 + 3 * x2 <= 50, \"BlackTarConstraint\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_minty_foam = optimize_minty_foam()\n    if max_minty_foam is not None:\n        print(f\"Maximum Total Minty Foam Produced: {max_minty_foam}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Entertainment"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A139",
    "description": "A meal service company delivers meals to customers either on electric bikes or scooters. A bike can hold 8 meals and requires 3 units of charge. A scooter can hold 5 meals and requires 2 units of charge. Since the city is more friendly towards scooters, at most 30% of the electric vehicles can be bikes and at least 20 scooters must be used. If the company only has 200 units of charge available, how many of each vehicle should be used to maximize the number of meals that can be delivered?",
    "ground_truth": 513.0,
    "formulation": null,
    "correct_program": "def optimize_meal_delivery():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MealDeliveryOptimization\")\n\n    # Decision variables\n    x_b = m.addVar(vtype=GRB.INTEGER, name=\"bikes\")\n    x_s = m.addVar(vtype=GRB.INTEGER, name=\"scooters\")\n\n    # Set objective: maximize total meals\n    m.setObjective(8 * x_b + 5 * x_s, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Charge constraint\n    m.addConstr(3 * x_b + 2 * x_s <= 200, name=\"charge_limit\")\n    # Bike usage limit (30% of total vehicles)\n    m.addConstr(7 * x_b <= 3 * x_s, name=\"bike_ratio\")\n    # Minimum scooters\n    m.addConstr(x_s >= 20, name=\"min_scooters\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum number of meals delivered\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_meals = optimize_meal_delivery()\n    if max_meals is not None:\n        print(f\"Maximum Meals Delivered: {max_meals}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A166",
    "description": "Employees have the option of car-pooling to work or taking the company bus. A car can take 4 employees and produces 10 units of pollution, while a bus can take 20 employees and produces 30 units of pollution. At least 300 employees need to be transported and at most 4 buses can be used. How many of each type of transport should be taken to minimize the total pollution produced.",
    "ground_truth": 670.0,
    "formulation": null,
    "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Employee_Transport_MinPollution\")\n\n    # Decision variables\n    # Number of cars\n    x = m.addVar(vtype=GRB.INTEGER, name=\"cars\", lb=0)\n    # Number of buses\n    y = m.addVar(vtype=GRB.INTEGER, name=\"buses\", lb=0, ub=4)\n\n    # Set objective: minimize total pollution\n    m.setObjective(10 * x + 30 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Ensure at least 300 employees are transported\n    m.addConstr(4 * x + 20 * y >= 300, \"transport_capacity\")\n    # Limit on number of buses\n    m.addConstr(y <= 4, \"bus_limit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total pollution\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    min_pollution = optimize_transportation()\n    if min_pollution is not None:\n        print(f\"Minimum Total Pollution: {min_pollution}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A200",
    "description": "An extremely large ski resort is looking into purchasing two types of ski lifts, a densely-seated one and a loosely-seated one. The densely-seated ski lift is able to bring 45 guests up the slopes every minute whereas the loosely-seated ski lift can transport 20 guests every minute.  The densely-seated ski lift uses 30 units of electricity and the loosely-seated lift uses 22 units of electricity. There must be at least five loosely-seated ski lifts because they move slower and are friendlier for beginners. The ski resort needs at least 1000 guests every minute to make a profit and has available 940 units of electricity. How many of each type of ski lifts should they plan to install to minimize the total number of ski lifts needed?",
    "ground_truth": 25.0,
    "formulation": null,
    "correct_program": "def optimize_ski_lifts():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"SkiLiftsOptimization\")\n    \n    # Decision variables\n    # x: number of densely-seated lifts\n    # y: number of loosely-seated lifts\n    x = m.addVar(vtype=GRB.INTEGER, name=\"x\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"y\", lb=5)\n    \n    # Set the objective: minimize total number of lifts\n    m.setObjective(x + y, GRB.MINIMIZE)\n    \n    # Capacity constraint\n    m.addConstr(45 * x + 20 * y >= 1000, name=\"capacity\")\n    \n    # Electricity constraint\n    m.addConstr(30 * x + 22 * y <= 940, name=\"electricity\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of lifts\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_lifts = optimize_ski_lifts()\n    if min_lifts is not None:\n        print(f\"Minimum Total Lifts: {min_lifts}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Recreation & Tourism"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A157",
    "description": "A tourist spot in the mountains allows visitors to travel to the top either by hot-air balloon or gondola lift. A hot air balloon can carry 4 visitors while a gondola lift can carry 6 visitors. Each hot air balloon produces 10 units of pollution while each gondola lift produces 15 units of pollution. There can be at most 10 hot-air balloon rides and at least 70 visitors need to be transported. How many of each type of transport method should be taken to minimize the total pollution produced?",
    "ground_truth": 175.0,
    "formulation": null,
    "correct_program": "def minimize_pollution():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TouristTransportPollution\")\n\n    # Decision variables\n    # x: number of hot-air balloon rides\n    # y: number of gondola lift rides\n    x = m.addVar(vtype=GRB.INTEGER, name=\"hot_air_balloons\", lb=0, ub=10)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"gondola_lifts\", lb=0)\n\n    # Set objective: minimize total pollution\n    m.setObjective(10 * x + 15 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Capacity constraint\n    m.addConstr(4 * x + 6 * y >= 70, \"capacity\")\n    # Hot-air balloon ride limit\n    m.addConstr(x <= 10, \"max_balloons\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pollution = minimize_pollution()\n    if min_pollution is not None:\n        print(f\"Minimum Total Pollution: {min_pollution}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Tourism"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A080",
    "description": "A summer camps does science experiments in two pre filled beakers, beaker 1 and beaker 2. Beaker 1 uses 4 units of flour and 6 units of special liquid to make 5 units of slime. Beaker 2 uses 6 units of flour and 3 units of special liquid to make 3 units of slime.  However, beaker 1 creates 4 units of waste while beaker 2 creates 2 units of waste. The summer camp has available 150 units of flour and 100 units of special liquid. If at most 30 units of waste can be produced, how many of each beaker should be used to maximize the amount of slime produced?",
    "ground_truth": 45.0,
    "formulation": null,
    "correct_program": "def optimize_slime_production(\n    flour_available=150,\n    liquid_available=100,\n    waste_limit=30\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"SlimeProduction\")\n\n    # Decision variables: number of times each beaker is used\n    x1 = model.addVar(vtype=GRB.INTEGER, name=\"Beaker1\")\n    x2 = model.addVar(vtype=GRB.INTEGER, name=\"Beaker2\")\n\n    # Set objective: maximize total slime\n    model.setObjective(5 * x1 + 3 * x2, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    model.addConstr(4 * x1 + 6 * x2 <= flour_available, \"FlourConstraint\")\n    model.addConstr(6 * x1 + 3 * x2 <= liquid_available, \"LiquidConstraint\")\n    model.addConstr(4 * x1 + 2 * x2 <= waste_limit, \"WasteConstraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage \nif __name__ == \"__main__\":\n    max_slime = optimize_slime_production()\n    if max_slime is not None:\n        print(f\"Maximum Total Slime Produced: {max_slime}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A220",
    "description": "A mask making company ships masks to their retail stores using small boxes and large boxes. A small box holds 25 masks whereas a large box holds 45 masks. Since small boxes are easier to stack and will be used first to stock stores, there must be at least three times as many small boxes as large boxes. Additionally, at least 5 large boxes must be used. If at least 750 masks are required to be distributed, how many of each size of box should be used to minimize the total number of boxes needed?",
    "ground_truth": 26.0,
    "formulation": null,
    "correct_program": "def optimize_mask_boxes():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"mask_box_optimization\")\n\n    # Decision variables\n    # Number of small boxes\n    x = m.addVar(vtype=GRB.INTEGER, name=\"small_boxes\")\n    # Number of large boxes\n    y = m.addVar(vtype=GRB.INTEGER, name=\"large_boxes\")\n\n    # Set objective: minimize total number of boxes\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Mask capacity constraint\n    m.addConstr(25 * x + 45 * y >= 750, name=\"mask_capacity\")\n    # Ratio constraint: small boxes at least three times large boxes\n    m.addConstr(x >= 3 * y, name=\"ratio_constraint\")\n    # Minimum large boxes\n    m.addConstr(y >= 5, name=\"min_large_boxes\")\n    # Non-negativity is implicit in variable type (integer >= 0)\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_boxes = m.objVal\n        small_boxes = x.X\n        large_boxes = y.X\n        return total_boxes\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_boxes = optimize_mask_boxes()\n    if min_boxes is not None:\n        print(f\"Minimum Total Boxes: {min_boxes}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A071",
    "description": "A toy company can build two factory types, a medium sized factory and a small factory. A medium sized factory can make 50 toys per day and requires 3 operators. A small factory can make 35 toys per day and requires 2 operators. The company must make at least 250 toys per day but they only have available 16 operators. How many of each factory should the company build to minimize the total number of factories?",
    "ground_truth": 5.0,
    "formulation": null,
    "correct_program": "def optimize_factory_selection():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Factory_Optimization\")\n    \n    # Decision variables: number of medium and small factories\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Medium_Factories\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Small_Factories\", lb=0)\n    \n    # Set the objective: minimize total number of factories\n    m.setObjective(x + y, GRB.MINIMIZE)\n    \n    # Add production constraint\n    m.addConstr(50 * x + 35 * y >= 250, name=\"Production_Constraint\")\n    \n    # Add operator constraint\n    m.addConstr(3 * x + 2 * y <= 16, name=\"Operator_Constraint\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_factories = optimize_factory_selection()\n    if min_factories is not None:\n        print(f\"Minimum Total Number of Factories: {min_factories}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A146",
    "description": "A chicken farmer has sold his chicken and they need to be transported either by bus or by car. A bus can take 100 chicken and takes 2 hours per trip. A car can take 40 chicken and takes 1.5 hours per trip. There can be at most 10 bus trips and at least 60% of the trips must be by car. If the farmer needs to transport 1200 chicken, how many trips of each should be done to minimize the total time needed to transport the chicken?",
    "ground_truth": 33.5,
    "formulation": null,
    "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"ChickenTransport\")\n\n    # Decision variables\n    x = m.addVar(vtype=GRB.INTEGER, name=\"bus_trips\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"car_trips\")\n\n    # Set objective: minimize total time\n    m.setObjective(2 * x + 1.5 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Capacity constraint\n    m.addConstr(100 * x + 40 * y >= 1200, name=\"capacity\")\n    # Bus trip limit\n    m.addConstr(x <= 10, name=\"max_bus_trips\")\n    # Trip ratio constraint (at least 60% by car)\n    m.addConstr(y >= 1.5 * x, name=\"car_ratio\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total time\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_transportation()\n    if min_time is not None:\n        print(f\"Minimum Total Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A132",
    "description": "A school is organizing a field trip to a science center and wants to hire small buses and large buses. A small bus can carry 20 students while a large bus can carry 50 students.  The school needs to provide transportation for at least 500 students.  In addition, since the parking lot is rather small, a maximum of 20% of the buses can be large buses. How many of each type of bus should be hired to minimize the total number of buses?",
    "ground_truth": 20.0,
    "formulation": null,
    "correct_program": "def optimize_buses():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"School_Bus_Optimization\")\n    \n    # Decision variables\n    x = m.addVar(vtype=GRB.INTEGER, name=\"small_buses\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"large_buses\")\n    \n    # Set objective: minimize total number of buses\n    m.setObjective(x + y, GRB.MINIMIZE)\n    \n    # Capacity constraint\n    m.addConstr(20 * x + 50 * y >= 500, name=\"capacity_constraint\")\n    \n    # Parking lot constraint (x >= 4y)\n    m.addConstr(x - 4 * y >= 0, name=\"parking_constraint\")\n    \n    # Non-negativity is implicit in variable definition (non-negative by default)\n    # but to be explicit:\n    m.addConstr(x >= 0, name=\"x_nonneg\")\n    m.addConstr(y >= 0, name=\"y_nonneg\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_buses = m.objVal\n        return total_buses\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_buses = optimize_buses()\n    if min_buses is not None:\n        print(f\"Minimum Total Buses: {min_buses}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A121",
    "description": "An engineering school has a bridge building competition where students must build as many beam bridges and truss bridges as they can using Popsicle sticks and glue. A beam bridge requires 30 Popsicle sticks and 5 units of glue while a truss bridge requires 50 Popsicle sticks and 8 units of glue. Each team has at most 600 Popsicle sticks and 100 units of glue. In addition, each team can build at most 5 truss bridges and the number of beam bridges must be larger than the number of truss bridges. If a beam bridge can hold 40 grams and a truss bridge can hold 60 grams, how many of each bridge should a team build to maximize the total mass that can be supported?",
    "ground_truth": 800.0,
    "formulation": null,
    "correct_program": "def optimize_bridges():\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"BridgeBuildingOptimization\")\n\n    # Decision variables\n    # x_b: number of beam bridges\n    # x_t: number of truss bridges\n    x_b = model.addVar(vtype=GRB.INTEGER, name=\"beam_bridges\", lb=0)\n    x_t = model.addVar(vtype=GRB.INTEGER, name=\"truss_bridges\", lb=0)\n\n    # Set objective: maximize total supported mass\n    model.setObjective(40 * x_b + 60 * x_t, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Material constraints\n    model.addConstr(30 * x_b + 50 * x_t <= 600, \"sticks_constraint\")\n    model.addConstr(5 * x_b + 8 * x_t <= 100, \"glue_constraint\")\n    # Truss bridge limit\n    model.addConstr(x_t <= 5, \"max_truss\")\n    # Beam > Truss\n    model.addConstr(x_b >= x_t + 1, \"beam_greater_than_truss\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total supported mass\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_mass = optimize_bridges()\n    if max_mass is not None:\n        print(f\"Maximum Supported Mass: {max_mass}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A198",
    "description": "A concert organizer has to transport equipment using carts or trolleys. Carts can transport 5 kg/min of equipment and requires 2 workers. Trolleys can transport 7 kg/min of equipment and requires 4 workers. There must be at least 12 trolleys to be used. Additionally, only a maximum of 40% of the transportation can be using trolleys. The organizer has to deliver at a rate of 100 kg/min of equipment. How many of each transportation method should be used to minimize the total number of workers?",
    "ground_truth": 100.0,
    "formulation": null,
    "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TransportationOptimization\")\n\n    # Decision variables\n    # x: number of carts\n    # y: number of trolleys\n    x = m.addVar(name=\"x\", vtype=GRB.INTEGER, lb=0)\n    y = m.addVar(name=\"y\", vtype=GRB.INTEGER, lb=12)\n\n    # Set objective: minimize total workers\n    m.setObjective(2 * x + 4 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Transportation capacity constraint\n    m.addConstr(5 * x + 7 * y >= 100, name=\"capacity\")\n    # Proportion constraint: 2x >= 4.2 y\n    m.addConstr(2 * x >= 4.2 * y, name=\"proportion\")\n    # y >= 12 is already enforced by lb=12\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of workers\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_workers = optimize_transportation()\n    if min_workers is not None:\n        print(f\"Minimum Total Workers: {min_workers}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Event Management"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A044",
    "description": "A bubble tea shop sells mango and lychee bubble tea. Each mango bubble tea requires 4 units of mango juice and 8 units of tea. Each lychee bubble tea requires 6 units of lychee juice and 6 units of tea. The shop has available 2000 units of mango juice and 3000 units of lychee juice. At least 40% of the bubble teas made must be lychee flavored. However, mango bubble tea sells better and thus the number of mango bubble teas made must be large than the number of lychee bubble teas made. How many of each bubble tea flavor should be made to minimize the total amount of tea needed?",
    "ground_truth": 36.0,
    "formulation": null,
    "correct_program": "def optimize_bubble_tea(minimize_tea=True):\n    from gurobipy import Model, GRB, quicksum\n\n    # Create a new model\n    model = Model(\"BubbleTeaOptimization\")\n    model.setParam('OutputFlag', 0)  # Suppress Gurobi output\n\n    # Decision variables: number of mango and lychee bubble teas\n    x_m = model.addVar(vtype=GRB.INTEGER, name='x_m', lb=0)\n    x_l = model.addVar(vtype=GRB.INTEGER, name='x_l', lb=0)\n\n    # Add constraints\n    # Juice constraints\n    model.addConstr(4 * x_m <= 2000, name='mango_juice')\n    model.addConstr(6 * x_l <= 3000, name='lychee_juice')\n    # Total tea constraint\n    model.addConstr(8 * x_m + 6 * x_l <= 3000, name='total_tea')\n    # Lychee proportion constraint\n    model.addConstr(3 * x_l >= 2 * x_m, name='lychee_ratio')\n    # Mango more than lychee\n    model.addConstr(x_m >= x_l + 1, name='mango_more_than_lychee')\n\n    # Objective: minimize total tea\n    model.setObjective(8 * x_m + 6 * x_l, GRB.MINIMIZE)\n\n    # Optimize\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_tea = model.objVal\n        return total_tea\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_tea = optimize_bubble_tea()\n    if min_tea is not None:\n        print(f\"Minimum Total Tea: {min_tea}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A209",
    "description": "A party organizer needs to transport party goers either by limousine or bus. Limousines can carry 12 people and buses can carry 18 people. They need to transport at least 400 people. Because limousines are more attractive, at least 70% of the vehicles must be limousines. How many of each type of vehicle should be used to minimize the total number of limousines and buses used?",
    "ground_truth": 30.0,
    "formulation": null,
    "correct_program": "def optimize_vehicle_allocation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Vehicle_Optimization\")\n\n    # Decision variables: number of limousines and buses\n    L = m.addVar(vtype=GRB.INTEGER, name=\"Limousines\", lb=0)\n    B = m.addVar(vtype=GRB.INTEGER, name=\"Buses\", lb=0)\n\n    # Set the objective: minimize total number of vehicles\n    m.setObjective(L + B, GRB.MINIMIZE)\n\n    # Add capacity constraint\n    m.addConstr(12 * L + 18 * B >= 400, name=\"CapacityConstraint\")\n\n    # Add ratio constraint: 3L >= 7B\n    m.addConstr(3 * L >= 7 * B, name=\"RatioConstraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_vehicles = L.X + B.X\n        return total_vehicles\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_vehicles = optimize_vehicle_allocation()\n    if min_vehicles is not None:\n        print(f\"Minimum Total Vehicles: {min_vehicles}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Event Management"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A068",
    "description": "An Indian restaurant makes goat and chicken curry. Each bowl of goat curry requires 3 units of goat meat and 6 units of the curry base. Each bowl of chicken curry requires 5 units of chicken meat and 5 units of the curry base. The restaurant has available 1500 units of goat meat and 2000 units of chicken meat. At least 25% of the bowls made must be chicken curry. Since goat curry is more popular, the number of goat curry bowls must be larger than the number of chicken curry bowls. How many of each type of curry bowl should be made to minimize the total amount of curry base used?",
    "ground_truth": 17.0,
    "formulation": null,
    "correct_program": "def optimize_curry_bowls():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"CurryOptimization\")\n    \n    # Decision variables: number of goat and chicken curry bowls\n    G = m.addVar(vtype=GRB.INTEGER, name=\"GoatCurry\")\n    C = m.addVar(vtype=GRB.INTEGER, name=\"ChickenCurry\")\n    \n    # Set the objective: minimize total curry base used\n    m.setObjective(6 * G + 5 * C, GRB.MINIMIZE)\n    \n    # Add resource constraints\n    m.addConstr(3 * G <= 1500, name=\"GoatMeatLimit\")\n    m.addConstr(5 * C <= 2000, name=\"ChickenMeatLimit\")\n    \n    # Add proportion constraint: C >= 0.25*(G + C) -> 3C >= G\n    m.addConstr(3 * C >= G, name=\"ProportionConstraint\")\n    \n    # Popularity constraint: G > C -> G >= C + 1\n    m.addConstr(G >= C + 1, name=\"PopularityConstraint\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total curry base used\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_curry_base = optimize_curry_bowls()\n    if min_curry_base is not None:\n        print(f\"Minimum Total Curry Base Used: {min_curry_base}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Food Service"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A039",
    "description": "A woodshop can purchase two types of saws, a miter saw and a circular saw. A miter saw can cut 50 planks of wood and produces 60 units of sawdust per day. A circular saw can cut 70 planks of wood and produces 100 units of sawdust per day. The woodshop must cut at least 1500 planks of wood per day. However, to avoid too much pollution in the woodshop they can produce at most 2000 units of sawdust per day. How many of each type of saw should be purchased to minimize the total number of saws needed?",
    "ground_truth": 26.0,
    "formulation": null,
    "correct_program": "def optimize_saws():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"woodshop_saws\")\n\n    # Decision variables: number of each saw type\n    x = m.addVar(vtype=GRB.INTEGER, name=\"miter_saws\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"circular_saws\", lb=0)\n\n    # Set the objective: minimize total number of saws\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Wood cutting constraint\n    m.addConstr(50 * x + 70 * y >= 1500, name=\"wood_cutting\")\n    # Sawdust production constraint\n    m.addConstr(60 * x + 100 * y <= 2000, name=\"sawdust_limit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of saws\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_saws = optimize_saws()\n    if min_saws is not None:\n        print(f\"Minimum Total Number of Saws: {min_saws}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A110",
    "description": "In a science club, there are two tables that can be set up to make slime. At table 1, 3 units of powder and 5 units of glue are used to make 4 units of slime. At table 2, 8 units of powder and 6 units of glue are used to make 5 units of slime. However, table 1 produces 2 units of mess while table 2 produces 4 units of mess. The science club has available 100 units of powder and 90 units of glue.  If at most 30 units of mess can be made, how many of each table should be set up to maximize the amount of slime produced?",
    "ground_truth": 60.0,
    "formulation": null,
    "correct_program": "def optimize_slime_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"SlimeProduction\")\n\n    # Decision variables: number of tables at each station\n    x = m.addVar(name=\"Table1\", lb=0)\n    y = m.addVar(name=\"Table2\", lb=0)\n\n    # Set the objective: maximize total slime\n    m.setObjective(4 * x + 5 * y, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    m.addConstr(3 * x + 8 * y <= 100, name=\"Powder\")\n    m.addConstr(5 * x + 6 * y <= 90, name=\"Glue\")\n    m.addConstr(2 * x + 4 * y <= 30, name=\"Mess\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_slime = optimize_slime_production()\n    if max_slime is not None:\n        print(f\"Maximum Slime Production: {max_slime}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A135",
    "description": "A toy store decides to deliver gifts using two shipping companies, a new one and an old one. The new company can deliver 50 gifts per trip while the old company can deliver 70 gifts per trip. The new company uses 30 liters of diesel per trip while the old company uses 40 liters of diesel per trip. The toy store needs to deliver at least 1000 gifts. There can be at most 15 trips made by the new company. In order to make sure that the old company does not go out of business, at least 40% of all trips must be made by the old company. How many trips should each company make to minimize the total amount of diesel used?",
    "ground_truth": 580.0,
    "formulation": null,
    "correct_program": "def optimize_gift_delivery(\n    max_trips_new=15,\n    min_gifts=1000,\n    gifts_per_trip_new=50,\n    gifts_per_trip_old=70,\n    diesel_per_trip_new=30,\n    diesel_per_trip_old=40,\n    min_old_trip_fraction=0.4\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"GiftDeliveryOptimization\")\n    \n    # Decision variables\n    x = model.addVar(vtype=GRB.INTEGER, name=\"x_trips_new\")  # Trips by new company\n    y = model.addVar(vtype=GRB.INTEGER, name=\"y_trips_old\")  # Trips by old company\n    \n    # Set objective: minimize total diesel consumption\n    model.setObjective(\n        diesel_per_trip_new * x + diesel_per_trip_old * y,\n        GRB.MINIMIZE\n    )\n    \n    # Add constraints\n    # Delivery requirement\n    model.addConstr(\n        gifts_per_trip_new * x + gifts_per_trip_old * y >= min_gifts,\n        name=\"DeliveryRequirement\"\n    )\n    # Trips limit for new company\n    model.addConstr(\n        x <= max_trips_new,\n        name=\"MaxTripsNew\"\n    )\n    # Old company trips proportion constraint: y >= 0.4*(x + y)\n    model.addConstr(\n        y >= min_old_trip_fraction * (x + y),\n        name=\"OldTripProportion\"\n    )\n    # Non-negativity constraints are implicit in variable types\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the total diesel used in the optimal solution\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    total_diesel = optimize_gift_delivery()\n    if total_diesel is not None:\n        print(f\"Minimum Total Diesel Consumption: {total_diesel}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A140",
    "description": "A car manufacturer ships their cars on large and small planes. A large plane can carry 30 cars while a small plane can carry 10 cars. Since large planes cause more pollution, the number of large planes must be less than the number of small planes. If the manufacturer wants to deliver at least 300 cars, find the minimum number of planes that can be used.",
    "ground_truth": 16.0,
    "formulation": null,
    "correct_program": "def minimize_planes():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MinimizePlanes\")\n\n    # Decision variables: number of large and small planes\n    L = m.addVar(vtype=GRB.INTEGER, name=\"LargePlanes\", lb=0)\n    S = m.addVar(vtype=GRB.INTEGER, name=\"SmallPlanes\", lb=0)\n\n    # Set the objective: minimize total number of planes\n    m.setObjective(L + S, GRB.MINIMIZE)\n\n    # Capacity constraint: at least 300 cars delivered\n    m.addConstr(30 * L + 10 * S >= 300, name=\"CapacityConstraint\")\n\n    # Relationship constraint: large planes less than small planes\n    m.addConstr(L <= S - 1, name=\"PlaneCountConstraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimum total number of planes\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_planes = minimize_planes()\n    if min_planes is not None:\n        print(f\"Minimum Total Planes: {min_planes}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A125",
    "description": "An international goods exporter uses ships and planes to transport goods. A ship can take 40 containers worth of goods and uses 500 liters of fuel per trip. A plane can take 20 containers worth of goods and uses 300 liters of fuel per trip. The company needs to transport at least 500 containers worth of goods. In addition, there can be at most 10 plane trips made and a minimum of 50% of the trips made must be by ship. How many of each trip should be made to minimize the total amount of fuel consumed?",
    "ground_truth": 6300.0,
    "formulation": null,
    "correct_program": "def optimize_transport(fuel_ship=500, fuel_plane=300, containers_required=500, max_plane_trips=10):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TransportOptimization\")\n\n    # Decision variables\n    x_s = m.addVar(vtype=GRB.INTEGER, name=\"ship_trips\", lb=0)\n    x_p = m.addVar(vtype=GRB.INTEGER, name=\"plane_trips\", lb=0)\n\n    # Set objective: minimize total fuel consumption\n    m.setObjective(fuel_ship * x_s + fuel_plane * x_p, GRB.MINIMIZE)\n\n    # Add constraints\n    # Container requirement\n    m.addConstr(40 * x_s + 20 * x_p >= containers_required, \"containers_min\")\n    # Plane trips limit\n    m.addConstr(x_p <= max_plane_trips, \"max_plane_trips\")\n    # Ship trips at least 50% of total trips\n    m.addConstr(x_s >= x_p, \"ship_at_least_equal_plane\")\n    \n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_fuel = m.objVal\n        return total_fuel\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_fuel = optimize_transport()\n    if min_fuel is not None:\n        print(f\"Minimum Total Fuel Consumption: {min_fuel}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A118",
    "description": "A chemistry teacher teaches her students two experiments, experiment 1 and experiment 2. In experiment 1, 3 units of the red liquid and 4 units of the blue liquid mix to create 5 units of green gas. In experiment 2, 5 units of the red liquid and 3 units of the blue liquid mix to create 6 units of the green gas. In addition, experiment 1 produces 1 units of smelly gas while experiment 2 produces 2 units of smelly gas.  The lab has available 80 units of red liquid and 70 units of blue liquid. If at most 10 units of smelly gas can be produced, how many experiments of each should be done to maximize the total amount of green gas produced?",
    "ground_truth": 50.0,
    "formulation": null,
    "correct_program": "def optimize_green_gas(\n    red_liquid=80,\n    blue_liquid=70,\n    max_smelly_gas=10\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"GreenGasOptimization\")\n\n    # Decision variables: number of experiments (integer, >=0)\n    x1 = model.addVar(vtype=GRB.INTEGER, name=\"Experiment1\")\n    x2 = model.addVar(vtype=GRB.INTEGER, name=\"Experiment2\")\n\n    # Set objective: maximize total green gas\n    model.setObjective(5 * x1 + 6 * x2, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    model.addConstr(3 * x1 + 5 * x2 <= red_liquid, \"RedLiquid\")\n    model.addConstr(4 * x1 + 3 * x2 <= blue_liquid, \"BlueLiquid\")\n    # Add smelly gas constraint\n    model.addConstr(x1 + 2 * x2 <= max_smelly_gas, \"SmellyGas\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_green_gas = optimize_green_gas()\n    if max_green_gas is not None:\n        print(f\"Maximum Total Green Gas: {max_green_gas}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A128",
    "description": "A lawn mowing service provides neighborhood services using small teams and large teams. A small team requires 3 employees and can mow 50 sq ft of lawn. A large team requires 5 employees and can mow 80 sq ft of lawn. The company has 150 employees available. Because most people have smaller lawns in the city, the number of small teams must be at least 3 times as much as the number of large teams. In addition, to make sure the company can meet all demands, there has to be at least 6 large teams and at least 10 small teams. How many of each team type should be used to maximize the amount of lawn that can be mowed?",
    "ground_truth": 2480.0,
    "formulation": null,
    "correct_program": "def optimize_lawn_mowing(small_team_min=10, large_team_min=6, total_employees=150):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"LawnMowingOptimization\")\n    m.setParam('OutputFlag', 0)  # Suppress Gurobi output\n\n    # Decision variables\n    s = m.addVar(vtype=GRB.INTEGER, name=\"small_teams\")\n    l = m.addVar(vtype=GRB.INTEGER, name=\"large_teams\")\n\n    # Set objective: maximize total lawn area\n    m.setObjective(50 * s + 80 * l, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Employee constraint\n    m.addConstr(3 * s + 5 * l <= total_employees, name=\"employee_limit\")\n    # Ratio constraint\n    m.addConstr(s >= 3 * l, name=\"ratio_constraint\")\n    # Minimum number of small teams\n    m.addConstr(s >= small_team_min, name=\"min_small_teams\")\n    # Minimum number of large teams\n    m.addConstr(l >= large_team_min, name=\"min_large_teams\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum lawn area\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_lawn_area = optimize_lawn_mowing()\n    if max_lawn_area is not None:\n        print(f\"Maximum Lawn Area: {max_lawn_area}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Services"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A162",
    "description": "A factory provides rides for its employees in either taxis or company cars. Each taxi ride can take 2 employees while each company car ride can take 3 employees. Since buying and maintaining cars is expensive, at most 60% of the rides can be company car rides. However, there has to be at least 30 company car rides. If the company needs to transport at least 500 employees, how many rides of each should be done to minimize the total number of taxi rides.",
    "ground_truth": 78.0,
    "formulation": null,
    "correct_program": "def optimize_rides():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Employee_Rides_Optimization\")\n    \n    # Decision variables\n    T = m.addVar(name=\"Taxi_Rides\", vtype=GRB.INTEGER, lb=0)\n    C = m.addVar(name=\"Company_Car_Rides\", vtype=GRB.INTEGER, lb=30)\n    \n    # Set objective: minimize taxi rides\n    m.setObjective(T, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Employee transportation constraint\n    m.addConstr(2 * T + 3 * C >= 500, name=\"EmployeeTransport\")\n    \n    # Ratio constraint: T >= (2/3) * C\n    m.addConstr(T >= (2/3) * C, name=\"CarRideRatio\")\n    \n    # C >= 30 is already enforced by lb=30\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal number of taxi rides\n        return T.X\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_taxi_rides = optimize_rides()\n    if min_taxi_rides is not None:\n        print(f\"Minimum number of taxi rides: {min_taxi_rides}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A153",
    "description": "An industrial tire company delivers large tires for equipment to remote engineering sites either by cargo planes or ultrawide trucks. Each cargo plane can transport 10 tires per trip and costs $1000. Each ultrawide truck can transport 6 tires per trip and costs $700. The company needs to transport at least 200 tires and has available $22000. Because most remote sites don't have proper airports, the number of plane trips cannot exceed the number of ultrawide truck trips. How many trips of each should be done to minimize the total number of trips?",
    "ground_truth": 26.0,
    "formulation": null,
    "correct_program": "def optimize_trips():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TireTransportOptimization\")\n\n    # Decision variables\n    x = m.addVar(vtype=GRB.INTEGER, name=\"plane_trips\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"truck_trips\")\n\n    # Set objective: minimize total trips\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Tire delivery constraint\n    m.addConstr(10 * x + 6 * y >= 200, name=\"TireRequirement\")\n    # Budget constraint\n    m.addConstr(1000 * x + 700 * y <= 22000, name=\"Budget\")\n    # Trip ratio constraint\n    m.addConstr(x <= y, name=\"TripRatio\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the total number of trips in the optimal solution\n        total_trips = m.objVal\n        return total_trips\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_trips = optimize_trips()\n    if min_trips is not None:\n        print(f\"Minimum Total Trips: {min_trips}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A222",
    "description": "A railway company is planning the infrastructure for the city and is considering two types of transportation, trains and trams. Each train can transport 120 people per hour comfortably and each tram can transport 30 people per hour comfortably. Since trains take longer to build, the number of trams must be at least twice the number of trains. If the railway company wants to transport at least 600 people per hour, minimize the total number of transportation units required.",
    "ground_truth": 11.0,
    "formulation": null,
    "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TransportationOptimization\")\n\n    # Decision variables: number of trains and trams\n    T = m.addVar(name=\"Trains\", vtype=GRB.INTEGER, lb=0)\n    M = m.addVar(name=\"Trams\", vtype=GRB.INTEGER, lb=0)\n\n    # Set the objective: minimize total units\n    m.setObjective(T + M, GRB.MINIMIZE)\n\n    # Capacity constraint\n    m.addConstr(120 * T + 30 * M >= 600, name=\"CapacityConstraint\")\n\n    # Relationship constraint\n    m.addConstr(M >= 2 * T, name=\"TramTrainRelation\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of units\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_units = optimize_transportation()\n    if min_units is not None:\n        print(f\"Minimum Total Units (Trains + Trams): {min_units}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A043",
    "description": "A honey farmer sells his honey in glass and plastic jars. A glass jar can hold 250 ml of honey while a plastic jar can hold 300 ml of honey. Since glass jars are more expensive, at least twice as many plastic jars must be filled as glass jars. However, at least 20 glass jars should be filled. If the farmer has 20000 ml of honey, how many jars of each should be filled to maximize the total number of bottles filled?",
    "ground_truth": 70.0,
    "formulation": null,
    "correct_program": "def optimize_honey_jars():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"HoneyJarsMaximize\")\n\n    # Decision variables\n    G = m.addVar(name=\"GlassJars\", vtype=GRB.INTEGER, lb=20)  # at least 20 glass jars\n    P = m.addVar(name=\"PlasticJars\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: maximize total number of jars\n    m.setObjective(G + P, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Honey volume constraint\n    m.addConstr(250 * G + 300 * P <= 20000, name=\"HoneyVolume\")\n    # Relationship constraint\n    m.addConstr(P >= 2 * G, name=\"PlasticAtLeastTwiceGlass\")\n    # Non-negativity is enforced by lb=0 for P and lb=20 for G\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum total number of jars filled\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_jars = optimize_honey_jars()\n    if max_jars is not None:\n        print(f\"Maximum Total Jars Filled: {max_jars}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A241",
    "description": "A tourism company can buy sedans or buses to add to their fleet of vehicles to increase their capacity for more tourists. A sedan can seat 50 tourists per day but results in 10 units of pollution. A bus can seat 250 tourists per day but results in 40 units of pollution. The city has limited this tourism company to producing at most 800 units of pollutants per day. To make a profit, this tourism company must take care of at least 4600 customers per day. Planning to make a profit, how many sedans and how many buses should this tourism company purchase to decrease the total number of vehicles needed?",
    "ground_truth": 19.0,
    "formulation": null,
    "correct_program": "def optimize_vehicle_fleet():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TourismFleetOptimization\")\n    \n    # Decision variables: number of sedans and buses\n    x = m.addVar(name=\"sedans\", vtype=GRB.INTEGER, lb=0)\n    y = m.addVar(name=\"buses\", vtype=GRB.INTEGER, lb=0)\n    \n    # Set the objective: minimize total number of vehicles\n    m.setObjective(x + y, GRB.MINIMIZE)\n    \n    # Capacity constraint: at least 4600 tourists\n    m.addConstr(50 * x + 250 * y >= 4600, name=\"capacity\")\n    \n    # Pollution constraint: at most 800 units\n    m.addConstr(10 * x + 40 * y <= 800, name=\"pollution\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of vehicles\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_vehicles = optimize_vehicle_fleet()\n    if min_vehicles is not None:\n        print(f\"Minimum Total Vehicles (Sedans + Buses): {min_vehicles}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Tourism"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A144",
    "description": "A snack exporter sends snacks to his customer in small and large suitcases. A small suitcase can hold 50 snacks while a large suitcase can hold 80 snacks. Most customer prefer small suitcases, and so at least twice as many small suitcases must be used as large suitcases. The exporter has available at most 70 small suitcases and 50 large suitcases. If he must send at least 15 large suitcases and can send  at most 70 suitcases in total, how many of each should he send to maximize the total number of snacks that can be delivered?",
    "ground_truth": 4190.0,
    "formulation": null,
    "correct_program": "def optimize_snacks():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Snack_Suitcases_Maximize\")\n\n    # Decision variables\n    # x: number of small suitcases\n    # y: number of large suitcases\n    x = m.addVar(vtype=GRB.INTEGER, name=\"small_suitcases\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"large_suitcases\")\n\n    # Set objective: maximize total snacks\n    m.setObjective(50 * x + 80 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(x - 2 * y >= 0, \"preference_constraint\")\n    m.addConstr(x <= 70, \"max_small\")\n    m.addConstr(y <= 50, \"max_large\")\n    m.addConstr(y >= 15, \"min_large\")\n    m.addConstr(x + y <= 70, \"total_limit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum total snacks\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_snacks = optimize_snacks()\n    if max_snacks is not None:\n        print(f\"Maximum Snacks in Suitcases: {max_snacks}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A203",
    "description": "In a science fair, there are two types of tables that can be used to display the children’s science experiments. At the circular tables, 4 poster boards and 5 participants can fit around the table to cater to 8 guests. At the rectangular tables, 4 poster boards and 4 participants can fit around the table to cater to 12 guests. However, each circular table takes up 15 units of space while each rectangular table takes up 20 units of space. The science fair has must be able to fit at least 500 participants and 300 poster boards. If the science fair has available 1900 units of space, how many of each type of table should be set up to maximize the number of catered guests?",
    "ground_truth": 1080.0,
    "formulation": null,
    "correct_program": "def optimize_science_fair(\n    min_participants=500,\n    min_posters=300,\n    max_space=1900\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Science_Fair_Tables\")\n\n    # Decision variables: number of circular and rectangular tables\n    x_c = model.addVar(vtype=GRB.INTEGER, name=\"Circular_Tables\", lb=0)\n    x_r = model.addVar(vtype=GRB.INTEGER, name=\"Rectangular_Tables\", lb=0)\n\n    # Set the objective: maximize total guests served\n    model.setObjective(8 * x_c + 12 * x_r, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Participants constraint\n    model.addConstr(5 * x_c + 4 * x_r >= min_participants, \"Participants\")\n    # Poster boards constraint\n    model.addConstr(4 * x_c + 4 * x_r >= min_posters, \"PosterBoards\")\n    # Space constraint\n    model.addConstr(15 * x_c + 20 * x_r <= max_space, \"Space\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_guests = optimize_science_fair()\n    if max_guests is not None:\n        print(f\"Maximum Guests Served: {max_guests}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Event Management"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A152",
    "description": "A village hosts a banquet and provides bike and car transportation for everyone. A bike can take 3 people while a car can take 5 people. Since cars are more expensive, at most 40% of the vehicles can be cars. If the village needs to transport at least 500 people, how many of each vehicle should be used to minimize the total number of bikes needed?",
    "ground_truth": 80.0,
    "formulation": null,
    "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TransportationOptimization\")\n\n    # Decision variables\n    b = m.addVar(vtype=GRB.INTEGER, name=\"bikes\", lb=0)\n    c = m.addVar(vtype=GRB.INTEGER, name=\"cars\", lb=0)\n\n    # Set objective: minimize number of bikes\n    m.setObjective(b, GRB.MINIMIZE)\n\n    # Add capacity constraint\n    m.addConstr(3 * b + 5 * c >= 500, name=\"capacity_constraint\")\n\n    # Add vehicle ratio constraint\n    # c <= (2/3) * b\n    m.addConstr(c <= (2/3) * b, name=\"vehicle_ratio_constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal number of bikes\n        return b.X\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_bikes = optimize_transportation()\n    if min_bikes is not None:\n        print(f\"Minimum number of bikes: {min_bikes}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A225",
    "description": "An airport can either install escalators or elevators. Escalators can transport 20 people every minute whereas elevators can transport 8 people every minute. Escalators take up 5 units of space while elevators take 2 units of space. The airport needs to have enough capacity to transport at least 400 people every minute. Additionally, there must be at least three times more escalators than elevators and at least 2 elevators must be used. How many of each type should the airport install to minimize the total units of space taken?",
    "ground_truth": 100.0,
    "formulation": null,
    "correct_program": "def optimize_transport_infrastructure():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"AirportTransport\")\n\n    # Decision variables\n    # Number of escalators\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Escalators\", lb=0)\n    # Number of elevators\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Elevators\", lb=0)\n\n    # Set objective: minimize total space\n    m.setObjective(5 * x + 2 * y, GRB.MINIMIZE)\n\n    # Capacity constraint\n    m.addConstr(20 * x + 8 * y >= 400, name=\"Capacity\")\n\n    # Ratio constraint: at least three times more escalators than elevators\n    m.addConstr(x >= 3 * y, name=\"Ratio\")\n\n    # Minimum number of elevators\n    m.addConstr(y >= 2, name=\"MinElevators\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total space\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_space = optimize_transport_infrastructure()\n    if min_space is not None:\n        print(f\"Minimum Total Space: {min_space}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A070",
    "description": "A factory has two machines, A and B. Each day, machine A can make 30 items and consumes 100 kWh. Machine B can make 50 items and consumes 120 kWh per day. The factory must produce at least 1000 items per day and has 3000 kWh of electricity available per day. Since there are not many workers that can operate both machines, at most 30% of the machines must be of type B. Further, at least 5 machines of type A should be used. How many of each machine should be used to minimize the total number of machines?",
    "ground_truth": 28.0,
    "formulation": null,
    "correct_program": "def optimize_machines():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Machine_Optimization\")\n    \n    # Decision variables\n    # Number of machine A (at least 5)\n    x_A = m.addVar(vtype=GRB.INTEGER, name=\"x_A\", lb=5)\n    # Number of machine B (non-negative)\n    x_B = m.addVar(vtype=GRB.INTEGER, name=\"x_B\", lb=0)\n    \n    # Set objective: minimize total number of machines\n    m.setObjective(x_A + x_B, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Production constraint\n    m.addConstr(30 * x_A + 50 * x_B >= 1000, \"prod_constraint\")\n    # Electricity constraint\n    m.addConstr(100 * x_A + 120 * x_B <= 3000, \"energy_constraint\")\n    # B proportion constraint\n    m.addConstr(x_B <= (3/7) * x_A, \"b_ratio_constraint\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_machines = x_A.X + x_B.X\n        return total_machines\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_machines = optimize_machines()\n    if min_machines is not None:\n        print(f\"Minimum Total Number of Machines: {min_machines}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A137",
    "description": "A farmer decides to move his cows to a nearby farm using helicopters and trucks. A helicopter can take 3 cows per trip and creates 5 units of pollution. A truck can take 7 cows per trip and creates 10 units of pollution. The farmer needs to transport 80 cows and he only has enough money for at most 8 truck trips. How many of each type of trip should be taken to minimize the total amount of pollution produced?",
    "ground_truth": 120.0,
    "formulation": null,
    "correct_program": "def optimize_cow_transport():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"CowTransport\")\n\n    # Decision variables\n    h = m.addVar(vtype=GRB.INTEGER, name=\"HelicopterTrips\", lb=0)\n    t = m.addVar(vtype=GRB.INTEGER, name=\"TruckTrips\", lb=0)\n\n    # Set objective: minimize total pollution\n    m.setObjective(5 * h + 10 * t, GRB.MINIMIZE)\n\n    # Add constraints\n    # Ensure at least 80 cows are transported\n    m.addConstr(3 * h + 7 * t >= 80, \"CowsTransported\")\n    # Limit on number of truck trips\n    m.addConstr(t <= 8, \"TruckLimit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total pollution\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pollution = optimize_cow_transport()\n    if min_pollution is not None:\n        print(f\"Minimum Total Pollution: {min_pollution}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A145",
    "description": "A mail delivery service in an island village delivers mail by regular and speed boats. A regular boat can carry 20 pieces of mail per trip and uses 10 liters of gas. A speed boat can carry 30 pieces of mail per trip and uses 20 liters of gas. There can be at most 20 regular boat trips. Since customers want their mail as fast as possible, at least 50% of the trips must be made by speed boats. If the service needs to deliver 1000 pieces of mail, how many trips of each should be made to minimize the total amount of gas consumed?",
    "ground_truth": 600.0,
    "formulation": null,
    "correct_program": "def optimize_mail_delivery():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MailDeliveryOptimization\")\n    \n    # Decision variables\n    R = m.addVar(vtype=GRB.INTEGER, name=\"RegularTrips\", lb=0, ub=20)\n    S = m.addVar(vtype=GRB.INTEGER, name=\"SpeedTrips\", lb=0)\n    \n    # Set objective: minimize total gas consumption\n    m.setObjective(10 * R + 20 * S, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Mail delivery constraint\n    m.addConstr(20 * R + 30 * S >= 1000, name=\"MailDelivery\")\n    # Regular trips limit\n    m.addConstr(R <= 20, name=\"MaxRegularTrips\")\n    # Speed trips at least 50% of total trips\n    m.addConstr(S >= R, name=\"SpeedAtLeastHalf\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total gas consumption\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_gas = optimize_mail_delivery()\n    if min_gas is not None:\n        print(f\"Minimum Total Gas Consumption: {min_gas}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A164",
    "description": "A shipping company need to transport packages by either truck or car. A truck can transport 50 packages per trip while a car can transport 30 packages per trip. In addition, a truck uses 20 liters of gas per trip while a car uses 15 liters of gas per trip. There can be at most 5 truck trips made and at least 30% of all the trips must be made by car. The company needs to transport at least 500 packages. How many of each transportation should they use to minimize the total amount of gas consumed?",
    "ground_truth": 230.0,
    "formulation": null,
    "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TransportationOptimization\")\n\n    # Decision variables\n    T = m.addVar(vtype=GRB.INTEGER, name=\"TruckTrips\", lb=0, ub=5)\n    C = m.addVar(vtype=GRB.INTEGER, name=\"CarTrips\", lb=0)\n\n    # Set objective: minimize total gas consumption\n    m.setObjective(20 * T + 15 * C, GRB.MINIMIZE)\n\n    # Add constraints\n    # Capacity constraint\n    m.addConstr(50 * T + 30 * C >= 500, name=\"PackageRequirement\")\n    # Trip ratio constraint\n    m.addConstr(C >= (3/7) * T, name=\"CarTripRatio\")\n    # T is at most 5 (already set as ub=5)\n    # T >= 0 (lb=0), C >= 0 (lb=0)\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total gas consumption\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_gas_consumption = optimize_transportation()\n    if min_gas_consumption is not None:\n        print(f\"Minimum Total Gas Consumption: {min_gas_consumption}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A143",
    "description": "A company in the middle east delivers their packages to customers on camels and horses. A camel can carry 50 packages while a horse can carry 60 packages. A camel requires 20 units of food while a horse requires 30 units of food. The company needs to deliver at least 1000 packages and they have 450 units of food available. Since horses are not as suited for the hot climate, the number of horses cannot exceed the number of camels. How many of each animal should be used to minimize the total number of animals?",
    "ground_truth": 19.0,
    "formulation": null,
    "correct_program": "def optimize_animals():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Animal_Optimization\")\n\n    # Decision variables\n    C = m.addVar(vtype=GRB.INTEGER, name=\"Camels\", lb=0)\n    H = m.addVar(vtype=GRB.INTEGER, name=\"Horses\", lb=0)\n\n    # Set objective: minimize total number of animals\n    m.setObjective(C + H, GRB.MINIMIZE)\n\n    # Add constraints\n    # Package capacity constraint\n    m.addConstr(50 * C + 60 * H >= 1000, name=\"PackageCapacity\")\n    # Food constraint\n    m.addConstr(20 * C + 30 * H <= 450, name=\"FoodLimit\")\n    # Horse-to-camel ratio\n    m.addConstr(H <= C, name=\"HorseCamelRatio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_animals = m.objVal\n        return total_animals\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_animals = optimize_animals()\n    if min_animals is not None:\n        print(f\"Minimum Total Animals (Camels + Horses): {min_animals}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A170",
    "description": "A volunteer organization transports voters to the polls on Election Day either by vans or cars. They have vans which can carry 6 people and cars which can carry 3 people.  They need to transport at least 200 voters to the polls. In addition, at most 30% of the vehicles can be vans. How many of each vehicle should be used to minimize the total number of cars used?",
    "ground_truth": 37.0,
    "formulation": null,
    "correct_program": "def optimize_vehicle_allocation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"VoterTransport\")\n\n    # Decision variables\n    V = m.addVar(vtype=GRB.INTEGER, name=\"Vans\")\n    C = m.addVar(vtype=GRB.INTEGER, name=\"Cars\")\n\n    # Set objective: minimize number of cars\n    m.setObjective(C, GRB.MINIMIZE)\n\n    # Capacity constraint: total capacity ≥ 200 voters\n    m.addConstr(6 * V + 3 * C >= 200, name=\"Capacity\")\n\n    # Vehicle ratio constraint: vans ≤ 30% of total vehicles\n    # Derived as: 7V ≤ 3C\n    m.addConstr(7 * V <= 3 * C, name=\"Vans_ratio\")\n\n    # Non-negativity constraints are implicit in variable definitions\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal number of cars used\n        return C.X\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cars = optimize_vehicle_allocation()\n    if min_cars is not None:\n        print(f\"Minimum number of cars needed: {min_cars}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Social Services"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A100",
    "description": "A science store makes two boxes, a cheap and expensive box. The cheap box contains 3 units of metal and 5 units of acid which can be mixed to create 8 units of foam. The expensive box contains 5 units of metal and 8 units of acid which can be mixed to create 10 units of foam. The cheap box however gives off 2 units of heat while the expensive box gives off 3 units of heat. The science store has available 200 units of metal and 300 units of acid. If at most 50 units of heat can be given off, how many of each box should the store make to maximize the amount of foam produced?",
    "ground_truth": 200.0,
    "formulation": null,
    "correct_program": "def optimize_foam(max_metal=200, max_acid=300, max_heat=50):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"FoamProduction\")\n\n    # Decision variables: number of cheap and expensive boxes\n    x = model.addVar(vtype=GRB.INTEGER, name=\"CheapBoxes\", lb=0)\n    y = model.addVar(vtype=GRB.INTEGER, name=\"ExpensiveBoxes\", lb=0)\n\n    # Set the objective: maximize foam\n    model.setObjective(8 * x + 10 * y, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    model.addConstr(3 * x + 5 * y <= max_metal, \"MetalConstraint\")\n    model.addConstr(5 * x + 8 * y <= max_acid, \"AcidConstraint\")\n    model.addConstr(2 * x + 3 * y <= max_heat, \"HeatConstraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_foam = optimize_foam()\n    if max_foam is not None:\n        print(f\"Maximum Foam Produced: {max_foam}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A063",
    "description": "An airport buys two types of vehicles, a 4-wheeler and 3-wheeler, to help move luggage. A 4-wheeler vehicle can move 60 luggage per day and produces 30 units of pollutant per day. A 3-wheeler vehicle can move 40 luggage per day and produces 15 units of pollutant per day. The airport needs to be able to move at least 1000 luggage per day. To avoid over-polluting the airport, they can produce at most 430 units of pollutant per day. How many of each vehicle should the airport buy to minimize the total number of vehicles needed.  ",
    "ground_truth": 22.0,
    "formulation": null,
    "correct_program": "def optimize_vehicles():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"airport_vehicles\")\n\n    # Decision variables: number of 4-wheelers and 3-wheelers\n    x = m.addVar(vtype=GRB.INTEGER, name=\"x\")  # 4-wheeler\n    y = m.addVar(vtype=GRB.INTEGER, name=\"y\")  # 3-wheeler\n\n    # Set the objective: minimize total number of vehicles\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Luggage capacity constraint\n    m.addConstr(60 * x + 40 * y >= 1000, \"luggage_constraint\")\n    # Pollution constraint\n    m.addConstr(30 * x + 15 * y <= 430, \"pollution_constraint\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_vehicles = optimize_vehicles()\n    if min_vehicles is not None:\n        print(f\"Minimum Total Number of Vehicles: {min_vehicles}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A227",
    "description": "Due to an accident, at least 550 locals must be moved across a lake. They can either be transported over the lake by a kayak or a motorboat. Kayaks can transport 4 people every trip and motorboats can transport 5 people every trip. Kayaks take 5 minutes per trip whereas motorboats take 3 minutes per trip. Due to the limited number of motorboats available to the locals, there can be at most 25 motorboat trips and at least 75% of the trips should be by kayak. How many of each transportation method should be used to minimize the total amount of time needed to transport all the locals?",
    "ground_truth": 610.0,
    "formulation": null,
    "correct_program": "def optimize_transportation(min_people=550, max_motor_trips=25, kayak_time=5, motor_time=3, min_kayak_ratio=0.75):\n    from gurobipy import Model, GRB\n    \n    # Create a new model\n    m = Model(\"LakeTransport\")\n    \n    # Decision variables\n    # k: number of kayak trips\n    # m_trips: number of motorboat trips\n    k = m.addVar(vtype=GRB.INTEGER, name=\"kayak_trips\", lb=0)\n    m_trips = m.addVar(vtype=GRB.INTEGER, name=\"motorboat_trips\", lb=0)\n    \n    # Set objective: minimize total time\n    m.setObjective(kayak_time * k + motor_time * m_trips, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Capacity constraint: at least min_people transported\n    m.addConstr(4 * k + 5 * m_trips >= min_people, \"capacity\")\n    \n    # Motorboat trip limit\n    m.addConstr(m_trips <= max_motor_trips, \"max_motor_trips\")\n    \n    # Trip ratio constraint: at least 75% trips are by kayak\n    m.addConstr(k >= 3 * m_trips, \"trip_ratio\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_time = m.objVal\n        return total_time\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_transportation()\n    if min_time is not None:\n        print(f\"Minimum Total Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A047",
    "description": "An ice cream store can buy two machines, a counter-top sized one and a fridge sized one, to make ice cream. The counter-top sized one can produce 80 cones worth of ice cream every day while the fridge sizes one can produce 150 cones worth of ice cream every day. The counter-top sized machine outputs 50 units of heat while the fridge sized one outputs 70 units of heat. The ice cream store can output at most 500 units of heat per day and must produce at least 1000 cones worth of ice cream. How many of each machine should they buy to minimize the total number of machines needed?",
    "ground_truth": 7.0,
    "formulation": null,
    "correct_program": "def optimize_machines():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"IceCreamMachineOptimization\")\n\n    # Decision variables: number of each machine type\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Countertop\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Fridge\", lb=0)\n\n    # Set the objective: minimize total number of machines\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add production constraint\n    m.addConstr(80 * x + 150 * y >= 1000, name=\"ProductionRequirement\")\n\n    # Add heat constraint\n    m.addConstr(50 * x + 70 * y <= 500, name=\"HeatLimit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of machines\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_machines = optimize_machines()\n    if min_machines is not None:\n        print(f\"Minimum Total Number of Machines: {min_machines}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A053",
    "description": "A bank can build small and large branches to serve their customers. A small branch can serve 50 customers per day and requires 10 bank tellers. A large branch can serve 100 customers per day and requires 15 bank tellers. The bank has available 200 bank tellers and needs to be able to serve at least 1200 customers per day. How many of each branch size should they build to minimize the total number of branches needed?",
    "ground_truth": 12.0,
    "formulation": null,
    "correct_program": "def optimize_branches():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"BankBranches\")\n\n    # Decision variables: number of small and large branches\n    x = m.addVar(vtype=GRB.INTEGER, name=\"small_branches\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"large_branches\", lb=0)\n\n    # Set the objective: minimize total number of branches\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add customer service constraint\n    m.addConstr(50 * x + 100 * y >= 1200, name=\"CustomerService\")\n\n    # Add teller constraint\n    m.addConstr(10 * x + 15 * y <= 200, name=\"TellerAvailability\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal value of the objective function\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_branches = optimize_branches()\n    if min_branches is not None:\n        print(f\"Minimum Total Number of Branches: {min_branches}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A158",
    "description": "A factory transports rice to the city in horse-drawn carts that are either medium or large size. A medium sized cart requires 2 horses and can carry 30 kg of rice. A large sized cart requires 4 horses and can carry 70 kg of rice.  The factory has 60 horses available. Because the horses don't get along well, the number of medium sized carts must be three times the number of large sized carts. In addition, there must be at least 5 medium sized carts and at least 5 large sized carts. How many of each cart size should be used to maximize the amount of rice that can be transported?",
    "ground_truth": 960.0,
    "formulation": null,
    "correct_program": "def optimize_rice_transport():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"RiceTransport\")\n\n    # Decision variables\n    # Since M = 3L, we only need to define L, and M is derived\n    L = m.addVar(vtype=GRB.INTEGER, name=\"L\")\n    M = m.addVar(vtype=GRB.INTEGER, name=\"M\")\n\n    # Set the objective: maximize total rice transported\n    # Total rice = 30*M + 70*L\n    # Since M = 3L, total rice = 90*L + 70*L = 160*L\n    m.setObjective(160 * L, GRB.MAXIMIZE)\n\n    # Add constraints\n    # M = 3L\n    m.addConstr(M == 3 * L, \"cart_relation\")\n    # Horse constraint\n    m.addConstr(2 * M + 4 * L <= 60, \"horse_limit\")\n    # Minimum carts\n    m.addConstr(L >= 5, \"min_large_carts\")\n    m.addConstr(M >= 5, \"min_medium_carts\")\n    # Link M and L to ensure integrality and consistency\n    # (M is defined as 3L, but to ensure M is integer, L must be integer)\n    # Already defined as integer, so no extra constraint needed\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Retrieve the value of L\n        optimal_L = int(L.X)\n        # Compute M\n        optimal_M = int(M.X)\n        # Compute total rice\n        total_rice = 160 * optimal_L\n        return total_rice\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_rice = optimize_rice_transport()\n    if max_rice is not None:\n        print(f\"Maximum Total Rice Transported: {max_rice} kg\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A207",
    "description": "A singer has two types of concerts he can hold, pop and R&B. Each pop concert will bring in 100 audience members and take 2 days of practice. Every R&B concert brings in 240 audience members and takes 4 days of practice. The singer must bring in at least 10000 audience members and only has available 180 days for practice. If he can at most perform 40% of his concerts as R&B because he likes pop songs more, how many of each type of concert should be created to minimize the total number of concerts?",
    "ground_truth": 65.0,
    "formulation": null,
    "correct_program": "def optimize_concerts():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"ConcertOptimization\")\n\n    # Decision variables: number of pop and R&B concerts\n    x = m.addVar(vtype=GRB.INTEGER, name=\"PopConcerts\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"R&BConcerts\", lb=0)\n\n    # Set the objective: minimize total number of concerts\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Audience constraint\n    m.addConstr(100 * x + 240 * y >= 10000, \"AudienceRequirement\")\n\n    # Practice days constraint\n    m.addConstr(2 * x + 4 * y <= 180, \"PracticeDaysLimit\")\n\n    # R&B performance limit: y <= (2/3) * x\n    m.addConstr(y <= (2/3) * x, \"R&B_Performance_Limit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_concerts = m.objVal\n        return total_concerts\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_concerts = optimize_concerts()\n    if min_concerts is not None:\n        print(f\"Minimum Total Concerts: {min_concerts}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Entertainment"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A133",
    "description": "A meat shop ships their burger patties using refrigerated trucks and vans. Each truck can take 1000 patties at a cost of $300 per trip. Each van can take 500 patties at a cost of $100 per trip. Because the trucks have difficulty moving around in the city, the number of trucks must not exceed the number of vans. The meat shop has to ship at least 50000 patties and they have a budget of $12500. How should they plan their shipment to minimize the total number of trips?",
    "ground_truth": 75.0,
    "formulation": null,
    "correct_program": "def optimize_shipment():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Meat_Shipment\")\n\n    # Decision variables: number of truck trips and van trips\n    T = m.addVar(vtype=GRB.INTEGER, name=\"TruckTrips\", lb=0)\n    V = m.addVar(vtype=GRB.INTEGER, name=\"VanTrips\", lb=0)\n\n    # Set the objective: minimize total trips\n    m.setObjective(T + V, GRB.MINIMIZE)\n\n    # Capacity constraint: at least 50,000 patties shipped\n    m.addConstr(1000 * T + 500 * V >= 50000, name=\"DemandConstraint\")\n\n    # Budget constraint: total cost not exceeding $12,500\n    m.addConstr(300 * T + 100 * V <= 12500, name=\"BudgetConstraint\")\n\n    # Vehicle count constraint: trucks not more than vans\n    m.addConstr(T <= V, name=\"VehicleCountConstraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal total number of trips\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_trips = optimize_shipment()\n    if min_trips is not None:\n        print(f\"Minimum Total Trips (Trucks + Vans): {min_trips}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A147",
    "description": "Children can go to school either by van or by minibus. A van can take 6 kids and produces 7 units of pollution. A minibus can take 10 kids and produced 10 units of pollution. There are at least 150 kids than need to go to school and at most 10 minibuses can be used. In addition, the number of vans used must exceed the number of minibuses. How many of each should be used to minimize the total amount of pollution produced?",
    "ground_truth": 160.0,
    "formulation": null,
    "correct_program": "def optimize_transportation(pollution_van=7, pollution_minibus=10, capacity_van=6, capacity_minibus=10, min_kids=150, max_minibuses=10):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"SchoolTransportPollutionMinimization\")\n    \n    # Decision variables\n    V = m.addVar(vtype=GRB.INTEGER, name=\"Vans\", lb=0)\n    M = m.addVar(vtype=GRB.INTEGER, name=\"Minibuses\", lb=0)\n    \n    # Set objective: minimize total pollution\n    m.setObjective(pollution_van * V + pollution_minibus * M, GRB.MINIMIZE)\n    \n    # Capacity constraint: at least 150 kids transported\n    m.addConstr(capacity_van * V + capacity_minibus * M >= min_kids, name=\"Capacity\")\n    \n    # Max number of minibuses\n    m.addConstr(M <= max_minibuses, name=\"MaxMinibuses\")\n    \n    # Vans must exceed minibuses: V > M\n    # Gurobi does not support strict inequalities directly, so we model V >= M + 1\n    m.addConstr(V >= M + 1, name=\"V_greater_than_M\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the total pollution of the optimal solution\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pollution = optimize_transportation()\n    if min_pollution is not None:\n        print(f\"Minimum Total Pollution: {min_pollution}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A155",
    "description": "A tropical city full of islands sends mail either by submarine or by boat. A submarine can carry 100 pieces of mail per trip and uses 30 liters of gas. A boat can carry 80 pieces of mail per trip and uses 25 liters of gas. There can be at most 6 submarine trips and a minimum of 50% of the trips must be by boat. If the city needs to transport at least 1000 pieces of mail, how many of each transportation should they use to minimize the total amount of gas used?",
    "ground_truth": 310.0,
    "formulation": null,
    "correct_program": "def optimize_mail_transport(\n    max_sub_trips=6,\n    min_total_mail=1000,\n    mail_per_sub=100,\n    mail_per_boat=80,\n    gas_per_sub=30,\n    gas_per_boat=25\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"MailTransportMinGas\")\n\n    # Decision variables: number of trips by submarine and boat\n    x = model.addVar(vtype=GRB.INTEGER, name=\"submarine_trips\")\n    y = model.addVar(vtype=GRB.INTEGER, name=\"boat_trips\")\n\n    # Set objective: minimize total gas\n    model.setObjective(gas_per_sub * x + gas_per_boat * y, GRB.MINIMIZE)\n\n    # Add constraints\n    model.addConstr(x <= max_sub_trips, \"max_sub_trips\")\n    model.addConstr(mail_per_sub * x + mail_per_boat * y >= min_total_mail, \"mail_requirement\")\n    model.addConstr(y >= x, \"boat_at_least_half\")  # y >= x\n\n    # Non-negativity constraints are implicit in variable definitions\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal total gas used\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    total_gas = optimize_mail_transport()\n    if total_gas is not None:\n        print(f\"Minimum Total Gas Consumption: {total_gas}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A156",
    "description": "The weather is freezing and the fish in the pond need to be transported either by helicopter or car. A helicopter can take 30 fish per trip and takes 40 minutes. A car can take 20 fish per trip and takes 30 minutes. Since helicopter trips are expensive, there can be at most 5 helicopter trips. In addition, at least 60% of the trips should be by car. If at least 300 fish need to transported, how many of each trip should be taken to minimize the total time needed?",
    "ground_truth": 430.0,
    "formulation": null,
    "correct_program": "def optimize_fish_transport():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"FishTransport\")\n\n    # Decision variables\n    h = m.addVar(vtype=GRB.INTEGER, name=\"helicopter_trips\", lb=0, ub=5)\n    c = m.addVar(vtype=GRB.INTEGER, name=\"car_trips\", lb=0)\n\n    # Set objective: minimize total time\n    m.setObjective(40 * h + 30 * c, GRB.MINIMIZE)\n\n    # Add constraints\n    # Fish transported constraint\n    m.addConstr(30 * h + 20 * c >= 300, name=\"fish_transport\")\n    # Trip proportion constraint\n    m.addConstr(c >= 1.5 * h, name=\"car_min_trips\")\n    # h <= 5 is already enforced by ub=5\n    # Non-negativity is enforced by lb=0\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total time\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_fish_transport()\n    if min_time is not None:\n        print(f\"Minimum Total Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A046",
    "description": "A cell phone company is building rural and urban factories. A rural factory can make 100 phones per day and requires 8 managers. An urban factory can make 200 phones per day and requires 20 managers. The company has available 260 managers and must make at least 3000 phones per day. How many of each factory type should be built to minimize the total number of factories?",
    "ground_truth": 25.0,
    "formulation": null,
    "correct_program": "def optimize_factory_selection(\n    min_phones=3000,\n    max_managers=260,\n    rural_phones=100,\n    urban_phones=200,\n    rural_managers=8,\n    urban_managers=20\n):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Factory_Optimization\")\n    m.setParam('OutputFlag', 0)  # Suppress Gurobi output\n\n    # Decision variables: number of rural and urban factories\n    R = m.addVar(vtype=GRB.INTEGER, name=\"Rural_Factories\", lb=0)\n    U = m.addVar(vtype=GRB.INTEGER, name=\"Urban_Factories\", lb=0)\n\n    # Set the objective: minimize total number of factories\n    m.setObjective(R + U, GRB.MINIMIZE)\n\n    # Add production constraint\n    m.addConstr(rural_phones * R + urban_phones * U >= min_phones, \"Production_Constraint\")\n\n    # Add manager constraint\n    m.addConstr(rural_managers * R + urban_managers * U <= max_managers, \"Manager_Constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_factories = optimize_factory_selection()\n    if min_factories is not None:\n        print(f\"Minimum Total Number of Factories: {min_factories}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A211",
    "description": "A dim sum restaurant can deliver their food by cart or by hand. Servers can deliver by cart and have 70 customer interactions and will have to refill food five times an hour. They can also deliver more food by hand, due to the increased mobility, and have 85 customer interactions while refilling food twenty times an hour. However, the customers get more options when delivering by cart, therefore at least 70% of delivery shifts must be by cart. There must be at least 3 servers delivering by hand for their direct customer service. If the restaurant wants to have 4000 customer interactions per hour, how many of each form of delivery should the dim sum restaurant schedule to minimize the total number of refills per hour?",
    "ground_truth": 330.0,
    "formulation": null,
    "correct_program": "def optimize_delivery_schedule():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"DimSumDeliveryOptimization\")\n    \n    # Decision variables\n    # x: number of cart delivery shifts per hour\n    # y: number of hand delivery shifts per hour\n    x = m.addVar(vtype=GRB.INTEGER, name=\"x\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"y\", lb=3)  # at least 3 servers delivering by hand\n    \n    m.update()\n    \n    # Add constraints\n    # Customer interactions constraint\n    m.addConstr(70 * x + 85 * y >= 4000, name=\"Interactions\")\n    \n    # Delivery proportion constraint: x >= (7/3) y\n    m.addConstr(x >= (7/3) * y, name=\"DeliveryProportion\")\n    \n    # Objective: minimize total refills\n    # Refills = 5x + 20y\n    m.setObjective(5 * x + 20 * y, GRB.MINIMIZE)\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total refills\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_refills = optimize_delivery_schedule()\n    if min_refills is not None:\n        print(f\"Minimum Total Refills: {min_refills}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Food Service"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A136",
    "description": "A zoo needs to transport their monkeys to the vet either by bus or by car. A bus can transport 20 monkeys per trip and takes 30 minutes. A car can transport 6 monkeys per trip and takes 15 minutes. There can be at most 10 bus trips. In addition, since the monkeys get aggressive when there are too many in one place at least 60% of the trips should be by car. If the zoo needs to transport 300 monkeys, how many trips of each should be done to minimize the total time required to transport the monkeys?",
    "ground_truth": 555.0,
    "formulation": null,
    "correct_program": "def optimize_monkey_transport():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MonkeyTransport\")\n\n    # Decision variables\n    x_b = m.addVar(vtype=GRB.INTEGER, name=\"bus_trips\")\n    x_c = m.addVar(vtype=GRB.INTEGER, name=\"car_trips\")\n\n    # Set objective: minimize total time\n    m.setObjective(30 * x_b + 15 * x_c, GRB.MINIMIZE)\n\n    # Add constraints\n    # Capacity constraint\n    m.addConstr(20 * x_b + 6 * x_c >= 300, name=\"capacity\")\n    # Bus trip limit\n    m.addConstr(x_b <= 10, name=\"max_bus_trips\")\n    # Proportion constraint (2 * x_c >= 3 * x_b)\n    m.addConstr(2 * x_c >= 3 * x_b, name=\"car_ratio\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal total time\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_monkey_transport()\n    if min_time is not None:\n        print(f\"Minimum Total Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A077",
    "description": "A candy company is making peach flavored candy and cherry flavored candy. Each pack of peach flavored candy requires 3 units of peach flavoring and 5 units of special syrup. Each pack of cherry flavored candy requires 5 units of cherry flavoring and 4 units of special syrup. The company has available 3000 units of peach flavoring and 4000 units of cherry flavoring. Peach candy is much more popular and thus the number of peach candy packs must be larger than the number of cherry candy packs. In addition, at least 30% of the pack must be cherry flavored. How many of each should be made to minimize the total amount of special syrup used?",
    "ground_truth": 14.0,
    "formulation": null,
    "correct_program": "def optimize_candy_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"CandyProduction\")\n\n    # Decision variables: number of peach and cherry packs\n    P = m.addVar(vtype=GRB.INTEGER, name=\"PeachPacks\", lb=0)\n    C = m.addVar(vtype=GRB.INTEGER, name=\"CherryPacks\", lb=0)\n\n    # Set the objective: minimize total syrup used\n    m.setObjective(5 * P + 4 * C, GRB.MINIMIZE)\n\n    # Flavoring constraints\n    m.addConstr(P <= 1000, \"PeachFlavorLimit\")\n    m.addConstr(C <= 800, \"CherryFlavorLimit\")\n\n    # Popularity constraint: peach packs > cherry packs\n    # Note: Gurobi does not support strict inequalities directly.\n    # To enforce P > C, we can model as P >= C + 1\n    m.addConstr(P >= C + 1, \"PopularityConstraint\")\n\n    # Cherry proportion constraint: C >= (3/7)*P\n    # To avoid fractional coefficients, multiply both sides by 7\n    m.addConstr(7 * C >= 3 * P, \"CherryProportion\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total syrup usage\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_syrup = optimize_candy_production()\n    if min_syrup is not None:\n        print(f\"Minimum Total Syrup Usage: {min_syrup}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A054",
    "description": "A shipping company can purchase regular and hybrid vans to make deliveries. A regular van can deliver 500 packages per day and produces 200 units of pollutants. A hybrid van can deliver 300 packages per day and produces 100 units of pollutants. Due to a new environmental law, they can produce at most 7000 units of pollutants per day. However, the company needs to be able to deliver at least 20000 packages per day. How many of each type of van should they buy to minimize the total number of vans needed?",
    "ground_truth": 60.0,
    "formulation": null,
    "correct_program": "def optimize_vans():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Vans_Optimization\")\n\n    # Decision variables: number of regular and hybrid vans\n    x = m.addVar(vtype=GRB.INTEGER, name=\"RegularVans\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"HybridVans\", lb=0)\n\n    # Set the objective: minimize total vans\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add delivery constraint\n    m.addConstr(500 * x + 300 * y >= 20000, name=\"DeliveryRequirement\")\n\n    # Add pollution constraint\n    m.addConstr(200 * x + 100 * y <= 7000, name=\"PollutionLimit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of vans\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_vans = optimize_vans()\n    if min_vans is not None:\n        print(f\"Minimum Total Number of Vans: {min_vans}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A230",
    "description": "A golf course is hosting an event and can transport guests using either golf carts or pull carts. A golf cart can take 4 guests while a pull cart can take 1 guest. Since golf carts take up a lot of space, at most 60% of carts can be golf carts. If the golf course needs to transport at least 80 guests, how many of each cart should be used to minimize the total number of carts needed?",
    "ground_truth": 29.0,
    "formulation": null,
    "correct_program": "def optimize_carts():\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Golf_Carts_Optimization\")\n\n    # Decision variables: number of golf carts (G) and pull carts (P)\n    G = model.addVar(vtype=GRB.INTEGER, name=\"GolfCarts\", lb=0)\n    P = model.addVar(vtype=GRB.INTEGER, name=\"PullCarts\", lb=0)\n\n    # Set the objective: minimize total carts\n    model.setObjective(G + P, GRB.MINIMIZE)\n\n    # Add constraints\n    # Guest transportation constraint\n    model.addConstr(4 * G + P >= 80, name=\"GuestTransport\")\n    # Cart composition ratio constraint\n    model.addConstr(2 * G <= 3 * P, name=\"CartRatio\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal total number of carts\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_carts = optimize_carts()\n    if min_carts is not None:\n        print(f\"Minimum Total Carts (Golf + Pull): {min_carts}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Recreation & Hospitality"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A130",
    "description": "A shoe company supplies shoes to stores via vans and trucks. A van can transport 50 pairs of shoes while a truck can transport 100 pairs of shoes. The company must supply a minimum of 2000 pairs of shoes around the city. Since most stores are small, the number of trucks used cannot exceed the number of vans used.  Find the minimum number of vans that can be used?",
    "ground_truth": 14.0,
    "formulation": null,
    "correct_program": "def minimize_vans():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Minimize_Vans\")\n\n    # Decision variables\n    V = m.addVar(vtype=GRB.INTEGER, name=\"Vans\", lb=0)\n    T = m.addVar(vtype=GRB.INTEGER, name=\"Trucks\", lb=0)\n\n    # Set objective: minimize number of vans\n    m.setObjective(V, GRB.MINIMIZE)\n\n    # Add constraints\n    # Supply constraint\n    m.addConstr(50 * V + 100 * T >= 2000, name=\"Supply\")\n    # Truck-to-van ratio constraint\n    m.addConstr(T <= V, name=\"Truck_Van_Ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimum number of vans used\n        return V.X\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_vans = minimize_vans()\n    if min_vans is not None:\n        print(f\"Minimum number of vans used: {min_vans}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A037",
    "description": "A sandwich company can open two types of stores, a dine-in place and a food-truck. A dine-in place can make 100 sandwiches per day and requires 8 employees to operate. A food-truck can make 50 sandwiches per day and requires 3 employees to operate. The company must make at least 500 sandwiches per day but they only have available 35 employees. How many of each type of store should the company open to minimize the total number of stores?",
    "ground_truth": 8.0,
    "formulation": null,
    "correct_program": "def optimize_stores():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Minimize_Stores\")\n\n    # Decision variables: number of dine-in stores and food-trucks\n    x = m.addVar(vtype=GRB.INTEGER, name=\"dine_in\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"food_truck\")\n\n    # Set the objective: minimize total number of stores\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Sandwich production constraint\n    m.addConstr(100 * x + 50 * y >= 500, \"sandwich_requirement\")\n    # Employee constraint\n    m.addConstr(8 * x + 3 * y <= 35, \"employee_limit\")\n    # Non-negativity constraints are implicit in variable definitions\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of stores\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_stores = optimize_stores()\n    if min_stores is not None:\n        print(f\"Minimum Number of Stores: {min_stores}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A134",
    "description": "A florist transports his flowers to stores in small bouquets and large bouquets. A small bouquet has 5 flowers while a large bouquet has 10 flowers. The florist can transport at most 80 small bouquets and 50 large bouquets. In total, he can transport at most 70 bouquets and he must transport at least 20 large bouquets. Since small bouquets are more popular, he must transport at least twice as many small bouquets as large bouquets. How many of each bouquet should he transport to maximize the total number of flowers that reach the stores?",
    "ground_truth": 465.0,
    "formulation": null,
    "correct_program": "def optimize_bouquets():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"FlowerBouquets\")\n\n    # Decision variables\n    S = m.addVar(vtype=GRB.INTEGER, name=\"SmallBouquets\")\n    L = m.addVar(vtype=GRB.INTEGER, name=\"LargeBouquets\")\n\n    # Set objective: maximize total flowers\n    m.setObjective(5 * S + 10 * L, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(S <= 80, name=\"MaxSmall\")\n    m.addConstr(L <= 50, name=\"MaxLarge\")\n    m.addConstr(S + L <= 70, name=\"TotalBouquets\")\n    m.addConstr(L >= 20, name=\"MinLarge\")\n    m.addConstr(S >= 2 * L, name=\"SmallAtLeastTwiceLarge\")\n    m.addConstr(S >= 0, name=\"NonNegSmall\")\n    m.addConstr(L >= 0, name=\"NonNegLarge\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum total number of flowers\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_flowers = optimize_bouquets()\n    if max_flowers is not None:\n        print(f\"Maximum Total Flowers: {max_flowers}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A221",
    "description": "An autobody shop needs to purchase two types of car jacks, an automatic electric one, or a gas-powered one. The automatic electric one can process 5 cars every hour and uses 6 units of electricity whereas the gas-powered one can process 4 cars each hour using 7 units of gas. Since there is a limit to how many automatic electric ones there can be due to the limited number of power outlets, the shop must use less than 15 automatic electric ones. The shop can use at most 50 units of electricity and 80 units of gas. How many of each type of jack should the shop purchase to maximize the amount of cars processed every hour?",
    "ground_truth": 84.0,
    "formulation": null,
    "correct_program": "def optimize_car_jacks():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"CarJacksOptimization\")\n    \n    # Decision variables\n    # x: number of automatic electric jacks\n    # y: number of gas-powered jacks\n    x = m.addVar(vtype=GRB.INTEGER, name=\"electric_jacks\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"gas_jacks\")\n    \n    # Set the objective: maximize total cars processed\n    m.setObjective(5 * x + 4 * y, GRB.MAXIMIZE)\n    \n    # Add constraints\n    m.addConstr(x <= 14, \"max_electric_jacks\")\n    m.addConstr(6 * x <= 50, \"electricity_limit\")\n    m.addConstr(7 * y <= 80, \"gas_limit\")\n    m.addConstr(x >= 0, \"non_neg_electric\")\n    m.addConstr(y >= 0, \"non_neg_gas\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum number of cars processed\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_cars = optimize_car_jacks()\n    if max_cars is not None:\n        print(f\"Maximum Cars Processed: {max_cars}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Automotive"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "B086",
    "description": "A transportation company has two types of trucks, Type A and Type B. Type A trucks have 20 cubic meters of refrigerated capacity and 40 cubic meters of non-refrigerated capacity. In contrast, Type B trucks have the same total capacity, but the capacities for refrigerated and non-refrigerated cargo are equal. A grocer needs to rent trucks to transport 3000 cubic meters of refrigerated cargo and 4000 cubic meters of non-refrigerated cargo. The rental cost per kilometer for Type A trucks is £30, while the rental cost per kilometer for Type B trucks is £40. How many of each type of truck should the grocer rent to minimize the total cost?\n\nTry to formulate a model for this problem.",
    "ground_truth": 4170.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_truck_rental():\n    \"\"\"\n    Solves the truck rental optimization problem to minimize total cost\n    while meeting refrigerated and non-refrigerated cargo requirements.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        truck_types = ['A', 'B']\n\n        # Capacities (m^3 per truck)\n        capacity_refrigerated = {'A': 20, 'B': 30}\n        capacity_non_refrigerated = {'A': 40, 'B': 30}\n\n        # Cargo Requirements (m^3)\n        required_refrigerated = 3000\n        required_non_refrigerated = 4000\n\n        # Rental Costs (£ per truck - assumed for the task)\n        rental_cost = {'A': 30, 'B': 40}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"TruckRentalOptimization\")\n\n        # --- Decision Variables ---\n        # N[t]: Number of trucks of type t to rent\n        N = model.addVars(truck_types,\n                          name=\"NumTrucks\",\n                          vtype=GRB.INTEGER,\n                          lb=0)\n\n        # --- Objective Function: Minimize Total Rental Cost ---\n        model.setObjective(\n            gp.quicksum(rental_cost[t] * N[t] for t in truck_types),\n            GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Refrigerated Cargo Requirement\n        model.addConstr(gp.quicksum(capacity_refrigerated[t] * N[t]\n                                    for t in truck_types)\n                        >= required_refrigerated,\n                        name=\"RefrigeratedCapacity\")\n\n        # 2. Non-Refrigerated Cargo Requirement\n        model.addConstr(gp.quicksum(capacity_non_refrigerated[t] * N[t]\n                                    for t in truck_types)\n                        >= required_non_refrigerated,\n                        name=\"NonRefrigeratedCapacity\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal truck rental plan found.\")\n            print(f\"Minimum Total Rental Cost: £{model.ObjVal:.2f}\")\n\n            print(\"\\nNumber of Trucks to Rent:\")\n            for t in truck_types:\n                print(f\"  Type {t}: {N[t].X:.0f} trucks\")\n\n            print(\"\\nCapacity Provided:\")\n            total_ref_cap = sum(capacity_refrigerated[t] * N[t].X\n                                for t in truck_types)\n            total_nonref_cap = sum(capacity_non_refrigerated[t] * N[t].X\n                                   for t in truck_types)\n            print(\n                f\"  Total Refrigerated Capacity: {total_ref_cap:.0f} m³ (Required: >= {required_refrigerated})\"\n            )\n            print(\n                f\"  Total Non-Refrigerated Capacity: {total_nonref_cap:.0f} m³ (Required: >= {required_non_refrigerated})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and requirements.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"truck_rental_iis.ilp\")\n            # print(\"IIS written to truck_rental_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_truck_rental()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "B062",
    "description": "A farmer needs to transport 1000 units of fresh produce from the farm to a nearby market. The farmer has three transportation options: a horse, a bicycle, and a handcart. Since both the bicycle and handcart are very physically demanding, the farmer wants to choose only one of these two transportation methods. The horse generates 80 units of pollution per trip, the bicycle generates 0 units of pollution, and the handcart generates 0 units of pollution. The total amount of pollution generated by all trips must not exceed 1000 units. At least 8 trips must be made using the horse. The horse, bicycle, and handcart can carry 55 units, 30 units, and 40 units of produce per trip respectively. The farmer needs to ensure that the total amount of transported produce is at least 1000 units.",
    "ground_truth": 640.0,
    "formulation": null,
    "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Parameters\n    total_produce = 1000\n    pollution_limit = 1000\n    min_horse_trips = 8\n    capacity_horse = 55\n    capacity_bicycle = 30\n    capacity_handcart = 40\n    pollution_horse = 80\n    M = 1000  # Large number for linking constraints\n\n    # Create model\n    m = Model(\"FarmerTransport\")\n\n    # Decision variables\n    x_H = m.addVar(vtype=GRB.INTEGER, lb=min_horse_trips, name=\"x_H\")\n    x_B = m.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_B\")\n    x_C = m.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_C\")\n    y_B = m.addVar(vtype=GRB.BINARY, name=\"y_B\")\n    y_C = m.addVar(vtype=GRB.BINARY, name=\"y_C\")\n\n    m.update()\n\n    # Objective: Minimize pollution from horse trips\n    m.setObjective(pollution_horse * x_H, GRB.MINIMIZE)\n\n    # Constraints\n    # Produce transportation\n    m.addConstr(\n        capacity_horse * x_H + capacity_bicycle * x_B + capacity_handcart * x_C\n        >= total_produce, \"ProduceTransport\")\n    # Pollution limit\n    m.addConstr(pollution_horse * x_H <= pollution_limit, \"PollutionLimit\")\n    # Mode selection\n    m.addConstr(y_B + y_C == 1, \"ModeSelection\")\n    # Linking trips to mode selection\n    m.addConstr(x_B <= M * y_B, \"LinkBicycle\")\n    m.addConstr(x_C <= M * y_C, \"LinkHandcart\")\n    # Minimum horse trips\n    m.addConstr(x_H >= min_horse_trips, \"MinHorseTrips\")\n\n    # Optimize\n    m.optimize()\n\n    # Check feasibility and return result\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_transportation()\n    if result is not None:\n        print(f\"Optimal total pollution: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "B091",
    "description": "A school is preparing a trip for 400 students. The transportation company has 10 buses with 50 seats each and 8 minibuses with 40 seats each, but only 9 drivers are available. The rental cost for a bus is £800, and the rental cost for a minibus is £600. Calculate how many of each type of bus should be used to achieve the lowest cost.\n\nTry to formulate a model for this problem.",
    "ground_truth": 6200.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_school_bus_rental():\n    \"\"\"\n    Solves the school bus rental problem to minimize total cost,\n    subject to student capacity, vehicle availability, and driver constraints.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        num_students = 400\n\n        bus_types = ['LargeBus', 'Minibus']\n\n        # Vehicle details\n        capacity = {'LargeBus': 50, 'Minibus': 40}  # seats\n        availability = {'LargeBus': 10, 'Minibus': 8}  # number of vehicles\n        rental_cost = {'LargeBus': 800, 'Minibus': 600}  # £ per vehicle\n\n        # Driver availability\n        available_drivers = 9\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"SchoolBusRental\")\n\n        # --- Decision Variables ---\n        # N[bt]: Number of buses of type bt to rent\n        N = model.addVars(bus_types,\n                          name=\"NumVehicles\",\n                          vtype=GRB.INTEGER,\n                          lb=0)\n\n        # --- Objective Function: Minimize Total Rental Cost ---\n        model.setObjective(\n            gp.quicksum(rental_cost[bt] * N[bt] for bt in bus_types),\n            GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Student Capacity Constraint: Total seats >= num_students\n        model.addConstr(gp.quicksum(capacity[bt] * N[bt] for bt in bus_types)\n                        >= num_students,\n                        name=\"StudentCapacity\")\n\n        # 2. Driver Availability Constraint: Total vehicles <= available_drivers\n        model.addConstr(gp.quicksum(N[bt] for bt in bus_types)\n                        <= available_drivers,\n                        name=\"DriverLimit\")\n\n        # 3. Vehicle Availability Constraints: N[bt] <= availability[bt]\n        for bt in bus_types:\n            model.addConstr(N[bt] <= availability[bt],\n                            name=f\"VehicleLimit_{bt}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal bus rental plan found.\")\n            print(f\"Minimum Total Rental Cost: £{model.ObjVal:.2f}\")\n\n            print(\"\\nNumber of Vehicles to Rent:\")\n            total_vehicles = 0\n            total_capacity = 0\n            for bt in bus_types:\n                print(\n                    f\"  {bt}: {N[bt].X:.0f} (Max Available: {availability[bt]})\"\n                )\n                total_vehicles += N[bt].X\n                total_capacity += capacity[bt] * N[bt].X\n\n            print(\"\\nSummary:\")\n            print(\n                f\"  Total Vehicles Rented: {total_vehicles:.0f} (Drivers Available: {available_drivers})\"\n            )\n            print(\n                f\"  Total Seating Capacity: {total_capacity:.0f} (Students: {num_students})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. It's impossible to transport all students with the available vehicles/drivers.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"bus_rental_iis.ilp\")\n            print(\"IIS written to bus_rental_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_school_bus_rental()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F016",
    "description": "A science store makes two boxes, a cheap and expensive box. The cheap box contains 3 units of metal and 5 units of acid which can be mixed to create 8 units of foam. The expensive box contains 5 units of metal and 8 units of acid which can be mixed to create 10 units of foam. The cheap box however gives off 2 units of heat while the expensive box gives off 3 units of heat. The science store has available 200 units of metal and 300 units of acid. If at most 50 units of heat can be given off, how many of each box should the store make to maximize the amount of foam produced?",
    "ground_truth": 200.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Add variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"cheap_box\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"expensive_box\")\n\n# Set objective: Maximize 8x + 10y\nmodel.setObjective(8 * x + 10 * y, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(3 * x + 5 * y <= 200, \"MetalConstraint\")\nmodel.addConstr(5 * x + 8 * y <= 300, \"AcidConstraint\")\nmodel.addConstr(2 * x + 3 * y <= 50, \"HeatConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F125",
    "description": "A railway company is planning the infrastructure for the city and is considering two types of transportation, trains and trams. Each train can transport 120 people per hour comfortably and each tram can transport 30 people per hour comfortably. Since trains take longer to build, the number of trams must be at least twice the number of trains. If the railway company wants to transport at least 600 people per hour, minimize the total number of transportation units required.",
    "ground_truth": 11.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of trains\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of trams\n\n# Set objective: Minimize the total number of transportation units\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(120 * x + 30 * y >= 600, \"MinTransport\")  # Constraint C1\nmodel.addConstr(y >= 2 * x, \"TramToTrainRatio\")           # Constraint C2\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F199",
    "description": "An airport buys two types of vehicles, a 4-wheeler and 3-wheeler, to help move luggage. A 4-wheeler vehicle can move 60 luggage per day and produces 30 units of pollutant per day. A 3-wheeler vehicle can move 40 luggage per day and produces 15 units of pollutant per day. The airport needs to be able to move at least 1000 luggage per day. To avoid over-polluting the airport, they can produce at most 430 units of pollutant per day. How many of each vehicle should the airport buy to minimize the total number of vehicles needed.",
    "ground_truth": 22.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"AirportVehicleOptimization\")\n\n# Parameters\nL_4 = 60  # luggage per 4-wheeler per day\nP_4 = 30  # pollution units per 4-wheeler per day\nL_3 = 40  # luggage per 3-wheeler per day\nP_3 = 15  # pollution units per 3-wheeler per day\nL_min = 1000  # minimum luggage to move per day\nP_max = 430  # maximum pollution per day\n\n# Variables\nx_4 = model.addVar(vtype=GRB.INTEGER, name=\"x_4\")  # number of 4-wheeler vehicles\nx_3 = model.addVar(vtype=GRB.INTEGER, name=\"x_3\")  # number of 3-wheeler vehicles\n\n# Objective: Minimize the total number of vehicles\nmodel.setObjective(x_4 + x_3, GRB.MINIMIZE)\n\n# Constraints\n# (C1) Luggage capacity constraint\nmodel.addConstr(L_4 * x_4 + L_3 * x_3 >= L_min, \"LuggageCapacity\")\n\n# (C2) Pollution constraint\nmodel.addConstr(P_4 * x_4 + P_3 * x_3 <= P_max, \"Pollution\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F130",
    "description": "Due to an accident, at least 550 locals must be moved across a lake. They can either be transported over the lake by a kayak or a motorboat. Kayaks can transport 4 people every trip and motorboats can transport 5 people every trip. Kayaks take 5 minutes per trip whereas motorboats take 3 minutes per trip. Due to the limited number of motorboats available to the locals, there can be at most 25 motorboat trips and at least 75% of the trips should be by kayak. How many of each transportation method should be used to minimize the total amount of time needed to transport all the locals?",
    "ground_truth": 610.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nN = 550  # number of people to be transported\np_k = 4  # people per kayak trip\np_m = 5  # people per motorboat trip\nt_k = 5  # time in minutes per kayak trip\nt_m = 3  # time in minutes per motorboat trip\nT_m = 25  # maximum motorboat trips\nalpha = 0.75  # minimum fraction of trips by kayak\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # number of kayak trips\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # number of motorboat trips\n\n# Objective: Minimize total time\nmodel.setObjective(t_k * x + t_m * y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(p_k * x + p_m * y >= N, \"C1\")  # Ensure enough people are transported\nmodel.addConstr(y <= T_m, \"C2\")  # Limit on motorboat trips\nmodel.addConstr(x >= alpha * (x + y), \"C3\")  # Minimum fraction of trips by kayak\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F112",
    "description": "A singer has two types of concerts he can hold, pop and R&B. Each pop concert will bring in 100 audience members and take 2 days of practice. Every R&B concert brings in 240 audience members and takes 4 days of practice. The singer must bring in at least 10000 audience members and only has available 180 days for practice. If he can at most perform 40% of his concerts as R&B because he likes pop songs more, how many of each type of concert should be created to minimize the total number of concerts?",
    "ground_truth": 65.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"ConcertOptimization\")\n\n# Parameters\nA_p = 100\nA_r = 240\nD_p = 2\nD_r = 4\nN_audience = 10000\nN_days = 180\nF_r = 0.40\n\n# Variables\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")  # Number of pop concerts\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")  # Number of R&B concerts\n\n# Objective: Minimize the total number of concerts\nmodel.setObjective(x_p + x_r, GRB.MINIMIZE)\n\n# Constraints\n# Audience members constraint\nmodel.addConstr(A_p * x_p + A_r * x_r >= N_audience, \"AudienceConstraint\")\n\n# Practice days constraint\nmodel.addConstr(D_p * x_p + D_r * x_r <= N_days, \"PracticeDaysConstraint\")\n\n# R&B concert fraction constraint\nmodel.addConstr(x_r <= F_r * (x_p + x_r), \"R&BFractionConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Entertainment"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F057",
    "description": "A chicken farmer has sold his chicken and they need to be transported either by bus or by car. A bus can take 100 chicken and takes 2 hours per trip. A car can take 40 chicken and takes 1.5 hours per trip. There can be at most 10 bus trips and at least 60% of the trips must be by car. If the farmer needs to transport 1200 chicken, how many trips of each should be done to minimize the total time needed to transport the chicken?",
    "ground_truth": 33.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F203",
    "description": "An Indian restaurant makes goat and chicken curry. Each bowl of goat curry requires 3 units of goat meat and 6 units of the curry base. Each bowl of chicken curry requires 5 units of chicken meat and 5 units of the curry base. The restaurant has available 1500 units of goat meat and 2000 units of chicken meat. At least 25% of the bowls made must be chicken curry. Since goat curry is more popular, the number of goat curry bowls must be larger than the number of chicken curry bowls. How many of each type of curry bowl should be made to minimize the total amount of curry base used?",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "run_error"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Food Service"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F067",
    "description": "A factory transports rice to the city in horse-drawn carts that are either medium or large size. A medium sized cart requires 2 horses and can carry 30 kg of rice. A large sized cart requires 4 horses and can carry 70 kg of rice.  The factory has 60 horses available. Because the horses don't get along well, the number of medium sized carts must be three times the number of large sized carts. In addition, there must be at least 5 medium sized carts and at least 5 large sized carts. How many of each cart size should be used to maximize the amount of rice that can be transported?",
    "ground_truth": 960.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nh = 60  # Total number of horses available\nc_m = 30  # Capacity of a medium-sized cart in kg\nc_l = 70  # Capacity of a large-sized cart in kg\nh_m = 2  # Number of horses required for a medium-sized cart\nh_l = 4  # Number of horses required for a large-sized cart\n\n# Variables\nx_m = model.addVar(vtype=GRB.INTEGER, name=\"x_m\")  # Number of medium-sized carts\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")  # Number of large-sized carts\n\n# Objective: Maximize the total amount of rice transported\nmodel.setObjective(c_m * x_m + c_l * x_l, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(h_m * x_m + h_l * x_l <= h, \"HorseAvailability\")\nmodel.addConstr(x_m == 3 * x_l, \"CartRatio\")\nmodel.addConstr(x_m >= 5, \"MinMediumCarts\")\nmodel.addConstr(x_l >= 5, \"MinLargeCarts\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F143",
    "description": "A tourism company can buy sedans or buses to add to their fleet of vehicles to increase their capacity for more tourists. A sedan can seat 50 tourists per day but results in 10 units of pollution. A bus can seat 250 tourists per day but results in 40 units of pollution. The city has limited this tourism company to producing at most 800 units of pollutants per day. To make a profit, this tourism company must take care of at least 4600 customers per day. Planning to make a profit, how many sedans and how many buses should this tourism company purchase to decrease the total number of vehicles needed?",
    "ground_truth": 19.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nS = 50   # Number of tourists a sedan can seat per day\nB = 250  # Number of tourists a bus can seat per day\nP_s = 10  # Pollution units produced by a sedan\nP_b = 40  # Pollution units produced by a bus\nP_max = 800  # Maximum allowable pollution units per day\nD_min = 4600  # Minimum number of customers per day\n\n# Variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")  # Number of sedans purchased\nx_b = model.addVar(vtype=GRB.INTEGER, name=\"x_b\")  # Number of buses purchased\n\n# Objective: Minimize the total number of vehicles\nmodel.setObjective(x_s + x_b, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(S * x_s + B * x_b >= D_min, \"C1\")  # Ensure at least 4600 customers are served per day\nmodel.addConstr(P_s * x_s + P_b * x_b <= P_max, \"C2\")  # Ensure pollution does not exceed 800 units\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F201",
    "description": "A coffee shop sells mochas and regular coffees. Each mocha requires 3 units of coffee powder and 6 units of milk. Each regular coffee requires 6 units of coffee powder and 2 units of milk. The shop has available 400 units of coffee powder and 500 units of milk. Making a mocha takes 5 minutes and making a regular coffee takes 3 minutes. Since mochas are more popular among people, the shop must make at least 3 times as many mochas as regular coffees. How many of each should they make to minimize the total production time?",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nc_m = 3  # Units of coffee powder required for one mocha\nm_m = 6  # Units of milk required for one mocha\nc_r = 6  # Units of coffee powder required for one regular coffee\nm_r = 2  # Units of milk required for one regular coffee\nP = 400  # Total available units of coffee powder\nM = 500  # Total available units of milk\nt_m = 5  # Time in minutes to make one mocha\nt_r = 3  # Time in minutes to make one regular coffee\nr = 3    # Ratio of mochas to regular coffees\n\n# Variables\nx_m = model.addVar(vtype=GRB.INTEGER, name=\"x_m\")  # Number of mochas\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")  # Number of regular coffees\n\n# Objective: Minimize the total production time\nmodel.setObjective(t_m * x_m + t_r * x_r, GRB.MINIMIZE)\n\n# Constraints\n# Coffee powder constraint\nmodel.addConstr(c_m * x_m + c_r * x_r <= P, \"C1\")\n\n# Milk constraint\nmodel.addConstr(m_m * x_m + m_r * x_r <= M, \"C2\")\n\n# Popularity ratio constraint\nmodel.addConstr(x_m >= r * x_r, \"C3\")\n\n# Non-negativity constraints are implicitly handled by variable definitions\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F033",
    "description": "A chocolate company can transport their boxes of chocolate either using their own vans or by renting trucks. Their vans can transport 50 boxes per trip while a truck can transport 80 boxes per trip. Since they own their vans, the cost per van trip is $30 while the cost per truck trip is $50. The company needs to transport at least 1500 boxes of chocolate and they have a budget of $1000. Since the vans also provide advertising, the number of trips by van must be larger than the number of trips by trucks. How many of trip by each should be done to minimize the total number of trips?",
    "ground_truth": 24.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nV_c = 30  # Cost per van trip\nT_c = 50  # Cost per truck trip\nV_b = 50  # Boxes per van trip\nT_b = 80  # Boxes per truck trip\nB = 1000  # Total budget\nN = 1500  # Minimum boxes to transport\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of van trips\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of truck trips\n\n# Objective: Minimize the total number of trips\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(V_c * x + T_c * y <= B, \"BudgetConstraint\")  # C1\nmodel.addConstr(V_b * x + T_b * y >= N, \"BoxTransportConstraint\")  # C2\nmodel.addConstr(x >= y + 1, \"VanGreaterThanTruck\")  # C3 (Revised to use >= y + 1)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F108",
    "description": "In a science fair, there are two types of tables that can be used to display the children’s science experiments. At the circular tables, 4 poster boards and 5 participants can fit around the table to cater to 8 guests. At the rectangular tables, 4 poster boards and 4 participants can fit around the table to cater to 12 guests. However, each circular table takes up 15 units of space while each rectangular table takes up 20 units of space. The science fair has must be able to fit at least 500 participants and 300 poster boards. If the science fair has available 1900 units of space, how many of each type of table should be set up to maximize the number of catered guests?",
    "ground_truth": 1080.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nT_c = 15  # Space units taken by one circular table\nT_r = 20  # Space units taken by one rectangular table\nP_c = 5   # Participants per circular table\nP_r = 4   # Participants per rectangular table\nB_c = 4   # Poster boards per circular table\nB_r = 4   # Poster boards per rectangular table\nG_c = 8   # Guests catered by one circular table\nG_r = 12  # Guests catered by one rectangular table\nSpace = 1900  # Total available space units\nMin_Participants = 500  # Minimum number of participants needed\nMin_Boards = 300  # Minimum number of poster boards needed\n\n# Variables\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"x_c\")  # Number of circular tables\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")  # Number of rectangular tables\n\n# Objective\nmodel.setObjective(G_c * x_c + G_r * x_r, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(T_c * x_c + T_r * x_r <= Space, \"SpaceConstraint\")\nmodel.addConstr(P_c * x_c + P_r * x_r >= Min_Participants, \"MinParticipantsConstraint\")\nmodel.addConstr(B_c * x_c + B_r * x_r >= Min_Boards, \"MinBoardsConstraint\")\nmodel.addConstr(x_c >= 0, \"NonNegativityConstraint_Circular\")\nmodel.addConstr(x_r >= 0, \"NonNegativityConstraint_Rectangular\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Event Management"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F111",
    "description": "A food delivery person can either have shifts on bikes or scooters. A shift on a bike can deliver 10 orders, takes 5 units of energy, and brings in $50 on tips because it is faster. A shift on a scooter can deliver 7 orders, takes 6 units of energy, and brings in $43 on tips.  The delivery person has available 40 shifts a month and has 230 units of energy and must bring at least 320 orders. He must have at least 5 shifts on a scooter because bikes are harder to get. How many shifts on each type of transportation should the delivery person schedule to maximize tips received?",
    "ground_truth": 1965.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define parameters\nT_b = 50  # Tips per bike shift\nT_s = 43  # Tips per scooter shift\nO_b = 10  # Orders delivered per bike shift\nO_s = 7   # Orders delivered per scooter shift\nE_b = 5   # Energy consumed per bike shift\nE_s = 6   # Energy consumed per scooter shift\nS_total = 40  # Total available shifts\nE_total = 230 # Total available energy\nO_min = 320   # Minimum required orders\nS_s_min = 5   # Minimum required scooter shifts\n\n# Define variables\nx_b = model.addVar(vtype=GRB.INTEGER, name=\"x_b\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n\n# Set objective\nmodel.setObjective(T_b * x_b + T_s * x_s, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x_b + x_s <= S_total, name=\"TotalShifts\")          # C1\nmodel.addConstr(E_b * x_b + E_s * x_s <= E_total, name=\"TotalEnergy\") # C2\nmodel.addConstr(O_b * x_b + O_s * x_s >= O_min, name=\"MinOrders\")  # C3\nmodel.addConstr(x_s >= S_s_min, name=\"MinScooterShifts\")           # C4\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Gig Economy"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F038",
    "description": "A lawn mowing service provides neighborhood services using small teams and large teams. A small team requires 3 employees and can mow 50 sq ft of lawn. A large team requires 5 employees and can mow 80 sq ft of lawn. The company has 150 employees available. Because most people have smaller lawns in the city, the number of small teams must be at least 3 times as much as the number of large teams. In addition, to make sure the company can meet all demands, there has to be at least 6 large teams and at least 10 small teams. How many of each team type should be used to maximize the amount of lawn that can be mowed?",
    "ground_truth": 2480.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"LawnMowingService\")\n\n# Parameters\ne_s = 3  # Number of employees in a small team\ne_l = 5  # Number of employees in a large team\nm_s = 50  # Area mowed by a small team (sq ft)\nm_l = 80  # Area mowed by a large team (sq ft)\nE = 150  # Total number of employees available\nr = 3  # Minimum ratio of small teams to large teams\nL_min = 6  # Minimum number of large teams\nS_min = 10  # Minimum number of small teams\n\n# Variables\nS = model.addVar(vtype=GRB.INTEGER, name=\"SmallTeams\")\nL = model.addVar(vtype=GRB.INTEGER, name=\"LargeTeams\")\n\n# Objective: Maximize the total area mowed\nmodel.setObjective(m_s * S + m_l * L, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(e_s * S + e_l * L <= E, \"EmployeeConstraint\")\nmodel.addConstr(S >= r * L, \"RatioConstraint\")\nmodel.addConstr(L >= L_min, \"MinLargeTeams\")\nmodel.addConstr(S >= S_min, \"MinSmallTeams\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Service"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F148",
    "description": "A municipality hires full-time and part-time staff to deliver mail. Part-time staff works 15 hours per week and gets paid 450 dollars whereas a full-time staff works 40 hours every week and gets paid 1280 dollars  for that week.  Since it is the week leading up to a holiday, planning ahead, the municipality needs 1000 hours of mail staff labor. The municipality has a budget of 31500 dollars for mail delivery for this season. How many of each type of staff should the municipality hire to decrease the total number of staff?",
    "ground_truth": 40.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nw_p = 15  # hours/week for part-time\nw_f = 40  # hours/week for full-time\nc_p = 450  # cost/week for part-time\nc_f = 1280  # cost/week for full-time\nH = 1000  # hours required\nB = 31500  # budget\n\n# Variables\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")  # Number of part-time staff\nx_f = model.addVar(vtype=GRB.INTEGER, name=\"x_f\")  # Number of full-time staff\n\n# Objective: Minimize total number of staff\nmodel.setObjective(x_p + x_f, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(w_p * x_p + w_f * x_f >= H, \"LaborHours\")  # C1: Labor hours requirement\nmodel.addConstr(c_p * x_p + c_f * x_f <= B, \"Budget\")  # C2: Budget constraint\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Public Sector"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F104",
    "description": "An extremely large ski resort is looking into purchasing two types of ski lifts, a densely-seated one and a loosely-seated one. The densely-seated ski lift is able to bring 45 guests up the slopes every minute whereas the loosely-seated ski lift can transport 20 guests every minute.  The densely-seated ski lift uses 30 units of electricity and the loosely-seated lift uses 22 units of electricity. There must be at least five loosely-seated ski lifts because they move slower and are friendlier for beginners. The ski resort needs at least 1000 guests every minute to make a profit and has available 940 units of electricity. How many of each type of ski lifts should they plan to install to minimize the total number of ski lifts needed?",
    "ground_truth": 25.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SkiLiftOptimization\")\n\n# Parameters\ng1 = 45  # Guests per minute for densely-seated ski lift\ng2 = 20  # Guests per minute for loosely-seated ski lift\ne1 = 30  # Electricity units used by densely-seated ski lift\ne2 = 22  # Electricity units used by loosely-seated ski lift\nE = 940  # Total available electricity units\nG = 1000  # Minimum guests per minute requirement\nL = 5     # Minimum number of loosely-seated ski lifts required\n\n# Variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")  # Number of densely-seated ski lifts\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")  # Number of loosely-seated ski lifts\n\n# Objective: Minimize the total number of ski lifts\nmodel.setObjective(x1 + x2, GRB.MINIMIZE)\n\n# Constraints\n# Guest capacity constraint\nmodel.addConstr(g1 * x1 + g2 * x2 >= G, \"GuestCapacity\")\n\n# Electricity usage constraint\nmodel.addConstr(e1 * x1 + e2 * x2 <= E, \"ElectricityUsage\")\n\n# Minimum number of loosely-seated lifts constraint\nmodel.addConstr(x2 >= L, \"MinLooselySeated\")\n\n# Non-negativity constraints\nmodel.addConstr(x1 >= 0, \"NonNegativityX1\")\nmodel.addConstr(x2 >= 0, \"NonNegativityX2\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Recreation & Tourism"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F179",
    "description": "A honey farmer sells his honey in glass and plastic jars. A glass jar can hold 250 ml of honey while a plastic jar can hold 300 ml of honey. Since glass jars are more expensive, at least twice as many plastic jars must be filled as glass jars. However, at least 20 glass jars should be filled. If the farmer has 20000 ml of honey, how many jars of each should be filled to maximize the total number of bottles filled?",
    "ground_truth": 70.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nV_g = 250  # Volume of honey a glass jar can hold (ml)\nV_p = 300  # Volume of honey a plastic jar can hold (ml)\nH = 20000  # Total volume of honey available (ml)\n\n# Variables\nx_g = model.addVar(vtype=GRB.INTEGER, name=\"x_g\")  # Number of glass jars filled\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")  # Number of plastic jars filled\n\n# Objective: Maximize the total number of jars filled\nmodel.setObjective(x_g + x_p, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(V_g * x_g + V_p * x_p <= H, \"C1\")  # Total honey used cannot exceed available honey\nmodel.addConstr(x_p >= 2 * x_g, \"C2\")              # At least twice as many plastic jars as glass jars\nmodel.addConstr(x_g >= 20, \"C3\")                   # At least 20 glass jars should be filled\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F046",
    "description": "A toy store decides to deliver gifts using two shipping companies, a new one and an old one. The new company can deliver 50 gifts per trip while the old company can deliver 70 gifts per trip. The new company uses 30 liters of diesel per trip while the old company uses 40 liters of diesel per trip. The toy store needs to deliver at least 1000 gifts. There can be at most 15 trips made by the new company. In order to make sure that the old company does not go out of business, at least 40% of all trips must be made by the old company. How many trips should each company make to minimize the total amount of diesel used?",
    "ground_truth": 580.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nC_n = 50  # gifts per trip by new company\nC_o = 70  # gifts per trip by old company\nD_n = 30  # liters of diesel per trip by new company\nD_o = 40  # liters of diesel per trip by old company\nG = 1000  # minimum number of gifts to be delivered\nT_n_max = 15  # maximum trips for new company\nalpha = 0.4  # minimum fraction of total trips by old company\n\n# Variables\nx_n = model.addVar(vtype=GRB.INTEGER, name=\"x_n\", lb=0)\nx_o = model.addVar(vtype=GRB.INTEGER, name=\"x_o\", lb=0)\n\n# Objective: Minimize total diesel used\nmodel.setObjective(D_n * x_n + D_o * x_o, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(C_n * x_n + C_o * x_o >= G, \"C1\")\nmodel.addConstr(x_n <= T_n_max, \"C2\")\nmodel.addConstr(x_o >= alpha * (x_n + x_o), \"C3\")\nmodel.addConstr(x_n >= 0, \"C4\")\nmodel.addConstr(x_o >= 0, \"C4\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F037",
    "description": "A soda company sends bottles of their soda to stores around the city in old and new vans. An old van can take 100 soda bottles while a new van can take 80 soda bottles. An old van produces 50 units of pollution while a new van only produces 30 units of pollution. The company needs to send at least 5000 bottles. In addition, at most 30 new vans can be used. How many of each van should be used to minimize the total amount of pollution produced?",
    "ground_truth": 2200.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Soda_Van_Optimization\")\n\n# Parameters\nC_o = 100  # Capacity of an old van\nC_n = 80   # Capacity of a new van\nP_o = 50   # Pollution produced by an old van\nP_n = 30   # Pollution produced by a new van\nB = 5000   # Minimum number of bottles to be sent\nN_max = 30 # Maximum number of new vans\n\n# Variables\nx_o = model.addVar(vtype=GRB.INTEGER, name=\"x_o\")\nx_n = model.addVar(vtype=GRB.INTEGER, name=\"x_n\")\n\n# Objective\nmodel.setObjective(P_o * x_o + P_n * x_n, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(C_o * x_o + C_n * x_n >= B, \"TotalBottles\")\nmodel.addConstr(x_n <= N_max, \"NewVanLimit\")\nmodel.addConstr(x_o >= 0, \"NonNegativityOldVans\")\nmodel.addConstr(x_n >= 0, \"NonNegativityNewVans\")\n\n# Solve the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F036",
    "description": "There has been an oil spill in the ocean and ducks need to be taken to shore to be cleaned either by boat or by canoe. A boat can take 10 ducks per trip while a canoe can take 8 ducks per trip. Since the boats are motor powered, they take 20 minutes per trip while the canoes take 40 minutes per trip. In order to avoid further environmental damage, there can be at most 12 boat trips and at least 60% of the trips should be by canoe. If at least 300 ducks need to be taken to shore, how many of each transportation method should be used to minimize the total amount of time needed to transport the ducks?",
    "ground_truth": 1160.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nB = 10\nC = 8\nT_B = 20\nT_C = 40\nM_B = 12\nR_C = 0.6\nD = 300\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of boat trips\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of canoe trips\n\n# Objective: Minimize the total time\nmodel.setObjective(T_B * x + T_C * y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(B * x + C * y >= D, \"c1\")  # Minimum ducks transported\nmodel.addConstr(x <= M_B, \"c2\")  # Maximum boat trips\nmodel.addConstr(y >= R_C * (x + y), \"c3\")  # Proportion of canoe trips\nmodel.addConstr(x >= 0, \"c4\")  # Non-negativity for x\nmodel.addConstr(y >= 0, \"c5\")  # Non-negativity for y\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Environment"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F034",
    "description": "A bee farmer transports his honey in small and large bottles. A small bottle can take 5 units of honey while a large bottle can take 20 units of honey. The farmer has available at most 300 small bottles and at most 100 large bottles. In addition, since small bottles are easier to sell, at least twice as many small bottles must be used than large bottles. Finally, he can transport at most 200 bottles total and at least 50 must be large bottles. How many of each bottle should be use to maximize the total amount of honey he can transport?",
    "ground_truth": 1990.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"HoneyTransportOptimization\")\n\n# Define variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of small bottles\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of large bottles\n\n# Set objective\nmodel.setObjective(5 * x + 20 * y, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x <= 300, \"C1\")   # Small bottle availability constraint\nmodel.addConstr(y <= 100, \"C2\")   # Large bottle availability constraint\nmodel.addConstr(x + y <= 200, \"C3\")  # Total bottle constraint\nmodel.addConstr(y >= 50, \"C4\")   # Minimum large bottle constraint\nmodel.addConstr(x >= 2 * y, \"C5\")  # Small to large bottle ratio constraint\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F047",
    "description": "A zoo needs to transport their monkeys to the vet either by bus or by car. A bus can transport 20 monkeys per trip and takes 30 minutes. A car can transport 6 monkeys per trip and takes 15 minutes. There can be at most 10 bus trips. In addition, since the monkeys get aggressive when there are too many in one place at least 60% of the trips should be by car. If the zoo needs to transport 300 monkeys, how many trips of each should be done to minimize the total time required to transport the monkeys?",
    "ground_truth": 555.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F071",
    "description": "A factory provides rides for its employees in either taxis or company cars. Each taxi ride can take 2 employees while each company car ride can take 3 employees. Since buying and maintaining cars is expensive, at most 60% of the rides can be company car rides. However, there has to be at least 30 company car rides. If the company needs to transport at least 500 employees, how many rides of each should be done to minimize the total number of taxi rides.",
    "ground_truth": 78.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nn = 500  # Total number of employees\np = 0.60 # Maximum percentage of rides that can be company car rides\nm = 30   # Minimum number of company car rides required\nc = 3    # Capacity of a company car\nt = 2    # Capacity of a taxi\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of taxi rides\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of company car rides\n\n# Objective: Minimize the number of taxi rides\nmodel.setObjective(x, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(2 * x + 3 * y >= 500, \"C1\")       # Ensure enough capacity for all employees\nmodel.addConstr(y <= p * (x + y), \"C2\")           # Maximum 60% of rides can be company cars\nmodel.addConstr(y >= m, \"C3\")                     # At least 30 company car rides\nmodel.addConstr(x >= 0, \"C4_x\")                   # Non-negativity constraint for taxi rides\nmodel.addConstr(y >= 0, \"C4_y\")                   # Non-negativity constraint for company car rides\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F191",
    "description": "A shipping company can purchase regular and hybrid vans to make deliveries. A regular van can deliver 500 packages per day and produces 200 units of pollutants. A hybrid van can deliver 300 packages per day and produces 100 units of pollutants. Due to a new environmental law, they can produce at most 7000 units of pollutants per day. However, the company needs to be able to deliver at least 20000 packages per day. How many of each type of van should they buy to minimize the total number of vans needed?",
    "ground_truth": 60.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nR = 500  # Packages per day delivered by a regular van\nH = 300  # Packages per day delivered by a hybrid van\nP_R = 200  # Pollutants produced by a regular van\nP_H = 100  # Pollutants produced by a hybrid van\nD = 20000  # Minimum packages to be delivered per day\nP_max = 7000  # Maximum pollutants allowed per day\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of regular vans\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of hybrid vans\n\n# Objective: Minimize the total number of vans\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(R * x + H * y >= D, \"C1\")  # Minimum packages constraint\nmodel.addConstr(P_R * x + P_H * y <= P_max, \"C2\")  # Maximum pollutants constraint\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F102",
    "description": "A concert organizer has to transport equipment using carts or trolleys. Carts can transport 5 kg/min of equipment and requires 2 workers. Trolleys can transport 7 kg/min of equipment and requires 4 workers. There must be at least 12 trolleys to be used. Additionally, only a maximum of 40% of the transportation can be using trolleys. The organizer has to deliver at a rate of 100 kg/min of equipment. How many of each transportation method should be used to minimize the total number of workers?",
    "ground_truth": 84.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "failure_solve"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Event Management"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F040",
    "description": "A shoe company supplies shoes to stores via vans and trucks. A van can transport 50 pairs of shoes while a truck can transport 100 pairs of shoes. The company must supply a minimum of 2000 pairs of shoes around the city. Since most stores are small, the number of trucks used cannot exceed the number of vans used.  Find the minimum number of vans that can be used?",
    "ground_truth": 14.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Shoe_Transport_Optimization\")\n\n# Parameters\nS_v = 50  # Pairs of shoes a van can transport\nS_t = 100  # Pairs of shoes a truck can transport\nD = 2000  # Minimum pairs of shoes to be supplied\n\n# Variables\nx_v = model.addVar(vtype=GRB.INTEGER, name=\"vans\")  # Number of vans used\nx_t = model.addVar(vtype=GRB.INTEGER, name=\"trucks\")  # Number of trucks used\n\n# Objective: Minimize the number of vans\nmodel.setObjective(x_v, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(S_v * x_v + S_t * x_t >= D, \"C1\")  # Meet the minimum supply requirement\nmodel.addConstr(x_t <= x_v, \"C2\")  # The number of trucks cannot exceed the number of vans\nmodel.addConstr(x_v >= 0, \"C3\")  # Non-negativity constraint for vans\nmodel.addConstr(x_t >= 0, \"C4\")  # Non-negativity constraint for trucks\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F122",
    "description": "A candle-making company can move their inventory of candles using freight and air. Freight can transport 5 tons per trip while using air can transport 3 tons per trip. Since freight take longer, the cost for each freight trip is $300 while the cost over air for each trip is $550. The company needs to transport at least 200 tons of candles and they have a budget of $20000. Additionally, due to some urgent orders, at least 30% of tons of candles must be transported through air. There must also be at least 5 trips through freight. How many of trip by each should be scheduled to minimize the total number of trips?",
    "ground_truth": 46.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F050",
    "description": "A car manufacturer ships their cars on large and small planes. A large plane can carry 30 cars while a small plane can carry 10 cars. Since large planes cause more pollution, the number of large planes must be less than the number of small planes. If the manufacturer wants to deliver at least 300 cars, find the minimum number of planes that can be used.",
    "ground_truth": 16.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Add variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of large planes\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of small planes\n\n# Set objective\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(30 * x + 10 * y >= 300, \"CapacityConstraint\")\nmodel.addConstr(x <= y - 1, \"LargeLessThanSmall\")  # Corrected constraint\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F065",
    "description": "The weather is freezing and the fish in the pond need to be transported either by helicopter or car. A helicopter can take 30 fish per trip and takes 40 minutes. A car can take 20 fish per trip and takes 30 minutes. Since helicopter trips are expensive, there can be at most 5 helicopter trips. In addition, at least 60% of the trips should be by car. If at least 300 fish need to transported, how many of each trip should be taken to minimize the total time needed?",
    "ground_truth": 430.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"FishTransportation\")\n\n# Parameters\nH = 30  # Fish per helicopter trip\nT_H = 40  # Time in minutes per helicopter trip\nC = 20  # Fish per car trip\nT_C = 30  # Time in minutes per car trip\nM_H = 5  # Maximum number of helicopter trips\nR_C = 0.6  # Minimum proportion of trips by car\nF = 300  # Minimum number of fish to transport\n\n# Variables\nx_H = model.addVar(vtype=GRB.INTEGER, name=\"x_H\")\nx_C = model.addVar(vtype=GRB.INTEGER, name=\"x_C\")\n\n# Objective: Minimize total time\nmodel.setObjective(T_H * x_H + T_C * x_C, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(H * x_H + C * x_C >= F, \"C1\")  # At least 300 fish must be transported\nmodel.addConstr(x_H <= M_H, \"C2\")  # At most 5 helicopter trips\nmodel.addConstr(x_C >= (R_C / (1 - R_C)) * x_H, \"C3\")  # At least 60% of trips by car\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F029",
    "description": "A chemistry teacher teaches her students two experiments, experiment 1 and experiment 2. In experiment 1, 3 units of the red liquid and 4 units of the blue liquid mix to create 5 units of green gas. In experiment 2, 5 units of the red liquid and 3 units of the blue liquid mix to create 6 units of the green gas. In addition, experiment 1 produces 1 units of smelly gas while experiment 2 produces 2 units of smelly gas.  The lab has available 80 units of red liquid and 70 units of blue liquid. If at most 10 units of smelly gas can be produced, how many experiments of each should be done to maximize the total amount of green gas produced?",
    "ground_truth": 50.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nr1, b1, g1, s1 = 3, 4, 5, 1\nr2, b2, g2, s2 = 5, 3, 6, 2\nR, B, S = 80, 70, 10\n\n# Decision variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")\n\n# Objective function\nmodel.setObjective(g1 * x1 + g2 * x2, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(r1 * x1 + r2 * x2 <= R, \"RedLiquidConstraint\")\nmodel.addConstr(b1 * x1 + b2 * x2 <= B, \"BlueLiquidConstraint\")\nmodel.addConstr(s1 * x1 + s2 * x2 <= S, \"SmellyGasConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F128",
    "description": "An airport can either install escalators or elevators. Escalators can transport 20 people every minute whereas elevators can transport 8 people every minute. Escalators take up 5 units of space while elevators take 2 units of space. The airport needs to have enough capacity to transport at least 400 people every minute. Additionally, there must be at least three times more escalators than elevators and at least 2 elevators must be used. How many of each type should the airport install to minimize the total units of space taken?",
    "ground_truth": 100.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\np_e = 20  # people/minute per escalator\np_l = 8   # people/minute per elevator\ns_e = 5   # space units per escalator\ns_l = 2   # space units per elevator\nP = 400   # total people/minute required\nr = 3     # escalator to elevator ratio requirement\nm_l = 2   # minimum number of elevators required\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # number of escalators\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # number of elevators\n\n# Objective: Minimize the total units of space taken\nmodel.setObjective(s_e * x + s_l * y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(p_e * x + p_l * y >= P, \"C1\")  # Transport capacity constraint\nmodel.addConstr(x >= r * y, \"C2\")              # Escalator to elevator ratio constraint\nmodel.addConstr(y >= m_l, \"C3\")                # Minimum number of elevators constraint\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F206",
    "description": "A factory has two machines, A and B. Each day, machine A can make 30 items and consumes 100 kWh. Machine B can make 50 items and consumes 120 kWh per day. The factory must produce at least 1000 items per day and has 3000 kWh of electricity available per day. Since there are not many workers that can operate both machines, at most 30% of the machines must be of type B. Further, at least 5 machines of type A should be used. How many of each machine should be used to minimize the total number of machines?",
    "ground_truth": 28.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\np_A = 30\np_B = 50\ne_A = 100\ne_B = 120\nI = 1000\nE = 3000\nB_max_percent = 0.3\nA_min = 5\n\n# Variables\nx_A = model.addVar(vtype=GRB.INTEGER, name=\"x_A\")\nx_B = model.addVar(vtype=GRB.INTEGER, name=\"x_B\")\n\n# Objective: Minimize the total number of machines\nmodel.setObjective(x_A + x_B, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(p_A * x_A + p_B * x_B >= I, \"C1\")  # Production requirement\nmodel.addConstr(e_A * x_A + e_B * x_B <= E, \"C2\")  # Energy constraint\nmodel.addConstr(x_B <= B_max_percent * (x_A + x_B), \"C3\")  # Machine B usage limit\nmodel.addConstr(x_A >= A_min, \"C4\")  # Minimum machine A usage\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F202",
    "description": "A water company sells water in glass and plastic bottles. A glass bottle can hole 500 ml of water while a plastic bottle can hold 750 ml of water. Because most customer prefer plastic bottles, the number of plastic bottles must be at least 3 times the number of glass bottles. However, there must be at least 20 glass bottles. If the company has available 250000 ml of water, how many of each bottle should be made to maximize the total number of bottles?",
    "ground_truth": 363.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"WaterBottles\")\n\n# Parameters\nV_g = 500  # Volume of a glass bottle in ml\nV_p = 750  # Volume of a plastic bottle in ml\nW = 250000 # Total available water in ml\n\n# Variables\nx_g = model.addVar(vtype=GRB.INTEGER, name=\"x_g\")  # Number of glass bottles\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")  # Number of plastic bottles\n\n# Objective: Maximize total number of bottles\nmodel.setObjective(x_g + x_p, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(V_g * x_g + V_p * x_p <= W, \"WaterLimit\")  # C1: Water constraint\nmodel.addConstr(x_p >= 3 * x_g, \"PlasticPreference\")       # C2: Plastic preference\nmodel.addConstr(x_g >= 20, \"GlassMinimum\")                 # C3: Minimum glass bottles\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F079",
    "description": "A volunteer organization transports voters to the polls on Election Day either by vans or cars. They have vans which can carry 6 people and cars which can carry 3 people.  They need to transport at least 200 voters to the polls. In addition, at most 30% of the vehicles can be vans. How many of each vehicle should be used to minimize the total number of cars used?",
    "ground_truth": 37.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"vans\")  # Number of vans\ny = model.addVar(vtype=GRB.INTEGER, name=\"cars\")  # Number of cars\n\n# Set objective: Minimize the total number of cars used\nmodel.setObjective(y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(6*x + 3*y >= 200, \"C1\")  # Ensure at least 200 voters are transported\nmodel.addConstr(x <= 0.3 * (x + y), \"C2\")  # At most 30% of the vehicles can be vans\n\n# Non-negativity constraints are implicit in variable definitions\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Social Services"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F073",
    "description": "A grape farmer transports his grapes in either small crates or large crates. A small crate can take 200 grapes while a large crate can take 500.  Because his customers prefer smaller crates, at least 3 times as many small crates must be used than large crates. The farmer has available at most 100 small crates and at most 50 large crates. In addition, his truck can take at most 60 crates total and he must use at least 10 large crates. How many of each crate should he use to maximize the total number of grapes he can transport?",
    "ground_truth": 16500.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nS = 200  # Number of grapes a small crate can carry\nL = 500  # Number of grapes a large crate can carry\nM_s = 100  # Maximum number of small crates available\nM_l = 50   # Maximum number of large crates available\nT = 60     # Total number of crates the truck can carry\nN_l = 10   # Minimum number of large crates to be used\n\n# Variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")  # Number of small crates used\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")  # Number of large crates used\n\n# Objective: Maximize the total number of grapes transported\nmodel.setObjective(S * x_s + L * x_l, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_s <= M_s, \"C1\")  # Small crates cannot exceed availability\nmodel.addConstr(x_l <= M_l, \"C2\")  # Large crates cannot exceed availability\nmodel.addConstr(x_s + x_l <= T, \"C3\")  # Total crates cannot exceed truck capacity\nmodel.addConstr(x_l >= N_l, \"C4\")  # At least 10 large crates must be used\nmodel.addConstr(x_s >= 3 * x_l, \"C5\")  # At least 3 times as many small crates as large crates\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F198",
    "description": "A hot dog company can build two types of butcher shops, a small shop and a large shop. A small shop can make 30 hot dogs per day and requires 2 workers. A large shop can make 70 hot dogs per day and requires 4 workers. The company must make at least 500 hot dogs per day but they only have available 30 workers. How many of each butcher shop should the company build to minimize the total number of butcher shops?",
    "ground_truth": 8.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\np_s = 30  # Number of hot dogs produced per day by a small shop\np_l = 70  # Number of hot dogs produced per day by a large shop\nw_s = 2   # Number of workers required for a small shop\nw_l = 4   # Number of workers required for a large shop\nH = 500   # Minimum number of hot dogs required per day\nW = 30    # Total number of workers available\n\n# Variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n# Objective function: Minimize the total number of shops\nmodel.setObjective(x_s + x_l, GRB.MINIMIZE)\n\n# Constraints\n# Production constraint\nmodel.addConstr(p_s * x_s + p_l * x_l >= H, \"ProductionConstraint\")\n\n# Worker constraint\nmodel.addConstr(w_s * x_s + w_l * x_l <= W, \"WorkerConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F135",
    "description": "A village delivers mail to nearby villages either by runners or canoers. Runners can carry three bags of mail each time and takes 4 hours. Canoers can carry ten bags of mail each time and takes 2 hours. At most 33% of deliveries can be by canoe. Additionally, the village can spare at most 200 total hours and at least 4 runners must be used. How many of each way to deliver must be used to maximize the total amount of mail that can be delivered?",
    "ground_truth": 310.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MailDeliveryOptimization\")\n\n# Parameters\nBr = 3  # bags per delivery by runners\nTr = 4  # hours per delivery by runners\nBc = 10 # bags per delivery by canoers\nTc = 2  # hours per delivery by canoers\nPc = 0.33 # maximum proportion of deliveries by canoe\nH = 200  # maximum total hours available\nR_min = 4 # minimum number of runners to be used\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"runners\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"canoers\")\n\n# Objective: Maximize the total amount of mail delivered\nmodel.setObjective(Br * x + Bc * y, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(Tr * x + Tc * y <= H, \"TotalHours\") # C1\nmodel.addConstr(y <= Pc * (x + y), \"CanoeProportion\") # C2\nmodel.addConstr(x >= R_min, \"MinRunners\") # C3\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F183",
    "description": "An ice cream store can buy two machines, a counter-top sized one and a fridge sized one, to make ice cream. The counter-top sized one can produce 80 cones worth of ice cream every day while the fridge sizes one can produce 150 cones worth of ice cream every day. The counter-top sized machine outputs 50 units of heat while the fridge sized one outputs 70 units of heat. The ice cream store can output at most 500 units of heat per day and must produce at least 1000 cones worth of ice cream. How many of each machine should they buy to minimize the total number of machines needed?",
    "ground_truth": 7.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create the model\nmodel = gp.Model(\"IceCreamMachineOptimization\")\n\n# Parameters\np1 = 80  # cones per day produced by the counter-top machine\np2 = 150 # cones per day produced by the fridge-sized machine\nh1 = 50  # heat units per day produced by the counter-top machine\nh2 = 70  # heat units per day produced by the fridge-sized machine\nH_max = 500  # maximum heat units allowed per day\nC_min = 1000 # minimum cones required per day\n\n# Variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\") # number of counter-top machines\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\") # number of fridge-sized machines\n\n# Objective: Minimize the total number of machines\nmodel.setObjective(x1 + x2, GRB.MINIMIZE)\n\n# Constraints\n# Production constraint\nmodel.addConstr(p1 * x1 + p2 * x2 >= C_min, \"Production\")\n\n# Heat constraint\nmodel.addConstr(h1 * x1 + h2 * x2 <= H_max, \"Heat\")\n\n# Non-negativity constraints are implicitly handled by the integer variable type in Gurobi\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F064",
    "description": "A tropical city full of islands sends mail either by submarine or by boat. A submarine can carry 100 pieces of mail per trip and uses 30 liters of gas. A boat can carry 80 pieces of mail per trip and uses 25 liters of gas. There can be at most 6 submarine trips and a minimum of 50% of the trips must be by boat. If the city needs to transport at least 1000 pieces of mail, how many of each transportation should they use to minimize the total amount of gas used?",
    "ground_truth": 310.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nC_s = 100  # Capacity of a submarine in pieces of mail\nG_s = 30   # Gas usage per submarine trip in liters\nC_b = 80   # Capacity of a boat in pieces of mail\nG_b = 25   # Gas usage per boat trip in liters\nM = 1000   # Minimum pieces of mail to transport\nT_s = 6    # Maximum number of submarine trips\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of submarine trips\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of boat trips\n\n# Objective\nmodel.setObjective(G_s * x + G_b * y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(C_s * x + C_b * y >= M, \"MailCapacity\")  # C1: Mail capacity constraint\nmodel.addConstr(x <= T_s, \"SubmarineTripLimit\")          # C2: Submarine trip constraint\nmodel.addConstr(y >= 0.5 * (x + y), \"BoatTripPercentage\")  # C3: Boat trip percentage constraint\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F140",
    "description": "A company in the desert can transport goods to rural cities either by camel caravans or desert trucks. A camel caravan can deliver 50 units of goods per trip and takes 12 hours. A desert truck can deliver 150 units of goods per trip and takes 5 hours. However, due to the cost of fuel, the company prefers to have more camel caravans than desert trucks.  If the company needs to deliver 1500 units of goods, how many of each method of transportation should the company organize to minimize the total number of hours required?",
    "ground_truth": 136.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F124",
    "description": "A mask making company ships masks to their retail stores using small boxes and large boxes. A small box holds 25 masks whereas a large box holds 45 masks. Since small boxes are easier to stack and will be used first to stock stores, there must be at least three times as many small boxes as large boxes. Additionally, at least 5 large boxes must be used. If at least 750 masks are required to be distributed, how many of each size of box should be used to minimize the total number of boxes needed?",
    "ground_truth": 26.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Add variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n# Set objective: Minimize the total number of boxes\nmodel.setObjective(x_s + x_l, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(25 * x_s + 45 * x_l >= 750, \"MaskRequirement\")\nmodel.addConstr(x_s >= 3 * x_l, \"SmallLargeRatio\")\nmodel.addConstr(x_l >= 5, \"MinLargeBoxes\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F024",
    "description": "In a science club, there are two tables that can be set up to make slime. At table 1, 3 units of powder and 5 units of glue are used to make 4 units of slime. At table 2, 8 units of powder and 6 units of glue are used to make 5 units of slime. However, table 1 produces 2 units of mess while table 2 produces 4 units of mess. The science club has available 100 units of powder and 90 units of glue.  If at most 30 units of mess can be made, how many of each table should be set up to maximize the amount of slime produced?",
    "ground_truth": 60.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SlimeProductionOptimization\")\n\n# Parameters\np1, g1, s1, m1 = 3, 5, 4, 2\np2, g2, s2, m2 = 8, 6, 5, 4\nP, G, M = 100, 90, 30\n\n# Variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")\n\n# Objective: Maximize the total slime produced\nmodel.setObjective(s1 * x1 + s2 * x2, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(p1 * x1 + p2 * x2 <= P, \"PowderConstraint\")\nmodel.addConstr(g1 * x1 + g2 * x2 <= G, \"GlueConstraint\")\nmodel.addConstr(m1 * x1 + m2 * x2 <= M, \"MessConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F076",
    "description": "Employees have the option of car-pooling to work or taking the company bus. A car can take 4 employees and produces 10 units of pollution, while a bus can take 20 employees and produces 30 units of pollution. At least 300 employees need to be transported and at most 4 buses can be used. How many of each type of transport should be taken to minimize the total pollution produced.",
    "ground_truth": 670.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nP_c = 10  # Pollution units produced by one car\nP_b = 30  # Pollution units produced by one bus\nC = 4     # Capacity of one car (number of employees)\nB = 20    # Capacity of one bus (number of employees)\nE = 300   # Minimum number of employees that need to be transported\nN_b = 4   # Maximum number of buses that can be used\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of cars\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of buses\n\n# Objective\nmodel.setObjective(P_c * x + P_b * y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(C * x + B * y >= E, \"C1\")  # Meet the minimum employee requirement\nmodel.addConstr(y <= N_b, \"C2\")            # Limit the number of buses\nmodel.addConstr(x >= 0, \"C3_x\")            # Non-negativity for x\nmodel.addConstr(y >= 0, \"C3_y\")            # Non-negativity for y\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F042",
    "description": "A school is organizing a field trip to a science center and wants to hire small buses and large buses. A small bus can carry 20 students while a large bus can carry 50 students.  The school needs to provide transportation for at least 500 students.  In addition, since the parking lot is rather small, a maximum of 20% of the buses can be large buses. How many of each type of bus should be hired to minimize the total number of buses?",
    "ground_truth": 20.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nS = 20  # Capacity of a small bus\nL = 50  # Capacity of a large bus\nN = 500  # Minimum number of students to transport\nP = 0.2  # Maximum percentage of buses that can be large buses\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of small buses\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of large buses\n\n# Objective: Minimize the total number of buses\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(S * x + L * y >= N, \"C1\")  # Ensure at least 500 students are transported\nmodel.addConstr(y <= P * (x + y), \"C2\")    # No more than 20% of the buses can be large buses\nmodel.addConstr(x >= 0, \"C3\")              # Non-negativity constraint for small buses\nmodel.addConstr(y >= 0, \"C4\")              # Non-negativity constraint for large buses\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F074",
    "description": "A shipping company need to transport packages by either truck or car. A truck can transport 50 packages per trip while a car can transport 30 packages per trip. In addition, a truck uses 20 liters of gas per trip while a car uses 15 liters of gas per trip. There can be at most 5 truck trips made and at least 30% of all the trips must be made by car. The company needs to transport at least 500 packages. How many of each transportation should they use to minimize the total amount of gas consumed?",
    "ground_truth": 230.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"ShippingOptimization\")\n\n# Define parameters\nP_t = 50  # packages per truck trip\nP_c = 30  # packages per car trip\nG_t = 20  # liters of gas per truck trip\nG_c = 15  # liters of gas per car trip\nT_max = 5  # maximum truck trips\nR_c = 0.3  # minimum proportion of trips by car\nD = 500  # packages to be transported\n\n# Define variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"truck_trips\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"car_trips\")\n\n# Set objective: Minimize total gas consumption\nmodel.setObjective(G_t * x + G_c * y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(P_t * x + P_c * y >= D, \"C1\")  # At least 500 packages\nmodel.addConstr(x <= T_max, \"C2\")              # At most 5 truck trips\nmodel.addConstr(y >= R_c * (x + y), \"C3\")      # At least 30% of trips by car\nmodel.addConstr(x >= 0, \"C4_x\")                # Non-negativity for x\nmodel.addConstr(y >= 0, \"C4_y\")                # Non-negativity for y\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F174",
    "description": "A sandwich company can open two types of stores, a dine-in place and a food-truck. A dine-in place can make 100 sandwiches per day and requires 8 employees to operate. A food-truck can make 50 sandwiches per day and requires 3 employees to operate. The company must make at least 500 sandwiches per day but they only have available 35 employees. How many of each type of store should the company open to minimize the total number of stores?",
    "ground_truth": 8.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SandwichStoreOptimization\")\n\n# Parameters\nS_d = 100  # Sandwiches per day for dine-in place\nS_f = 50   # Sandwiches per day for food-truck\nE_d = 8    # Employees required for dine-in place\nE_f = 3    # Employees required for food-truck\nS_min = 500  # Minimum sandwiches required per day\nE_total = 35 # Total employees available\n\n# Variables\nx_d = model.addVar(vtype=GRB.INTEGER, name=\"x_d\", lb=0)\nx_f = model.addVar(vtype=GRB.INTEGER, name=\"x_f\", lb=0)\n\n# Objective: Minimize the total number of stores\nmodel.setObjective(x_d + x_f, GRB.MINIMIZE)\n\n# Constraints\n# (C1) Sandwich production constraint\nmodel.addConstr(S_d * x_d + S_f * x_f >= S_min, \"SandwichProduction\")\n\n# (C2) Employee constraint\nmodel.addConstr(E_d * x_d + E_f * x_f <= E_total, \"EmployeeLimit\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A056",
    "description": "A tea estate has available 500 acres of land and they need to pick the tea leaves either using a traditional machine or modern machine. For each acre of land, the traditional machine can pick 30 kg of tea leaves, creates 10 kg of waste, and requires 20 liters of fuel. For each acre of land, the modern machine can pick 40 kg of tea leaves, creates 15 kg of waste, and requires 15 liters of fuel. The estate has available 9000 liters of fuel can handle at most 6000 kg of waste. For how many acres should each machine be used to maximize the amount of tea leaves that can be picked?",
    "ground_truth": 17000.0,
    "formulation": null,
    "correct_program": "def optimize_tea_harvest(\n    total_acres=500,\n    total_fuel=9000,\n    max_waste=6000\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Tea_Harvest_Maximization\")\n\n    # Decision variables: acres assigned to traditional and modern machines\n    x = model.addVar(name=\"Traditional_Acres\", lb=0)\n    y = model.addVar(name=\"Modern_Acres\", lb=0)\n\n    # Set the objective: maximize total tea leaves\n    model.setObjective(30 * x + 40 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Land constraint\n    model.addConstr(x + y <= total_acres, name=\"Land_Limit\")\n    # Fuel constraint\n    model.addConstr(20 * x + 15 * y <= total_fuel, name=\"Fuel_Limit\")\n    # Waste constraint\n    model.addConstr(10 * x + 15 * y <= max_waste, name=\"Waste_Limit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total tea leaves picked\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_tea_leaves = optimize_tea_harvest()\n    if max_tea_leaves is not None:\n        print(f\"Maximum Total Tea Leaves Picked: {max_tea_leaves}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 8,
    "retrieved_insights": []
  },
  {
    "task_id": "A073",
    "description": "A mining company has available a total of 100 square miles of mining sites and considering the use of two mining techniques: heap leaching and vat leaching. For each square mile of land, heap leaching technique can have a daily production of 3 tons of rare earth oxide per square miles but it also creates 8 tons of polluted wastewater and requires 10 extraction machines. On the other hand, vat leaching technique produces 5 tons of rare earth oxide per square miles per day while creating 17 tons of polluted wastewater and requiring 20 extraction machines. There are 100 machines available and due to environmental regulations, the amount of polluted wastewater must be at most 90 tons daily. Find the proportion of lands that use each mining technique in order to maximize the daily production of rare earth oxide.",
    "ground_truth": 30.0,
    "formulation": null,
    "correct_program": "def optimize_mining_proportions():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MiningOptimization\")\n\n    # Decision variables: proportions of land allocated to each technique\n    x = m.addVar(name=\"heap_leaching\", lb=0)\n    y = m.addVar(name=\"vat_leaching\", lb=0)\n\n    # Set the objective: maximize total REO production\n    m.setObjective(300 * x + 500 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Land constraint\n    m.addConstr(x + y <= 1, name=\"land_constraint\")\n    # Machine constraint\n    m.addConstr(1000 * x + 2000 * y <= 100, name=\"machine_constraint\")\n    # Wastewater constraint\n    m.addConstr(800 * x + 1700 * y <= 90, name=\"wastewater_constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum production value\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_production = optimize_mining_proportions()\n    if max_production is not None:\n        print(f\"Maximum REO Production: {max_production}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Mining"
      }
    ],
    "cluster": 8,
    "retrieved_insights": []
  },
  {
    "task_id": "A224",
    "description": "There are two ways to extract a metal from mined ores. The first way is to use process J and the second is process P. Process J can extract 5 units of metal using 8 units of water and produces 3 units of pollution. Process P can extract 9 units of metal using 6 units of water and produces 5 units of pollution. There can be at most 1500 units of water 1350 units of pollution. How many of each type of processes should be performed to maximize the amount of metal extracted?",
    "ground_truth": 2250.0,
    "formulation": null,
    "correct_program": "def optimize_metal_extraction(water_limit=1500, pollution_limit=1350):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"MetalExtraction\")\n\n    # Decision variables: number of times to perform each process\n    x_J = model.addVar(name=\"Process_J\", vtype=GRB.INTEGER, lb=0)\n    x_P = model.addVar(name=\"Process_P\", vtype=GRB.INTEGER, lb=0)\n\n    # Set the objective: maximize total metal extracted\n    model.setObjective(5 * x_J + 9 * x_P, GRB.MAXIMIZE)\n\n    # Add water constraint\n    model.addConstr(8 * x_J + 6 * x_P <= water_limit, name=\"WaterLimit\")\n\n    # Add pollution constraint\n    model.addConstr(3 * x_J + 5 * x_P <= pollution_limit, name=\"PollutionLimit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum amount of metal extracted\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage \nif __name__ == \"__main__\":\n    max_metal = optimize_metal_extraction()\n    if max_metal is not None:\n        print(f\"Maximum Metal Extracted: {max_metal}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Mining"
      }
    ],
    "cluster": 8,
    "retrieved_insights": []
  },
  {
    "task_id": "A040",
    "description": "A farmer has 200 acres of land on which he must process hay using either a windrower or hay harvester. For each acre of land, the windrower can process 10 kg of hay while the hay harvester can process 8 kg of hay. Per acre, the windrower produces 5 kg of methane gas and requires 2 kg of fuel. On the other hand, the hay harvester produces 3 kg of methane gas per acre and requires 1 kg of fuel. There are 300 kg of fuel available and the farmer can produce at most 800 kg of methane gas. For how many acres should each machine be used to maximize the amount of hay processed?",
    "ground_truth": 1800.0,
    "formulation": null,
    "correct_program": "def optimize_hay_processing():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"HayProcessing\")\n\n    # Decision variables: acres assigned to windrower (x) and harvester (y)\n    x = m.addVar(name=\"windrower_acres\", lb=0)\n    y = m.addVar(name=\"harvester_acres\", lb=0)\n\n    # Set the objective: maximize total hay processed\n    m.setObjective(10 * x + 8 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(x + y <= 200, name=\"land_constraint\")\n    m.addConstr(2 * x + y <= 300, name=\"fuel_constraint\")\n    m.addConstr(5 * x + 3 * y <= 800, name=\"methane_constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum hay processed\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_hay_processed = optimize_hay_processing()\n    if max_hay_processed is not None:\n        print(f\"Maximum Hay Processed: {max_hay_processed}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 8,
    "retrieved_insights": []
  },
  {
    "task_id": "F176",
    "description": "A farmer has 200 acres of land on which he must process hay using either a windrower or hay harvester. For each acre of land, the windrower can process 10 kg of hay while the hay harvester can process 8 kg of hay. Per acre, the windrower produces 5 kg of methane gas and requires 2 kg of fuel. On the other hand, the hay harvester produces 3 kg of methane gas per acre and requires 1 kg of fuel. There are 300 kg of fuel available and the farmer can produce at most 800 kg of methane gas. For how many acres should each machine be used to maximize the amount of hay processed?",
    "ground_truth": 1800.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nA = 200  # Total acres available\nf = 300  # Total kg of fuel available\nm = 800  # Maximum kg of methane gas allowed\nh_w = 10  # kg of hay processed per acre by windrower\nh_h = 8   # kg of hay processed per acre by hay harvester\ng_w = 5   # kg of methane gas produced per acre by windrower\ng_h = 3   # kg of methane gas produced per acre by hay harvester\nc_w = 2   # kg of fuel required per acre by windrower\nc_h = 1   # kg of fuel required per acre by hay harvester\n\n# Variables\nx = model.addVar(vtype=GRB.CONTINUOUS, name=\"x\", lb=0)  # Acres processed by windrower\ny = model.addVar(vtype=GRB.CONTINUOUS, name=\"y\", lb=0)  # Acres processed by hay harvester\n\n# Objective\nmodel.setObjective(h_w * x + h_h * y, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x + y <= A, \"TotalAcres\")             # Constraint C1\nmodel.addConstr(c_w * x + c_h * y <= f, \"Fuel\")       # Constraint C2\nmodel.addConstr(g_w * x + g_h * y <= m, \"Methane\")    # Constraint C3\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 8,
    "retrieved_insights": []
  },
  {
    "task_id": "F209",
    "description": "A mining company has available a total of 100 square miles of mining sites and considering the use of two mining techniques: heap leaching and vat leaching. For each square mile of land, heap leaching technique can have a daily production of 3 tons of rare earth oxide per square miles but it also creates 8 tons of polluted wastewater and requires 10 extraction machines. On the other hand, vat leaching technique produces 5 tons of rare earth oxide per square miles per day while creating 17 tons of polluted wastewater and requiring 20 extraction machines. There are 100 machines available and due to environmental regulations, the amount of polluted wastewater must be at most 90 tons daily. Find the proportion of lands that use each mining technique in order to maximize the daily production of rare earth oxide.",
    "ground_truth": 30.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nA = 100  # total available land in square miles\nM = 100  # total available machines\nW = 90   # maximum allowable polluted wastewater\np_h = 3  # production rate of heap leaching\np_v = 5  # production rate of vat leaching\nw_h = 8  # wastewater of heap leaching\nw_v = 17 # wastewater of vat leaching\nm_h = 10 # machine requirement for heap leaching\nm_v = 20 # machine requirement for vat leaching\n\n# Decision variables\nx_h = model.addVar(lb=0, ub=A, name=\"x_h\")  # land in square miles using heap leaching\nx_v = model.addVar(lb=0, ub=A, name=\"x_v\")  # land in square miles using vat leaching\n\n# Objective function: Maximize production of rare earth oxide\nmodel.setObjective(p_h * x_h + p_v * x_v, GRB.MAXIMIZE)\n\n# Constraints\n# C1: Land usage constraint\nmodel.addConstr(x_h + x_v <= A, \"LandUsage\")\n\n# C2: Machine constraint\nmodel.addConstr(m_h * x_h + m_v * x_v <= M, \"MachineConstraint\")\n\n# C3: Wastewater constraint\nmodel.addConstr(w_h * x_h + w_v * x_v <= W, \"WastewaterConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "failure_solve"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Mining"
      }
    ],
    "cluster": 8,
    "retrieved_insights": []
  },
  {
    "task_id": "F103",
    "description": "Both subsoil and topsoil need to be added to a garden bed. One bag of subsoil requires 10 units of water to hydrate while one bag of topsoil requires 6 units of water to hydrate every day. The truck used to transport the dirt has limited capacity and therefore, the farmer has available 150 bags of topsoil and subsoil combined. In addition, at least 10 bags of topsoil must be used. Since the topsoil is more expensive, at most 30% of all bags of soil can be topsoil. How many bags of each should be bought to minimize the total amount of water required to hydrate the garden bed?",
    "ground_truth": 300.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 8,
    "retrieved_insights": []
  },
  {
    "task_id": "F063",
    "description": "A water salesman collects water from a glacier and transports it in either small or large kegs. A small keg can hold 40 liters of water while a large keg can hold 100 liters of water. The salesman has available at most 30 small kegs and 10 large kegs. Since small kegs are easier to carry, at least twice as may small kegs must be used than large kegs. If he can transport at most 25 kegs total and at least 5 kegs must be large, how many of each should he use to maximize the total amount of glacial water he can transport?",
    "ground_truth": 1480.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"WaterTransportation\")\n\n# Parameters\nS = 40  # Capacity of a small keg in liters\nL = 100  # Capacity of a large keg in liters\nS_max = 30  # Maximum number of small kegs available\nL_max = 10  # Maximum number of large kegs available\nK_max = 25  # Maximum total number of kegs\nL_min = 5  # Minimum number of large kegs\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of small kegs used\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of large kegs used\n\n# Objective: Maximize the total amount of water transported\nmodel.setObjective(S * x + L * y, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x + y <= K_max, \"TotalKegs\")\nmodel.addConstr(x <= S_max, \"MaxSmallKegs\")\nmodel.addConstr(y <= L_max, \"MaxLargeKegs\")\nmodel.addConstr(y >= L_min, \"MinLargeKegs\")\nmodel.addConstr(x >= 2 * y, \"RatioConstraint\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 8,
    "retrieved_insights": []
  },
  {
    "task_id": "F127",
    "description": "There are two ways to extract a metal from mined ores. The first way is to use process J and the second is process P. Process J can extract 5 units of metal using 8 units of water and produces 3 units of pollution. Process P can extract 9 units of metal using 6 units of water and produces 5 units of pollution. There can be at most 1500 units of water 1350 units of pollution. How many of each type of processes should be performed to maximize the amount of metal extracted?",
    "ground_truth": 2250.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nm_J = 5\nm_P = 9\nw_J = 8\nw_P = 6\np_J = 3\np_P = 5\nW_max = 1500\nP_max = 1350\n\n# Variables\nx_J = model.addVar(vtype=GRB.INTEGER, name=\"x_J\")\nx_P = model.addVar(vtype=GRB.INTEGER, name=\"x_P\")\n\n# Objective: Maximize metal extracted\nmodel.setObjective(m_J * x_J + m_P * x_P, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(w_J * x_J + w_P * x_P <= W_max, \"WaterConstraint\")\nmodel.addConstr(p_J * x_J + p_P * x_P <= P_max, \"PollutionConstraint\")\nmodel.addConstr(x_J >= 0, \"NonNegativity_xJ\")\nmodel.addConstr(x_P >= 0, \"NonNegativity_xP\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Mining"
      }
    ],
    "cluster": 8,
    "retrieved_insights": []
  },
  {
    "task_id": "F193",
    "description": "A tea estate has available 500 acres of land and they need to pick the tea leaves either using a traditional machine or modern machine. For each acre of land, the traditional machine can pick 30 kg of tea leaves, creates 10 kg of waste, and requires 20 liters of fuel. For each acre of land, the modern machine can pick 40 kg of tea leaves, creates 15 kg of waste, and requires 15 liters of fuel. The estate has available 9000 liters of fuel can handle at most 6000 kg of waste. For how many acres should each machine be used to maximize the amount of tea leaves that can be picked?",
    "ground_truth": 17000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nA = 500\nF = 9000\nW = 6000\nT_t = 30\nW_t = 10\nF_t = 20\nT_m = 40\nW_m = 15\nF_m = 15\n\n# Variables\nx_t = model.addVar(name=\"x_t\", vtype=GRB.CONTINUOUS, lb=0)\nx_m = model.addVar(name=\"x_m\", vtype=GRB.CONTINUOUS, lb=0)\n\n# Objective: Maximize the amount of tea leaves picked\nmodel.setObjective(T_t * x_t + T_m * x_m, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_t + x_m <= A, \"TotalAcres\")\nmodel.addConstr(F_t * x_t + F_m * x_m <= F, \"Fuel\")\nmodel.addConstr(W_t * x_t + W_m * x_m <= W, \"Waste\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 8,
    "retrieved_insights": []
  },
  {
    "task_id": "A083",
    "description": "A cleaning company uses a cleansing chemical and odor-removing chemical to clean a house. Each unit of the cleansing chemical takes 4 units to be effective while each unit of the odor-removing chemical takes 6 minutes to be effective. The company must use at least 100 units of the cleansing chemical. In total, at least 300 units of chemicals can be used per house. Further, because the cleansing chemical is strong, there can be at most twice the amount of cleansing chemical as odor-removing chemical. How many units of each should be used to minimize the total time it takes for a house to be cleaned?",
    "ground_truth": 700.0,
    "formulation": null,
    "correct_program": "def optimize_chemical_usage():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Chemical_Optimization\")\n\n    # Decision variables\n    # x: units of cleansing chemical\n    # y: units of odor-removing chemical\n    x = m.addVar(name=\"x\", lb=0)\n    y = m.addVar(name=\"y\", lb=0)\n\n    # Set the objective: minimize total cleaning time\n    m.setObjective(4 * x + 6 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(x >= 100, name=\"min_cleansing\")\n    m.addConstr(x + y <= 300, name=\"total_chemicals\")\n    m.addConstr(x <= 2 * y, name=\"strength_ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total time\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_chemical_usage()\n    if min_time is not None:\n        print(f\"Minimum Total Cleaning Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Cleaning Services"
      }
    ],
    "cluster": 18,
    "retrieved_insights": []
  },
  {
    "task_id": "A240",
    "description": "Both chemical A and chemical B need to be added to a mixer for making bread. One unit of chemical A takes 30 seconds to be effective while one unit of chemical B takes 45 seconds to be effective. Because chemical A can be dangerous, there has to be at most a third as much chemical A as chemical B in the mixer. If there has to be at least 300 units of chemical A in the mixer and at least 1500 units of total chemicals in the mixer, how many units of each should be added to minimize the total time it takes for the mixed bread to be ready?",
    "ground_truth": 61875.0,
    "formulation": null,
    "correct_program": "from gurobipy import Model, GRB\n\n\ndef minimize_chemical_time():\n    # Create a new model\n    model = Model(\"chemical_time_optimization\")\n\n    # Variables\n    x = model.addVar(name=\"x\", lb=300)\n    y = model.addVar(name=\"y\", lb=0)\n\n    # Objective function: minimize 30x + 45y\n    model.setObjective(30 * x + 45 * y, GRB.MINIMIZE)\n\n    # Constraints\n    model.addConstr(x <= (1 / 3) * y, \"A_B_ratio\")\n    model.addConstr(x + y >= 1500, \"total_chemicals\")\n\n    # Optimize\n    model.optimize()\n\n    # Check if solution exists\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n\n\n# Example usage\nif __name__ == \"__main__\":\n    result = minimize_chemical_time()\n    print(f\"Minimum total time for bread to be ready: {result}\")\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Food Processing"
      }
    ],
    "cluster": 18,
    "retrieved_insights": []
  },
  {
    "task_id": "A093",
    "description": "Both fertilizer and seeds need to be added to a lawn. One unit of fertilizer takes 0.5 minutes to be effective while one unit of seeds takes 1.5 minutes to be effective. There can be at most 300 units of fertilizer and seeds combined added to the lawn. In addition at least 50 units of fertilizer need to be added. Since the lawn is really patchy, there can be at most twice the amount of fertilizer as seeds. How many units of each should be added to minimize the total time it takes for the lawn to be ready?",
    "ground_truth": 37.5,
    "formulation": null,
    "correct_program": "def optimize_lawn_treatment():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"LawnTreatment\")\n\n    # Decision variables\n    # F: units of fertilizer\n    # S: units of seeds\n    # T: total time (auxiliary variable)\n    F = m.addVar(name=\"F\", lb=0, vtype=GRB.INTEGER)\n    S = m.addVar(name=\"S\", lb=0, vtype=GRB.INTEGER)\n    T = m.addVar(name=\"T\", lb=0, vtype=GRB.CONTINUOUS)\n\n    # Set objective: minimize total time T\n    m.setObjective(T, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(F + S <= 300, name=\"TotalUnits\")\n    m.addConstr(F >= 50, name=\"MinFertilizer\")\n    m.addConstr(F <= 2 * S, name=\"FertilizerSeedsRatio\")\n    m.addConstr(T >= 0.5 * F, name=\"TimeFertilizer\")\n    m.addConstr(T >= 1.5 * S, name=\"TimeSeeds\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_lawn_treatment()\n    if min_time is not None:\n        print(f\"Minimum Total Time for Lawn Treatment: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 18,
    "retrieved_insights": []
  },
  {
    "task_id": "A112",
    "description": "Both sulfate and ginger need to be added to a shampoo. One unit of sulfate takes 0.5 minutes to be effective while one unit of ginger takes 0.75 minutes to be effective. The shampoo must contain at least 100 units of sulfates and a total of 400 units of both ingredient. Since too much sulfate can damage the hair, there can be at most twice the amount of sulfate as ginger in the shampoo. How many units of each should be added to the shampoo to minimize the total amount of time it takes for the mixture to be effective? (Note: one must be added before the other)",
    "ground_truth": 233.5,
    "formulation": null,
    "correct_program": "def optimize_shampoo_ingredients():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"shampoo_optimization\")\n\n    # Decision variables: number of units of sulfate and ginger\n    S = m.addVar(name=\"S\", lb=0, vtype=GRB.INTEGER)\n    G = m.addVar(name=\"G\", lb=0, vtype=GRB.INTEGER)\n\n    # Set the objective: minimize total effective time\n    m.setObjective(0.5 * S + 0.75 * G, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(S >= 100, name=\"min_sulfate\")\n    m.addConstr(S + G == 400, name=\"total_units\")\n    m.addConstr(S <= 2 * G, name=\"max_sulfate_ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total time\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_shampoo_ingredients()\n    if min_time is not None:\n        print(f\"Minimum Total Effective Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 18,
    "retrieved_insights": []
  },
  {
    "task_id": "A069",
    "description": "An accounting firm employs part time workers and full time workers. Full time workers work 8 hours per shift while part time workers work 4 hours per shift. In addition, full time workers are paid $300 per shift while part time workers are paid $100 per shift. Currently, the accounting firm has a project requiring 500 hours of labor. If the firm has a budget of $15000, how many of each type of worker should be scheduled to minimize the total number of workers.",
    "ground_truth": 100.0,
    "formulation": null,
    "correct_program": "def optimize_worker_schedule():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"WorkerScheduling\")\n\n    # Decision variables: number of full-time and part-time workers\n    F = m.addVar(vtype=GRB.INTEGER, name=\"FullTime\")\n    P = m.addVar(vtype=GRB.INTEGER, name=\"PartTime\")\n\n    # Set the objective: minimize total number of workers\n    m.setObjective(F + P, GRB.MINIMIZE)\n\n    # Add labor hours constraint\n    m.addConstr(8 * F + 4 * P >= 500, name=\"LaborHours\")\n\n    # Add budget constraint\n    m.addConstr(300 * F + 100 * P <= 15000, name=\"Budget\")\n\n    # Set non-negativity constraints (implicitly handled by variable types)\n    # Solve the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of workers\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_workers = optimize_worker_schedule()\n    if min_workers is not None:\n        print(f\"Minimum Total Number of Workers: {min_workers}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Professional Services"
      }
    ],
    "cluster": 10,
    "retrieved_insights": []
  },
  {
    "task_id": "A060",
    "description": "A fire department employs regular and emergency fire fighters. A regular fire fighter works 10 hours per shift and earns $300. An emergency fire fighter works 6 hours per shift and earns $100. Due to wildfires in the region, the fire department needs at least 300 hours of fire fighter time. If the fire department has a budget of $7000, how many of each should the fire department hire to minimize the total number of fire fighters?",
    "ground_truth": 40.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef optimize_firefighters(\n    hours_required=300,\n    hours_regular=10,\n    hours_emergency=6,\n    cost_regular=300,\n    cost_emergency=100,\n    budget=7000\n):\n    # Create a new model\n    model = gp.Model(\"FireFighterOptimization\")\n    \n    # Add decision variables: number of regular and emergency fire fighters\n    R = model.addVar(vtype=GRB.INTEGER, name=\"Regular_Firefighters\", lb=0)\n    E = model.addVar(vtype=GRB.INTEGER, name=\"Emergency_Firefighters\", lb=0)\n    \n    # Set the objective: minimize total number of fire fighters\n    model.setObjective(R + E, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Hours constraint\n    model.addConstr(hours_regular * R + hours_emergency * E >= hours_required, \"HoursRequirement\")\n    \n    # Budget constraint\n    model.addConstr(cost_regular * R + cost_emergency * E <= budget, \"BudgetLimit\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the total number of fire fighters hired\n        total_firefighters = R.X + E.X\n        return total_firefighters\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    total_firefighters = optimize_firefighters()\n    if total_firefighters is not None:\n        print(f\"Total Fire Fighters Hired: {total_firefighters}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Public Services"
      }
    ],
    "cluster": 10,
    "retrieved_insights": []
  },
  {
    "task_id": "F205",
    "description": "An accounting firm employs part time workers and full time workers. Full time workers work 8 hours per shift while part time workers work 4 hours per shift. In addition, full time workers are paid $300 per shift while part time workers are paid $100 per shift. Currently, the accounting firm has a project requiring 500 hours of labor. If the firm has a budget of $15000, how many of each type of worker should be scheduled to minimize the total number of workers.",
    "ground_truth": 100.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nh_f = 8\nh_p = 4\nc_f = 300\nc_p = 100\nH = 500\nB = 15000\n\n# Variables\nx_f = model.addVar(vtype=GRB.INTEGER, name=\"x_f\")\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")\n\n# Objective: Minimize the total number of workers\nmodel.setObjective(x_f + x_p, GRB.MINIMIZE)\n\n# Constraints\n# Labor requirement constraint\nmodel.addConstr(h_f * x_f + h_p * x_p >= H, \"C1\")\n# Budget constraint\nmodel.addConstr(c_f * x_f + c_p * x_p <= B, \"C2\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 10,
    "retrieved_insights": []
  },
  {
    "task_id": "F172",
    "description": "A school employs staff and substitute teachers. Per shift, staff teachers work 6 hours and get paid $300. Per shift, substitute teachers work 3 hours and get paid $100. For the summer term, the school requires 1000 hours of teaching availability. If the school has a budget of $40000, how many of each teacher should be hired to minimize the total number of teachers?",
    "ground_truth": 268.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nHs = 6  # hours per shift for staff teachers\nHsub = 3  # hours per shift for substitute teachers\nPs = 300  # payment per shift for staff teachers\nPsub = 100  # payment per shift for substitute teachers\nT = 1000  # total required teaching hours\nB = 40000  # total budget\n\n# Variables\nxs = model.addVar(vtype=GRB.INTEGER, name=\"staff_teachers\")\nxsub = model.addVar(vtype=GRB.INTEGER, name=\"substitute_teachers\")\n\n# Objective function: Minimize the total number of teachers\nmodel.setObjective(xs + xsub, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(Hs * xs + Hsub * xsub >= T, \"hours_requirement\")\nmodel.addConstr(Ps * xs + Psub * xsub <= B, \"budget_constraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 10,
    "retrieved_insights": []
  },
  {
    "task_id": "A169",
    "description": "A large fishing boat sends fish back to shore either by small canoes or smaller diesel boats. A canoe can carry back 10 fish while a small diesel boat can carry back 15 fish. In order to follow environmental rules, the number of small canoes used has to be at least 3 times as many as the number of diesel boats uses. If  at least 1000 fish need to be transported to shore, minimize the total number of canoes and diesel boats needed.",
    "ground_truth": 89.0,
    "formulation": null,
    "correct_program": "def optimize_boats():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"FishingBoatsOptimization\")\n\n    # Decision variables\n    # x: number of canoes\n    # y: number of diesel boats\n    x = m.addVar(vtype=GRB.INTEGER, name=\"canoes\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"diesel_boats\", lb=0)\n\n    # Set objective: minimize total number of boats\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Fish transportation constraint\n    m.addConstr(10 * x + 15 * y >= 1000, name=\"fish_transport\")\n    # Environmental constraint\n    m.addConstr(x >= 3 * y, name=\"env_rule\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal total number of boats\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    min_boats = optimize_boats()\n    if min_boats is not None:\n        print(f\"Minimum Total Boats: {min_boats}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Fisheries"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "A161",
    "description": "A farmer on an island sends corn to the main land either by ferry or light rail. Each ferry trip can take 20 boxes of corn while each light rail trip can take 15 boxes of corn. Since ferry trips are slow, the number of light rail trip has to be at least 4 times the number of ferry trips. If the farmer wants to send at least 500 boxes of corn, minimize the total number of trips of either type needed.",
    "ground_truth": 32.0,
    "formulation": null,
    "correct_program": "def optimize_corn_transport(\n    min_boxes=500,\n    ferry_capacity=20,\n    rail_capacity=15,\n    min_ratio=4\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Farmer_Corn_Transport\")\n\n    # Decision variables: number of ferry trips and light rail trips\n    F = model.addVar(vtype=GRB.INTEGER, name=\"FerryTrips\", lb=0)\n    L = model.addVar(vtype=GRB.INTEGER, name=\"RailTrips\", lb=0)\n\n    # Set the objective: minimize total trips\n    model.setObjective(F + L, GRB.MINIMIZE)\n\n    # Add constraints\n    # Capacity constraint: total boxes >= min_boxes\n    model.addConstr(20 * F + 15 * L >= min_boxes, name=\"TotalBoxes\")\n    # Trip ratio constraint: L >= 4 * F\n    model.addConstr(L >= min_ratio * F, name=\"TripRatio\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_trips = F.X + L.X\n        return total_trips\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_transport = optimize_corn_transport()\n    if min_transport is not None:\n        print(f\"Minimum Total Transport (Ferry + Rail): {min_transport}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "A131",
    "description": "An oil and gas company is sending their oil to the port using containers and trucks. A container can hold 30 units of oil while a truck can hold 40 units of oil. Due to government restrictions, the number of trucks used has to at most half the number of containers used. If at least 2000 units of oil need to be sent to the port and at least 15 containers need to be used, minimize the total number of containers and trucks needed.",
    "ground_truth": 60.0,
    "formulation": null,
    "correct_program": "def optimize_oil_transport():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"OilTransport\")\n\n    # Decision variables\n    # Number of containers (at least 15)\n    C = m.addVar(name=\"Containers\", vtype=GRB.INTEGER, lb=15)\n    # Number of trucks (non-negative)\n    T = m.addVar(name=\"Trucks\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: minimize total number of containers and trucks\n    m.setObjective(C + T, GRB.MINIMIZE)\n\n    # Capacity constraint: at least 2000 units of oil\n    m.addConstr(30 * C + 40 * T >= 2000, name=\"Capacity\")\n\n    # Truck-to-container ratio constraint\n    m.addConstr(T <= 0.5 * C, name=\"TruckContainerRatio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of containers and trucks\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_transport = optimize_oil_transport()\n    if min_transport is not None:\n        print(f\"Minimum Total Transport (Containers + Trucks): {min_transport}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Oil and Gas"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "A168",
    "description": "An international shipping company uses large and small ships to transport containers around the world. A large ship can carry 500 containers while a small ship can carry 200 containers. Because most ports are small, the number of large ships cannot exceed the number of small ships. If the company is under contract needs to transport at least 3000 containers, find the minimum number of ships that can be used.",
    "ground_truth": 9.0,
    "formulation": null,
    "correct_program": "def minimize_ships():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Minimize_Ships\")\n\n    # Decision variables: number of large and small ships\n    L = m.addVar(vtype=GRB.INTEGER, name=\"LargeShips\", lb=0)\n    S = m.addVar(vtype=GRB.INTEGER, name=\"SmallShips\", lb=0)\n\n    # Set the objective: minimize total number of ships\n    m.setObjective(L + S, GRB.MINIMIZE)\n\n    # Add capacity constraint\n    m.addConstr(500 * L + 200 * S >= 3000, name=\"CapacityConstraint\")\n\n    # Add port constraint: large ships cannot exceed small ships\n    m.addConstr(L <= S, name=\"PortConstraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimum total number of ships\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_ships = minimize_ships()\n    if min_ships is not None:\n        print(f\"Minimum Total Ships (Large + Small): {min_ships}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "A138",
    "description": "A sand company delivers sand for playgrounds in small and large containers. A small container requires 1 person to unload and can hold 20 units of sand. A large container requires 3 people to unload and can hold 50 units of sand. Since most playgrounds are small, the number of small containers used must be thrice the number of large containers used. In addition, there must be at least 5 small containers and 3 large containers used. If the company has 100 people available, maximize the amount of sand that they can deliver.",
    "ground_truth": 1760.0,
    "formulation": null,
    "correct_program": "def optimize_sand_delivery():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"SandDelivery\")\n\n    # Decision variables\n    # x_s: number of small containers\n    # x_l: number of large containers\n    x_s = m.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n    x_l = m.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n    # Set objective: maximize total sand\n    m.setObjective(20 * x_s + 50 * x_l, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Container ratio constraint\n    m.addConstr(x_s == 3 * x_l, \"ratio\")\n    # Minimum containers\n    m.addConstr(x_s >= 5, \"min_small\")\n    m.addConstr(x_l >= 3, \"min_large\")\n    # Labor constraint\n    m.addConstr(x_s + 3 * x_l <= 100, \"labor\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum amount of sand delivered\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_sand = optimize_sand_delivery()\n    if max_sand is not None:\n        print(f\"Maximum Amount of Sand Delivered: {max_sand}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "A160",
    "description": "A construction company in the tropics uses cows and elephants to carry bricks. A cow can carry 20 bricks on its back while an elephant can carry 50 bricks on its back. To avoid having elephants create too much traffic, the number of elephant cannot exceed the number of cows. In addition, there can be at most twice the number of cows as elephants. If the company needs to transport at least 1000 bricks, find the minimum number of animals, cows and elephants, that can be used..",
    "ground_truth": 29.0,
    "formulation": null,
    "correct_program": "def minimize_animals(\n    bricks_required=1000,\n    bricks_per_cow=20,\n    bricks_per_elephant=50\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Minimize Animals\")\n\n    # Decision variables: number of cows and elephants\n    x = model.addVar(vtype=GRB.INTEGER, name=\"cows\", lb=0)\n    y = model.addVar(vtype=GRB.INTEGER, name=\"elephants\", lb=0)\n\n    # Set the objective: minimize total animals\n    model.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Brick transportation constraint\n    model.addConstr(bricks_per_cow * x + bricks_per_elephant * y >= bricks_required, \"bricks_constraint\")\n    # Elephants cannot exceed cows\n    model.addConstr(y <= x, \"elephants_not_exceed_cows\")\n    # At most twice the number of cows as elephants\n    model.addConstr(x <= 2 * y, \"cows_at_most_twice_elephants\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_animals = x.X + y.X\n        return total_animals\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    total_animals = minimize_animals()\n    if total_animals is not None:\n        print(f\"Minimum total number of animals: {total_animals}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Construction"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "A141",
    "description": "A mine sends ore to the surface in small and large wagons. A small wagon hold 20 units of ore while a large wagon holds 50 units of ore. To avoid taking up too much space on the ramps, the number of small wagons must be at least twice as much as the number or large wagons. In addition, at least 10 large wagons must be used. If 2000 units of ore need to taken to the surface, minimize the total number of wagons needed.",
    "ground_truth": 67.0,
    "formulation": null,
    "correct_program": "def optimize_wagons():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"WagonOptimization\")\n\n    # Decision variables\n    # x: number of small wagons\n    # y: number of large wagons\n    x = m.addVar(name=\"small_wagons\", vtype=GRB.INTEGER, lb=0)\n    y = m.addVar(name=\"large_wagons\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: minimize total wagons\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Ore transportation constraint\n    m.addConstr(20 * x + 50 * y >= 2000, name=\"OreRequirement\")\n    # Small wagons at least twice large wagons\n    m.addConstr(x >= 2 * y, name=\"SmallLargeRatio\")\n    # Minimum large wagons\n    m.addConstr(y >= 10, name=\"MinLargeWagons\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_wagons = m.objVal\n        return total_wagons\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_wagons = optimize_wagons()\n    if min_wagons is not None:\n        print(f\"Minimum Total Wagons: {min_wagons}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Mining"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "F041",
    "description": "An oil and gas company is sending their oil to the port using containers and trucks. A container can hold 30 units of oil while a truck can hold 40 units of oil. Due to government restrictions, the number of trucks used has to at most half the number of containers used. If at least 2000 units of oil need to be sent to the port and at least 15 containers need to be used, minimize the total number of containers and trucks needed.",
    "ground_truth": 60.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OilAndGasTransportation\")\n\n# Create variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"containers\")  # Number of containers\ny = model.addVar(vtype=GRB.INTEGER, name=\"trucks\")      # Number of trucks\n\n# Set objective\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(30 * x + 40 * y >= 2000, \"OilCapacity\")  # Constraint C1\nmodel.addConstr(y <= 0.5 * x, \"TruckToContainerRatio\")   # Constraint C2\nmodel.addConstr(x >= 15, \"MinContainers\")                # Constraint C3\nmodel.addConstr(x >= 0, \"NonNegativityX\")                # Constraint C4 (part of non-negativity)\nmodel.addConstr(y >= 0, \"NonNegativityY\")                # Constraint C4 (part of non-negativity)\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Oil and Gas"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "F051",
    "description": "A mine sends ore to the surface in small and large wagons. A small wagon hold 20 units of ore while a large wagon holds 50 units of ore. To avoid taking up too much space on the ramps, the number of small wagons must be at least twice as much as the number or large wagons. In addition, at least 10 large wagons must be used. If 2000 units of ore need to taken to the surface, minimize the total number of wagons needed.",
    "ground_truth": 67.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n# Set objective\nmodel.setObjective(x_s + x_l, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(20 * x_s + 50 * x_l == 2000, \"C1\")\nmodel.addConstr(x_s >= 2 * x_l, \"C2\")\nmodel.addConstr(x_l >= 10, \"C3\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Mining"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "F059",
    "description": "A corn farmer sends his corn to the city by either tractor or car.  A tractor can carry 40 kg of corn while a car can carry 20 kg of corn. Since tractors are very slow, the number of cars used has to be at least twice the number of tractors used. If at least 500 kg of corn need to be sent to the city, minimize the total number of tractors and cars needed.",
    "ground_truth": 19.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nT = 40  # kg/tractor\nC = 20  # kg/car\nR = 2   # minimum ratio of cars to tractors\nQ = 500 # kg (minimum amount of corn to send)\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"tractors\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"cars\")\n\n# Objective\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(T * x + C * y >= Q, \"corn_requirement\")\nmodel.addConstr(y >= R * x, \"car_to_tractor_ratio\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "F070",
    "description": "A farmer on an island sends corn to the main land either by ferry or light rail. Each ferry trip can take 20 boxes of corn while each light rail trip can take 15 boxes of corn. Since ferry trips are slow, the number of light rail trip has to be at least 4 times the number of ferry trips. If the farmer wants to send at least 500 boxes of corn, minimize the total number of trips of either type needed.",
    "ground_truth": 32.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Add variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of ferry trips\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of light rail trips\n\n# Set objective\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(20 * x + 15 * y >= 500, \"C1\")  # Minimum boxes constraint\nmodel.addConstr(y >= 4 * x, \"C2\")  # Light rail to ferry trip ratio constraint\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "F069",
    "description": "A construction company in the tropics uses cows and elephants to carry bricks. A cow can carry 20 bricks on its back while an elephant can carry 50 bricks on its back. To avoid having elephants create too much traffic, the number of elephant cannot exceed the number of cows. In addition, there can be at most twice the number of cows as elephants. If the company needs to transport at least 1000 bricks, find the minimum number of animals, cows and elephants, that can be used..",
    "ground_truth": 29.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define parameters\nb_c = 20  # Number of bricks a cow can carry\nb_e = 50  # Number of bricks an elephant can carry\nB = 1000  # Minimum number of bricks to be transported\n\n# Add variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"cows\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"elephants\")\n\n# Set objective\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(b_c * x + b_e * y >= B, \"C1\")\nmodel.addConstr(y <= x, \"C2\")\nmodel.addConstr(x <= 2 * y, \"C3\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Construction"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "F078",
    "description": "A large fishing boat sends fish back to shore either by small canoes or smaller diesel boats. A canoe can carry back 10 fish while a small diesel boat can carry back 15 fish. In order to follow environmental rules, the number of small canoes used has to be at least 3 times as many as the number of diesel boats uses. If  at least 1000 fish need to be transported to shore, minimize the total number of canoes and diesel boats needed.",
    "ground_truth": 89.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nc = 10  # Capacity of a canoe\nd = 15  # Capacity of a diesel boat\nR = 3   # Minimum ratio of canoes to diesel boats\nF = 1000  # Minimum number of fish to be transported\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"canoes\")      # Number of canoes\ny = model.addVar(vtype=GRB.INTEGER, name=\"diesel_boats\") # Number of diesel boats\n\n# Objective: Minimize total number of canoes and diesel boats\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(c * x + d * y >= F, \"C1\")   # Ensure at least 1000 fish are transported\nmodel.addConstr(x >= R * y, \"C2\")           # Number of canoes must be at least 3 times the number of diesel boats\nmodel.addConstr(x >= 0, \"C3\")               # Non-negativity constraint for canoes\nmodel.addConstr(y >= 0, \"C4\")               # Non-negativity constraint for diesel boats\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Fisheries"
      }
    ],
    "cluster": 42,
    "retrieved_insights": []
  },
  {
    "task_id": "A176",
    "description": "A young boy is trying to grow taller by drinking milk and eating vegetables. He wants to get a minimum of 100 units of calcium and 50 units of iron per day. A glass of milk costs $1 and contains 40 units of calcium and 25 units of iron. A plate of vegetables costs $2 and contains 15 units of calcium and 30 units of iron. How many of each should he consume to minimize his cost?",
    "ground_truth": 2.5,
    "formulation": null,
    "correct_program": "def optimize_nutrition(cost_milk=1, cost_vegetables=2, calcium_milk=40, calcium_veg=15,\n                       iron_milk=25, iron_veg=30, min_calcium=100, min_iron=50):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"NutritionOptimization\")\n\n    # Decision variables: number of glasses of milk and plates of vegetables\n    x = model.addVar(name=\"milk\", lb=0)\n    y = model.addVar(name=\"vegetables\", lb=0)\n\n    # Set the objective: minimize total cost\n    model.setObjective(cost_milk * x + cost_vegetables * y, GRB.MINIMIZE)\n\n    # Add calcium constraint\n    model.addConstr(calcium_milk * x + calcium_veg * y >= min_calcium, name=\"CalciumReq\")\n    # Add iron constraint\n    model.addConstr(iron_milk * x + iron_veg * y >= min_iron, name=\"IronReq\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cost = optimize_nutrition()\n    if min_cost is not None:\n        print(f\"Minimum Cost: {min_cost}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "A113",
    "description": "A doctor suggests that his patient eat oranges and grapefruit to meet his vitamin C and vitamin A requirements. One orange contains 5 units of vitamin C, 3 units of vitamin A, and 5 grams of sugar. One grapefruit contains 7 units of vitamin C, 5 units of vitamin A, and 6 grams of sugar. The patient must get at least 80 units of vitamin C and 70 units of vitamin A. Since the patent prefers oranges, he must eat at least 2 times as many oranges as grapefruit. How many of each should he eat to minimize his sugar intake?",
    "ground_truth": 105.0,
    "formulation": null,
    "correct_program": "def optimize_fruit_intake():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Fruit_Optimization\")\n\n    # Decision variables: number of oranges and grapefruits\n    x = m.addVar(name=\"oranges\", lb=0, vtype=GRB.INTEGER)\n    y = m.addVar(name=\"grapefruits\", lb=0, vtype=GRB.INTEGER)\n\n    # Set the objective: minimize total sugar intake\n    m.setObjective(5 * x + 6 * y, GRB.MINIMIZE)\n\n    # Add vitamin C constraint\n    m.addConstr(5 * x + 7 * y >= 80, name=\"VitaminC\")\n    # Add vitamin A constraint\n    m.addConstr(3 * x + 5 * y >= 70, name=\"VitaminA\")\n    # Add preference constraint: oranges at least twice grapefruits\n    m.addConstr(x - 2 * y >= 0, name=\"Preference\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal objective value (minimum sugar intake)\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n\n# Example usage\nprint(optimize_fruit_intake())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "A120",
    "description": "A dietician recommends her client eat blueberries and strawberries to meet her anti-oxidant and mineral requirement. A pack of blueberries contains 3 units of anti-oxidants and 5 units of minerals. A pack of strawberries contains 1 unit of anti-oxidants and 7 units of minerals. The client must get at least 90 units of anti-oxidants and 100 units of minerals. In addition, because blueberries are not in season, the dietician recommend she eats at least 3 times as many packs of strawberries as blueberries. If a pack of blueberries contains 5 grams of sugar and a pack of strawberries contains 7 grams of sugar, how many of packs of each should she consume to minimize her sugar intake?",
    "ground_truth": 390.0,
    "formulation": null,
    "correct_program": "def optimize_fruit_packs():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Fruit_Packs_Minimize_Sugar\")\n\n    # Decision variables: number of blueberry and strawberry packs\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Blueberry_Packs\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Strawberry_Packs\", lb=0)\n\n    # Set objective: minimize total sugar intake\n    m.setObjective(5 * x + 7 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(3 * x + y >= 90, \"AntiOxidant_Requirement\")\n    m.addConstr(5 * x + 7 * y >= 100, \"Mineral_Requirement\")\n    m.addConstr(y >= 3 * x, \"Strawberry_to_Blueberry_Ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimum sugar intake\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_sugar = optimize_fruit_packs()\n    if min_sugar is not None:\n        print(f\"Minimum Sugar Intake: {min_sugar}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "A092",
    "description": "A parent feeds their baby two flavors of baby food, apple and carrot, in order to meet the babies fat and folate requirements. Each serving of apple flavored baby food contains 2 units of fat and 5 units of folate. Each serving of carrot flavored baby food contains 4 units of fat and 3 units of folate. The baby does not like the carrot flavor, and therefore he must eat three times as many apple flavored baby food as carrot flavored baby food. However, he must eat at least 2 servings of carrot flavored baby food. If the baby can consume at most 100 units of folate, how many servings of each should he eat to maximize his fat intake?",
    "ground_truth": 55.55555555555556,
    "formulation": null,
    "correct_program": "def optimize_baby_food():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"BabyFoodOptimization\")\n    \n    # Decision variables\n    # Since servings are discrete, define as integer variables\n    C = m.addVar(name=\"C\", lb=2)  # Carrot servings, at least 2\n    A = m.addVar(name=\"A\", lb=0)        # Apple servings\n    \n    # Add the preference constraint: A = 3 * C\n    m.addConstr(A == 3 * C, name=\"preference\")\n    \n    # Add the folate constraint: 5A + 3C <= 100\n    m.addConstr(5 * A + 3 * C <= 100, name=\"folate_limit\")\n    \n    # Objective: maximize total fat intake = 2A + 4C\n    m.setObjective(2 * A + 4 * C, GRB.MAXIMIZE)\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum fat intake\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nprint(optimize_baby_food())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "A102",
    "description": "A boy needs to get enough magnesium and zinc in his diet by eating chewable gummies and taking pills. Each gummy contains 3 units of magnesium and 4 units of zinc. Each pill contains 2 units of magnesium and 5 units of zinc. The boy must take at least 10 pills. Since he prefers gummies more, he must eat at least 3 times the amount of gummies as pills. If the boy can consume at most 200 units of magnesium, how many of each should he eat to maximize his zinc intake?",
    "ground_truth": 306.0,
    "formulation": null,
    "correct_program": "def optimize_diet(max_magnesium=200, min_pills=10, ratio_gummies_to_pills=3):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Magnesium_Zinc_Optimization\")\n    \n    # Decision variables: number of gummies and pills\n    x = m.addVar(name=\"Gummies\", lb=0, vtype=GRB.INTEGER)\n    y = m.addVar(name=\"Pills\", lb=0, vtype=GRB.INTEGER)\n    \n    # Set the objective: maximize zinc intake\n    m.setObjective(4 * x + 5 * y, GRB.MAXIMIZE)\n    \n    # Add constraints\n    m.addConstr(y >= min_pills, \"MinPills\")\n    m.addConstr(x >= ratio_gummies_to_pills * y, \"GummiesPillsRatio\")\n    m.addConstr(3 * x + 2 * y <= max_magnesium, \"MagnesiumLimit\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum zinc intake\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nprint(optimize_diet())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "A082",
    "description": "A scientist in the arctic needs to get enough vitamin D and vitamin C in his diet by drinking orange and apple juice. Each box of orange juice contains 10 units of vitamin D and 8 units of vitamin C. Each box of apple juice contains 12 units of vitamin D and 6 units of vitamin C. Since the scientist prefers apple juice, he must drink at least 3 times as many apple juice boxes and orange juice boxes. However, he must also drink at least 3 orange juice boxes. To avoid a vitamin C overdose, the scientist can consume at most 300 units of vitamin C. How many of each juice box should he drink to maximize his total vitamin D intake?",
    "ground_truth": 582.0,
    "formulation": null,
    "correct_program": "def optimize_vitamins():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"VitaminIntakeMaximization\")\n\n    # Decision variables: number of orange and apple juice boxes\n    x = m.addVar(name=\"orange_boxes\", vtype=GRB.INTEGER, lb=3)\n    y = m.addVar(name=\"apple_boxes\", vtype=GRB.INTEGER, lb=0)\n\n    # Set the objective: maximize total vitamin D\n    m.setObjective(10 * x + 12 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Vitamin C constraint\n    m.addConstr(8 * x + 6 * y <= 300, name=\"VitaminC_limit\")\n    # Preference constraint: at least 3 times as many apple as orange\n    m.addConstr(y >= 3 * x, name=\"Preference\")\n    # Minimum orange boxes\n    m.addConstr(x >= 3, name=\"Min_orange\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum vitamin D intake\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_vitamin_d = optimize_vitamins()\n    if max_vitamin_d is not None:\n        print(f\"Maximum Vitamin D Intake: {max_vitamin_d}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "A032",
    "description": "A man  only eats vegetable and fruits. A serving of vegetables contains 2 units of vitamins and 3 units of minerals. A serving of fruit contains 4 units of vitamins and 1 unit of minerals. He wants to eat at least 20 units of vitamins and 30 units of minerals. If vegetables cost $3 per serving and fruits cost $5 per serving, how many servings of each should he eat to minimize his cost?",
    "ground_truth": 30.0,
    "formulation": null,
    "correct_program": "def optimize_food_servings():\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"FoodOptimization\")\n\n    # Decision variables: servings of vegetables and fruits\n    x = model.addVar(name=\"vegetables\", lb=0)\n    y = model.addVar(name=\"fruits\", lb=0)\n\n    # Set the objective: minimize total cost\n    model.setObjective(3 * x + 5 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Vitamins constraint\n    model.addConstr(2 * x + 4 * y >= 20, name=\"Vitamins\")\n    # Minerals constraint\n    model.addConstr(3 * x + y >= 30, name=\"Minerals\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal cost\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cost = optimize_food_servings()\n    if min_cost is not None:\n        print(f\"Minimum Cost of Food Servings: {min_cost}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "F168",
    "description": "A man  only eats vegetable and fruits. A serving of vegetables contains 2 units of vitamins and 3 units of minerals. A serving of fruit contains 4 units of vitamins and 1 unit of minerals. He wants to eat at least 20 units of vitamins and 30 units of minerals. If vegetables cost $3 per serving and fruits cost $5 per serving, how many servings of each should he eat to minimize his cost?",
    "ground_truth": 30.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define variables\nx_v = model.addVar(vtype=GRB.INTEGER, name=\"x_v\")\nx_f = model.addVar(vtype=GRB.INTEGER, name=\"x_f\")\n\n# Set objective: Minimize cost\nmodel.setObjective(3 * x_v + 5 * x_f, GRB.MINIMIZE)\n\n# Add constraints\n# Vitamin requirement\nmodel.addConstr(2 * x_v + 4 * x_f >= 20, \"VitaminReq\")\n\n# Mineral requirement\nmodel.addConstr(3 * x_v + x_f >= 30, \"MineralReq\")\n\n# Non-negativity constraints\nmodel.addConstr(x_v >= 0, \"NonNeg_x_v\")\nmodel.addConstr(x_f >= 0, \"NonNeg_x_f\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "F031",
    "description": "A dietician recommends her client eat blueberries and strawberries to meet her anti-oxidant and mineral requirement. A pack of blueberries contains 3 units of anti-oxidants and 5 units of minerals. A pack of strawberries contains 1 unit of anti-oxidants and 7 units of minerals. The client must get at least 90 units of anti-oxidants and 100 units of minerals. In addition, because blueberries are not in season, the dietician recommend she eats at least 3 times as many packs of strawberries as blueberries. If a pack of blueberries contains 5 grams of sugar and a pack of strawberries contains 7 grams of sugar, how many of packs of each should she consume to minimize her sugar intake?",
    "ground_truth": 390.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nB = 3   # anti-oxidants per pack of blueberries\nM_B = 5 # minerals per pack of blueberries\nS_B = 5 # sugar per pack of blueberries\n\nA = 1   # anti-oxidants per pack of strawberries\nM_S = 7 # minerals per pack of strawberries\nS_S = 7 # sugar per pack of strawberries\n\nR_A = 90 # minimum required units of anti-oxidants\nR_M = 100 # minimum required units of minerals\n\n# Variables\nx_B = model.addVar(vtype=GRB.INTEGER, name=\"x_B\") # packs of blueberries\nx_S = model.addVar(vtype=GRB.INTEGER, name=\"x_S\") # packs of strawberries\n\n# Objective: Minimize sugar intake\nmodel.setObjective(S_B * x_B + S_S * x_S, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(B * x_B + A * x_S >= R_A, \"AntiOxidantRequirement\")\nmodel.addConstr(M_B * x_B + M_S * x_S >= R_M, \"MineralRequirement\")\nmodel.addConstr(x_S >= 3 * x_B, \"StrawberryBlueberryRatio\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "F005",
    "description": "A scientist in the arctic needs to get enough vitamin D and vitamin C in his diet by drinking orange and apple juice. Each box of orange juice contains 10 units of vitamin D and 8 units of vitamin C. Each box of apple juice contains 12 units of vitamin D and 6 units of vitamin C. Since the scientist prefers apple juice, he must drink at least 3 times as many apple juice boxes and orange juice boxes. However, he must also drink at least 3 orange juice boxes. To avoid a vitamin C overdose, the scientist can consume at most 300 units of vitamin C. How many of each juice box should he drink to maximize his total vitamin D intake?",
    "ground_truth": 582.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Add variables\nx_O = model.addVar(vtype=GRB.INTEGER, name=\"x_O\")\nx_A = model.addVar(vtype=GRB.INTEGER, name=\"x_A\")\n\n# Set the objective\nmodel.setObjective(10 * x_O + 12 * x_A, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x_A >= 3 * x_O, \"C1\")  # Minimum ratio of apple to orange juice boxes\nmodel.addConstr(x_O >= 3, \"C2\")        # Minimum number of orange juice boxes\nmodel.addConstr(8 * x_O + 6 * x_A <= 300, \"C3\")  # Maximum vitamin C intake\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "F008",
    "description": "A sailor can eat either a crab cakes or a lobster roll for his meals. He needs to ensure he gets at least 80 units of vitamin A and 100 units of vitamin C. Each crab cake contains 5 units of vitamin A and 7 units of vitamin C. Each lobster roll contains 8 units of vitamin A and 4 units of vitamin C. In addition, since lobster is more expensive, at most 40% of his meals should be lobster rolls. If each crab cake contains 4 units of unsaturated fat and each lobster roll contains 6 units of unsaturated fat, how many of each should he eat to minimize his unsaturated fat intake?",
    "ground_truth": 64.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\na1, c1, f1 = 5, 7, 4\na2, c2, f2 = 8, 4, 6\nA, C, p = 80, 100, 0.4\n\n# Variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\", lb=0)\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\", lb=0)\n\n# Objective: Minimize total unsaturated fat intake\nmodel.setObjective(f1 * x1 + f2 * x2, GRB.MINIMIZE)\n\n# Constraints\n# Vitamin A requirement\nmodel.addConstr(a1 * x1 + a2 * x2 >= A, \"C1\")\n# Vitamin C requirement\nmodel.addConstr(c1 * x1 + c2 * x2 >= C, \"C2\")\n# Proportion of lobster rolls\nmodel.addConstr(x2 <= p * (x1 + x2), \"C3\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 7,
    "retrieved_insights": []
  },
  {
    "task_id": "A229",
    "description": "A researcher is outsourcing annotations and has two options: a specialized third-party or a common third-party annotation company. The specialized company can annotate at a rate of 60 images per hour whereas the common company can annotate at a rate of 40 images per hour. However, the specialized company charges $100 per hour and the common company charges $72 per hour. The researcher has deadlines to meet and must complete a dataset of at least 10,000 images. They also have some special images that only the specialized company can annotate. Therefore, at least a third of work must be allocated to the specialized company. How should the researcher distribute the annotations to the two companies to minimize the cost of annotating the whole dataset?",
    "ground_truth": 16666.666666666668,
    "formulation": null,
    "correct_program": "def optimize_annotation_distribution(\n    total_images=10000,\n    specialized_rate=60,\n    common_rate=40,\n    specialized_cost=100,\n    common_cost=72\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"AnnotationCostMinimization\")\n\n    # Decision variables: number of images assigned to each company\n    x = model.addVar(name=\"specialized_images\", lb=0)\n    y = model.addVar(name=\"common_images\", lb=0)\n\n    # Set the objective: minimize total cost\n    # Cost per image for specialized company\n    cost_per_image_specialized = specialized_cost / specialized_rate\n    # Cost per image for common company\n    cost_per_image_common = common_cost / common_rate\n\n    model.setObjective(\n        cost_per_image_specialized * x + cost_per_image_common * y,\n        GRB.MINIMIZE\n    )\n\n    # Add constraints\n    # Total images constraint\n    model.addConstr(x + y >= total_images, name=\"total_images\")\n    # Minimum work for specialized company (at least one-third)\n    model.addConstr(2 * x >= y, name=\"specialized_min_work\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal total cost\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cost = optimize_annotation_distribution()\n    if min_cost is not None:\n        print(f\"Minimum Total Annotation Cost: {min_cost}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Information Technology"
      }
    ],
    "cluster": 48,
    "retrieved_insights": []
  },
  {
    "task_id": "F131",
    "description": "A researcher is outsourcing annotations and has two options: a specialized third-party or a common third-party annotation company. The specialized company can annotate at a rate of 60 images per hour whereas the common company can annotate at a rate of 40 images per hour. However, the specialized company charges $100 per hour and the common company charges $72 per hour. The researcher has deadlines to meet and must complete a dataset of at least 10,000 images. They also have some special images that only the specialized company can annotate. Therefore, at least a third of work must be allocated to the specialized company. How should the researcher distribute the annotations to the two companies to minimize the cost of annotating the whole dataset?",
    "ground_truth": 16666.667,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nn = 10000  # Total images to annotate\nr_s = 60   # Rate of annotation for specialized company (images/hour)\nr_c = 40   # Rate of annotation for common company (images/hour)\nc_s = 100  # Cost per hour for specialized company ($/hour)\nc_c = 72   # Cost per hour for common company ($/hour)\np_s = 1/3  # Minimum proportion of work for specialized company\n\n# Variables\nx_s = model.addVar(name=\"x_s\", lb=0)  # Number of images annotated by the specialized company\nx_c = model.addVar(name=\"x_c\", lb=0)  # Number of images annotated by the common company\n\n# Objective: Minimize the total cost\nmodel.setObjective((x_s / r_s) * c_s + (x_c / r_c) * c_c, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(x_s + x_c >= n, \"TotalImagesConstraint\")  # C1: Total images constraint\nmodel.addConstr(x_s >= p_s * n, \"SpecializedWorkConstraint\")  # C2: Minimum work allocation to specialized company\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Services"
      }
    ],
    "cluster": 48,
    "retrieved_insights": []
  },
  {
    "task_id": "A167",
    "description": "A magic school sends letters to student either by carrier pigeons or owls. A carrier pigeon can carry two letters at a time and requires 3 treats for service. An owl can carry 5 letters at a time and requires 5 treats for service.  At most 40% of the birds can be owls. In addition, the school only has 1000 treats available and at least 20 carrier pigeons must be uses. How many of each bird can be used to maximize the total number of letters that can be sent.",
    "ground_truth": 841.0,
    "formulation": null,
    "correct_program": "def optimize_bird_usage(\n    min_pigeons=20,\n    max_treats=1000,\n    max_owl_ratio=0.4\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create model\n    model = gp.Model(\"BirdLettersMaximization\")\n    model.setParam('OutputFlag', 0)  # Silence Gurobi output\n\n    # Decision variables\n    x = model.addVar(vtype=GRB.INTEGER, lb=min_pigeons, name=\"pigeons\")\n    y = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"owls\")\n\n    # Objective: Maximize total letters sent\n    model.setObjective(2 * x + 5 * y, GRB.MAXIMIZE)\n\n    # Constraints\n    # Treats constraint\n    model.addConstr(3 * x + 5 * y <= max_treats, \"TreatsLimit\")\n    # Owl ratio constraint: y <= (2/3) * x\n    model.addConstr(y <= (2/3) * x, \"OwlRatio\")\n    # Pigeons at least 20\n    model.addConstr(x >= min_pigeons, \"MinPigeons\")\n\n    # Optimize\n    model.optimize()\n\n    # Check feasibility and return result\n    if model.status == GRB.OPTIMAL:\n        total_letters = model.objVal\n        return total_letters\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_letters = optimize_bird_usage()\n    if max_letters is not None:\n        print(f\"Maximum Letters Sent: {max_letters}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 37,
    "retrieved_insights": []
  },
  {
    "task_id": "F077",
    "description": "A magic school sends letters to student either by carrier pigeons or owls. A carrier pigeon can carry two letters at a time and requires 3 treats for service. An owl can carry 5 letters at a time and requires 5 treats for service.  At most 40% of the birds can be owls. In addition, the school only has 1000 treats available and at least 20 carrier pigeons must be uses. How many of each bird can be used to maximize the total number of letters that can be sent.",
    "ground_truth": 841.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nL_p = 2  # letters per carrier pigeon\nT_p = 3  # treats per carrier pigeon\nL_o = 5  # letters per owl\nT_o = 5  # treats per owl\nT = 1000  # total available treats\nP_min = 20  # minimum carrier pigeons\nalpha = 0.4  # maximum proportion of owls\n\n# Variables\np = model.addVar(vtype=GRB.INTEGER, name=\"p\")  # number of carrier pigeons\no = model.addVar(vtype=GRB.INTEGER, name=\"o\")  # number of owls\n\n# Objective: Maximize total number of letters\nmodel.setObjective(2 * p + 5 * o, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(T_p * p + T_o * o <= T, \"TreatsConstraint\")\nmodel.addConstr(p >= P_min, \"MinCarriersConstraint\")\nmodel.addConstr(o <= alpha * (p + o), \"MaxOwlsProportionConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 37,
    "retrieved_insights": []
  },
  {
    "task_id": "A013",
    "description": "My family has decided to invest in real state for the first time. Currently, they have $600,000 to invest, some in apartments and the rest in townhouses. The money invested in apartments must not be greater than $200,000. They have decided that the money invested in apartments must be at least a half as much as that in townhouses.  If the apartments earn 10%, and the townhouses earn 15%, how much money should they invest in each to maximize profit?",
    "ground_truth": 80000.0,
    "formulation": null,
    "correct_program": "def optimize_investment(total_budget=600000, max_apartment_investment=200000, apartment_return=0.10, townhouse_return=0.15):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"RealEstateInvestment\")\n\n    # Decision variables\n    x = model.addVar(name=\"Apartments\", lb=0)  # Investment in apartments\n    y = model.addVar(name=\"Townhouses\", lb=0)  # Investment in townhouses\n\n    # Set objective: maximize profit\n    profit = apartment_return * x + townhouse_return * y\n    model.setObjective(profit, GRB.MAXIMIZE)\n\n    # Add constraints\n    model.addConstr(x + y <= total_budget, name=\"TotalBudget\")\n    model.addConstr(x <= max_apartment_investment, name=\"ApartmentLimit\")\n    model.addConstr(x >= 0.5 * y, name=\"InvestmentRatio\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit value\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_investment()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 26,
    "retrieved_insights": []
  },
  {
    "task_id": "A186",
    "description": "A woman has $100000 to gamble on two sports bets: a basketball tournament, a horse race, and a soccer game. Based on simple analysis, the woman determines her chance of losing her money would be 50% for basketball tournament, 25% for horse race, and 10% for the soccer game. The payout for each dollar put on each bet will be $1.2 for basketball tournament, $0.5 for horse race, and $0.1 for the soccer game. Knowing herself, she limits her average chance of losing her money should be at most 30%. Could you help her determine how much to money to put on each sport bet to maximize her average payout?",
    "ground_truth": 42000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef optimize_bets(total_budget=100000, risk_limit=30000):\n    # Create a new model\n    m = gp.Model(\"BettingOptimization\")\n\n    # Decision variables\n    x_b = m.addVar(name=\"x_b\", lb=0)\n    x_h = m.addVar(name=\"x_h\", lb=0)\n    x_s = m.addVar(name=\"x_s\", lb=0)\n\n    # Set the objective: maximize expected payout\n    m.setObjective(0.6 * x_b + 0.375 * x_h + 0.09 * x_s, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Total investment equals total budget\n    m.addConstr(x_b + x_h + x_s == total_budget, name=\"TotalInvestment\")\n\n    # Risk constraint\n    m.addConstr(0.5 * x_b + 0.25 * x_h + 0.10 * x_s <= risk_limit,\n                name=\"RiskLimit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_payout = optimize_bets()\n    if max_payout is not None:\n        print(f\"Maximum Expected Payout: {max_payout}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 26,
    "retrieved_insights": []
  },
  {
    "task_id": "A000",
    "description": "Mrs. Watson wants to invest in the real-estate market and has a total budget of at most $760000. She has two choices which include condos and detached houses. Each dollar invested in condos yields a $0.50 profit and each dollar invested in detached houses yields a $1 profit. A minimum of 20% of all money invested must be in condos, and at least $20000 must be in detached houses. Formulate an LP that can be used to maximize total profit earned from Mrs. Watson's investment.",
    "ground_truth": 684000.0,
    "formulation": null,
    "correct_program": "def optimize_investment(budget=760000, min_detached=20000, condo_profit_rate=0.5, detached_profit_rate=1.0):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"MrsWatsonInvestment\")\n\n    # Decision variables\n    x_c = model.addVar(name=\"CondoInvestment\", lb=0)\n    x_d = model.addVar(name=\"DetachedInvestment\", lb=min_detached)\n\n    # Set objective: maximize profit\n    model.setObjective(condo_profit_rate * x_c + detached_profit_rate * x_d, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Total budget constraint\n    model.addConstr(x_c + x_d <= budget, name=\"TotalBudget\")\n    # Minimum condo investment (20% of total)\n    # Rearranged as: 0.80 * x_c - 0.20 * x_d >= 0\n    model.addConstr(0.80 * x_c - 0.20 * x_d >= 0, name=\"MinCondoPercent\")\n    # Minimum investment in detached houses\n    model.addConstr(x_d >= min_detached, name=\"MinDetached\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_investment()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 26,
    "retrieved_insights": []
  },
  {
    "task_id": "F196",
    "description": "Jacob has $3000 to invest. He has decided to invest in his favorite clothing company and his favorite tech company. He has decided that the money invested in his favorite clothing company must be at least four times as much as the amount invested in his favorite tech company. He has also limited himself to invest at most $500 in his favorite tech company. If the money invested in his favorite clothing company earns 7% and the money invested in his favorite tech company earns 10%, how much should he invest in each to maximize his profit?",
    "ground_truth": 225.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"InvestmentOptimization\")\n\n# Parameters\nI = 3000  # Total investment\nr_c = 0.07  # Return rate for the clothing company\nr_t = 0.10  # Return rate for the tech company\nR = 500  # Maximum investment in the tech company\nk = 4  # Minimum ratio of clothing to tech investment\n\n# Variables\nx_c = model.addVar(name=\"x_c\", vtype=GRB.CONTINUOUS, lb=0)\nx_t = model.addVar(name=\"x_t\", vtype=GRB.CONTINUOUS, lb=0)\n\n# Objective: Maximize profit\nmodel.setObjective(r_c * x_c + r_t * x_t, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_c + x_t == I, \"TotalInvestment\")  # (C1)\nmodel.addConstr(x_c >= k * x_t, \"RatioConstraint\")  # (C2)\nmodel.addConstr(x_t <= R, \"MaxTechInvestment\")  # (C3)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 26,
    "retrieved_insights": []
  },
  {
    "task_id": "F007",
    "description": "Mrs. Watson wants to invest in the real-estate market and has a total budget of at most $760000. She has two choices which include condos and detached houses. Each dollar invested in condos yields a $0.50 profit and each dollar invested in detached houses yields a $1 profit. A minimum of 20% of all money invested must be in condos, and at least $20000 must be in detached houses. Formulate an LP that can be used to maximize total profit earned from Mrs. Watson's investment.",
    "ground_truth": 684000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"InvestmentOptimization\")\n\n# Parameters\nB = 760000\nr_c = 0.50\nr_d = 1.0\nalpha = 0.20\nM_d = 20000\n\n# Variables\nx_c = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_c\", lb=0)\nx_d = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_d\", lb=0)\n\n# Objective: Maximize profit\nmodel.setObjective(r_c * x_c + r_d * x_d, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_c + x_d <= B, name=\"TotalInvestmentConstraint\")  # C1\nmodel.addConstr(x_c >= alpha * (x_c + x_d), name=\"MinCondosConstraint\")  # C2\nmodel.addConstr(x_d >= M_d, name=\"MinDetachedHousesConstraint\")  # C3\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 26,
    "retrieved_insights": []
  },
  {
    "task_id": "F121",
    "description": "My family has decided to invest in real state for the first time. Currently, they have $600,000 to invest, some in apartments and the rest in townhouses. The money invested in apartments must not be greater than $200,000. They have decided that the money invested in apartments must be at least a half as much as that in townhouses.  If the apartments earn 10%, and the townhouses earn 15%, how much money should they invest in each to maximize profit?",
    "ground_truth": 80000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"RealEstateInvestment\")\n\n# Parameters\nT = 600000  # Total investment available\nA_max = 200000  # Maximum investment in apartments\nr_a = 0.10  # Return rate for apartments\nr_t = 0.15  # Return rate for townhouses\n\n# Variables\nx_a = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"x_a\")  # Investment in apartments\nx_t = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"x_t\")  # Investment in townhouses\n\n# Objective: Maximize total profit\nmodel.setObjective(r_a * x_a + r_t * x_t, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_a + x_t == T, \"TotalInvestment\")  # Total investment constraint\nmodel.addConstr(x_a <= A_max, \"MaxApartmentInvestment\")  # Max investment in apartments\nmodel.addConstr(x_a >= 0.5 * x_t, \"MinApartmentInvestmentRatio\")  # Min ratio constraint\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 26,
    "retrieved_insights": []
  },
  {
    "task_id": "A205",
    "description": "A dentist has 3000 units of resin to fill cavities in both molars and canines. Molars require 20 units of resin and 3 units of pain killer. Canines require 15 units of resin and 2.3 units of pain killer. Since this dentist sees more cavities in canines, at least 60% of cavities filled must be in canines. In addition, the dentist must reserve materials to fill at least 45 molars. How many of each type of teeth should the dentist schedule to fill to minimize the amount of pain killer needed?",
    "ground_truth": 291.4,
    "formulation": null,
    "correct_program": "def optimize_cavity_filling():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"dentist_cavity_filling\")\n    \n    # Decision variables: number of molars and canines to fill\n    x_m = m.addVar(vtype=GRB.INTEGER, name=\"molars\")\n    x_c = m.addVar(vtype=GRB.INTEGER, name=\"canines\")\n    \n    # Set the objective: minimize total pain killer\n    m.setObjective(3 * x_m + 2.3 * x_c, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Resin constraint\n    m.addConstr(20 * x_m + 15 * x_c <= 3000, \"resin_limit\")\n    \n    # Canine proportion constraint: x_c >= 1.5 * x_m\n    m.addConstr(x_c >= 1.5 * x_m, \"canine_proportion\")\n    \n    # Minimum molars filled\n    m.addConstr(x_m >= 45, \"min_molars\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal pain killer usage\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pain_killer = optimize_cavity_filling()\n    if min_pain_killer is not None:\n        print(f\"Minimum Total Pain Killer Usage: {min_pain_killer}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A104",
    "description": "A pharmacy makes eye cream and foot cream using two different machines, machine 1 and machine 2. Machine 1 can  make 30 ml of eye cream and 60 ml of foot cream per hour. Machine 2 can make 45 ml of eye cream and 30 ml of foot cream per hour. Furthermore, machine 1 requires 20 ml of distilled water per hour while machine 2 requires 15 ml of distilled water per hour. The pharmacy has available 1200 ml of distilled water. If the pharmacy needs to make at least 1300 ml of eye cream and 1500 ml of foot cream, how many hours should each machine be used to minimize the total time needed?",
    "ground_truth": 17.333333333333332,
    "formulation": null,
    "correct_program": "def optimize_machine_hours(\n    production_eye_target=1300,\n    production_foot_target=1500,\n    water_available=1200\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Machine_Usage_Minimization\")\n\n    # Decision variables: hours of machine 1 and machine 2\n    x1 = model.addVar(name=\"x1\", lb=0)\n    x2 = model.addVar(name=\"x2\", lb=0)\n    max_hour = model.addVar(name=\"max_hour\", lb=0)\n\n    # Set objective: minimize total hours\n    model.setObjective(max_hour, GRB.MINIMIZE)\n\n    # Add production constraints\n    model.addConstr(30 * x1 + 45 * x2 >= production_eye_target, name=\"EyeCream\")\n    model.addConstr(60 * x1 + 30 * x2 >= production_foot_target, name=\"FootCream\")\n\n    # Add water constraint\n    model.addConstr(20 * x1 + 15 * x2 <= water_available, name=\"WaterLimit\")\n\n    # Add maximum hour constraints\n    model.addConstr(max_hour >= x1, name=\"MaxHour_x1\")\n    model.addConstr(max_hour >= x2, name=\"MaxHour_x2\")\n    \n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the minimal total time\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nprint(optimize_machine_hours())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A201",
    "description": "A student takes calcium pills and vitamin D pills one after the other. Each calcium pill takes 5 minutes to be effective while each vitamin D pill takes 6 minutes to be effective. Over a month, the student must take at least 130 pills of medication and at least 40 should be vitamin D pills because they enhance the absorption of calcium in the body. Since vitamin D is complimentary to calcium, the student must take more calcium pills than vitamin D pills. How many pills of each should the student take to minimize the total time it takes for the medication to be effective?",
    "ground_truth": 690.0,
    "formulation": null,
    "correct_program": "def optimize_pills():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"PillOptimization\")\n\n    # Decision variables: number of calcium and vitamin D pills\n    C = m.addVar(name=\"CalciumPills\", vtype=GRB.INTEGER, lb=0)\n    D = m.addVar(name=\"VitaminDPills\", vtype=GRB.INTEGER, lb=0)\n\n    # Set the objective: minimize total effective time\n    m.setObjective(5 * C + 6 * D, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(C + D >= 130, name=\"TotalPills\")\n    m.addConstr(D >= 40, name=\"MinVitaminD\")\n    m.addConstr(C >= D + 1, name=\"CalciumMoreThanVitaminD\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total time\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_pills()\n    if min_time is not None:\n        print(f\"Minimum Total Effective Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A048",
    "description": "There are two specialized containers, a small and large one, that are used to make a pharmaceutical paste. The small container requires 10 units of water and 15 units of the powdered pill to make 20 units of the paste. The large container requires 20 units of water and 20 units of the powdered pill to make 30 units of the paste. The pharmacy has available 500 units of water and 700 units of the powdered pill. How many of each container should be used to maximize the amount of paste that can be made?",
    "ground_truth": 950.0,
    "formulation": null,
    "correct_program": "def optimize_paste(max_water=500, max_powder=700):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"pharmaceutical_paste\")\n\n    # Decision variables: number of small and large containers\n    x = model.addVar(vtype=GRB.INTEGER, name=\"small_container\")\n    y = model.addVar(vtype=GRB.INTEGER, name=\"large_container\")\n\n    # Set the objective: maximize total paste\n    model.setObjective(20 * x + 30 * y, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    model.addConstr(10 * x + 20 * y <= max_water, \"water_constraint\")\n    model.addConstr(15 * x + 20 * y <= max_powder, \"powder_constraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total paste produced\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_paste = optimize_paste()\n    if max_paste is not None:\n        print(f\"Maximum Total Paste Produced: {max_paste}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Pharmaceuticals"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A159",
    "description": "A dog school trains labradors and golden retrievers to deliver newspaper. A labrador can deliver 7 newspapers at a time and requires 5 small bone treats for service. A golden retriever can deliver 10 newspapers at a time and requires 6 small bone treats per service. The school only has 1500 small bone treats available. In addition, at least 50 golden retrievers must be used and at most 60% of the dogs can be labradors. How many of each dog should be used to maximize the number of newspapers that can be delivered?",
    "ground_truth": 2500.0,
    "formulation": null,
    "correct_program": "def optimize_dogs(max_treats=1500, min_golden=50, max_lab_ratio=0.6):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"DogSchoolOptimization\")\n    m.setParam('OutputFlag', 0)  # Silence Gurobi output\n\n    # Decision variables\n    L = m.addVar(name=\"Labradors\", vtype=GRB.INTEGER, lb=0)\n    G = m.addVar(name=\"Goldens\", vtype=GRB.INTEGER, lb=min_golden)\n\n    # Objective: Maximize total newspapers delivered\n    m.setObjective(7 * L + 10 * G, GRB.MAXIMIZE)\n\n    # Constraints\n    # Bone treat constraint\n    m.addConstr(5 * L + 6 * G <= max_treats, name=\"TreatsLimit\")\n    # Golden retriever minimum\n    m.addConstr(G >= min_golden, name=\"MinGoldens\")\n    # Labrador proportion constraint: L <= 0.6 * (L + G)\n    # Rearranged: 2L <= 3G\n    m.addConstr(2 * L <= 3 * G, name=\"LabradorProportion\")\n\n    # Optimize\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_newspapers = m.objVal\n        return total_newspapers\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_newspapers = optimize_dogs()\n    if max_newspapers is not None:\n        print(f\"Maximum Newspapers Delivered: {max_newspapers}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Education"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A086",
    "description": "A pharmaceutical company makes skin cream in batches, a regular batch and premium batch, to sell to hospitals. The regular batch requires 50 units of medicinal ingredients and 40 units of rehydration product. A premium batch requires 40 units of medicinal ingredients and 60 units of rehydration product. The company has available 3000 units of medicinal ingredients and 3500 units of rehydration product. Since the premium batch sells better, the number of regular batches must be less than the number of premium batches. In addition, the company must make at least 10 regular batches. If a regular batch can treat 50 people and a premium batch can treat 30 people, how many of each batch should be made to maximize the number of people that can be treated?",
    "ground_truth": 2650.0,
    "formulation": null,
    "correct_program": "def optimize_batches(\n    min_regular_batches=10,\n    max_resource_medicinal=3000,\n    max_resource_rehydration=3500\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Batch_Production_Optimization\")\n\n    # Decision variables\n    # x: number of regular batches\n    # y: number of premium batches\n    x = model.addVar(name=\"x\", vtype=GRB.INTEGER, lb=min_regular_batches)\n    y = model.addVar(name=\"y\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: maximize total number of treated people\n    model.setObjective(50 * x + 30 * y, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    model.addConstr(50 * x + 40 * y <= max_resource_medicinal, \"Medicinal\")\n    model.addConstr(40 * x + 60 * y <= max_resource_rehydration, \"Rehydration\")\n\n    # Add batch relationship constraint: x < y\n    # Since variables are integers, x <= y - 1\n    model.addConstr(x <= y - 1, \"BatchRelation\")\n\n    # Optional: To ensure logical bounds, but already set lb for x\n    # model.addConstr(x >= 10, \"MinRegularBatches\") # Already set lb=10\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total treated people\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_treated_people = optimize_batches()\n    if max_treated_people is not None:\n        print(f\"Maximum Total Number of Treated People: {max_treated_people}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A088",
    "description": "A patient with a sore throat can drink two syrups, syrup 1 and syrup 2 for treatment. Per serving, syrup 1 delivers 0.5 units of medicine to the throat and 0.4 units of medicine to the lungs. Per serving, syrup 2 delivers 0.2 units of medicine to the throat and 0.5 units of medicine to the lungs. Furthermore, syrup 1 contains 0.5 units of sugar while syrup 2 contains 0.3 units of sugar per serving. The patient can get at most 5 units of medicine for the throat and at least 4 units of medicine to the lungs. How many servings of each should the patient take to minimize his sugar intake?",
    "ground_truth": 2.4,
    "formulation": null,
    "correct_program": "def optimize_syrup_intake():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"SyrupOptimization\")\n\n    # Decision variables: number of servings of each syrup\n    x1 = m.addVar(name=\"x1\", lb=0)\n    x2 = m.addVar(name=\"x2\", lb=0)\n\n    # Set the objective: minimize sugar intake\n    m.setObjective(0.5 * x1 + 0.3 * x2, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(0.5 * x1 + 0.2 * x2 <= 5, name=\"ThroatMedicine\")\n    m.addConstr(0.4 * x1 + 0.5 * x2 >= 4, name=\"LungMedicine\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n\n# Example usage\nprint(optimize_syrup_intake())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A103",
    "description": "A patient takes anxiety medication and anti-depressants one after the other. Each unit of anxiety medication takes 3 minutes to be effective while each unit of anti-depressant takes 5 minutes to be effective. The patient must take at least 100 units of medication and at least 30 should be anxiety medication. Since the anxiety medication is strong, the patient can take at most twice the amount of anxiety medication as anti-depressants. How many units of each should the patient take to minimize the total time it take for the medication to be effective?",
    "ground_truth": 368.0,
    "formulation": null,
    "correct_program": "def optimize_medication_time(\n    min_total_units=100,\n    min_anxiety_units=30,\n    max_ratio=2\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Medication_Minimize_Time\")\n\n    # Decision variables: number of units of each medication\n    x = model.addVar(name=\"x\", lb=0, vtype=GRB.INTEGER)  # anxiety medication\n    y = model.addVar(name=\"y\", lb=0, vtype=GRB.INTEGER)  # anti-depressants\n\n    # Set objective: minimize total time\n    model.setObjective(3 * x + 5 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    model.addConstr(x + y >= min_total_units, name=\"total_units\")\n    model.addConstr(x >= min_anxiety_units, name=\"min_anxiety\")\n    model.addConstr(x <= max_ratio * y, name=\"ratio_constraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the minimal total time\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_medication_time()\n    if min_time is not None:\n        print(f\"Minimum Total Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A036",
    "description": "A gem factory has two drills, a high intensity one and a low intensity one. Each day, the high intensity drill can process 50 gems and requires 50 units of water to dissipate heat. Each day, the low intensity drill can process 30 gems and requires 20 units of water to dissipate heat. Each day the factory must process 800 gems and they have available 700 units of water. Since the high intensity drill produces a lot of noise pollution, at most 40% of the drills can be high intensity ones. Further, at least 10 should be low intensity drills. How many of each drill should be used to minimize the total number of drills needed?",
    "ground_truth": 22.0,
    "formulation": null,
    "correct_program": "def optimize_drills():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"GemFactoryDrills\")\n\n    # Decision variables: number of high and low intensity drills\n    x = m.addVar(vtype=GRB.INTEGER, name=\"HighIntensityDrills\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"LowIntensityDrills\", lb=0)\n\n    # Set the objective: minimize total number of drills\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Gem processing capacity\n    m.addConstr(50 * x + 30 * y >= 800, \"GemProcessing\")\n    # Water availability\n    m.addConstr(50 * x + 20 * y <= 700, \"WaterLimit\")\n    # High intensity drill proportion limit\n    m.addConstr(3 * x - 2 * y <= 0, \"HighIntensityLimit\")\n    # Minimum low intensity drills\n    m.addConstr(y >= 10, \"MinLowDrills\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of drills\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_drills = optimize_drills()\n    if min_drills is not None:\n        print(f\"Minimum Total Number of Drills: {min_drills}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A014",
    "description": "My grandma is required to take two medicines Z1 and D3 everyday. She needs to take at least 5 grams of Z1 and 10 grams of D3 everyday. These medicines are available in two pills named Zodiac and Sunny. One pill of Zodiac contains 1.3 grams of Z1 while one pill of Sunny contains 1.2 grams of Z1. On the other hand, one pill of Zodiac contains 1.5 grams of D3 and one pill of Sunny contains 5 grams of D3. The cost per pill of Zodiac is $1 and the cost per pill of Sunny is $3. Formulate a LP such that the medicine requirement can be fulfilled at the lowest cost.",
    "ground_truth": 7.0,
    "formulation": null,
    "correct_program": "def optimize_medicine_purchase():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MedicineOptimization\")\n\n    # Decision variables: number of pills to buy\n    x_z = m.addVar(name=\"Zodiac\", lb=0, vtype=GRB.INTEGER)\n    x_s = m.addVar(name=\"Sunny\", lb=0, vtype=GRB.INTEGER)\n\n    # Set objective: minimize total cost\n    m.setObjective(x_z + 3 * x_s, GRB.MINIMIZE)\n\n    # Add constraints\n    # Z1 requirement\n    m.addConstr(1.3 * x_z + 1.2 * x_s >= 5, name=\"Z1_requirement\")\n    # D3 requirement\n    m.addConstr(1.5 * x_z + 5 * x_s >= 10, name=\"D3_requirement\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n\nprint(optimize_medicine_purchase())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A116",
    "description": "A patient is undergoing radiation treatment involving two beams, Beam 1 and Beam 2. Beam 1 delivers a dose of 0.3 units of medicine per minute to the benign area of the pancreas and 0.2 units of medicine per minute to the benign area of the skin. Beam 2 delivers 0.2 units of medicine per minute to the benign area of the pancreas and 0.1 units of medicine per minute to the benign area of the skin.  In addition, beam 1 delivers 0.6 units of medicine per minute to the tumor and beam 2 delivers 0.4 units of medicine per minute to the tumor. At most 4 units of medicine should be received by the skin and at least 3 units of medicine should be delivered to the tumor.  How many minutes of each beam should be used to minimize the total radiation received by the pancreas?",
    "ground_truth": 1.5,
    "formulation": null,
    "correct_program": "def optimize_radiation_treatment():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"RadiationTreatment\")\n\n    # Decision variables: minutes of each beam\n    x1 = m.addVar(name=\"x1\", lb=0)\n    x2 = m.addVar(name=\"x2\", lb=0)\n\n    # Set the objective: minimize pancreas dose\n    m.setObjective(0.3 * x1 + 0.2 * x2, GRB.MINIMIZE)\n\n    # Add skin dose constraint\n    m.addConstr(0.2 * x1 + 0.1 * x2 <= 4, name=\"SkinDoseLimit\")\n\n    # Add tumor dose constraint\n    m.addConstr(0.6 * x1 + 0.4 * x2 >= 3, name=\"TumorDoseRequirement\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pancreas_dose = optimize_radiation_treatment()\n    if min_pancreas_dose is not None:\n        print(f\"Minimum Pancreas Dose: {min_pancreas_dose}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A081",
    "description": "An dog hospital has 2000 units of tooth medication to make both small and large bones. A small bone requires 10 units of tooth medication and 12 units of meat. A large bone requires 15 units of tooth medication and 15 units of meat. Since most dogs prefer the small bones, at least 50% of the bones made must be small. In addition, the hospital must make at least 30 large bones. How many of each bone should be made to minimize the amount of meat needed?",
    "ground_truth": 810.0,
    "formulation": null,
    "correct_program": "def optimize_bone_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"BoneProduction\")\n\n    # Decision variables\n    # x: number of small bones\n    # y: number of large bones\n    x = m.addVar(vtype=GRB.INTEGER, name=\"small_bones\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"large_bones\", lb=30)\n\n    # Set objective: minimize total meat\n    m.setObjective(12 * x + 15 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Tooth medication constraint\n    m.addConstr(10 * x + 15 * y <= 2000, \"tooth_limit\")\n    # Ratio constraint: at least 50% small bones\n    m.addConstr(x >= y, \"small_ratio\")\n    # Minimum large bones\n    m.addConstr(y >= 30, \"min_large_bones\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total meat used\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_meat = optimize_bone_production()\n    if min_meat is not None:\n        print(f\"Minimum Total Meat Used: {min_meat}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A078",
    "description": "A patient in the hospital can take two pills, Pill 1 and Pill 2. Per pill, pill 1 provides 0.2 units of pain medication and 0.3 units of anxiety medication. Per pill, pill 2 provides 0.6 units of pain medication and 0.2 units of anxiety medication. In addition, pill 1 causes 0.3 units of discharge while pill 2 causes 0.1 units of discharge. At most 6 units of pain medication can be provided and at least 3 units of anxiety medication must be provided. How many pills of each should the patient be given to minimize the total amount of discharge?",
    "ground_truth": 2.3,
    "formulation": null,
    "correct_program": "def optimize_pills(pain_limit=6, anxiety_requirement=3):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Pill_Optimization\")\n\n    # Decision variables: number of pills of each type\n    x1 = model.addVar(name=\"x1\", lb=0, vtype=GRB.INTEGER)  # Type 1 pills\n    x2 = model.addVar(name=\"x2\", lb=0, vtype=GRB.INTEGER)  # Type 2 pills\n\n    # Set the objective: minimize total discharge\n    model.setObjective(0.3 * x1 + 0.1 * x2, GRB.MINIMIZE)\n\n    # Add constraints\n    # Pain medication constraint\n    model.addConstr(0.2 * x1 + 0.6 * x2 <= pain_limit, name=\"PainLimit\")\n    # Anxiety medication constraint\n    model.addConstr(0.3 * x1 + 0.2 * x2 >= anxiety_requirement, name=\"AnxietyReq\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal objective value (minimum discharge)\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n\nprint(optimize_pills())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A114",
    "description": "A university research lab can make two types of diabetes medicine, medicine A and medicine B. Per dose, medicine A takes 30 units of imported material and 50 units of mRNA to make. Per dose, medicine B takes 40 units of imported material and 30 units of mRNA to take. The lab has available at most 300 units of imported material and 400 units of mRNA. The lab can make at most 5 doses of medicine A and the number of doses of medicine B must be larger than the number of dosed of medicine A. If one dose of medicine A can treat 12 people and one dose of medicine B can treat 8 people, how many doses of each should be made to maximize the number of people that can be treated?",
    "ground_truth": 76.0,
    "formulation": null,
    "correct_program": "def optimize_medicine_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MedicineProduction\")\n\n    # Decision variables\n    x = m.addVar(vtype=GRB.INTEGER, name=\"x\")  # Doses of medicine A\n    y = m.addVar(vtype=GRB.INTEGER, name=\"y\")  # Doses of medicine B\n\n    # Set objective: maximize total treated people\n    m.setObjective(12 * x + 8 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(30 * x + 40 * y <= 300, \"MaterialConstraint\")\n    m.addConstr(50 * x + 30 * y <= 400, \"mRNAConstraint\")\n    m.addConstr(x <= 5, \"MaxDosesA\")\n    m.addConstr(y >= x + 1, \"B_at_least_A\")\n    m.addConstr(x >= 0, \"NonNegX\")\n    m.addConstr(y >= 0, \"NonNegY\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum number of people treated\n        return m.objVal\n    else:\n        return None\n\nprint(optimize_medicine_production())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A119",
    "description": "A lab has 1000 units of medicinal ingredients to make two pills, a large pill and a small pill. A large pill requires 3 units of medicinal ingredients and 2 units of filler. A small pill requires 2 units of medicinal ingredients and 1 unit of filler. The lab has to make at least 100 large pills. However, since small pills are more popular at least 60% of the total number of pills must be small. How many of each should be made to minimize the total number of filler material needed?",
    "ground_truth": 350.0,
    "formulation": null,
    "correct_program": "def optimize_pills():\n    from gurobipy import Model, GRB, quicksum\n\n    # Create a new model\n    m = Model(\"PillProduction\")\n\n    # Decision variables\n    # L: number of large pills (integer, at least 100)\n    L = m.addVar(vtype=GRB.INTEGER, name=\"LargePills\", lb=100)\n    # S: number of small pills (integer, at least 0)\n    S = m.addVar(vtype=GRB.INTEGER, name=\"SmallPills\", lb=0)\n\n    # Set objective: minimize total filler used\n    m.setObjective(2 * L + S, GRB.MINIMIZE)\n\n    # Add resource constraint for medicinal ingredients\n    m.addConstr(3 * L + 2 * S <= 1000, \"MedicinalConstraint\")\n\n    # Add constraint for small pills being at least 60% of total\n    # S >= 1.5 * L\n    m.addConstr(S >= 1.5 * L, \"SmallPercentageConstraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal filler usage\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    min_filler = optimize_pills()\n    if min_filler is not None:\n        print(f\"Minimum Total Filler Used: {min_filler}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F138",
    "description": "A clinical firm has two factories, a northern factory and a western factory, where they make expensive anti-itch injections and topical cream. Every hour, the northern factory makes 800 g of anti-itch injections and 700 g of topical cream. Every hour, the western factory makes 650 g of anti-itch injections and 750 g of topical cream. The northern factory requires 40 units of plastic per hour while the western factory requires 35 units of plastic to manufacture the packaging. The clinical firm has available 60,000 units of plastic. Further, they must make at least 800,000 g of anti-itch injections and 700,000 g of topical cream. How many hours should each factory be run to minimize the total time needed?",
    "ground_truth": 1000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nN_inj = 800  # g/hr\nN_cream = 700  # g/hr\nW_inj = 650  # g/hr\nW_cream = 750  # g/hr\nP_N = 40  # units/hr\nP_W = 35  # units/hr\nPlastic_available = 60000  # units\nMin_inj = 800000  # g\nMin_cream = 700000  # g\n\n# Variables\nx_N = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_N\")\nx_W = model.addVar(vtype=GRB.CONTINUOUS, name=\"x_W\")\n\n# Objective: Minimize the total hours run by both factories\nmodel.setObjective(x_N + x_W, GRB.MINIMIZE)\n\n# Constraints\n# C1: Anti-itch injection production constraint\nmodel.addConstr(N_inj * x_N + W_inj * x_W >= Min_inj, \"C1\")\n\n# C2: Topical cream production constraint\nmodel.addConstr(N_cream * x_N + W_cream * x_W >= Min_cream, \"C2\")\n\n# C3: Plastic usage constraint\nmodel.addConstr(P_N * x_N + P_W * x_W <= Plastic_available, \"C3\")\n\n# C4: Non-negativity constraints are implicitly handled by Gurobi\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F030",
    "description": "A lab has 1000 units of medicinal ingredients to make two pills, a large pill and a small pill. A large pill requires 3 units of medicinal ingredients and 2 units of filler. A small pill requires 2 units of medicinal ingredients and 1 unit of filler. The lab has to make at least 100 large pills. However, since small pills are more popular at least 60% of the total number of pills must be small. How many of each should be made to minimize the total number of filler material needed?",
    "ground_truth": 350.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nI = 1000  # Total units of medicinal ingredients available\nF_L = 2  # Units of filler needed for one large pill\nF_S = 1  # Units of filler needed for one small pill\nM_L = 3  # Units of medicinal ingredients needed for one large pill\nM_S = 2  # Units of medicinal ingredients needed for one small pill\nP_L = 100  # Minimum number of large pills\nr = 0.6  # Minimum ratio of small pills to total pills\n\n# Variables\nx_L = model.addVar(vtype=GRB.INTEGER, name=\"x_L\")  # Number of large pills produced\nx_S = model.addVar(vtype=GRB.INTEGER, name=\"x_S\")  # Number of small pills produced\n\n# Objective\nmodel.setObjective(F_L * x_L + F_S * x_S, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(M_L * x_L + M_S * x_S <= I, \"IngredientConstraint\")\nmodel.addConstr(x_L >= P_L, \"MinLargePillsConstraint\")\nmodel.addConstr(x_S >= r * (x_L + x_S), \"SmallPillsRatioConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F110",
    "description": "A dentist has 3000 units of resin to fill cavities in both molars and canines. Molars require 20 units of resin and 3 units of pain killer. Canines require 15 units of resin and 2.3 units of pain killer. Since this dentist sees more cavities in canines, at least 60% of cavities filled must be in canines. In addition, the dentist must reserve materials to fill at least 45 molars. How many of each type of teeth should the dentist schedule to fill to minimize the amount of pain killer needed?",
    "ground_truth": 291.4,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DentistOptimization\")\n\n# Parameters\nR = 3000\nP_m = 3\nP_c = 2.3\nR_m = 20\nR_c = 15\nM_min = 45\nC_min_percent = 0.6\n\n# Variables\nx_m = model.addVar(vtype=GRB.INTEGER, name=\"x_m\")\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"x_c\")\n\n# Objective: Minimize the total amount of pain killer used\nmodel.setObjective(P_m * x_m + P_c * x_c, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(R_m * x_m + R_c * x_c <= R, \"ResinConstraint\")\nmodel.addConstr(x_m >= M_min, \"MinMolarsConstraint\")\nmodel.addConstr(x_c >= 1.5 * x_m, \"CaninePercentageConstraint\")\nmodel.addConstr(x_m >= 0, \"NonNegativityMolar\")\nmodel.addConstr(x_c >= 0, \"NonNegativityCanine\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F004",
    "description": "An dog hospital has 2000 units of tooth medication to make both small and large bones. A small bone requires 10 units of tooth medication and 12 units of meat. A large bone requires 15 units of tooth medication and 15 units of meat. Since most dogs prefer the small bones, at least 50% of the bones made must be small. In addition, the hospital must make at least 30 large bones. How many of each bone should be made to minimize the amount of meat needed?",
    "ground_truth": 810.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DogBoneOptimization\")\n\n# Parameters\nT = 2000  # Total units of tooth medication available\nu_s = 10  # Units of tooth medication required per small bone\nu_l = 15  # Units of tooth medication required per large bone\nm_s = 12  # Units of meat required per small bone\nm_l = 15  # Units of meat required per large bone\np = 0.5   # Minimum proportion of small bones\nL_min = 30  # Minimum number of large bones\n\n# Variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")  # Number of small bones\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")  # Number of large bones\n\n# Objective: Minimize total amount of meat used\nmodel.setObjective(m_s * x_s + m_l * x_l, GRB.MINIMIZE)\n\n# Constraints\n# Constraint 1: Tooth medication constraint\nmodel.addConstr(u_s * x_s + u_l * x_l <= T, \"C1\")\n\n# Constraint 2: Small bones proportion constraint\nmodel.addConstr(x_s >= x_l, \"C2\")\n\n# Constraint 3: Minimum large bones constraint\nmodel.addConstr(x_l >= L_min, \"C3\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F134",
    "description": "A researcher must perform two types of experiments, in-vivo and ex-vivo. In-vivo experiments requires 30 minutes to prepare and 60 minutes to execute. Ex-vivo experiments require 45 minutes to prepare and 30 minutes to execute. In addition, in-vivo experiments gives the researcher 2 units of radiation while ex-vivo experiments give the researcher 3 unites of radiation. At most 400 minutes can be used for preparation and 500 minutes for execution of the experiment. How many of each experiment should be scheduled by the researcher to minimize the total radiation received by the researcher?",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nt_p_in_vivo = 30\nt_e_in_vivo = 60\nr_in_vivo = 2\n\nt_p_ex_vivo = 45\nt_e_ex_vivo = 30\nr_ex_vivo = 3\n\nT_p_max = 400\nT_e_max = 500\n\n# Variables\nx_in_vivo = model.addVar(vtype=GRB.INTEGER, name=\"x_in_vivo\")\nx_ex_vivo = model.addVar(vtype=GRB.INTEGER, name=\"x_ex_vivo\")\n\n# Objective: Minimize total radiation\nmodel.setObjective(r_in_vivo * x_in_vivo + r_ex_vivo * x_ex_vivo, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(t_p_in_vivo * x_in_vivo + t_p_ex_vivo * x_ex_vivo <= T_p_max, \"PreparationTime\")\nmodel.addConstr(t_e_in_vivo * x_in_vivo + t_e_ex_vivo * x_ex_vivo <= T_e_max, \"ExecutionTime\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F129",
    "description": "My grandma is required to take two medicines Z1 and D3 everyday. She needs to take at least 5 grams of Z1 and 10 grams of D3 everyday. These medicines are available in two pills named Zodiac and Sunny. One pill of Zodiac contains 1.3 grams of Z1 while one pill of Sunny contains 1.2 grams of Z1. On the other hand, one pill of Zodiac contains 1.5 grams of D3 and one pill of Sunny contains 5 grams of D3. The cost per pill of Zodiac is $1 and the cost per pill of Sunny is $3. Formulate a LP such that the medicine requirement can be fulfilled at the lowest cost.",
    "ground_truth": 7.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nZ1_requirement = 5  # grams\nD3_requirement = 10  # grams\nZ1_Zodiac = 1.3  # grams/pill\nZ1_Sunny = 1.2  # grams/pill\nD3_Zodiac = 1.5  # grams/pill\nD3_Sunny = 5  # grams/pill\nCost_Zodiac = 1  # dollar/pill\nCost_Sunny = 3  # dollars/pill\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"Zodiac\")  # Number of Zodiac pills\ny = model.addVar(vtype=GRB.INTEGER, name=\"Sunny\")  # Number of Sunny pills\n\n# Objective: Minimize cost\nmodel.setObjective(Cost_Zodiac * x + Cost_Sunny * y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(Z1_Zodiac * x + Z1_Sunny * y >= Z1_requirement, \"Z1_requirement\")\nmodel.addConstr(D3_Zodiac * x + D3_Sunny * y >= D3_requirement, \"D3_requirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F014",
    "description": "A patient can be hooked up to two machines to have medicine delivered, machine 1 and machine 2. Machine 1 delivers 0.5 units of medicine to the heart per minute and 0.8 units of medicine per minute to the brain. Machine 2 delivers 0.3 units of medicine per minute to the heart and 1 unit of medicine per minute to the brain. In addition however, machine 1 creates 0.3 units of waste per minute while machine 2 creates 0.5 units of waste per minute. If at most 8 units of medicine can be received by the heart and at least 4 units of medicine should be received by the brain, how many minutes should each machine be used to minimize the total amount of waste produced?",
    "ground_truth": 1.5,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nr_h1 = 0.5\nr_b1 = 0.8\nw_1 = 0.3\nr_h2 = 0.3\nr_b2 = 1.0\nw_2 = 0.5\nH_max = 8\nB_min = 4\n\n# Variables\nx1 = model.addVar(vtype=GRB.CONTINUOUS, name=\"x1\", lb=0)\nx2 = model.addVar(vtype=GRB.CONTINUOUS, name=\"x2\", lb=0)\n\n# Objective\nmodel.setObjective(w_1 * x1 + w_2 * x2, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(r_h1 * x1 + r_h2 * x2 <= H_max, \"Heart Medicine Limit\")\nmodel.addConstr(r_b1 * x1 + r_b2 * x2 >= B_min, \"Brain Medicine Requirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F068",
    "description": "A dog school trains labradors and golden retrievers to deliver newspaper. A labrador can deliver 7 newspapers at a time and requires 5 small bone treats for service. A golden retriever can deliver 10 newspapers at a time and requires 6 small bone treats per service. The school only has 1500 small bone treats available. In addition, at least 50 golden retrievers must be used and at most 60% of the dogs can be labradors. How many of each dog should be used to maximize the number of newspapers that can be delivered?",
    "ground_truth": 2500.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DogSchoolOptimization\")\n\n# Parameters\nt_L = 5\nt_G = 6\nn_L = 7\nn_G = 10\nT = 1500\nG_min = 50\np_L = 0.6\n\n# Variables\nL = model.addVar(vtype=GRB.INTEGER, name=\"L\")\nG = model.addVar(vtype=GRB.INTEGER, lb=G_min, name=\"G\")\n\n# Objective\nmodel.setObjective(n_L * L + n_G * G, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(t_L * L + t_G * G <= T, \"TotalTreats\")\nmodel.addConstr(G >= G_min, \"MinGoldenRetrievers\")\nmodel.addConstr(L <= p_L * (L + G), \"MaxLabradorsProportion\")\nmodel.addConstr(L >= 0, \"NonNegLabradors\")\nmodel.addConstr(G >= 0, \"NonNegGoldenRetrievers\")\n\n# Optimize\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Animal Training/Services"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F139",
    "description": "A hospital prepares batches of medication patches and anti-biotic creams. Each medication patch requires 3 minutes to prepare and 5 units of materials. Each anti-biotic cream requires 5 minutes to prepare and 6 units of materials. Since anti-biotic creams are used more often, there must be at least twice as many anti-biotic creams as medication patches. Due to storage reasons, the hospital can make at most 100 batches of medication patches and anti-biotic creams in total. The hospital has available 400 minutes of staff to spare and 530 units of materials. If each batch of medication patches can treat 3 people and each batch of anti-biotic cream can treat 2 people, how many batches of each should be made to maximize the number of people that can be treated?",
    "ground_truth": 214.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nT_max = 400\nM_max = 530\nB_max = 100\n\nt_p = 3\nm_p = 5\nt_c = 5\nm_c = 6\n\ntreat_p = 3\ntreat_c = 2\n\n# Decision variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # batches of medication patches\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # batches of anti-biotic creams\n\n# Objective function\nmodel.setObjective(treat_p * x + treat_c * y, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(t_p * x + t_c * y <= T_max, \"TimeConstraint\")\nmodel.addConstr(m_p * x + m_c * y <= M_max, \"MaterialConstraint\")\nmodel.addConstr(x + y <= B_max, \"BatchesConstraint\")\nmodel.addConstr(y >= 2 * x, \"CreamsTwicePatches\")\nmodel.addConstr(x >= 0, \"NonNegativityX\")\nmodel.addConstr(y >= 0, \"NonNegativityY\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F027",
    "description": "A patient is undergoing radiation treatment involving two beams, Beam 1 and Beam 2. Beam 1 delivers a dose of 0.3 units of medicine per minute to the benign area of the pancreas and 0.2 units of medicine per minute to the benign area of the skin. Beam 2 delivers 0.2 units of medicine per minute to the benign area of the pancreas and 0.1 units of medicine per minute to the benign area of the skin.  In addition, beam 1 delivers 0.6 units of medicine per minute to the tumor and beam 2 delivers 0.4 units of medicine per minute to the tumor. At most 4 units of medicine should be received by the skin and at least 3 units of medicine should be delivered to the tumor.  How many minutes of each beam should be used to minimize the total radiation received by the pancreas?",
    "ground_truth": 1.5,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"RadiationTreatmentOptimization\")\n\n# Parameters\nd_p1 = 0.3  # Dose to pancreas by Beam 1\nd_p2 = 0.2  # Dose to pancreas by Beam 2\nd_s1 = 0.2  # Dose to skin by Beam 1\nd_s2 = 0.1  # Dose to skin by Beam 2\nd_t1 = 0.6  # Dose to tumor by Beam 1\nd_t2 = 0.4  # Dose to tumor by Beam 2\nS_max = 4   # Max dose to skin\nT_min = 3   # Min dose to tumor\n\n# Variables\nx1 = model.addVar(vtype=GRB.CONTINUOUS, name=\"x1\", lb=0)\nx2 = model.addVar(vtype=GRB.CONTINUOUS, name=\"x2\", lb=0)\n\n# Objective: Minimize the total radiation received by the pancreas\nmodel.setObjective(d_p1 * x1 + d_p2 * x2, GRB.MINIMIZE)\n\n# Constraints\n# Skin dose constraint\nmodel.addConstr(d_s1 * x1 + d_s2 * x2 <= S_max, \"SkinDose\")\n\n# Tumor dose constraint\nmodel.addConstr(d_t1 * x1 + d_t2 * x2 >= T_min, \"TumorDose\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F019",
    "description": "A pharmacy makes eye cream and foot cream using two different machines, machine 1 and machine 2. Machine 1 can  make 30 ml of eye cream and 60 ml of foot cream per hour. Machine 2 can make 45 ml of eye cream and 30 ml of foot cream per hour. Furthermore, machine 1 requires 20 ml of distilled water per hour while machine 2 requires 15 ml of distilled water per hour. The pharmacy has available 1200 ml of distilled water. If the pharmacy needs to make at least 1300 ml of eye cream and 1500 ml of foot cream, how many hours should each machine be used to minimize the total time needed?",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F018",
    "description": "A patient takes anxiety medication and anti-depressants one after the other. Each unit of anxiety medication takes 3 minutes to be effective while each unit of anti-depressant takes 5 minutes to be effective. The patient must take at least 100 units of medication and at least 30 should be anxiety medication. Since the anxiety medication is strong, the patient can take at most twice the amount of anxiety medication as anti-depressants. How many units of each should the patient take to minimize the total time it take for the medication to be effective?",
    "ground_truth": 368.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nt_a = 3  # Time for anxiety medication\nt_d = 5  # Time for anti-depressant\nM = 100  # Minimum total units of medication\nA_min = 30  # Minimum units of anxiety medication\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Units of anxiety medication\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Units of anti-depressant\n\n# Objective: Minimize total time for medication to be effective\nmodel.setObjective(t_a * x + t_d * y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(x + y >= M, \"C1\")  # Total medication constraint\nmodel.addConstr(x >= A_min, \"C2\")  # Minimum anxiety medication constraint\nmodel.addConstr(x <= 2 * y, \"C3\")  # Ratio constraint for anxiety medication\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F184",
    "description": "There are two specialized containers, a small and large one, that are used to make a pharmaceutical paste. The small container requires 10 units of water and 15 units of the powdered pill to make 20 units of the paste. The large container requires 20 units of water and 20 units of the powdered pill to make 30 units of the paste. The pharmacy has available 500 units of water and 700 units of the powdered pill. How many of each container should be used to maximize the amount of paste that can be made?",
    "ground_truth": 950.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nW_s = 10\nP_s = 15\nPaste_s = 20\nW_l = 20\nP_l = 20\nPaste_l = 30\nW_total = 500\nP_total = 700\n\n# Variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n# Objective\nmodel.setObjective(Paste_s * x_s + Paste_l * x_l, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(W_s * x_s + W_l * x_l <= W_total, \"WaterConstraint\")\nmodel.addConstr(P_s * x_s + P_l * x_l <= P_total, \"PillConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "F088",
    "description": "Calcium and Magnesium are found in two health supplements, health supplement A and health supplement B. One serving of health supplement A contains 30 grams of Calcium and 50 grams of Magnesium. One serving of health supplement B contains 60 grams of Calcium and 10 grams of Magnesium. The cost per health supplement for health supplement A is $14 and the cost per health supplement for health supplement B is $25. A patient must consume these two health supplements every day to get at least 400 grams of Calcium and 50 grams of Magnesium. Determine how much servings of each supplement the patient needs to minimize her daily cost.",
    "ground_truth": 175.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nc_A = 30\nm_A = 50\nc_B = 60\nm_B = 10\ncost_A = 14\ncost_B = 25\nC_min = 400\nM_min = 50\n\n# Variables\nx_A = model.addVar(vtype=GRB.INTEGER, name=\"x_A\")\nx_B = model.addVar(vtype=GRB.INTEGER, name=\"x_B\")\n\n# Objective\nmodel.setObjective(cost_A * x_A + cost_B * x_B, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(c_A * x_A + c_B * x_B >= C_min, \"CalciumRequirement\")\nmodel.addConstr(m_A * x_A + m_B * x_B >= M_min, \"MagnesiumRequirement\")\nmodel.addConstr(x_A >= 0, \"NonNegativity_x_A\")\nmodel.addConstr(x_B >= 0, \"NonNegativity_x_B\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 47,
    "retrieved_insights": []
  },
  {
    "task_id": "A031",
    "description": "John has a 300 acre berry farm on which to plant blueberries and raspberries. John has $10000 to spend on watering and 575 days worth of labor available. For each acre of blueberries, 6 days worth of labor and $22 in watering costs is required. For each acre of raspberries, 3 days worth of labor and $25 in watering costs is required. The profit per acre of blueberries is $56 and the profit per acre of raspberries is $75. Formulate an LP problem in order to maximize profit.",
    "ground_truth": 14375.0,
    "formulation": null,
    "correct_program": "def optimize_berry_farm(\n    total_acres=300,\n    budget=10000,\n    labor_days=575,\n    profit_blueberry=56,\n    profit_raspberry=75,\n    watering_cost_blueberry=22,\n    watering_cost_raspberry=25,\n    labor_blueberry=6,\n    labor_raspberry=3\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"BerryFarmOptimization\")\n\n    # Decision variables: acres of blueberries and raspberries\n    x = model.addVar(name=\"Blueberries\", lb=0)\n    y = model.addVar(name=\"Raspberries\", lb=0)\n\n    # Set the objective: maximize profit\n    model.setObjective(profit_blueberry * x + profit_raspberry * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Land constraint\n    model.addConstr(x + y <= total_acres, name=\"Land\")\n    # Watering cost constraint\n    model.addConstr(watering_cost_blueberry * x + watering_cost_raspberry * y <= budget, name=\"Watering\")\n    # Labor constraint\n    model.addConstr(labor_blueberry * x + labor_raspberry * y <= labor_days, name=\"Labor\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_berry_farm()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 22,
    "retrieved_insights": []
  },
  {
    "task_id": "A035",
    "description": "A farmer has 500 acres of land to grow turnips and pumpkins. Turnips require 50 minutes of watering and $80 worth of pesticide per acre. Pumpkins require 90 minutes of watering and $50 worth of pesticide per acre. The farmer has 40000 minutes available for watering and $34000 available to spend on pesticide. If the revenue per acre of turnips is $300 and the revenue per acre of pumpkins is $450, how many acres of each should he grow to maximize his revenue.",
    "ground_truth": 206250.0,
    "formulation": null,
    "correct_program": "def optimize_crop_allocation(\n    total_land=500,\n    total_water_minutes=40000,\n    total_pesticide_budget=34000,\n    revenue_turnips=300,\n    revenue_pumpkins=450,\n    watering_time_turnips=50,\n    watering_time_pumpkins=90,\n    pesticide_cost_turnips=80,\n    pesticide_cost_pumpkins=50\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"FarmerCropOptimization\")\n\n    # Decision variables: acres of turnips and pumpkins\n    x_T = model.addVar(name=\"Turnips\", lb=0)\n    x_P = model.addVar(name=\"Pumpkins\", lb=0)\n\n    # Set the objective: maximize total revenue\n    model.setObjective(\n        revenue_turnips * x_T + revenue_pumpkins * x_P,\n        GRB.MAXIMIZE\n    )\n\n    # Add constraints\n    # Land constraint\n    model.addConstr(x_T + x_P <= total_land, name=\"LandLimit\")\n    # Watering time constraint\n    model.addConstr(\n        watering_time_turnips * x_T + watering_time_pumpkins * x_P <= total_water_minutes,\n        name=\"WateringTimeLimit\"\n    )\n    # Pesticide budget constraint\n    model.addConstr(\n        pesticide_cost_turnips * x_T + pesticide_cost_pumpkins * x_P <= total_pesticide_budget,\n        name=\"PesticideBudgetLimit\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal revenue\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_revenue = optimize_crop_allocation()\n    if max_revenue is not None:\n        print(f\"Maximum Revenue: {max_revenue}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 22,
    "retrieved_insights": []
  },
  {
    "task_id": "F171",
    "description": "A farmer has 500 acres of land to grow turnips and pumpkins. Turnips require 50 minutes of watering and $80 worth of pesticide per acre. Pumpkins require 90 minutes of watering and $50 worth of pesticide per acre. The farmer has 40000 minutes available for watering and $34000 available to spend on pesticide. If the revenue per acre of turnips is $300 and the revenue per acre of pumpkins is $450, how many acres of each should he grow to maximize his revenue.",
    "ground_truth": 206250.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nA = 500  # Total land available in acres\nW_t = 50  # Watering time for turnips in minutes/acre\nW_p = 90  # Watering time for pumpkins in minutes/acre\nW_max = 40000  # Maximum watering time available in minutes\nP_t = 80  # Pesticide cost for turnips in dollars/acre\nP_p = 50  # Pesticide cost for pumpkins in dollars/acre\nP_max = 34000  # Maximum pesticide budget in dollars\nR_t = 300  # Revenue per acre of turnips in dollars\nR_p = 450  # Revenue per acre of pumpkins in dollars\n\n# Variables\nx_t = model.addVar(name=\"x_t\", vtype=GRB.CONTINUOUS, lb=0)  # Acres of turnips planted\nx_p = model.addVar(name=\"x_p\", vtype=GRB.CONTINUOUS, lb=0)  # Acres of pumpkins planted\n\n# Objective: Maximize total revenue\nmodel.setObjective(R_t * x_t + R_p * x_p, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_t + x_p <= A, \"LandConstraint\")  # Constraint C1\nmodel.addConstr(W_t * x_t + W_p * x_p <= W_max, \"WateringConstraint\")  # Constraint C2\nmodel.addConstr(P_t * x_t + P_p * x_p <= P_max, \"PesticideConstraint\")  # Constraint C3\n\n# Non-negativity constraints are inherent in variable definitions\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 22,
    "retrieved_insights": []
  },
  {
    "task_id": "F167",
    "description": "John has a 300 acre berry farm on which to plant blueberries and raspberries. John has $10000 to spend on watering and 575 days worth of labor available. For each acre of blueberries, 6 days worth of labor and $22 in watering costs is required. For each acre of raspberries, 3 days worth of labor and $25 in watering costs is required. The profit per acre of blueberries is $56 and the profit per acre of raspberries is $75. Formulate an LP problem in order to maximize profit.",
    "ground_truth": 14325.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 22,
    "retrieved_insights": []
  },
  {
    "task_id": "A107",
    "description": "A clinic is conducting a throat or nasal swabs on each patient. A throat swab takes 5 minutes while a nasal swab takes 3 minutes. The clinic must administer at least 30 nasal swabs. Since the nasal swab is more uncomfortable, at least 4 times as many throat swabs must be done as nasal swabs. If the clinic is only operational for 20000 minutes, how many of each swab should be done to maximize the number of patients seen?",
    "ground_truth": 4347.0,
    "formulation": null,
    "correct_program": "def optimize_swabs(time_limit=20000, min_nasal=30, ratio=4):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Swab Optimization\")\n    \n    # Decision variables: number of throat and nasal swabs\n    T = model.addVar(name=\"ThroatSwabs\", vtype=GRB.INTEGER, lb=0)\n    N = model.addVar(name=\"NasalSwabs\", vtype=GRB.INTEGER, lb=0)\n    \n    # Set the objective: maximize total number of patients (swabs)\n    model.setObjective(T + N, GRB.MAXIMIZE)\n    \n    # Add constraints\n    # Time constraint\n    model.addConstr(5 * T + 3 * N <= time_limit, name=\"TimeLimit\")\n    # Minimum nasal swabs\n    model.addConstr(N >= min_nasal, name=\"MinNasal\")\n    # Throat to nasal ratio\n    model.addConstr(T >= ratio * N, name=\"ThroatNasalRatio\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total number of patients served\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_patients = optimize_swabs()\n    if max_patients is not None:\n        print(f\"Maximum Number of Patients Served: {max_patients}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 15,
    "retrieved_insights": []
  },
  {
    "task_id": "A122",
    "description": "A clinic administers two vaccines available for the public to take one at a time. One vaccine is taken as a pill and another is taken as a shot. The pill vaccine takes 10 minutes to administer while the shot takes 20 minutes to administer. Since the shot has been more thoroughly studied, the clinic must deliver at least 3 times as many shots as pill. In addition, the clinic must administer at least 30 pill vaccines. If the clinic only operates for 10000 minutes, maximize the number of patients that can be vaccinated.",
    "ground_truth": 571.0,
    "formulation": null,
    "correct_program": "def optimize_vaccination(max_time=10000, min_pills=30):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Vaccination_Optimization\")\n\n    # Decision variables: number of pills and shots\n    x = model.addVar(name=\"pill\", vtype=GRB.INTEGER, lb=0)\n    y = model.addVar(name=\"shot\", vtype=GRB.INTEGER, lb=0)\n\n    # Set the objective: maximize total vaccinated\n    model.setObjective(x + y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Time constraint\n    model.addConstr(10 * x + 20 * y <= max_time, name=\"time_limit\")\n    # Ratio constraint\n    model.addConstr(y >= 3 * x, name=\"ratio\")\n    # Minimum pills\n    model.addConstr(x >= min_pills, name=\"min_pills\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum number of patients vaccinated\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage \nif __name__ == \"__main__\":\n    max_vaccinated = optimize_vaccination()\n    if max_vaccinated is not None:\n        print(f\"Maximum Patients Vaccinated: {max_vaccinated}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 15,
    "retrieved_insights": []
  },
  {
    "task_id": "F032",
    "description": "A clinic administers two vaccines available for the public to take one at a time. One vaccine is taken as a pill and another is taken as a shot. The pill vaccine takes 10 minutes to administer while the shot takes 20 minutes to administer. Since the shot has been more thoroughly studied, the clinic must deliver at least 3 times as many shots as pill. In addition, the clinic must administer at least 30 pill vaccines. If the clinic only operates for 10000 minutes, maximize the number of patients that can be vaccinated.",
    "ground_truth": 571.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nt_p = 10  # Time in minutes to administer one pill vaccine\nt_s = 20  # Time in minutes to administer one shot vaccine\nr = 3     # Minimum ratio of shots to pills\nP_min = 30 # Minimum number of pill vaccines to be administered\nT_max = 10000 # Total available time in minutes\n\n# Variables\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")  # Number of pill vaccines administered\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")  # Number of shot vaccines administered\n\n# Objective\nmodel.setObjective(x_p + x_s, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(t_p * x_p + t_s * x_s <= T_max, \"TimeConstraint\")  # Constraint C1\nmodel.addConstr(x_s >= r * x_p, \"RatioConstraint\")                 # Constraint C2\nmodel.addConstr(x_p >= P_min, \"MinPillsConstraint\")                # Constraint C3\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 15,
    "retrieved_insights": []
  },
  {
    "task_id": "F021",
    "description": "A clinic is conducting a throat or nasal swabs on each patient. A throat swab takes 5 minutes while a nasal swab takes 3 minutes. The clinic must administer at least 30 nasal swabs. Since the nasal swab is more uncomfortable, at least 4 times as many throat swabs must be done as nasal swabs. If the clinic is only operational for 20000 minutes, how many of each swab should be done to maximize the number of patients seen?",
    "ground_truth": 4347.82612,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SwabOptimization\")\n\n# Parameters\nT = 5  # minutes per throat swab\nN = 3  # minutes per nasal swab\nM = 20000  # total operational minutes available\nR = 4  # minimum ratio of throat swabs to nasal swabs\nL = 30  # minimum number of nasal swabs\n\n# Variables\nx = model.addVar(vtype=GRB.CONTINUOUS, name=\"throat_swabs\")\ny = model.addVar(vtype=GRB.CONTINUOUS, name=\"nasal_swabs\")\n\n# Objective: Maximize the number of patients seen (x + y)\nmodel.setObjective(x + y, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(T * x + N * y <= M, \"TotalTimeConstraint\")\nmodel.addConstr(y >= L, \"MinNasalSwabsConstraint\")\nmodel.addConstr(x >= R * y, \"ThroatToNasalRatioConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 15,
    "retrieved_insights": []
  },
  {
    "task_id": "A091",
    "description": "A lab has 20000 mg of mRNA anti-viral available to make children's and adult vaccines. Each children's vaccine contains 50 mg of mRNA and 50 mg of fever suppressant. Each adult vaccine contains 75 mg of mRNA and 75 mg of fever suppressant. Since adult vaccines are more essential, at least 70% of vaccines should be adult vaccines. However, at least 50 children's vaccines should be made. How many of each vaccine should be made to minimize the amount of fever suppressant used?",
    "ground_truth": 11275.0,
    "formulation": null,
    "correct_program": "def optimize_vaccine_production(\n    total_mrna=20000,\n    min_children=50,\n    adult_ratio=0.7,\n    children_mrna=50,\n    children_fever=50,\n    adult_mrna=75,\n    adult_fever=75\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Vaccine_Production_Optimization\")\n    \n    # Decision variables: number of children's and adult vaccines\n    x = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"Children\")\n    y = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"Adult\")\n    \n    # Set the objective: minimize total fever suppressant\n    model.setObjective(children_fever * x + adult_fever * y, GRB.MINIMIZE)\n    \n    # Add resource constraint (mRNA availability)\n    model.addConstr(children_mrna * x + adult_mrna * y <= total_mrna, \"mRNA_constraint\")\n    \n    # Add ratio constraint: y >= (7/3) * x\n    model.addConstr(y >= (7/3) * x, \"adult_ratio_constraint\")\n    \n    # Add minimum children's vaccines constraint\n    model.addConstr(x >= min_children, \"min_children_constraint\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the minimum total fever suppressant used\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_fever_suppressant = optimize_vaccine_production()\n    if min_fever_suppressant is not None:\n        print(f\"Minimum Total Fever Suppressant Used: {min_fever_suppressant}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 24,
    "retrieved_insights": []
  },
  {
    "task_id": "A003",
    "description": "A store employs senior citizens who earn $500 per week and young adults who earn $750 per week. The store must keep the weekly wage bill below $30000. On any day, the store requires at least 50 workers, of whom at least 10 must be young adults. To ensure the store runs smoothly, the number of young adults should be at least a third the number of senior citizens. Formulate a LP to minimize the wage bill.",
    "ground_truth": 28250.0,
    "formulation": null,
    "correct_program": "def optimize_staffing(wage_budget=30000, min_total_workers=50, min_young=10):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Store Staffing Optimization\")\n    \n    # Decision variables: number of senior citizens and young adults\n    S = m.addVar(name=\"SeniorCitizens\", lb=0, vtype=GRB.INTEGER)\n    Y = m.addVar(name=\"YoungAdults\", lb=0, vtype=GRB.INTEGER)\n    \n    # Set the objective: minimize total wages\n    m.setObjective(500 * S + 750 * Y, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Wage budget constraint\n    m.addConstr(500 * S + 750 * Y <= wage_budget, \"WageBudget\")\n    # Total workers per week\n    m.addConstr(S + Y >= min_total_workers, \"MinTotalWorkers\")\n    # Minimum young adults\n    m.addConstr(Y >= min_young, \"MinYoungAdults\")\n    # Young adults at least a third of senior citizens\n    m.addConstr(3 * Y >= S, \"YoungAtLeastOneThirdSenior\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    total_wages = optimize_staffing()\n    if total_wages is not None:\n        print(f\"Minimum Total Wages: {total_wages}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 27,
    "retrieved_insights": []
  },
  {
    "task_id": "F081",
    "description": "An accounting firm has senior accountants earning $3000 per week and junior accountants earning $1000 per week. The contracts with companies to provide accounting services require at least 100 accountants, of whom at least 5 must be senior accountants. To make sure there is enough experience on the accounting team, the number of senior accountants should be at least a third of the number to junior accountants. The firm wants to keep the weekly wage bill below $150000. Formulate an LP to minimize the wage bill.",
    "ground_truth": 150000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"AccountingFirm\")\n\n# Parameters\nc_s = 3000  # Cost for senior accountants\nc_j = 1000  # Cost for junior accountants\nN = 100     # Minimum total number of accountants\nS_min = 5   # Minimum number of senior accountants\nW = 150000  # Maximum total wage bill\n\n# Variables\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")  # Number of senior accountants\nx_j = model.addVar(vtype=GRB.INTEGER, name=\"x_j\")  # Number of junior accountants\n\n# Set objective: Minimize the total wage bill\nmodel.setObjective(c_s * x_s + c_j * x_j, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(x_s + x_j >= N, \"C1\")                   # Total number of accountants\nmodel.addConstr(x_s >= S_min, \"C2\")                     # Minimum number of senior accountants\nmodel.addConstr(x_s >= (1/3) * x_j, \"C3\")               # Experience requirement\nmodel.addConstr(c_s * x_s + c_j * x_j <= W, \"C4\")       # Maximum wage bill\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 27,
    "retrieved_insights": []
  },
  {
    "task_id": "A021",
    "description": "You are designing an office space with two types of desks: long desks and short desks. You can spend at most $2000. Long desks cost $300, take up 10 square feet of space, and seat 6 employees. Short desks cost $100, take up 4 square feet of space, and seat 2 employees. The office can have at most 200 square feet of desks. How many of each desk should you buy in order to maximize the seating availability?",
    "ground_truth": 40.0,
    "formulation": null,
    "correct_program": "def optimize_office_desks(budget=2000, space_limit=200, long_desk_cost=300, short_desk_cost=100,\n                          long_desk_space=10, short_desk_space=4, long_desk_seats=6, short_desk_seats=2):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Office_Desks_Optimization\")\n    \n    # Decision variables: number of long and short desks\n    x = m.addVar(vtype=GRB.INTEGER, name=\"LongDesks\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"ShortDesks\", lb=0)\n    \n    # Set the objective: maximize total seating\n    m.setObjective(long_desk_seats * x + short_desk_seats * y, GRB.MAXIMIZE)\n    \n    # Add budget constraint\n    m.addConstr(long_desk_cost * x + short_desk_cost * y <= budget, \"BudgetConstraint\")\n    \n    # Add space constraint\n    m.addConstr(long_desk_space * x + short_desk_space * y <= space_limit, \"SpaceConstraint\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum seating capacity\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_seating = optimize_office_desks()\n    if max_seating is not None:\n        print(f\"Maximum Seating Capacity: {max_seating}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Real Estate"
      }
    ],
    "cluster": 17,
    "retrieved_insights": []
  },
  {
    "task_id": "F156",
    "description": "You are designing an office space with two types of desks: long desks and short desks. You can spend at most $2000. Long desks cost $300, take up 10 square feet of space, and seat 6 employees. Short desks cost $100, take up 4 square feet of space, and seat 2 employees. The office can have at most 200 square feet of desks. How many of each desk should you buy in order to maximize the seating availability?",
    "ground_truth": 40.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OfficeSpaceOptimization\")\n\n# Add variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"long_desks\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"short_desks\")\n\n# Set objective: Maximize the number of employees seated\nmodel.setObjective(6 * x + 2 * y, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(300 * x + 100 * y <= 2000, \"budget_constraint\")\nmodel.addConstr(10 * x + 4 * y <= 200, \"area_constraint\")\nmodel.addConstr(x >= 0, \"non_negativity_x\")\nmodel.addConstr(y >= 0, \"non_negativity_y\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Real Estate"
      }
    ],
    "cluster": 17,
    "retrieved_insights": []
  },
  {
    "task_id": "A219",
    "description": "A production company needs to transport their equipment and staff for a movie they are shooting using large mobile production units or small mobile production units. Large mobile production units can hold 6 people and takes up 2 parking spots whereas small mobile production units can hold only 2 people and takes up 1 parking spot. Movie stars prefer to have their small mobile production unit to share with a close staff, therefore at least 5 units must be small mobile units. However, due to logistic limitations, large mobile production units are more space efficient per spot, they must make up at least 75% of all vehicles. If the movie needs to transport 80 people, minimize the total number of parking spots required by this production.",
    "ground_truth": 35.0,
    "formulation": null,
    "correct_program": "def optimize_production_units():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"ProductionUnits\")\n\n    # Decision variables\n    L = m.addVar(vtype=GRB.INTEGER, name=\"LargeUnits\")\n    S = m.addVar(vtype=GRB.INTEGER, name=\"SmallUnits\")\n\n    # Set objective: minimize total parking spots\n    m.setObjective(2 * L + S, GRB.MINIMIZE)\n\n    # Add constraints\n    # Capacity constraint\n    m.addConstr(6 * L + 2 * S >= 80, name=\"PeopleCapacity\")\n    # Minimum small units\n    m.addConstr(S >= 5, name=\"MinSmallUnits\")\n    # Large units at least 75% of total units\n    m.addConstr(L >= 3 * S, name=\"LargeAtLeast75Percent\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal total parking spots\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_parking_spots = optimize_production_units()\n    if min_parking_spots is not None:\n        print(f\"Minimum Total Parking Spots: {min_parking_spots}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Media & Entertainment"
      }
    ],
    "cluster": 4,
    "retrieved_insights": []
  },
  {
    "task_id": "F149",
    "description": "A park is designing their trails and can either create a wide trail or a narrow trail. A wide trail can take 50 visitors every day while the narrow trail expects 20 visitors every day. The wide trail will introduce 6 units of garbage and the narrow trail will introduce 3 units of garbage. There can be at most 3 wide trails and the park hopes to have at most 225 visitors every day. How many of each type of trail should the park construct to minimize the total amount of garbage produced.",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nV_w = 50  # Number of visitors per day for a wide trail\nV_n = 20  # Number of visitors per day for a narrow trail\nG_w = 6   # Units of garbage produced by a wide trail\nG_n = 3   # Units of garbage produced by a narrow trail\nW_max = 3  # Maximum number of wide trails\nV_max = 225  # Maximum number of visitors allowed per day\n\n# Variables\nx_w = model.addVar(vtype=GRB.INTEGER, name=\"x_w\")  # Number of wide trails\nx_n = model.addVar(vtype=GRB.INTEGER, name=\"x_n\")  # Number of narrow trails\n\n# Objective: Minimize the total amount of garbage produced\nmodel.setObjective(G_w * x_w + G_n * x_n, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(V_w * x_w + V_n * x_n <= V_max, \"VisitorConstraint\")\nmodel.addConstr(x_w <= W_max, \"MaxWideTrailsConstraint\")\nmodel.addConstr(x_w >= 0, \"NonNegativityWide\")\nmodel.addConstr(x_n >= 0, \"NonNegativityNarrow\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Environment"
      }
    ],
    "cluster": 4,
    "retrieved_insights": []
  },
  {
    "task_id": "F123",
    "description": "A production company needs to transport their equipment and staff for a movie they are shooting using large mobile production units or small mobile production units. Large mobile production units can hold 6 people and takes up 2 parking spots whereas small mobile production units can hold only 2 people and takes up 1 parking spot. Movie stars prefer to have their small mobile production unit to share with a close staff, therefore at least 5 units must be small mobile units. However, due to logistic limitations, large mobile production units are more space efficient per spot, they must make up at least 75% of all vehicles. If the movie needs to transport 80 people, minimize the total number of parking spots required by this production.",
    "ground_truth": 35.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nP = 80  # Total number of people to transport\nS = 5   # Minimum number of small mobile production units required\nR = 0.75  # Minimum fraction of all vehicles that must be large mobile production units\nc_L = 6  # Capacity of a large mobile production unit\nc_S = 2  # Capacity of a small mobile production unit\np_L = 2  # Parking spots required for one large mobile production unit\np_S = 1  # Parking spots required for one small mobile production unit\n\n# Variables\nx_L = model.addVar(vtype=GRB.INTEGER, name=\"x_L\")\nx_S = model.addVar(vtype=GRB.INTEGER, name=\"x_S\")\n\n# Objective: Minimize the total number of parking spots\nmodel.setObjective(p_L * x_L + p_S * x_S, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(c_L * x_L + c_S * x_S >= P, \"PeopleCapacity\")\nmodel.addConstr(x_S >= S, \"MinSmallUnits\")\nmodel.addConstr(x_L >= R * (x_L + x_S), \"ProportionLargeUnits\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Entertainment"
      }
    ],
    "cluster": 4,
    "retrieved_insights": []
  },
  {
    "task_id": "A129",
    "description": "An aquarium does shows using otters and dolphins. An otter will do 3 tricks at a time and requires 3 treats to do so. A dolphin will do 1 trick at a time and requires 5 treats to do so. Since dolphins are more popular, at least 10 dolphins must be used and at most 30% of the performers can be otters. If the aquarium only has 200 treats available, maximize the total number of tricks that can be preformed.",
    "ground_truth": 71.0,
    "formulation": null,
    "correct_program": "def optimize_tricks():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Aquarium_Performance\")\n\n    # Decision variables: number of sessions for otters and dolphins\n    x_o = m.addVar(vtype=GRB.INTEGER, name=\"Otters\")\n    x_d = m.addVar(vtype=GRB.INTEGER, name=\"Dolphins\")\n\n    # Set objective: maximize total tricks\n    m.setObjective(3 * x_o + x_d, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Otter proportion constraint: 7 * x_o <= 3 * x_d\n    m.addConstr(7 * x_o <= 3 * x_d, name=\"OtterProportion\")\n    # Minimum number of dolphins\n    m.addConstr(x_d >= 10, name=\"MinDolphins\")\n    # Treats constraint\n    m.addConstr(3 * x_o + 5 * x_d <= 200, name=\"TreatsLimit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum total tricks\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_tricks = optimize_tricks()\n    if max_tricks is not None:\n        print(f\"Maximum Tricks: {max_tricks}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Entertainment"
      }
    ],
    "cluster": 30,
    "retrieved_insights": []
  },
  {
    "task_id": "F039",
    "description": "An aquarium does shows using otters and dolphins. An otter will do 3 tricks at a time and requires 3 treats to do so. A dolphin will do 1 trick at a time and requires 5 treats to do so. Since dolphins are more popular, at least 10 dolphins must be used and at most 30% of the performers can be otters. If the aquarium only has 200 treats available, maximize the total number of tricks that can be preformed.",
    "ground_truth": 71.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Aquarium_Show_Optimization\")\n\n# Parameters\nt = 200  # Total number of treats available\nd_min = 10  # Minimum number of dolphins required\no_max_ratio = 0.3  # Maximum percentage of performers that can be otters\n\n# Variables\no = model.addVar(vtype=GRB.INTEGER, name=\"otters\")\nd = model.addVar(vtype=GRB.INTEGER, name=\"dolphins\")\n\n# Objective: Maximize the total number of tricks\nmodel.setObjective(3 * o + d, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(3 * o + 5 * d <= t, \"Treats_Constraint\")\nmodel.addConstr(d >= d_min, \"Min_Dolphins_Constraint\")\nmodel.addConstr(o <= o_max_ratio * (o + d), \"Otters_Percentage_Constraint\")\nmodel.addConstr(o >= 0, \"Non_Negativity_Otters_Constraint\")\nmodel.addConstr(d >= 0, \"Non_Negativity_Dolphins_Constraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Entertainment"
      }
    ],
    "cluster": 30,
    "retrieved_insights": []
  },
  {
    "task_id": "A111",
    "description": "A competitive eater challenges himself to eat slices of cheesecake and caramel cake. Each slice of cheesecake contains 200 calories and 40 grams of sugar. Each slice of caramel cake contains 250 calories and 50 grams of sugar. He prefers cheesecake and decides to eat at least 3 times as many slices of cheesecake as caramel cake. However, he must also eat at least 3 slices of caramel cake. If he can consume at most 10000 calories in one day, how many slices of each cake should he eat to maximize the total amount of sugar he consumes?",
    "ground_truth": 2000.0,
    "formulation": null,
    "correct_program": "def optimize_cakes():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"CakeEatingOptimization\")\n\n    # Decision variables\n    # x: number of cheesecake slices\n    # y: number of caramel cake slices\n    x = m.addVar(vtype=GRB.INTEGER, name=\"x\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"y\", lb=0)\n\n    # Set objective: maximize sugar intake\n    m.setObjective(40 * x + 50 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Preference constraint: x >= 3y\n    m.addConstr(x >= 3 * y, \"pref_constraint\")\n    # Minimum caramel slices\n    m.addConstr(y >= 3, \"min_caramel\")\n    # Calorie constraint\n    m.addConstr(200 * x + 250 * y <= 10000, \"calorie_limit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum sugar intake\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_sugar = optimize_cakes()\n    if max_sugar is not None:\n        print(f\"Maximum Sugar Intake: {max_sugar}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 38,
    "retrieved_insights": []
  },
  {
    "task_id": "F025",
    "description": "A competitive eater challenges himself to eat slices of cheesecake and caramel cake. Each slice of cheesecake contains 200 calories and 40 grams of sugar. Each slice of caramel cake contains 250 calories and 50 grams of sugar. He prefers cheesecake and decides to eat at least 3 times as many slices of cheesecake as caramel cake. However, he must also eat at least 3 slices of caramel cake. If he can consume at most 10000 calories in one day, how many slices of each cake should he eat to maximize the total amount of sugar he consumes?",
    "ground_truth": 2000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nC_c = 200  # calories per slice of cheesecake\nS_c = 40   # grams of sugar per slice of cheesecake\nC_m = 250  # calories per slice of caramel cake\nS_m = 50   # grams of sugar per slice of caramel cake\nC_max = 10000  # maximum calories\n\n# Variables\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"x_c\")  # number of slices of cheesecake\nx_m = model.addVar(vtype=GRB.INTEGER, name=\"x_m\")  # number of slices of caramel cake\n\n# Objective: Maximize total amount of sugar\nmodel.setObjective(S_c * x_c + S_m * x_m, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_c >= 3 * x_m, \"C1\")\nmodel.addConstr(x_m >= 3, \"C2\")\nmodel.addConstr(C_c * x_c + C_m * x_m <= C_max, \"C3\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 38,
    "retrieved_insights": []
  },
  {
    "task_id": "A223",
    "description": "Platinum in combination with palladium has been used as a catalyst in cars and it changes carbon monoxide, which is toxic, into carbon dioxide. An automotive company is comparing two different catalysts, a palladium-heavy catalyst and a platinum-heavy catalyst. The process with a palladium-heavy catalyst requires 15 units of platinum and 25 units of palladium and can perform the conversion to carbon dioxide at a rate of 5 units per second. A platinum-heavy catalyst requires 20 units of platinum and 14 units of palladium and converts to carbon dioxide at a rate of 4 units per second. There are 450 units of platinum and 390 units of palladium available. How many of each catalyst should be used to maximize the amount converted into carbon dioxide?",
    "ground_truth": 100.34482758620688,
    "formulation": null,
    "correct_program": "def optimize_catalysts(platinum_available=450, palladium_available=390):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Catalyst_Optimization\")\n\n    # Decision variables: number of each catalyst\n    x = model.addVar(name=\"palladium_heavy\", lb=0)\n    y = model.addVar(name=\"platinum_heavy\", lb=0)\n\n    # Set the objective: maximize total CO2 conversion\n    model.setObjective(5 * x + 4 * y, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    model.addConstr(15 * x + 20 * y <= platinum_available, name=\"Platinum_Constraint\")\n    model.addConstr(25 * x + 14 * y <= palladium_available, name=\"Palladium_Constraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_conversion = optimize_catalysts()\n    if max_conversion is not None:\n        print(f\"Maximum CO2 Conversion: {max_conversion}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 31,
    "retrieved_insights": []
  },
  {
    "task_id": "F192",
    "description": "In order to make carbon dioxide, wood is burned using two processes, with a catalyst and without a catalyst. The process with a catalyst requires 10 units of wood and 20 units of oxygen to make 15 units of carbon dioxide. The process without a catalyst requires 15 units of wood and 12 units of oxygen to make 18 units of carbon dioxide. There are 300 units of wood and 300 units of oxygen available. How many of each process should be used to maximize the amount of carbon dioxide produced?",
    "ground_truth": 369.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Add variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")\n\n# Set objective\nmodel.setObjective(15 * x1 + 18 * x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(10 * x1 + 15 * x2 <= 300, \"WoodConstraint\")\nmodel.addConstr(20 * x1 + 12 * x2 <= 300, \"OxygenConstraint\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 31,
    "retrieved_insights": []
  },
  {
    "task_id": "F126",
    "description": "Platinum in combination with palladium has been used as a catalyst in cars and it changes carbon monoxide, which is toxic, into carbon dioxide. An automotive company is comparing two different catalysts, a palladium-heavy catalyst and a platinum-heavy catalyst. The process with a palladium-heavy catalyst requires 15 units of platinum and 25 units of palladium and can perform the conversion to carbon dioxide at a rate of 5 units per second. A platinum-heavy catalyst requires 20 units of platinum and 14 units of palladium and converts to carbon dioxide at a rate of 4 units per second. There are 450 units of platinum and 390 units of palladium available. How many of each catalyst should be used to maximize the amount converted into carbon dioxide?",
    "ground_truth": 98.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"CatalystOptimization\")\n\n# Add variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")  # Number of palladium-heavy catalysts\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")  # Number of platinum-heavy catalysts\n\n# Set objective\nmodel.setObjective(5 * x1 + 4 * x2, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(15 * x1 + 20 * x2 <= 450, \"C1\")  # Platinum usage constraint\nmodel.addConstr(25 * x1 + 14 * x2 <= 390, \"C2\")  # Palladium usage constraint\nmodel.addConstr(x1 >= 0, \"C3\")  # Non-negativity constraint for x1\nmodel.addConstr(x2 >= 0, \"C4\")  # Non-negativity constraint for x2\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 31,
    "retrieved_insights": []
  },
  {
    "task_id": "A214",
    "description": "A metal-working shop has access to two types of metal-working equipment, a chop saw and a steel cutter. A chop saw can work 25 pounds of steel and generates 25 units of waste every day. A steel cutter can only cut 5 pounds of steel and generates 3 units of waste every day.  The metal-working shop is expecting an increase in demand and must cut 520 pounds of metal every day. However, there is a waste limitation due to the fines that may be in place if too much heavy metal is discarded and they may at most produce 400 units of waste every day. How should the metal-working shop purchase their metal-working equipment to decrease the total number of metal-working equipment needed?",
    "ground_truth": 72.0,
    "formulation": null,
    "correct_program": "def optimize_equipment_purchase():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Equipment_Purchase\")\n\n    # Decision variables: number of chop saws (x) and steel cutters (y)\n    x = m.addVar(vtype=GRB.INTEGER, name=\"chop_saws\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"steel_cutters\", lb=0)\n\n    # Set the objective: minimize total equipment\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add demand constraint\n    m.addConstr(25 * x + 5 * y >= 520, name=\"demand_constraint\")\n\n    # Add waste constraint\n    m.addConstr(25 * x + 3 * y <= 400, name=\"waste_constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of equipment\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_equipment = optimize_equipment_purchase()\n    if min_equipment is not None:\n        print(f\"Minimum Total Equipment (Chop Saws + Steel Cutters): {min_equipment}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B076",
    "description": "There are 10 different parts, and they can all be processed on machine \\( A \\), machine \\( B \\), or machine \\( C \\). The unit processing costs are shown in Table 5-6. Additionally, as long as any part is processed on the aforementioned machines, a one-time setup cost will be incurred regardless of whether one or multiple types of parts are processed, with the respective costs being \\( d_A = 100 \\), \\( d_B = 135 \\), and \\( d_C = 200 \\) yuan. If the requirements are:\n\n1. One piece of each of the aforementioned 10 types of parts needs to be processed;\n2. If the 1st part is processed on machine \\( A \\), then the 2nd part must be processed on machine \\( B \\) or \\( C \\); conversely, if the 1st part is processed on machine \\( B \\) or \\( C \\), then the 2nd part must be processed on machine \\( A \\);\n3. Parts 3, 4, and 5 must be processed on machines A, B, and C respectively;\n4. The number of parts processed on machine \\( C \\) should not exceed 3 types.\n\nTry to establish an integer programming mathematical model for this problem with the objective of minimizing the total cost.\n\nTable 5-6\n| Machine/Part | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |\n|--------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| A            | $10$ | $20$ | $30$ | $40$ | $50$ | $60$ | $70$ | $80$ | $90$ | $100$ |\n| B            | $15$ | $25$ | $35$ | $45$ | $55$ | $65$ | $75$ | $85$ | $95$ | $105$ |\n| C            | $20$ | $30$ | $40$ | $50$ | $60$ | $70$ | $80$ | $90$ | $100$ | $110$ |",
    "ground_truth": 1005.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_machine_assignment():\n    \"\"\"\n    Solves the machine assignment problem with fixed setup costs and constraints\n    to minimize the total cost.\n    \"\"\"\n    try:\n        # --- Data ---\n        parts = list(range(1, 11))  # Parts 1 to 10\n        machines = ['A', 'B', 'C']\n\n        # Processing costs c[part][machine]\n        # Note: Using part index p-1 for 0-based list access\n        processing_costs_data = [\n            # A   B    C   (Machine)\n            [10, 15, 20],  # Part 1\n            [20, 25, 30],  # Part 2\n            [30, 35, 40],  # Part 3\n            [40, 45, 50],  # Part 4\n            [50, 55, 60],  # Part 5\n            [60, 65, 70],  # Part 6\n            [70, 75, 80],  # Part 7\n            [80, 85, 90],  # Part 8\n            [90, 95, 100],  # Part 9\n            [100, 105, 110]  # Part 10\n        ]\n\n        # Create cost dictionary c[p,m] for easier access\n        proc_costs = {}\n        for p_idx, p in enumerate(parts):\n            for m_idx, m in enumerate(machines):\n                proc_costs[p, m] = processing_costs_data[p_idx][m_idx]\n\n        # Fixed setup costs d[m]\n        setup_costs = {'A': 100, 'B': 135, 'C': 200}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"MachineAssignmentFixedCost\")\n\n        # --- Decision Variables ---\n        # x[p,m]: 1 if part p is processed on machine m, 0 otherwise\n        x = model.addVars(parts, machines, vtype=GRB.BINARY, name=\"x_assign\")\n\n        # y[m]: 1 if machine m is used (setup cost incurred), 0 otherwise\n        y = model.addVars(machines, vtype=GRB.BINARY, name=\"y_setup\")\n\n        # --- Objective Function: Minimize Total Cost ---\n        total_processing_cost = gp.quicksum(proc_costs[p, m] * x[p, m]\n                                            for p in parts for m in machines)\n        total_setup_cost = gp.quicksum(setup_costs[m] * y[m] for m in machines)\n\n        model.setObjective(total_processing_cost + total_setup_cost,\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Process Each Part: Each part p processed on exactly one machine m\n        for p in parts:\n            model.addConstr(gp.quicksum(x[p, m] for m in machines) == 1,\n                            name=f\"ProcessPart_{p}\")\n\n        # 2. Conditional Assignment (Part 1 and Part 2)\n        # If x[1,'A'] = 1, then x[2,'B'] + x[2,'C'] = 1\n        model.addConstr(x[1, 'A'] <= x[2, 'B'] + x[2, 'C'],\n                        name=\"Cond_1A_implies_2BC\")\n        # If x[1,'B'] + x[1,'C'] = 1, then x[2,'A'] = 1\n        model.addConstr(x[1, 'B'] + x[1, 'C'] <= x[2, 'A'],\n                        name=\"Cond_1BC_implies_2A\")\n\n        # 3. Fixed Assignments (Parts 3, 4, 5)\n        model.addConstr(x[3, 'A'] == 1, name=\"Fixed_Part3_MachineA\")\n        model.addConstr(x[4, 'B'] == 1, name=\"Fixed_Part4_MachineB\")\n        model.addConstr(x[5, 'C'] == 1, name=\"Fixed_Part5_MachineC\")\n\n        # 4. Machine C Capacity Limit: No more than 3 parts on machine C\n        model.addConstr(gp.quicksum(x[p, 'C'] for p in parts) <= 3,\n                        name=\"Limit_MachineC\")\n\n        # 5. Linking Setup Cost: If any x[p,m] = 1, then y[m] must be 1\n        for m in machines:\n            for p in parts:\n                model.addConstr(x[p, m] <= y[m], name=f\"LinkSetup_{p}_{m}\")\n\n        # Alternative tighter linking constraint (optional, usually the one above is sufficient)\n        # for m in machines:\n        #     model.addConstr(gp.quicksum(x[p,m] for p in parts) <= len(parts) * y[m],\n        #                     name=f\"LinkSetupAggregate_{m}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal assignment found.\")\n            print(\n                f\"Minimum Total Cost (Processing + Setup): {model.ObjVal:.2f} Yuan\"\n            )\n\n            print(\"\\nMachine Setup Status:\")\n            for m in machines:\n                if y[m].X > 0.5:\n                    print(\n                        f\"  Machine {m}: Used (Setup Cost: {setup_costs[m]})\")\n                else:\n                    print(f\"  Machine {m}: Not Used\")\n\n            print(\"\\nPart Assignments (Part -> Machine):\")\n            assignments = {}\n            parts_on_machine = {m: [] for m in machines}\n            for p in parts:\n                for m in machines:\n                    if x[p, m].X > 0.5:  # Check if x[p,m] is 1\n                        print(\n                            f\"  Part {p} -> Machine {m} (Processing Cost: {proc_costs[p,m]})\"\n                        )\n                        assignments[p] = m\n                        parts_on_machine[m].append(p)\n                        break  # Move to next part once assigned\n\n            print(\"\\nParts processed on each machine:\")\n            for m in machines:\n                print(\n                    f\"  Machine {m}: {sorted(parts_on_machine[m])} (Count: {len(parts_on_machine[m])})\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and data for contradictions.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"machine_assignment_iis.ilp\")\n            print(\n                \"IIS written to machine_assignment_iis.ilp. Review this file to find conflicting constraints.\"\n            )\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_machine_assignment()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B041",
    "description": "Two steel furnaces at a steel plant each use two methods of steelmaking simultaneously. The first method takes $a=2$ hours per furnace and costs $m=50$ in fuel expenses; the second method takes $b=3$ hours per furnace and costs $n=70$ in fuel expenses. Assuming each furnace produces $k=10$ tons of steel regardless of the method used, and that at least $d=30$ tons of steel must be produced within $c=12$ hours, how should these two methods be allocated to minimize fuel expenses? Formulate this problem as a linear programming model.",
    "ground_truth": 150.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_steelmaking_allocation():\n    \"\"\"\n    Solves the steelmaking allocation problem to minimize fuel expenses\n    subject to furnace time and steel production constraints.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        # Method 1\n        time_m1 = 2.0  # hours per operation\n        cost_m1 = 50.0  # fuel expense per operation\n\n        # Method 2\n        time_m2 = 3.0  # hours per operation\n        cost_m2 = 70.0  # fuel expense per operation\n\n        # Production\n        steel_per_op = 10.0  # tons per operation (same for both methods)\n\n        # Constraints\n        min_total_steel = 30.0  # tons\n        max_furnace_hours = 12.0  # hours available per furnace\n\n        num_furnaces = 2\n        num_methods = 2\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"Steelmaking_Allocation\")\n\n        # --- Decision Variables ---\n        # x[f,m]: number of times furnace f uses method m\n        # f=0 for Furnace 1, f=1 for Furnace 2\n        # m=0 for Method 1, m=1 for Method 2\n        x = model.addVars(num_furnaces,\n                          num_methods,\n                          name=\"x\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # For easier reference using problem's notation:\n        # x11 = x[0,0] (Furnace 1, Method 1)\n        # x12 = x[0,1] (Furnace 1, Method 2)\n        # x21 = x[1,0] (Furnace 2, Method 1)\n        # x22 = x[1,1] (Furnace 2, Method 2)\n\n        # --- Objective Function: Minimize Total Fuel Expenses ---\n        objective = cost_m1 * (x[0,0] + x[1,0]) + \\\n                    cost_m2 * (x[0,1] + x[1,1])\n        model.setObjective(objective, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Time Constraint for Furnace 1 (f=0)\n        model.addConstr(time_m1 * x[0, 0] + time_m2 * x[0, 1]\n                        <= max_furnace_hours,\n                        name=\"Time_Furnace1\")\n\n        # 2. Time Constraint for Furnace 2 (f=1)\n        model.addConstr(time_m1 * x[1, 0] + time_m2 * x[1, 1]\n                        <= max_furnace_hours,\n                        name=\"Time_Furnace2\")\n\n        # 3. Steel Production Constraint\n        total_steel_produced = steel_per_op * (x[0, 0] + x[0, 1] + x[1, 0] +\n                                               x[1, 1])\n        model.addConstr(total_steel_produced >= min_total_steel,\n                        name=\"Min_Steel_Production\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal allocation found.\")\n            print(f\"Minimum Total Fuel Expenses: {model.ObjVal:.2f} Klunz\")\n\n            print(\n                \"\\nOptimal Allocation (Number of times each method is used):\")\n            print(f\"  Furnace 1, Method 1 (x11): {x[0,0].X:.2f} times\")\n            print(f\"  Furnace 1, Method 2 (x12): {x[0,1].X:.2f} times\")\n            print(f\"  Furnace 2, Method 1 (x21): {x[1,0].X:.2f} times\")\n            print(f\"  Furnace 2, Method 2 (x22): {x[1,1].X:.2f} times\")\n\n            # Verification of constraints\n            print(\"\\nVerification:\")\n            f1_hours = time_m1 * x[0, 0].X + time_m2 * x[0, 1].X\n            f2_hours = time_m1 * x[1, 0].X + time_m2 * x[1, 1].X\n            print(\n                f\"  Furnace 1 Hours Used: {f1_hours:.2f} / {max_furnace_hours}\"\n            )\n            print(\n                f\"  Furnace 2 Hours Used: {f2_hours:.2f} / {max_furnace_hours}\"\n            )\n\n            total_steel = steel_per_op * (x[0, 0].X + x[0, 1].X + x[1, 0].X +\n                                          x[1, 1].X)\n            print(\n                f\"  Total Steel Produced: {total_steel:.2f} tons (Min required: {min_total_steel})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and parameters.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"steel_allocation_iis.ilp\")\n            # print(\"IIS written to steel_allocation_iis.ilp\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_steelmaking_allocation()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "F118",
    "description": "A metal-working shop has access to two types of metal-working equipment, a chop saw and a steel cutter. A chop saw can work 25 pounds of steel and generates 25 units of waste every day. A steel cutter can only cut 5 pounds of steel and generates 3 units of waste every day.  The metal-working shop is expecting an increase in demand and must cut 520 pounds of metal every day. However, there is a waste limitation due to the fines that may be in place if too much heavy metal is discarded and they may at most produce 400 units of waste every day. How should the metal-working shop purchase their metal-working equipment to decrease the total number of metal-working equipment needed?",
    "ground_truth": 72.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define parameters\np_s = 25  # pounds of steel a chop saw can cut per day\nw_s = 25  # waste units generated by a chop saw per day\np_c = 5   # pounds of steel a steel cutter can cut per day\nw_c = 3   # waste units generated by a steel cutter per day\nD = 520   # total pounds of steel that must be cut per day\nW = 400   # maximum allowable waste units per day\n\n# Define variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"chop_saws\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"steel_cutters\")\n\n# Set objective function\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(p_s * x + p_c * y >= D, \"SteelCuttingRequirement\")\nmodel.addConstr(w_s * x + w_c * y <= W, \"WasteLimitation\")\nmodel.addConstr(x >= 0, \"NonNegativity_x\")\nmodel.addConstr(y >= 0, \"NonNegativity_y\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "A193",
    "description": "Platinum Database sells two types of subscription software packages: a personal license and a commercial license which will cost $550 and $2000 to generate respectively. The marketing department estimates that they can sell at most 300 licenses for both versions combined a month. The profit per personal license is $450 and the profit per commercial version is $1200. If the company does not want to spend more than $400000, how many of each software package should they produce to maximize the profits.",
    "ground_truth": 256500.0,
    "formulation": null,
    "correct_program": "def optimize_licenses(sales_limit=300, budget_limit=400000, cost_personal=550, cost_commercial=2000,\n                      profit_personal=450, profit_commercial=1200):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"License_Production_Optimization\")\n    \n    # Decision variables: number of personal and commercial licenses\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Personal_Licenses\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Commercial_Licenses\", lb=0)\n    \n    # Set the objective: maximize profit\n    m.setObjective(profit_personal * x + profit_commercial * y, GRB.MAXIMIZE)\n    \n    # Add constraints\n    m.addConstr(x + y <= sales_limit, \"SalesLimit\")\n    m.addConstr(cost_personal * x + cost_commercial * y <= budget_limit, \"BudgetLimit\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_licenses()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Software"
      }
    ],
    "cluster": 36,
    "retrieved_insights": []
  },
  {
    "task_id": "F099",
    "description": "Platinum Database sells two types of subscription software packages: a personal license and a commercial license which will cost $550 and $2000 to generate respectively. The marketing department estimates that they can sell at most 300 licenses for both versions combined a month. The profit per personal license is $450 and the profit per commercial version is $1200. If the company does not want to spend more than $400000, how many of each software package should they produce to maximize the profits.",
    "ground_truth": 256500.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nc_p = 550  # Cost to generate a personal license\nc_c = 2000  # Cost to generate a commercial license\np_p = 450  # Profit per personal license\np_c = 1200  # Profit per commercial license\nB = 400000  # Budget limit\nL = 300  # Maximum number of licenses\n\n# Variables\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"x_c\")\n\n# Objective function\nmodel.setObjective(p_p * x_p + p_c * x_c, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_p + x_c <= L, \"CombinedSalesLimit\")\nmodel.addConstr(c_p * x_p + c_c * x_c <= B, \"BudgetConstraint\")\nmodel.addConstr(x_p >= 0, \"NonNegativity_x_p\")\nmodel.addConstr(x_c >= 0, \"NonNegativity_x_c\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Software"
      }
    ],
    "cluster": 36,
    "retrieved_insights": []
  },
  {
    "task_id": "A097",
    "description": "A doctor's office takes the  temperature of patients one by one either by using an electronic or regular thermometer. The electronic thermometer takes 3 minutes to make a reading while the regular thermometer takes 2 minutes to make a reading. Since the electronic thermometer is more accurate, at least twice as many patients should have their temperature checked by the electronic thermometer than the regular thermometer. Since the electronic thermometer has a cooldown time, at least 50 patients should have their temperature checked by a regular thermometer. If the office is open for 15000 minutes, maximize the number of patients whose temperature can be taken?",
    "ground_truth": 5625.0,
    "formulation": null,
    "correct_program": "def maximize_patients(time_available=15000, min_regular=50):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Maximize_Patients\")\n\n    # Decision variables: number of patients checked with each thermometer\n    x = model.addVar(vtype=GRB.INTEGER, name=\"electronic\")\n    y = model.addVar(vtype=GRB.INTEGER, name=\"regular\")\n\n    # Set the objective: maximize total patients\n    model.setObjective(x + y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Time constraint\n    model.addConstr(3 * x + 2 * y <= time_available, \"TimeLimit\")\n    # Accuracy constraint\n    model.addConstr(x >= 2 * y, \"Accuracy\")\n    # Minimum regular thermometer patients\n    model.addConstr(y >= min_regular, \"MinRegular\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum number of patients served\n        return int(model.objVal)\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_patients = maximize_patients()\n    if max_patients is not None:\n        print(f\"Maximum Number of Patients Served: {max_patients}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 46,
    "retrieved_insights": []
  },
  {
    "task_id": "A087",
    "description": "A clinic takes patient blood pressure either using an automatic machine or a manual machine. The automatic machine takes 10 minutes per patient while the manual machine takes 15 minutes per patient. Since the automatic machine frequently breaks, at least twice as many patients must have their blood pressure taken by the manual machine than the automatic machine. However, at least 20 patient can be processed by the automatic machine. If the clinic is open for 20000 minutes, maximize the number of patients whose blood pressure can be taken.",
    "ground_truth": 1500.0,
    "formulation": null,
    "correct_program": "def maximize_patients(open_minutes=20000, time_auto=10, time_manual=15, min_auto=20):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"BloodPressureScheduling\")\n\n    # Decision variables\n    x = model.addVar(name=\"automatic_patients\", vtype=GRB.INTEGER, lb=0)\n    y = model.addVar(name=\"manual_patients\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: maximize total patients\n    model.setObjective(x + y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Time constraint\n    model.addConstr(time_auto * x + time_manual * y <= open_minutes, name=\"time_limit\")\n    # Manual patients at least twice automatic\n    model.addConstr(y >= 2 * x, name=\"manual_at_least_twice_auto\")\n    # Minimum automatic patients\n    model.addConstr(x >= min_auto, name=\"min_auto\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum number of patients served\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_patients = maximize_patients()\n    if max_patients is not None:\n        print(f\"Maximum Number of Patients Served: {max_patients}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 46,
    "retrieved_insights": []
  },
  {
    "task_id": "F012",
    "description": "A doctor's office takes the  temperature of patients one by one either by using an electronic or regular thermometer. The electronic thermometer takes 3 minutes to make a reading while the regular thermometer takes 2 minutes to make a reading. Since the electronic thermometer is more accurate, at least twice as many patients should have their temperature checked by the electronic thermometer than the regular thermometer. Since the electronic thermometer has a cooldown time, at least 50 patients should have their temperature checked by a regular thermometer. If the office is open for 15000 minutes, maximize the number of patients whose temperature can be taken?",
    "ground_truth": 5625.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nt_e = 3  # Time for electronic thermometer\nt_r = 2  # Time for regular thermometer\nT = 15000  # Total available time\nM_r = 50  # Minimum number of patients for regular thermometer\n\n# Variables\nx_e = model.addVar(vtype=GRB.INTEGER, name=\"x_e\")\nx_r = model.addVar(vtype=GRB.INTEGER, name=\"x_r\")\n\n# Objective: Maximize the total number of patients\nmodel.setObjective(x_e + x_r, GRB.MAXIMIZE)\n\n# Constraints\n# C1: Total time used should not exceed the available time\nmodel.addConstr(3 * x_e + 2 * x_r <= 15000, \"TimeConstraint\")\n\n# C2: At least twice as many patients should be checked with the electronic thermometer\nmodel.addConstr(x_e >= 2 * x_r, \"AccuracyConstraint\")\n\n# C3: At least 50 patients should be checked with the regular thermometer\nmodel.addConstr(x_r >= 50, \"MinimumRegularConstraint\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 46,
    "retrieved_insights": []
  },
  {
    "task_id": "A197",
    "description": "The government is reworking the pipes to transport water to houses in the area. The water can be transported through wide pipes or narrow pipes. Wide pipes can transport 25 units of water per minute and narrow pipes can transport 15 units of water per minute. Due to logistics, the number of wide pipes can be at most a third the number of narrow pipes. If there needs to be at least 900 units of water transported every minute, and at least 5 wide pipes must be used, minimize the total number of pipes required.",
    "ground_truth": 52.0,
    "formulation": null,
    "correct_program": "def optimize_pipes():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"WaterPipeOptimization\")\n\n    # Decision variables\n    W = m.addVar(name=\"WidePipes\", vtype=GRB.INTEGER, lb=5)\n    N = m.addVar(name=\"NarrowPipes\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: minimize total number of pipes\n    m.setObjective(W + N, GRB.MINIMIZE)\n\n    # Add constraints\n    # Water capacity constraint\n    m.addConstr(25 * W + 15 * N >= 900, name=\"WaterCapacity\")\n    # Ratio constraint: W <= N/3\n    m.addConstr(3 * W <= N, name=\"PipeRatio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of pipes\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pipes = optimize_pipes()\n    if min_pipes is not None:\n        print(f\"Minimum Total Pipes (Wide + Narrow): {min_pipes}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Utilities"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "F109",
    "description": "An oil and gas company has two types of pipes, a high-volume and a low-volume one. Every day, the high-volume pipe allows 10000 US gallons and it is recommended that 12 technicians closely monitor the pipes to ensure that it is functioning properly. Each day, the low-volume pipe allows 5000 US gallons and 5 technicians should closely monitor for safety reasons. Every day, the oil and gas company needs to meet the demands of at least 150000 US gallons of gas and they have 160 technicians that are on their staff. Since the high-volume pipe has a higher risk of environmental damage, at most 35 percent of the pipes can be high-volume ones. Additionally, there must be a minimum of 8 low-volume pipes. How many of each pipe types should be used to reduce the total number of pipes required?",
    "ground_truth": 25.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nD = 150000  # Daily demand in gallons\nT = 160     # Total technicians available\nHV = 10000  # Capacity of high-volume pipe in gallons\nHV_tech = 12 # Technicians required per high-volume pipe\nLV = 5000   # Capacity of low-volume pipe in gallons\nLV_tech = 5 # Technicians required per low-volume pipe\nalpha = 0.35 # Max fraction of high-volume pipes\nminLV = 8   # Minimum number of low-volume pipes\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"high_volume_pipes\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"low_volume_pipes\")\n\n# Objective: Minimize the total number of pipes\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(HV * x + LV * y >= D, \"DemandConstraint\")\nmodel.addConstr(HV_tech * x + LV_tech * y <= T, \"TechnicianConstraint\")\nmodel.addConstr(x <= alpha * (x + y), \"HighVolumePipeLimit\")\nmodel.addConstr(y >= minLV, \"MinimumLowVolumePipes\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Oil and Gas"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "A210",
    "description": "A hospital purchases two pills available for the patients to take one at a time. One pill is taken as a prevention and another is taken for treatment. The prevention pill takes 15 dollars to make while the treatment pill takes 25 dollars to make. Since the prevention pill is in higher demand, the hospital must purchase at least two times as many prevention pills as treatment pills. In addition, the hospital must purchase at least 50 treatment pills. If the clinic only has a budget of 10000 dollars, maximize the number of patients that can be treated.",
    "ground_truth": 181.0,
    "formulation": null,
    "correct_program": "def optimize_pills(budget=10000, cost_prevention=15, cost_treatment=25, min_treatment=50):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Hospital_Pills_Optimization\")\n    \n    # Decision variables\n    T = model.addVar(name=\"Treatment_Pills\", vtype=GRB.INTEGER, lb=min_treatment)\n    P = model.addVar(name=\"Prevention_Pills\", vtype=GRB.INTEGER, lb=0)\n    \n    # Set objective: maximize number of treatment pills (patients)\n    model.setObjective(T, GRB.MAXIMIZE)\n    \n    # Add constraints\n    # Budget constraint\n    model.addConstr(cost_prevention * P + cost_treatment * T <= budget, name=\"Budget\")\n    # Prevention pills at least twice treatment pills\n    model.addConstr(P >= 2 * T, name=\"Prevention_vs_Treatment\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum number of patients (treatment pills)\n        return int(T.X)\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_patients = optimize_pills()\n    if max_patients is not None:\n        print(f\"Maximum Patients Treated: {max_patients}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 49,
    "retrieved_insights": []
  },
  {
    "task_id": "F158",
    "description": "Sleep inducing medicine and anti-inflammatory medicine is found in two pills, pill A and pill B. One pill A contains 3 units of sleep inducing medicine and 5 units of anti-inflammatory medicine. One pill B contains 6 units of sleep-inducing medicine and 1 unit of anti-inflammatory medicine. The cost per pill for pill A is $4 and the cost per pill for pill B is $5. A patient must consume these two pills to get at least 40 units of sleep-inducing medicine and 50 units of anti-inflammatory medicine. Formulate a LP to minimize the cost for the patient.",
    "ground_truth": 50.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MedicationOptimization\")\n\n# Parameters\nc_A = 4  # Cost per pill A\nc_B = 5  # Cost per pill B\ns_A = 3  # Sleep-inducing medicine units per pill A\ns_B = 6  # Sleep-inducing medicine units per pill B\na_A = 5  # Anti-inflammatory medicine units per pill A\na_B = 1  # Anti-inflammatory medicine units per pill B\nS = 40   # Required units of sleep-inducing medicine\nA = 50   # Required units of anti-inflammatory medicine\n\n# Variables\nx_A = model.addVar(vtype=GRB.INTEGER, name=\"x_A\")\nx_B = model.addVar(vtype=GRB.INTEGER, name=\"x_B\")\n\n# Objective\nmodel.setObjective(c_A * x_A + c_B * x_B, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(s_A * x_A + s_B * x_B >= S, \"SleepInducingConstraint\")\nmodel.addConstr(a_A * x_A + a_B * x_B >= A, \"AntiInflammatoryConstraint\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 49,
    "retrieved_insights": []
  },
  {
    "task_id": "A165",
    "description": "There has been a horrible accident and patients need to be taken to the hospital by either a helicopter or bus. A helicopter can transport 5 patients per trip and takes 1 hour. On the other hand, a bus can transport 8 patients per trip and takes 3 hours. At least 120 patients need to be transported and at least 30% of the trips should be by helicopter. In addition, there can be at most 10 bus trips. How should the patients be taken to minimize the total time to transport the patients?",
    "ground_truth": 24.0,
    "formulation": null,
    "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"PatientTransport\")\n\n    # Decision variables\n    h = m.addVar(vtype=GRB.INTEGER, name=\"helicopter_trips\", lb=0)\n    b = m.addVar(vtype=GRB.INTEGER, name=\"bus_trips\", lb=0)\n\n    # Set objective: minimize total transportation time\n    m.setObjective(h + 3 * b, GRB.MINIMIZE)\n\n    # Add constraints\n    # Patients transported constraint\n    m.addConstr(5 * h + 8 * b >= 120, name=\"patients_min\")\n    # Trip proportion constraint: h >= (3/7) * b\n    m.addConstr(h >= (3/7) * b, name=\"trip_ratio\")\n    # Bus trip limit\n    m.addConstr(b <= 10, name=\"bus_limit\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_transportation()\n    if min_time is not None:\n        print(f\"Minimum Total Transportation Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 1,
    "retrieved_insights": []
  },
  {
    "task_id": "F150",
    "description": "A hospital can transport their patients either using a type II ambulance or hospital van. The hospital needs to transport 320 patients every day. A type II ambulance is mounted on a truck-style chassis and can move 20 patients every shift and costs the hospital (including gas and salary) $820. A hospital van can move 15 patients and costs the hospital $550 every shift. The hospital can have at most 60% of shifts be hospital vans due to union limitations of the type II ambulance drivers. How many of shift using each type of vehicle should be scheduled to minimize the total cost to the hospital?",
    "ground_truth": 12600.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nP = 320  # Total number of patients\nCa = 820  # Cost per shift for type II ambulance\nCv = 550  # Cost per shift for hospital van\nNa = 20   # Patients per shift for type II ambulance\nNv = 15   # Patients per shift for hospital van\nL = 0.6   # Maximum fraction of shifts that can be hospital vans\n\n# Variables\nxa = model.addVar(vtype=GRB.INTEGER, name=\"xa\", lb=0)\nxv = model.addVar(vtype=GRB.INTEGER, name=\"xv\", lb=0)\n\n# Objective\nmodel.setObjective(Ca * xa + Cv * xv, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(Na * xa + Nv * xv >= P, \"C1\")\nmodel.addConstr(xv <= L * (xa + xv), \"C2\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 1,
    "retrieved_insights": []
  },
  {
    "task_id": "A202",
    "description": "An amusement park has two types of games: throwing and climbing games. Throwing games attract 15 customers every hour and climbing games attract 8 customers every hour. Throwing games costs the amusement park $2 in prizes per hour whereas climbing games cost $3 in prizes per hour. Since throwing games yield the most profit, there must be at least twice as many throwing games as climbing games. However, at least 5 games must be climbing. If the amusement park can have at most $100 in prizes every hour, maximize the total number of customers attracted every hour.",
    "ground_truth": 670.0,
    "formulation": null,
    "correct_program": "def optimize_amusement_park():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"AmusementPark\")\n\n    # Decision variables\n    T = m.addVar(name=\"ThrowingGames\", vtype=GRB.INTEGER, lb=0)\n    C = m.addVar(name=\"ClimbingGames\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: maximize total customers\n    m.setObjective(15 * T + 8 * C, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(2 * T + 3 * C <= 100, name=\"PrizeLimit\")\n    m.addConstr(T >= 2 * C, name=\"ThrowingAtLeastTwiceClimbing\")\n    m.addConstr(C >= 5, name=\"MinimumClimbing\")\n    \n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum number of customers attracted\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_customers = optimize_amusement_park()\n    if max_customers is not None:\n        print(f\"Maximum Customers Attracted: {max_customers}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Recreation & Entertainment"
      }
    ],
    "cluster": 41,
    "retrieved_insights": []
  },
  {
    "task_id": "F107",
    "description": "An amusement park has two types of games: throwing and climbing games. Throwing games attract 15 customers every hour and climbing games attract 8 customers every hour. Throwing games costs the amusement park $2 in prizes per hour whereas climbing games cost $3 in prizes per hour. Since throwing games yield the most profit, there must be at least twice as many throwing games as climbing games. However, at least 5 games must be climbing. If the amusement park can have at most $100 in prizes every hour, maximize the total number of customers attracted every hour.",
    "ground_truth": 670.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"AmusementParkGames\")\n\n# Define variables\nx_t = model.addVar(vtype=GRB.INTEGER, name=\"ThrowingGames\")\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"ClimbingGames\")\n\n# Set objective\nmodel.setObjective(15 * x_t + 8 * x_c, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(2 * x_t + 3 * x_c <= 100, \"PrizeCost\")\nmodel.addConstr(x_t >= 2 * x_c, \"RatioConstraint\")\nmodel.addConstr(x_c >= 5, \"MinClimbingGames\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Entertainment"
      }
    ],
    "cluster": 41,
    "retrieved_insights": []
  },
  {
    "task_id": "B016",
    "description": "Certain strategic bomber groups are tasked with destroying enemy military targets. It is known that the target has four key parts, and destroying any one of them will suffice. The fuel consumption limit for completing this task is 48,000 liters, with a maximum of 48 heavy bombs and 32 light bombs. When carrying heavy bombs, each liter of fuel allows a distance of 2 km, whereas with light bombs, each liter allows 3 km. Additionally, each aircraft can only carry one bomb per trip, and each bombing run requires fuel not only for the round trip (each liter of fuel allows 4 km when the aircraft is empty) but also 100 liters for both takeoff and landing per trip. Relevant data is shown in Table 1-17.\n\nTable 1-17\n| Key Part | Distance from Airport (km) | Probability of Destruction per Heavy Bomb | Probability of Destruction per Light Bomb |\n|----------|----------------------------|-----------------------------------------|------------------------------------------|\n|          |                            |                                         |                                          |\n| 1        | 450                        | 0.10                                    | 0.08                                     |\n| 2        | 480                        | 0.20                                    | 0.16                                     |\n| 3        | 540                        | 0.15                                    | 0.12                                     |\n| 4        | 600                        | 0.25                                    | 0.20                                     |\n\nTo maximize the probability of destroying the enemy military target, how should the bombing plan be determined? Establish a linear programming model for this problem.",
    "ground_truth": 0.9999999992023356,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_bomber_problem():\n    try:\n        # --- Problem Data ---\n        # Key Part | Distance (km) | P(Destroy | Heavy) | P(Destroy | Light)\n        # 1        | 450           | 0.10             | 0.08\n        # 2        | 480           | 0.20             | 0.16\n        # 3        | 540           | 0.15             | 0.12\n        # 4        | 600           | 0.25             | 0.20\n\n        num_parts = 4\n        parts = range(num_parts)\n\n        distances = [450, 480, 540, 600]  # km\n        prob_destroy_heavy = [0.10, 0.20, 0.15, 0.25]\n        prob_destroy_light = [0.08, 0.16, 0.12, 0.20]\n\n        # Resource Limits\n        max_fuel = 48000  # liters\n        max_heavy_bombs = 48\n        max_light_bombs = 32\n\n        # Fuel Consumption Parameters\n        eff_heavy_loaded = 2.0  # km/liter\n        eff_light_loaded = 3.0  # km/liter\n        eff_empty_return = 4.0  # km/liter (return trip)\n        fuel_takeoff_landing = 100  # liters per trip\n\n        # --- Pre-calculations ---\n\n        # Fuel per trip for each bomb type to each part\n        fuel_per_heavy_trip = []\n        for d in distances:\n            # Fuel to target (loaded) + Fuel return (empty) + Takeoff/Landing\n            fuel = (d / eff_heavy_loaded) + (\n                d / eff_empty_return) + fuel_takeoff_landing\n            fuel_per_heavy_trip.append(fuel)\n\n        fuel_per_light_trip = []\n        for d in distances:\n            # Fuel to target (loaded) + Fuel return (empty) + Takeoff/Landing\n            fuel = (d / eff_light_loaded) + (\n                d / eff_empty_return) + fuel_takeoff_landing\n            fuel_per_light_trip.append(fuel)\n\n        # Objective function coefficients: log(P(not destroyed by one bomb))\n        # log(1 - p) will be negative. We want to minimize this sum.\n        log_prob_not_destroy_heavy = []\n        for p in prob_destroy_heavy:\n            if p < 1.0:  # Ensure p is not 1 to avoid log(0)\n                log_prob_not_destroy_heavy.append(math.log(1 - p))\n            else:  # Should not happen with given data, but good for robustness\n                log_prob_not_destroy_heavy.append(\n                    -float('inf'))  # Effectively forces use if possible\n\n        log_prob_not_destroy_light = []\n        for p in prob_destroy_light:\n            if p < 1.0:\n                log_prob_not_destroy_light.append(math.log(1 - p))\n            else:\n                log_prob_not_destroy_light.append(-float('inf'))\n\n        # --- Model Creation ---\n        model = gp.Model(\"StrategicBomberPlanning\")\n\n        # --- Decision Variables ---\n        # x_h[i]: number of heavy bombs assigned to part i\n        x_h = model.addVars(num_parts,\n                            vtype=GRB.INTEGER,\n                            name=\"HeavyBombs\",\n                            lb=0)\n        # x_l[i]: number of light bombs assigned to part i\n        x_l = model.addVars(num_parts,\n                            vtype=GRB.INTEGER,\n                            name=\"LightBombs\",\n                            lb=0)\n\n        # --- Objective Function ---\n        # Minimize the sum of log probabilities of NOT destroying each part\n        # This is equivalent to maximizing the probability of destroying at least one part\n        objective = gp.quicksum(log_prob_not_destroy_heavy[i] * x_h[i] for i in parts) + \\\n                    gp.quicksum(log_prob_not_destroy_light[i] * x_l[i] for i in parts)\n        model.setObjective(objective, GRB.MINIMIZE)\n\n        # --- Constraints ---\n\n        # 1. Total heavy bombs constraint\n        model.addConstr(\n            gp.quicksum(x_h[i] for i in parts) <= max_heavy_bombs,\n            \"MaxHeavyBombs\")\n\n        # 2. Total light bombs constraint\n        model.addConstr(\n            gp.quicksum(x_l[i] for i in parts) <= max_light_bombs,\n            \"MaxLightBombs\")\n\n        # 3. Total fuel consumption constraint\n        total_fuel_consumed = gp.quicksum(fuel_per_heavy_trip[i] * x_h[i] for i in parts) + \\\n                              gp.quicksum(fuel_per_light_trip[i] * x_l[i] for i in parts)\n        model.addConstr(total_fuel_consumed <= max_fuel, \"MaxFuel\")\n\n        # --- Optimize Model ---\n        model.optimize()\n\n        # --- Results ---\n        print(\"-\" * 30)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found!\")\n            print(\n                f\"Objective Value (sum of log-probabilities of non-destruction): {model.objVal:.4f}\"\n            )\n\n            # Calculate overall probability of success\n            # P_success = 1 - exp(model.objVal) because model.objVal = ln(Q_total)\n            prob_success = 1 - math.exp(model.objVal)\n            print(\n                f\"Maximized Probability of Destroying at least one Target: {prob_success:.4%}\"\n            )\n            print(\"-\" * 30)\n\n            print(\"Bombing Plan:\")\n            total_h_bombs_used = 0\n            total_l_bombs_used = 0\n            actual_fuel_consumed = 0\n\n            for i in parts:\n                num_h = x_h[i].X\n                num_l = x_l[i].X\n                if num_h > 0.5 or num_l > 0.5:  # Check if any bombs assigned (due to float results)\n                    print(f\"  Key Part {i+1}:\")\n                    print(f\"    Heavy Bombs: {num_h:.0f}\")\n                    print(f\"    Light Bombs: {num_l:.0f}\")\n                total_h_bombs_used += num_h\n                total_l_bombs_used += num_l\n                actual_fuel_consumed += num_h * fuel_per_heavy_trip[\n                    i] + num_l * fuel_per_light_trip[i]\n\n            print(\"-\" * 30)\n            print(\"Resource Utilization:\")\n            print(\n                f\"  Total Heavy Bombs Used: {total_h_bombs_used:.0f} / {max_heavy_bombs}\"\n            )\n            print(\n                f\"  Total Light Bombs Used: {total_l_bombs_used:.0f} / {max_light_bombs}\"\n            )\n            print(\n                f\"  Total Fuel Consumed: {actual_fuel_consumed:.2f} / {max_fuel} liters\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists under the given constraints.\"\n            )\n        elif model.status == GRB.UNBOUNDED:\n            print(\"Model is unbounded.\")\n        else:\n            print(f\"Optimization was stopped with status {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Gurobi or one of its components is not available. Make sure Gurobi is installed and licensed.\"\n        )\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_bomber_problem()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Defense"
      }
    ],
    "cluster": 25,
    "retrieved_insights": []
  },
  {
    "task_id": "B046",
    "description": "A certain farm has 100 hectares of land and 15,000 yuan in funds for production development. The labor force situation on the farm is 3,500 person-days in autumn and winter, and 4,000 person-days in spring and summer. If the labor force itself is not fully utilized, they can work externally, earning 2.1 yuan/person-day in spring and summer and 1.8 yuan/person-day in autumn and winter.\n\nThe farm cultivates three types of crops: soybeans, corn, and wheat, and also raises dairy cows and chickens. Crop cultivation requires no specialized investment, but raising animals involves an investment of 400 yuan per dairy cow and 3 yuan per chicken. Raising dairy cows requires allocating 1.5 hectares of land per cow to grow feed, and involves 100 person-days in autumn and winter, and 50 person-days in spring and summer per cow. The annual net income is 400 yuan per dairy cow. Raising chickens does not use land, requires 0.6 person-days in autumn and winter, and 0.3 person-days in spring and summer per chicken. Annual net income is 2 yuan per chicken. The current chicken coop can accommodate up to 3,000 chickens, and the cow barn can accommodate up to 32 dairy cows. The labor and income requirements for the three types of crops per year are shown in Table 1-9.\n\nTable 1-9\n| Item           | Soybean | Corn | Wheat |\n|----------------|---------|------|-------|\n| Person-days (Autumn/Winter) | 20      | 35   | 10    |\n| Person-days (Spring/Summer) | 50      | 75   | 40    |\n| Annual Net Income (Yuan/hectare) | 175     | 300   | 120   |\n\nDetermine the farm's operating plan to maximize annual net income.",
    "ground_truth": 20242.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_farm_optimization():\n    \"\"\"\n    Solves the farm operation planning problem to maximize annual net income.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Resources\n        total_land = 100  # hectares\n        total_funds = 15000  # yuan\n        labor_aw_available = 3500  # person-days Autumn/Winter\n        labor_ss_available = 4000  # person-days Spring/Summer\n\n        # External labor income (yuan/person-day)\n        income_external_labor_aw = 1.8\n        income_external_labor_ss = 2.1\n\n        # Crop data: [Labor AW, Labor SS, Net Income/hectare]\n        crop_data = {\n            'Soybean': {\n                'labor_aw': 20,\n                'labor_ss': 50,\n                'income': 175\n            },\n            'Corn': {\n                'labor_aw': 35,\n                'labor_ss': 75,\n                'income': 300\n            },\n            'Wheat': {\n                'labor_aw': 10,\n                'labor_ss': 40,\n                'income': 120\n            }\n        }\n        crops = list(crop_data.keys())\n\n        # Animal data\n        # Dairy Cow\n        cow_investment = 400  # yuan/cow\n        cow_land_feed = 1.5  # hectares/cow\n        cow_labor_aw = 100  # person-days/cow\n        cow_labor_ss = 50  # person-days/cow\n        cow_income = 400  # yuan/cow\n        cow_max_capacity = 32\n\n        # Chicken\n        chicken_investment = 3  # yuan/chicken\n        # chicken_land_feed = 0 (explicitly stated \"does not use land\")\n        chicken_labor_aw = 0.6  # person-days/chicken\n        chicken_labor_ss = 0.3  # person-days/chicken\n        chicken_income = 2  # yuan/chicken\n        chicken_max_capacity = 3000\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"FarmOptimization\")\n\n        # --- Decision Variables ---\n        # Crop cultivation (hectares)\n        X = model.addVars(crops, name=\"X\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Number of animals (integer)\n        N_cow = model.addVar(name=\"N_cow\", lb=0.0, vtype=GRB.INTEGER)\n        N_chicken = model.addVar(name=\"N_chicken\", lb=0.0, vtype=GRB.INTEGER)\n\n        # External labor sold (person-days)\n        L_aw_out = model.addVar(name=\"L_aw_out\", lb=0.0, vtype=GRB.CONTINUOUS)\n        L_ss_out = model.addVar(name=\"L_ss_out\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Total Annual Net Income ---\n        total_income = gp.quicksum(crop_data[c]['income'] * X[c] for c in crops) + \\\n                       cow_income * N_cow + \\\n                       chicken_income * N_chicken + \\\n                       income_external_labor_aw * L_aw_out + \\\n                       income_external_labor_ss * L_ss_out\n\n        model.setObjective(total_income, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Land Constraint\n        land_for_cows = cow_land_feed * N_cow\n        total_land_used = gp.quicksum(X[c] for c in crops) + land_for_cows\n        model.addConstr(total_land_used <= total_land, name=\"LandLimit\")\n\n        # 2. Funds Constraint\n        total_investment = cow_investment * N_cow + chicken_investment * N_chicken\n        model.addConstr(total_investment <= total_funds, name=\"FundsLimit\")\n\n        # 3. Labor Constraint (Autumn/Winter)\n        labor_aw_farm = gp.quicksum(crop_data[c]['labor_aw'] * X[c] for c in crops) + \\\n                        cow_labor_aw * N_cow + \\\n                        chicken_labor_aw * N_chicken\n        model.addConstr(labor_aw_farm + L_aw_out <= labor_aw_available,\n                        name=\"LaborAWLimit\")\n\n        # 4. Labor Constraint (Spring/Summer)\n        labor_ss_farm = gp.quicksum(crop_data[c]['labor_ss'] * X[c] for c in crops) + \\\n                        cow_labor_ss * N_cow + \\\n                        chicken_labor_ss * N_chicken\n        model.addConstr(labor_ss_farm + L_ss_out <= labor_ss_available,\n                        name=\"LaborSSLimit\")\n\n        # 5. Animal Housing Capacity Constraints\n        model.addConstr(N_cow <= cow_max_capacity, name=\"CowCapacity\")\n        model.addConstr(N_chicken <= chicken_max_capacity,\n                        name=\"ChickenCapacity\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal farm operating plan found.\")\n            print(f\"Maximum Annual Net Income: {model.ObjVal:.2f} Yuan\")\n\n            print(\"\\nOptimal Plan Details:\")\n            print(\"  Crops (hectares):\")\n            for c in crops:\n                if X[c].X > 1e-6:\n                    print(f\"    {c}: {X[c].X:.2f} ha\")\n\n            print(\"  Animals (number):\")\n            if N_cow.X > 1e-6:\n                print(f\"    Dairy Cows: {N_cow.X:.0f}\")\n            if N_chicken.X > 1e-6:\n                print(f\"    Chickens: {N_chicken.X:.0f}\")\n\n            print(\"  External Labor Sold (person-days):\")\n            if L_aw_out.X > 1e-6:\n                print(\n                    f\"    Autumn/Winter: {L_aw_out.X:.2f} person-days (Income: {income_external_labor_aw * L_aw_out.X:.2f} Yuan)\"\n                )\n            if L_ss_out.X > 1e-6:\n                print(\n                    f\"    Spring/Summer: {L_ss_out.X:.2f} person-days (Income: {income_external_labor_ss * L_ss_out.X:.2f} Yuan)\"\n                )\n\n            print(\"\\nResource Utilization:\")\n            print(\n                f\"  Land Used: {total_land_used.getValue():.2f} / {total_land} ha ({(total_land_used.getValue()/total_land*100) if total_land > 0 else 0:.1f}%)\"\n            )\n            print(\n                f\"  Funds Used: {total_investment.getValue():.2f} / {total_funds} Yuan ({(total_investment.getValue()/total_funds*100) if total_funds > 0 else 0:.1f}%)\"\n            )\n            print(\n                f\"  Labor Autumn/Winter Used (Farm + External): {(labor_aw_farm.getValue() + L_aw_out.X):.2f} / {labor_aw_available} person-days (Farm: {labor_aw_farm.getValue():.2f}, External: {L_aw_out.X:.2f})\"\n            )\n            print(\n                f\"  Labor Spring/Summer Used (Farm + External): {(labor_ss_farm.getValue() + L_ss_out.X):.2f} / {labor_ss_available} person-days (Farm: {labor_ss_farm.getValue():.2f}, External: {L_ss_out.X:.2f})\"\n            )\n            print(f\"  Cow Capacity Used: {N_cow.X:.0f} / {cow_max_capacity}\")\n            print(\n                f\"  Chicken Capacity Used: {N_chicken.X:.0f} / {chicken_max_capacity}\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"farm_optimization_iis.ilp\")\n            # print(\"IIS written to farm_optimization_iis.ilp\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_farm_optimization()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 21,
    "retrieved_insights": []
  },
  {
    "task_id": "B003",
    "description": "A farmer needs to decide how many cows, sheep, and chickens to raise in order to achieve maximum profit. The farmer can sell cows, sheep, and chickens for $500, $200, and $8 each, respectively. The feed costs for each cow, sheep, and chicken are $100, $80, and $5, respectively. The profit is the difference between the selling price and the feed cost. Each cow, sheep, and chicken produces 10, 5, and 3 units of manure per day, respectively. Due to the limited time the farm staff has for cleaning the farm each day, they can handle up to 800 units of manure. Additionally, because of the limited farm size, the farmer can raise at most 50 chickens. Furthermore, the farmer must have at least 10 cows to meet customer demand. The farmer must also raise at least 20 sheep. Finally, the total number of animals cannot exceed 100.",
    "ground_truth": 30400.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef farmer_optimization(cow_price=500,\n                        sheep_price=200,\n                        chicken_price=8,\n                        cow_feed_cost=100,\n                        sheep_feed_cost=80,\n                        chicken_feed_cost=5,\n                        max_manure=800,\n                        max_chickens=50,\n                        min_cows=10,\n                        min_sheep=20,\n                        max_total_animals=100):\n    \"\"\"\n    Solves the farmer's optimization problem to maximize profit given constraints on\n    manure production, animal limits, and minimum required animals.\n\n    Parameters:\n        cow_price (float): Selling price for each cow. Default is 500.\n        sheep_price (float): Selling price for each sheep. Default is 200.\n        chicken_price (float): Selling price for each chicken. Default is 8.\n        cow_feed_cost (float): Feed cost for each cow. Default is 100.\n        sheep_feed_cost (float): Feed cost for each sheep. Default is 80.\n        chicken_feed_cost (float): Feed cost for each chicken. Default is 5.\n        max_manure (int): Maximum daily manure units allowed. Default is 800.\n        max_chickens (int): Maximum number of chickens allowed. Default is 50.\n        min_cows (int): Minimum number of cows required. Default is 10.\n        min_sheep (int): Minimum number of sheep required. Default is 20.\n        max_total_animals (int): Maximum total number of animals allowed. Default is 100.\n\n    Returns:\n        float or str: The optimal objective value if an optimal solution is found;\n                      otherwise, returns the model status as a string.\n    \"\"\"\n    model = gp.Model(\"Farmer_Optimization\")\n    model.setParam('OutputFlag', 0)  # Suppress output\n\n    # Decision variables\n    cows = model.addVar(vtype=GRB.INTEGER, name=\"cows\")\n    sheep = model.addVar(vtype=GRB.INTEGER, name=\"sheep\")\n    chickens = model.addVar(vtype=GRB.INTEGER, name=\"chickens\")\n\n    # Objective function\n    profit_cow = cow_price - cow_feed_cost\n    profit_sheep = sheep_price - sheep_feed_cost\n    profit_chicken = chicken_price - chicken_feed_cost\n\n    model.setObjective(profit_cow * cows + profit_sheep * sheep +\n                       profit_chicken * chickens,\n                       sense=GRB.MAXIMIZE)\n\n    # Constraints\n    model.addConstr(10 * cows + 5 * sheep + 3 * chickens <= max_manure,\n                    \"Manure_Capacity\")\n    model.addConstr(chickens <= max_chickens, \"Max_Chickens\")\n    model.addConstr(cows >= min_cows, \"Min_Cows\")\n    model.addConstr(sheep >= min_sheep, \"Min_Sheep\")\n    model.addConstr(cows + sheep + chickens <= max_total_animals,\n                    \"Total_Animals\")\n\n    # Optimize\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return model.ObjVal\n    else:\n        status_map = {\n            GRB.INFEASIBLE: \"Model is infeasible.\",\n            GRB.UNBOUNDED: \"Model is unbounded.\",\n            GRB.SUBOPTIMAL: \"Suboptimal solution found.\",\n            GRB.TIME_LIMIT: \"Optimization stopped due to time limit.\",\n            GRB.INTERRUPTED: \"Optimization interrupted.\"\n        }\n        return status_map.get(model.status,\n                              f\"Unknown status code {model.status}\")\nif __name__ == \"__main__\":\n    result = farmer_optimization()\n    print(f\"Optimal profit: {result}\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Agriculture"
      }
    ],
    "cluster": 21,
    "retrieved_insights": []
  },
  {
    "task_id": "B081",
    "description": "Changjiang Comprehensive Shopping Mall has 5000 m² of space for lease and plans to attract the following 5 types of stores as tenants. The table below shows the area occupied by each type of store for one shop, the minimum and maximum number of shops for each type within the mall, and the expected annual profit (in ten thousand yuan) per store for different numbers of stores. Each store pays 20% of its annual profit as rent to the mall. Question: How many of each type of store should the mall lease to maximize total rental income?\n\nTable 5-12\n\n| Code | Store Type | Area per Shop / m² | Min | Max | 1 Store | 2 Stores | 3 Stores |\n|------|------------|--------------------|-----|-----|---------|----------|----------|\n| 1    | Jewelry    | 250                | 1   | 3   | 9       | 8        | 7        |\n| 2    | Shoes & Hats | 350              | 1   | 2   | 10      | 9        | -        |\n| 3    | General Merchandise | 800      | 1   | 3   | 27      | 21       | 20       |\n| 4    | Bookstore  | 400                | 0   | 2   | 16      | 10       | -        |\n| 5    | Catering   | 500                | 1   | 3   | 17      | 15       | 12       |",
    "ground_truth": 28.0,
    "formulation": null,
    "correct_program": "def optimize_mall_leasing():\n    from gurobipy import Model, GRB\n\n    # Data\n    area_per_store = [250, 350, 800, 400, 500]\n    min_stores = [1, 1, 1, 0, 1]\n    max_stores = [3, 2, 3, 2, 3]\n    # Profit levels for each store type at 1, 2, 3 stores\n    profit_levels = [\n        [9, 8, 7],  # Jewelry\n        [10, 9, None],  # Shoes & Hats (only up to 2 stores)\n        [27, 21, 20],  # General Merchandise\n        [16, 10, None],  # Bookstore\n        [17, 15, 12]  # Catering\n    ]\n\n    # Initialize model\n    model = Model(\"Mall Leasing Optimization\")\n\n    # Decision variables: number of stores for each type\n    x = []\n    for i in range(5):\n        lb = min_stores[i]\n        ub = max_stores[i]\n        var = model.addVar(vtype=GRB.INTEGER, name=f\"x_{i+1}\", lb=lb, ub=ub)\n        x.append(var)\n\n    model.update()\n\n    # Area constraint\n    model.addConstr(sum(area_per_store[i] * x[i] for i in range(5)) <= 5000,\n                    name=\"area_constraint\")\n\n    # For each store type, define profit per store based on x_i\n    profit_per_store = []\n\n    for i in range(5):\n        # For store types with min=0 (store type 4), handle separately\n        if min_stores[i] == 0:\n            # For store type 4 (Bookstore), max=2\n            # Create binary indicators for 1 and 2 stores\n            b_1 = model.addVar(vtype=GRB.BINARY, name=f\"b_{i+1}_1\")\n            b_2 = model.addVar(vtype=GRB.BINARY, name=f\"b_{i+1}_2\")\n            model.update()\n\n            # Link x_i to indicators\n            # x_i = 1*b_1 + 2*b_2\n            model.addConstr(x[i] == b_1 + 2 * b_2, name=f\"link_x_b_{i+1}\")\n\n            # Exactly one indicator active if x_i > 0\n            model.addConstr(b_1 + b_2 <= 1, name=f\"one_indicator_{i+1}\")\n\n            # For x_i=0, both indicators are zero (no store)\n            # For x_i=1 or 2, one indicator is 1\n            # No need for additional constraints as above suffice\n\n            # Define profit per store based on indicators\n            profit_expr = 0\n            if profit_levels[i][0] is not None:\n                profit_expr += profit_levels[i][0] * b_1\n            if profit_levels[i][1] is not None:\n                profit_expr += profit_levels[i][1] * b_2\n            # For 0 stores, profit per store is 0\n            profit_per_store.append(profit_expr)\n\n        else:\n            # For store types with min >=1\n            # Create binary indicators for counts 1, 2, 3\n            indicators = []\n            for count in range(1, 4):\n                if count <= max_stores[i]:\n                    b = model.addVar(vtype=GRB.BINARY, name=f\"b_{i+1}_{count}\")\n                    indicators.append((count, b))\n            model.update()\n\n            # Link x_i to indicators\n            model.addConstr(x[i] == sum(count * b for count, b in indicators),\n                            name=f\"link_x_b_{i+1}\")\n\n            # Exactly one indicator active\n            model.addConstr(sum(b for _, b in indicators) == 1,\n                            name=f\"one_indicator_{i+1}\")\n\n            # Define profit per store based on indicator variables\n            profit_expr = 0\n            for count, b in indicators:\n                profit_value = profit_levels[i][count - 1]\n                profit_expr += profit_value * b\n            profit_per_store.append(profit_expr)\n\n    # Objective: maximize total rent income\n    total_income = 0\n    for i in range(5):\n        total_income += 0.2 * profit_per_store[i] * x[i]\n\n    model.setObjective(total_income, GRB.MAXIMIZE)\n\n    # Optimize\n    model.optimize()\n\n    # Check solution status\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n\nprint(optimize_mall_leasing())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 44,
    "retrieved_insights": []
  },
  {
    "task_id": "B032",
    "description": "A wealthy noble passed away, leaving the following inheritance:\n\n- A painting by Caillebotte: $25000\n- A bust of Diocletian: $5000\n- A Yuan dynasty Chinese vase: $20000\n- A 911 Porsche: $40000\n- Three diamonds: each $12000\n- A Louis XV sofa: $3000\n- Two very precious Jack Russell racing dogs: each $3000 (will stipulates they must not be separated)\n- A sculpture from 200 AD: $10000\n- A sailing boat: $15000\n- A Harley Davidson motorcycle: $10000\n- A piece of furniture once belonging to Cavour: $13000,\n\nwhich must be shared between two sons. How to formulate a mathematical program and solve it using COPTPY to minimize the difference in value between the two parts?",
    "ground_truth": 1000.0,
    "formulation": null,
    "correct_program": "def minimize_inheritance_difference():\n    from gurobipy import Model, GRB\n\n    # Item values\n    values = {\n        'painting': 25000,\n        'bust': 5000,\n        'vase': 20000,\n        'porsche': 40000,\n        'diamond1': 12000,\n        'diamond2': 12000,\n        'diamond3': 12000,\n        'sofa': 3000,\n        'dog1': 3000,\n        'dog2': 3000,\n        'sculpture': 10000,\n        'boat': 15000,\n        'motorcycle': 10000,\n        'cavour_furniture': 13000\n    }\n\n    # Initialize model\n    m = Model(\"InheritancePartition\")\n    m.setParam('OutputFlag', 0)  # Silence output\n\n    # Decision variables: y_i for each item\n    y_vars = {}\n    for item in values:\n        y_vars[item] = m.addVar(vtype=GRB.BINARY, name=f'y_{item}')\n\n    # Auxiliary variable for absolute difference\n    d = m.addVar(vtype=GRB.CONTINUOUS, name='d')\n\n    m.update()\n\n    # Total value\n    V_total = sum(values.values())\n\n    # Objective: minimize d\n    m.setObjective(d, GRB.MINIMIZE)\n\n    # Constraints for absolute difference linearization\n    sum_values_y = sum(values[item] * y_vars[item] for item in values)\n    m.addConstr(2 * sum_values_y - V_total <= d, \"abs_diff_upper\")\n    m.addConstr(-(2 * sum_values_y - V_total) <= d, \"abs_diff_lower\")\n\n    # Constraint: dogs must stay together\n    m.addConstr(y_vars['dog1'] == y_vars['dog2'], \"dogs_together\")\n\n    # Optimize\n    m.optimize()\n\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal difference\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = minimize_inheritance_difference()\n    if result is not None:\n        print(f\"Minimal inheritance difference: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Personal Finance"
      }
    ],
    "cluster": 40,
    "retrieved_insights": []
  },
  {
    "task_id": "B080",
    "description": "On Danzig Street, vehicles can park on both sides of the street. Mr. Edmonds, who lives at No. 1, is organizing a party with about 30 participants, and they will arrive in 15 cars. The length of the i-th car is λ_i, in meters, as follows:\n\n| i  | 1  | 2   | 3  | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |\n|----|----|-----|----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| λ_i | 4  | 4.5 | 5  | 4.1 | 2.4 | 5.2 | 3.7 | 3.5 | 3.2 | 4.5 | 2.3 | 3.3 | 3.8 | 4.6 | 3   |\n\nIn order to avoid disturbing the neighbors, Mr. Edmonds wants to arrange parking on both sides of the street so that the total length of the street occupied by his friends' vehicles is minimized. Please provide a mathematical programming formulation and solve this problem using AMPL.\nHow does the program change if the cars on one side of the street cannot occupy more than 30 meters?",
    "ground_truth": 28.6,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_car_parking(max_length_per_side=None):\n    \"\"\"\n    Solves the car parking assignment problem to minimize the maximum length\n    occupied on either side of the street.\n\n    Args:\n        max_length_per_side (float, optional): Maximum allowed length on one side. \n                                                If None, no limit is applied. Defaults to None.\n    \"\"\"\n    try:\n        # --- Data ---\n        car_lengths = {\n            1: 4.0,\n            2: 4.5,\n            3: 5.0,\n            4: 4.1,\n            5: 2.4,\n            6: 5.2,\n            7: 3.7,\n            8: 3.5,\n            9: 3.2,\n            10: 4.5,\n            11: 2.3,\n            12: 3.3,\n            13: 3.8,\n            14: 4.6,\n            15: 3.0\n        }\n        cars = list(car_lengths.keys())\n        sides = [1, 2]\n\n        total_car_length = sum(car_lengths.values())\n        print(f\"Total length of all cars: {total_car_length:.2f} meters\")\n\n        # --- Create Gurobi Model ---\n        model_name = \"CarParkingAssignment\"\n        if max_length_per_side is not None:\n            model_name += f\"_Max{max_length_per_side}\"\n        model = gp.Model(model_name)\n\n        # --- Decision Variables ---\n        # x[i,s]: 1 if car i is parked on side s, 0 otherwise\n        x = model.addVars(cars, sides, vtype=GRB.BINARY, name=\"x_assign\")\n\n        # L_max: Maximum length occupied on either side\n        L_max = model.addVar(name=\"L_max\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Minimize L_max ---\n        model.setObjective(L_max, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Assignment Constraint: Each car assigned to exactly one side\n        for i in cars:\n            model.addConstr(gp.quicksum(x[i, s] for s in sides) == 1,\n                            name=f\"AssignCar_{i}\")\n\n        # 2. Maximum Length Definition: L_max >= length on each side\n        for s in sides:\n            length_on_side_s = gp.quicksum(car_lengths[i] * x[i, s]\n                                           for i in cars)\n            model.addConstr(L_max >= length_on_side_s, name=f\"MaxLen_Side_{s}\")\n\n        # 3. (Optional) Side Length Limit Constraint\n        if max_length_per_side is not None:\n            print(\n                f\"\\nAdding constraint: Max length per side <= {max_length_per_side} meters\"\n            )\n            for s in sides:\n                length_on_side_s = gp.quicksum(car_lengths[i] * x[i, s]\n                                               for i in cars)\n                model.addConstr(length_on_side_s <= max_length_per_side,\n                                name=f\"SideLimit_{s}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"\\nOptimal parking assignment found.\")\n            print(\n                f\"Minimum Maximum Length Occupied (L_max): {model.ObjVal:.2f} meters\"\n            )\n\n            print(\"\\nParking Plan (Car -> Side):\")\n            assignment = {s: [] for s in sides}\n            length_used = {s: 0.0 for s in sides}\n\n            for i in cars:\n                for s in sides:\n                    if x[i, s].X > 0.5:  # Check if x[i,s] is 1\n                        assignment[s].append(i)\n                        length_used[s] += car_lengths[i]\n                        break  # Move to next car\n\n            for s in sides:\n                print(f\"  Side {s}: Cars {sorted(assignment[s])}\")\n                print(f\"    -> Total Length: {length_used[s]:.2f} meters\")\n                if max_length_per_side is not None:\n                    print(f\"       (Limit: <= {max_length_per_side})\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"\\nModel is infeasible. It's impossible to park the cars satisfying all constraints.\"\n            )\n            if max_length_per_side is not None:\n                print(\n                    f\"  This might be due to the {max_length_per_side}m limit per side.\"\n                )\n                print(\n                    f\"  Total car length is {total_car_length:.2f}m, requiring at least {total_car_length/2:.2f}m per side on average.\"\n                )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"car_parking_iis.ilp\")\n            print(\"  IIS written to car_parking_iis.ilp for debugging.\")\n        else:\n            print(f\"\\nOptimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\n# --- Solve the problems ---\nprint(\"--- Scenario 1: Minimize Maximum Length (No Side Limit) ---\")\nsolve_car_parking()\n\nprint(\"\\n=========================================================\\n\")\n\nprint(\"--- Scenario 2: Minimize Maximum Length (Max 30m per Side) ---\")\nsolve_car_parking(max_length_per_side=30.0)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 39,
    "retrieved_insights": []
  },
  {
    "task_id": "F211",
    "description": "An office is buying printers for their headquarters, a premium model and regular model. The premium model can print 30 pages per minute while the regular model can print 20 pages per minute. In addition, the premium model requires 4 units of ink per minute while the regular model requires 3 units of ink per minute. The office wants to make sure that at least 200 pages can be printed per minute and that at most 35 units of ink are used per minute.  Since the premium model is more user friendly, the number regular printers must be less than the number of premium printers. How many of each printer should be bought to minimize the total number of printers in the office?",
    "ground_truth": 7.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"PrinterOptimization\")\n\n# Parameters\nP_rate = 30  # pages per minute for premium\nR_rate = 20  # pages per minute for regular\nP_ink = 4    # ink usage per minute for premium\nR_ink = 3    # ink usage per minute for regular\nP_min = 200  # minimum pages required per minute\nI_max = 35   # maximum ink usage allowed per minute\n\n# Variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"x\")  # Number of premium printers\ny = model.addVar(vtype=GRB.INTEGER, name=\"y\")  # Number of regular printers\n\n# Objective: Minimize the total number of printers\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(P_rate * x + R_rate * y >= P_min, \"C1\")  # Total pages printed per minute constraint\nmodel.addConstr(P_ink * x + R_ink * y <= I_max, \"C2\")    # Total ink usage per minute constraint\nmodel.addConstr(y <= x - 1, \"C3\")                        # Number of regular printers constraint (y < x)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Office Management"
      }
    ],
    "cluster": 43,
    "retrieved_insights": []
  },
  {
    "task_id": "F195",
    "description": "A post office is buying stamping machines and they can buy a dual or single model stamping machine. A dual model stamping machine can stamp 50 letters per minute while a single model stamping machine can stamp 30 letters per minute. The dual model stamping machine requires 20 units of glue per minute while the single model stamping machine requires 15 units of glue per minute. Since the single model stamping machine is quieter, the number of single model stamping machines must be more than the number of dual model stamping machines. Further, the post office wants to make sure they can stamp at least 300 letters per minute and use at most 135 units of glue per minute. How many of each stamping machine should they purchase to minimize the total number of stamping machines?",
    "ground_truth": 8.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"PostOfficeStampingMachines\")\n\n# Parameters\np_d = 50  # Stamping rate of dual model\np_s = 30  # Stamping rate of single model\ng_d = 20  # Glue consumption rate of dual model\ng_s = 15  # Glue consumption rate of single model\nL = 300   # Minimum letters to be stamped\nG = 135   # Maximum glue units available\n\n# Variables\nx_d = model.addVar(vtype=GRB.INTEGER, name=\"x_d\")\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\n\n# Objective: Minimize total number of stamping machines\nmodel.setObjective(x_d + x_s, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(p_d * x_d + p_s * x_s >= L, \"C1\")  # Ensure at least 300 letters are stamped\nmodel.addConstr(g_d * x_d + g_s * x_s <= G, \"C2\")  # Ensure glue consumption does not exceed 135 units\nmodel.addConstr(x_s >= x_d + 1, \"C3\")  # Ensure the number of single model machines is more than dual model machines\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 43,
    "retrieved_insights": []
  },
  {
    "task_id": "A212",
    "description": "A macro-counting fitness guru only eats salmon and eggs. Each bowl of salmon contains 300 calories, 15 grams of protein, and 80 mg of sodium. Each bowl of eggs contains 200 calories, 8 grams of protein, and 20 mg of sodium. Since the fitness guru has a limit to how many eggs he would like to eat, at most 40% of his meals can be eggs. The fitness guru needs to eat at least 2000 calories and 90 grams of protein. How many of each type of meal should he eat to minimize his sodium intake?",
    "ground_truth": 460.0,
    "formulation": null,
    "correct_program": "def optimize_meals():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Salmon_Egg_Optimization\")\n\n    # Decision variables: number of salmon and eggs bowls\n    x_s = m.addVar(name=\"Salmon\", lb=0, vtype=GRB.INTEGER)\n    x_e = m.addVar(name=\"Eggs\", lb=0, vtype=GRB.INTEGER)\n\n    # Set the objective: minimize total sodium intake\n    sodium = 80 * x_s + 20 * x_e\n    m.setObjective(sodium, GRB.MINIMIZE)\n\n    # Add calorie constraint\n    m.addConstr(300 * x_s + 200 * x_e >= 2000, name=\"Calories\")\n\n    # Add protein constraint\n    m.addConstr(15 * x_s + 8 * x_e >= 90, name=\"Protein\")\n\n    # Add egg proportion constraint: x_e <= (2/3) * x_s\n    m.addConstr(x_e <= (2/3) * x_s, name=\"EggProportion\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal sodium intake\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nprint(optimize_meals())\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Diet Problem",
        "modeling_type": "MILP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E032",
    "description": "Imagine you're creating a meal plan for yourself and want to ensure you're getting the right amount of nutrients, but you also want to keep your budget in check. You're considering four different food items: Steak, Eggs, Pasta, and Chicken. Each of these food items has a different nutritional content and cost.\n\nHere's a brief overview of what each food item provides and how much it costs:\n\n- Steak: Provides you with 20 grams of protein, 2 grams of carbohydrates, and 68 calories for $4.\n- Eggs: Offer 7 grams of protein, 3 grams of carbohydrates, and 143 calories for just $1.\n- Pasta: Gives you 1 gram of protein, a large 26 grams of carbohydrates, and 52 calories for $9.\n- Chicken: Packs 10 grams of protein, 1 gram of carbohydrate, and 69 calories for $4.\n\nYou need to ensure that you consume at least 71 grams of protein, 141 grams of carbohydrates, and 1839 calories from the food combination you choose. The challenge is to determine the least expensive way to meet these nutritional requirements using these four food options. What is the least amount of money you can spend to meet your nutritional needs? Note that your response should only include the optimal cost value.",
    "ground_truth": 47.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlan\")\n\n# Sets and Parameters\nfoods = ['Steak', 'Eggs', 'Pasta', 'Chicken']\ncost = {'Steak': 4, 'Eggs': 1, 'Pasta': 9, 'Chicken': 4}\nprotein = {'Steak': 20, 'Eggs': 7, 'Pasta': 1, 'Chicken': 10}\ncarbs = {'Steak': 2, 'Eggs': 3, 'Pasta': 26, 'Chicken': 1}\ncalories = {'Steak': 68, 'Eggs': 143, 'Pasta': 52, 'Chicken': 69}\n\n# Minimum nutritional requirements\nmin_protein = 71\nmin_carbs = 141\nmin_calories = 1839\n\n# Decision Variables\nx = model.addVars(foods, vtype=GRB.INTEGER, name=\"Servings\")\n\n# Objective: Minimize cost\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in foods), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in foods) >= min_protein, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carbs[i] * x[i] for i in foods) >= min_carbs, \"CarbohydrateRequirement\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in foods) >= min_calories, \"CalorieRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Diet Problem",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E002",
    "description": "Imagine you're meticulously planning your weekly meals to ensure you're hitting all your nutritional goals while sticking to a budget. You're considering five diverse food items, each with unique nutritional benefits and costs. \n\nHere's a breakdown of what each food offers and its cost:\n\n- Food_1: Delivers 3 grams of protein, 16 grams of carbohydrates, and 96 calories for $9.\n- Food_2: Provides 17 grams of protein, 24 grams of carbohydrates, and 182 calories for $9.\n- Food_3: Offers 16 grams of protein, 27 grams of carbohydrates, and 114 calories for just $2.\n- Food_4: Contains 8 grams of protein, 16 grams of carbohydrates, and 208 calories for $9.\n- Food_5: Supplies 6 grams of protein, 6 grams of carbohydrates, and 236 calories for $5.\n\nYour dietary targets for the week are to consume at least 100 grams of protein, 180 grams of carbohydrates, and 1796 calories. Your challenge is to determine the most cost-effective combination of these food items to meet or exceed these nutritional requirements. What is the cheapest cost to achieve your dietary goals?",
    "ground_truth": 32.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nP = [3, 17, 16, 8, 6]  # Protein content for each food item\nC = [16, 24, 27, 16, 6]  # Carbohydrate content for each food item\nK = [96, 182, 114, 208, 236]  # Caloric content for each food item\nCost = [9, 9, 2, 9, 5]  # Cost for each food item\nT_P = 100  # Total weekly protein requirement\nT_C = 180  # Total weekly carbohydrate requirement\nT_K = 1796  # Total weekly caloric requirement\n\n# Decision variables: Number of units of each food item to purchase\nx = model.addVars(5, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: Minimize the total cost\nmodel.setObjective(gp.quicksum(Cost[i] * x[i] for i in range(5)), GRB.MINIMIZE)\n\n# Constraints\n# Protein constraint\nmodel.addConstr(gp.quicksum(P[i] * x[i] for i in range(5)) >= T_P, \"ProteinRequirement\")\n\n# Carbohydrate constraint\nmodel.addConstr(gp.quicksum(C[i] * x[i] for i in range(5)) >= T_C, \"CarbohydrateRequirement\")\n\n# Calorie constraint\nmodel.addConstr(gp.quicksum(K[i] * x[i] for i in range(5)) >= T_K, \"CalorieRequirement\")\n\n# Non-negativity constraints are automatically handled by variable definition\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Diet Problem",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E018",
    "description": "Picture this: you're trying to plan your meals for the day and you're aiming to get the right amount of nutrients, but also want to keep your expenses low. You have four different food options to choose from: Chicken, Cheese, Rice, and Beans. Each of these foods has a certain amount of protein, carbs, and calories, and each comes with its own price.\n\nHere's a brief overview of what each food provides and its cost:\n\n- Chicken: Gives you 16 grams of protein, 22 grams of carbohydrates, and 292 calories for $5.\n- Cheese: Offers 10 grams of protein, 4 grams of carbohydrates, and 82 calories for $9.\n- Rice: Provides 12 grams of protein, 21 grams of carbohydrates, and 207 calories for just $2.\n- Beans: Packs 13 grams of protein, 14 grams of carbohydrates, and 81 calories for a single dollar.\n\nYou need to ensure you consume at least 94 grams of protein, 191 grams of carbohydrates, and 2271 calories from the combination of these foods you choose. Your goal is to determine the most cost-effective way to reach these nutritional targets with these four food options. What is the minimum cost to meet your nutritional requirements?",
    "ground_truth": 22.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPlanning\")\n\n# Create variables\nx_chicken = model.addVar(name=\"x_chicken\", lb=0)\nx_cheese = model.addVar(name=\"x_cheese\", lb=0)\nx_rice = model.addVar(name=\"x_rice\", lb=0)\nx_beans = model.addVar(name=\"x_beans\", lb=0)\n\n# Set objective\nmodel.setObjective(5 * x_chicken + 9 * x_cheese + 2 * x_rice + x_beans, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(16 * x_chicken + 10 * x_cheese + 12 * x_rice + 13 * x_beans >= 94, \"ProteinRequirement\")\nmodel.addConstr(22 * x_chicken + 4 * x_cheese + 21 * x_rice + 14 * x_beans >= 191, \"CarbohydrateRequirement\")\nmodel.addConstr(292 * x_chicken + 82 * x_cheese + 207 * x_rice + 81 * x_beans >= 2271, \"CalorieRequirement\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Diet Problem",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E011",
    "description": "Imagine you're a dietitian tasked with planning a daily meal for a client with specific dietary goals. Your challenge is to select from four available food options to meet the nutritional requirements at the minimal cost. Each food item has its distinct protein, carbohydrate, and caloric content along with a price tag.\n\nHere’s a quick overview of the food items and their respective nutritional values and costs:\n\n- Food_1: Contains 2 grams of protein, 9 grams of carbohydrates, and 165 calories, all for $3.\n- Food_2: Provides 11 grams of protein, 29 grams of carbohydrates, and 230 calories for $3.\n- Food_3: Offers 19 grams of protein, 16 grams of carbohydrates, and 68 calories for $6.\n- Food_4: Delivers 17 grams of protein, 9 grams of carbohydrates, and 258 calories for $9.\n\nThe nutritional targets set for your client are to consume at least 88 grams of protein, 107 grams of carbohydrates, and 1944 calories in a day. Your goal is to determine the least expensive way to meet these dietary requirements using the available food options. What is the cheapest cost to achieve these nutritional goals?",
    "ground_truth": 27.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DietOptimization\")\n\n# Add variables: the number of units of each food item\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")\nx3 = model.addVar(vtype=GRB.INTEGER, name=\"x3\")\nx4 = model.addVar(vtype=GRB.INTEGER, name=\"x4\")\n\n# Set the objective: minimize the total cost\nmodel.setObjective(3*x1 + 3*x2 + 6*x3 + 9*x4, GRB.MINIMIZE)\n\n# Add constraints\n# Protein requirement\nmodel.addConstr(2*x1 + 11*x2 + 19*x3 + 17*x4 >= 88, \"ProteinRequirement\")\n\n# Carbohydrate requirement\nmodel.addConstr(9*x1 + 29*x2 + 16*x3 + 9*x4 >= 107, \"CarbohydrateRequirement\")\n\n# Caloric requirement\nmodel.addConstr(165*x1 + 230*x2 + 68*x3 + 258*x4 >= 1944, \"CaloricRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Diet Problem",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E006",
    "description": "Imagine you're meticulously planning your weekly meal prep and want to ensure that your diet is nutritionally balanced while also being cost-effective. You have a choice between five different food items, each with its own nutritional profile and cost. Your challenge is to choose the right combination of these foods to meet your nutritional needs without overspending.\n\nHere's what each food item offers along with its cost:\n\n- Food_1: Provides 10 grams of protein, 22 grams of carbohydrates, and 80 calories for $2.\n- Food_2: Offers 3 grams of protein, 4 grams of carbohydrates, and 189 calories for $8.\n- Food_3: Contains 17 grams of protein, 10 grams of carbohydrates, and 153 calories for $4.\n- Food_4: Delivers 6 grams of protein, 13 grams of carbohydrates, and 232 calories for $1.\n- Food_5: Packs 20 grams of protein, 5 grams of carbohydrates, and 204 calories for $8.\n\nYour dietary goals are to consume at least 74 grams of protein, 102 grams of carbohydrates, and 1564 calories in total. What is the minimum cost required to meet these nutritional targets using any combination of the available food items?",
    "ground_truth": 13.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MealPrepOptimization\")\n\n# Parameters\nprotein = [10, 3, 17, 6, 20]\ncarbohydrates = [22, 4, 10, 13, 5]\ncalories = [80, 189, 153, 232, 204]\ncost = [2, 8, 4, 1, 8]\n\n# Nutritional requirements\nprotein_req = 74\ncarbohydrates_req = 102\ncalories_req = 1564\n\n# Variables: quantities of each food item\nx = model.addVars(5, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: Minimize total cost\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in range(5)), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in range(5)) >= protein_req, \"ProteinReq\")\nmodel.addConstr(gp.quicksum(carbohydrates[i] * x[i] for i in range(5)) >= carbohydrates_req, \"CarbohydratesReq\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in range(5)) >= calories_req, \"CaloriesReq\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Diet Problem",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "E009",
    "description": "Imagine you're a dietitian, tasked with planning a nutritious and balanced meal for an athlete. The athlete needs to maintain a high protein, moderate carb diet, with enough calories to sustain their intense training regimen. The goal is to meet these dietary requirements at the lowest cost possible. You have five different food items to choose from: Steak, Rice, Chicken, Iceberg Lettuce, and Almonds. Each of these foods contains varying amounts of protein, carbohydrates, and calories, and each comes with a specific cost.\n\nHere's a detailed breakdown of the nutritional value of each food item and its cost:\n\n- Steak: Offers a whopping 20 grams of protein, 12 grams of carbohydrates, and 167 calories for $7.\n- Rice: Provides 6 grams of protein, an impressive 29 grams of carbohydrates, and a hefty 275 calories for $8.\n- Chicken: Packs 17 grams of protein, 26 grams of carbohydrates, and 112 calories for only $2.\n- Iceberg Lettuce: Contains only 1 gram of protein, 8 grams of carbohydrates, and 148 calories for $8.\n- Almonds: Provide 10 grams of protein, 2 grams of carbohydrates, and a high 286 calories for just $2.\n\nThe athlete's daily dietary requirements are as follows: at least 83 grams of protein, 128 grams of carbohydrates, and 1686 calories.\n\nYour challenge is to select a combination of these foods that meets the athletes' nutritional needs, while keeping the costs as low as possible. So, what is the lowest possible cost to meet these dietary requirements? Note: your response should be a single answer question, asking for the optimal value.",
    "ground_truth": 18.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DietOptimization\")\n\n# Parameters\nprotein = [20, 6, 17, 1, 10]\ncarbohydrates = [12, 29, 26, 8, 2]\ncalories = [167, 275, 112, 148, 286]\ncost = [7, 8, 2, 8, 2]\n\nP_min = 83\nC_min = 128\nCal_min = 1686\n\n# Variables\nx = model.addVars(5, lb=0, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: Minimize cost\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in range(5)), GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in range(5)) >= P_min, \"ProteinRequirement\")\nmodel.addConstr(gp.quicksum(carbohydrates[i] * x[i] for i in range(5)) >= C_min, \"CarbohydrateRequirement\")\nmodel.addConstr(gp.quicksum(calories[i] * x[i] for i in range(5)) >= Cal_min, \"CalorieRequirement\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Diet Problem",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "F080",
    "description": "A car manufacturing company makes hamburgers and chicken wraps for workers. They need to ensure workers get at least 2200 calories, 50 grams of protein, and 70 grams of carbs. One hamburger costs $6.5 and contains 800 calories, 19 grams of protein, and 20 grams of carbs. One chicken wrap costs $4 and contains 450 calories, 12 grams of protein, and 10 grams of carbs. What is the minimum cost diet that the company can provide for its workers?",
    "ground_truth": 23.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Diet Problem",
        "modeling_type": "LP",
        "industry_sector": "Food Service"
      }
    ],
    "cluster": 12,
    "retrieved_insights": []
  },
  {
    "task_id": "A183",
    "description": "A flooring company produces engineered laminate planks and carpets. The chief marketer reports an expected demand of at least 15,000 square feet of laminate planks and 5,000 square feet of carpets each week. The shipping contract requires a total of at least 50,000 square feet of products each week. However, due to a shortage of raw materials, no more than 40,000 square feet of laminate planks and 20,000 square feet of carpets can be produced weekly. If a square foot of laminate planks produces a $2.1 profit and a square foot of carpets yields a $3.3 profit, how many of each type of product should be made weekly to maximize the company's profit?",
    "ground_truth": 150000.0,
    "formulation": null,
    "correct_program": "def optimize_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"FlooringProduction\")\n\n    # Decision variables\n    # x: square feet of laminate planks\n    # y: square feet of carpets\n    x = m.addVar(name=\"x\", lb=15000, ub=40000, vtype=GRB.CONTINUOUS)\n    y = m.addVar(name=\"y\", lb=5000, ub=20000, vtype=GRB.CONTINUOUS)\n\n    # Set the objective: maximize profit\n    profit = 2.1 * x + 3.3 * y\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Add the shipping constraint\n    m.addConstr(x + y >= 50000, name=\"shipping_constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A010",
    "description": "A glass factory makes two types of glass panes: a regular glass pane and a tempered glass pane. Both require time on a heating and cooling machine. Both machines are available for a maximum of 300 minutes per day. It takes 3 minutes in the heating machine and 5 minutes in the cooling machine to make one regular glass pane. It takes 5 minutes in the heating machine and 8 minutes in the cooling machine to make one tempered glass pane. The profit per pane of regular glass is $8 and the profit per pane of tempered glass is $10. How many panes of each glass type should the factory make to maximize profit? What is the maximum profit?",
    "ground_truth": 480.0,
    "formulation": null,
    "correct_program": "def optimize_glass_production(\n    max_time=300,\n    profit_regular=8,\n    profit_tempered=10,\n    heating_time_regular=3,\n    cooling_time_regular=5,\n    heating_time_tempered=5,\n    cooling_time_tempered=8\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"GlassProductionMaxProfit\")\n\n    # Decision variables: number of regular and tempered panes\n    x = model.addVar(vtype=GRB.INTEGER, name=\"Regular\")\n    y = model.addVar(vtype=GRB.INTEGER, name=\"Tempered\")\n\n    # Set objective: maximize profit\n    model.setObjective(profit_regular * x + profit_tempered * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Heating machine constraint\n    model.addConstr(heating_time_regular * x + heating_time_tempered * y <= max_time, \"HeatingTime\")\n    # Cooling machine constraint\n    model.addConstr(cooling_time_regular * x + cooling_time_tempered * y <= max_time, \"CoolingTime\")\n    # Non-negativity constraints are implicit with variable types\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_glass_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A191",
    "description": "A printing company sells math workbooks and English workbooks. To meet demand, they must make at least 40 math workbooks and at least 60 English workbooks. However, they can make at most 140 math workbooks and at most 170 English workbooks. The company has a contract with a school to send at least 200 workbooks of either type. If the profit per math workbook is $15 and the profit per English workbook is $17, how many of each should the company make to maximize profit?",
    "ground_truth": 4990.0,
    "formulation": null,
    "correct_program": "def optimize_workbooks():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Workbook_Production\")\n\n    # Decision variables: number of math and English workbooks\n    # They are integers because you can't produce fractional workbooks\n    x = m.addVar(lb=40, ub=140, vtype=GRB.INTEGER, name=\"Math_Workbooks\")\n    y = m.addVar(lb=60, ub=170, vtype=GRB.INTEGER, name=\"English_Workbooks\")\n\n    # Set the objective: maximize profit\n    m.setObjective(15 * x + 17 * y, GRB.MAXIMIZE)\n\n    # Add demand constraint\n    m.addConstr(x + y >= 200, \"Demand_Constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_workbooks()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A194",
    "description": "Zeta Bakery sells two types of cookies. They sell a strawberry cookie and a sugar cookie. Let's say they make x1 strawberry cookies, at a profit of $5.5 each, and x2 sugar cookies, at a profit of $12 each (x1 and x2 are unknowns both greater than or equal to 0). The daily demand for these cookies is at most 100 strawberry cookies and at most 80 sugar cookies. The bakery is short staffed and can make a maximum of 100 cookies of either type per day. How much of each cookie should the bakery make in order to maximize profit?",
    "ground_truth": 1070.0,
    "formulation": null,
    "correct_program": "def optimize_bakery_profit(\n    profit_strawberry=5.5,\n    profit_sugar=12,\n    max_demand_strawberry=100,\n    max_demand_sugar=80,\n    max_total_production=100\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Bakery_Optimization\")\n\n    # Decision variables\n    x1 = model.addVar(name=\"x1\", lb=0)  # Strawberry cookies\n    x2 = model.addVar(name=\"x2\", lb=0)  # Sugar cookies\n\n    # Set objective: maximize profit\n    model.setObjective(profit_strawberry * x1 + profit_sugar * x2, GRB.MAXIMIZE)\n\n    # Add constraints\n    model.addConstr(x1 <= max_demand_strawberry, name=\"Demand_Strawberry\")\n    model.addConstr(x2 <= max_demand_sugar, name=\"Demand_Sugar\")\n    model.addConstr(x1 + x2 <= max_total_production, name=\"Total_Production\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_bakery_profit()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit:.2f}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A192",
    "description": "A music company produces two types of digital keyboards, one is full-weighted and another is semi-weighted. Both keyboards are sold for $2800 and $2400 respectively. There are about 3500 oscillator chips available every day from which the full-weighted version requires 20 chips while the semi-weighted version requires 15 chips. The company has a total of 6 working hours a day. Both of these keyboards require a production time of 1.2 hours. What should be the manufacturing quantity for each of the keyboards to maximize the total revenue?",
    "ground_truth": 14000.0,
    "formulation": null,
    "correct_program": "def optimize_keyboard_production(\n    price_full=2800,\n    price_semi=2400,\n    chips_available=3500,\n    hours_available=6,\n    production_time=1.2\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Keyboard_Production_Maximize_Revenue\")\n\n    # Decision variables: number of full-weighted and semi-weighted keyboards\n    x = model.addVar(vtype=GRB.INTEGER, name=\"Full_Weighted_Keyboard\")\n    y = model.addVar(vtype=GRB.INTEGER, name=\"Semi_Weighted_Keyboard\")\n\n    # Set objective: maximize total revenue\n    model.setObjective(price_full * x + price_semi * y, GRB.MAXIMIZE)\n\n    # Add chip constraint\n    model.addConstr(20 * x + 15 * y <= chips_available, \"Chip_Limit\")\n\n    # Add production time constraint\n    # Since each takes 1.2 hours, total hours for x and y\n    model.addConstr(production_time * (x + y) <= hours_available, \"Time_Limit\")\n\n    # Set non-negativity (implicit with variable type=GRB.INTEGER and default bounds)\n    # Solve the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal total revenue\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_revenue = optimize_keyboard_production()\n    if max_revenue is not None:\n        print(f\"Maximum Revenue: ${max_revenue}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A027",
    "description": "A flooring company produces engineered hardwood and vinyl planks. Their sales forecasts show an expected demand of at least 20,000 square foot of hardwood and 10,000 square feet of vinyl planks each week. To satisfy a shipping contract, a total of at least 60,000 square feet of flooring much be shipped each week. Due to a labor shortage issue, no more than 50,000 square feet of hardwood and 30,000  square feet of vinyl  can be produced weekly. If a square foot of hardwood flooring yields a profit of $2.5 and a square foot of vinyl planks produces a $3 profit, how many of each type of flooring should be made weekly to maximize the company's profit?",
    "ground_truth": 215000.0,
    "formulation": null,
    "correct_program": "def optimize_flooring_production(\n    demand_hardwood=20000,\n    demand_vinyl=10000,\n    total_shipment=60000,\n    max_hardwood=50000,\n    max_vinyl=30000,\n    profit_hardwood=2.5,\n    profit_vinyl=3\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Flooring_Production_Optimization\")\n\n    # Decision variables\n    x = model.addVar(name=\"Hardwood\", lb=0, ub=max_hardwood)\n    y = model.addVar(name=\"Vinyl\", lb=0, ub=max_vinyl)\n\n    # Set the objective\n    model.setObjective(profit_hardwood * x + profit_vinyl * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    model.addConstr(x >= demand_hardwood, \"HardwoodDemand\")\n    model.addConstr(y >= demand_vinyl, \"VinylDemand\")\n    model.addConstr(x + y >= total_shipment, \"TotalShipment\")\n    # The upper bounds are already enforced by variable bounds, but can be explicitly added\n    # for clarity:\n    model.addConstr(x <= max_hardwood, \"HardwoodCap\")\n    model.addConstr(y <= max_vinyl, \"VinylCap\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal profit\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_flooring_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A232",
    "description": "A handmade sports equipment manufacturing company makes basketballs and footballs. Basketballs require 5 units of materials and 1 hour to make whereas footballs require 3 units of materials and 2 hours to make. The manufacturing company has available 1500 units of materials and their workers working at max capacity can work for at most 750 hours. Since basketballs sell better, there must be at least three times as many basketballs as footballs but the manufacturing company would like at least 50 footballs. How many of each should the manufacturing company make to maximize the total number of sports equipment produced?",
    "ground_truth": 333.0,
    "formulation": null,
    "correct_program": "def optimize_sports_equipment(material_limit=1500, hours_limit=750, min_football=50):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Sports_Equipment_Production\")\n\n    # Decision variables: number of basketballs and footballs\n    x = model.addVar(name=\"Basketballs\", vtype=GRB.INTEGER, lb=0)\n    y = model.addVar(name=\"Footballs\", vtype=GRB.INTEGER, lb=0)\n\n    # Set the objective: maximize total equipment\n    model.setObjective(x + y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Material constraint\n    model.addConstr(5 * x + 3 * y <= material_limit, name=\"MaterialLimit\")\n    # Labor hours constraint\n    model.addConstr(x + 2 * y <= hours_limit, name=\"HoursLimit\")\n    # Production ratio constraint\n    model.addConstr(x >= 3 * y, name=\"BasketballToFootballRatio\")\n    # Minimum footballs\n    model.addConstr(y >= min_football, name=\"MinFootballs\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_produced = x.X + y.X\n        return total_produced\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    total_equipment = optimize_sports_equipment()\n    if total_equipment is not None:\n        print(f\"Maximum Total Sports Equipment Produced: {total_equipment}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A208",
    "description": "A neighbourhood pizza restaurant has opened and sells pizzas in two sizes; large pizza and medium pizza. Large pizzas require 12 units of dough, and 5 units of toppings. Medium pizzas require 8 units of dough, and 4 units of toppings. While large pizzas take 12 minutes to bake, medium pizzas require 8 minutes to bake. The neighbourhood pizza restaurant must use at least 10000 units of dough and 4400 units of toppings. Medium pizzas are popular due to a promotion, therefore, at least 200 medium pizzas must be made. There are regulars that prefer large pizzas and at least two times as many large pizzas should be made than medium pizzas. How many of each size of pizzas should the neighbourhood pizza restaurant make to reduce time spent baking?",
    "ground_truth": 10060.0,
    "formulation": null,
    "correct_program": "def optimize_pizza_baking():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Pizza_Baking_Minimize_Time\")\n\n    # Decision variables\n    L = m.addVar(vtype=GRB.INTEGER, name=\"Large_Pizzas\", lb=0)\n    M = m.addVar(vtype=GRB.INTEGER, name=\"Medium_Pizzas\", lb=0)\n\n    # Set objective: minimize total baking time\n    m.setObjective(12 * L + 8 * M, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(12 * L + 8 * M >= 10000, name=\"Dough_Constraint\")\n    m.addConstr(5 * L + 4 * M >= 4400, name=\"Toppings_Constraint\")\n    m.addConstr(M >= 200, name=\"Medium_Demand\")\n    m.addConstr(L >= 2 * M, name=\"Large_vs_Medium_Ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the total baking time of the optimal solution\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_baking_time = optimize_pizza_baking()\n    if min_baking_time is not None:\n        print(f\"Minimum Total Baking Time: {min_baking_time} minutes\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "IP",
        "industry_sector": "Food Service"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A057",
    "description": "A grilled cheese shop sells a light and heavy grilled cheese sandwich. A light grilled cheese sandwich requires 2 slices of bread and 3 slices of cheese. A heavy grilled cheese sandwich requires 3 slices of bread and 5 slices of cheese. Since most people who come to the store love grilled cheese, the store must make at least 3 times as many heavy grilled cheese sandwiches as light grilled cheese sandwiches. The store has available 300 slices of bread and 500 slices of cheese. If a light grilled cheese sandwich takes 10 minutes to make and a heavy grilled cheese sandwich takes 15 minutes to make, how many of each should they make to minimize the total production time?",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": "def optimize_grilled_cheese():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"GrilledCheeseOptimization\")\n    \n    # Decision variables: number of light and heavy sandwiches\n    x = m.addVar(name=\"light_sandwiches\", vtype=GRB.INTEGER, lb=0)\n    y = m.addVar(name=\"heavy_sandwiches\", vtype=GRB.INTEGER, lb=0)\n    \n    # Set the objective: minimize total production time\n    m.setObjective(10 * x + 15 * y, GRB.MINIMIZE)\n    \n    # Add resource constraints\n    m.addConstr(2 * x + 3 * y <= 300, name=\"bread_constraint\")\n    m.addConstr(3 * x + 5 * y <= 500, name=\"cheese_constraint\")\n    \n    # Add demand ratio constraint\n    m.addConstr(y >= 3 * x, name=\"heavy_light_ratio\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total production time\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_grilled_cheese()\n    if min_time is not None:\n        print(f\"Minimum Total Production Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Food Service"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "B065",
    "description": "A toy company manufactures three types of tabletop golf toys, each requiring different manufacturing techniques. The high-end type requires 17 hours of manufacturing labor, 8 hours of inspection, and yields a profit of 300 yuan per unit. The mid-range type requires 10 hours of labor, 4 hours of inspection, and yields a profit of 200 yuan per unit. The low-end type requires 2 hours of labor, 2 hours of inspection, and yields a profit of 100 yuan per unit. Available labor hours are 1000, and available inspection hours are 500. Additionally, market forecasts indicate a demand of no more than 50 units for the high-end type, no more than 80 units for the mid-range type, and no more than 150 units for the low-end type. Determine the production plan for the company to maximize profit.",
    "ground_truth": 25000.0,
    "formulation": null,
    "correct_program": "def optimize_toy_production(labor_hours=1000,\n                            inspection_hours=500,\n                            demand_high=50,\n                            demand_mid=80,\n                            demand_low=150,\n                            profit_high=300,\n                            profit_mid=200,\n                            profit_low=100,\n                            labor_high=17,\n                            labor_mid=10,\n                            labor_low=2,\n                            inspect_high=8,\n                            inspect_mid=4,\n                            inspect_low=2):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Toy_Production_Maximize_Profit\")\n\n    # Decision variables: number of units to produce for each type\n    x_H = model.addVar(vtype=GRB.INTEGER, name=\"HighEnd\", lb=0, ub=demand_high)\n    x_M = model.addVar(vtype=GRB.INTEGER, name=\"MidRange\", lb=0, ub=demand_mid)\n    x_L = model.addVar(vtype=GRB.INTEGER, name=\"LowEnd\", lb=0, ub=demand_low)\n\n    # Set objective: maximize total profit\n    model.setObjective(profit_high * x_H + profit_mid * x_M + profit_low * x_L,\n                       GRB.MAXIMIZE)\n\n    # Add labor hours constraint\n    model.addConstr(labor_high * x_H + labor_mid * x_M + labor_low * x_L\n                    <= labor_hours,\n                    name=\"LaborHours\")\n\n    # Add inspection hours constraint\n    model.addConstr(inspect_high * x_H + inspect_mid * x_M + inspect_low * x_L\n                    <= inspection_hours,\n                    name=\"InspectionHours\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit value\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":\n    result = optimize_toy_production()\n    if result is not None:\n        print(f\"Optimal total profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "B008",
    "description": "Haus Toys can manufacture and sell toy trucks, toy airplanes, toy boats, and toy trains. The profit for each truck sold is $5, each airplane $10, each boat $8, and each train $7. How many types of toys should Haus Toys manufacture to maximize profits?\n\nThere are 890 units of wood available. Each truck requires 12 units, each airplane 20 units, each boat 15 units, and each train 10 units.\n\nThere are 500 units of steel available. Each airplane requires 3 units, each boat 5 units, each train 4 units, and each truck 6 units.\n\nIf Haus Toys manufactures trucks, they will not manufacture trains.\n\nHowever, if they manufacture boats, they will also manufacture airplanes.\n\nThe number of toy boats manufactured cannot exceed the number of toy trains manufactured.",
    "ground_truth": 623.0,
    "formulation": null,
    "correct_program": "def optimize_toy_production(\n        wood_available=890,\n        steel_available=500,\n        profit_truck=5,\n        profit_airplane=10,\n        profit_boat=8,\n        profit_train=7,\n        M=1000  # Big-M value\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create model\n    model = gp.Model(\"HausToysOptimization\")\n    model.setParam('OutputFlag', 0)  # Silence output\n\n    # Decision variables\n    T = model.addVar(vtype=GRB.INTEGER, name=\"T\")  # Trucks\n    A = model.addVar(vtype=GRB.INTEGER, name=\"A\")  # Airplanes\n    B = model.addVar(vtype=GRB.INTEGER, name=\"B\")  # Boats\n    R = model.addVar(vtype=GRB.INTEGER, name=\"R\")  # Trains\n\n    # Binary variables for logical conditions\n    y_T = model.addVar(vtype=GRB.BINARY, name=\"y_T\")\n    y_R = model.addVar(vtype=GRB.BINARY, name=\"y_R\")\n    y_B = model.addVar(vtype=GRB.BINARY, name=\"y_B\")\n\n    # Objective: maximize profit\n    model.setObjective(\n        profit_truck * T + profit_airplane * A + profit_boat * B +\n        profit_train * R, GRB.MAXIMIZE)\n\n    # Resource constraints\n    model.addConstr(12 * T + 20 * A + 15 * B + 10 * R <= wood_available,\n                    \"Wood\")\n    model.addConstr(6 * T + 3 * A + 5 * B + 4 * R <= steel_available, \"Steel\")\n\n    # Boats cannot exceed trains\n    model.addConstr(B <= R, \"BoatTrainLimit\")\n\n    # Logical constraints for trucks and trains (mutual exclusivity)\n    model.addConstr(T <= M * y_T, \"TruckLogical\")\n    model.addConstr(R <= M * y_R, \"TrainLogical\")\n    model.addConstr(y_T + y_R <= 1, \"MutualExclusion\")\n\n    # Logical constraints for boats and airplanes\n    model.addConstr(A >= y_B, \"AirplaneBoat\")\n    model.addConstr(B <= y_B * M, \"BoatBinary\")\n\n    # Optional: enforce non-negativity (default in Gurobi)\n    # Variables are already non-negative by default unless specified otherwise\n\n    # Optimize\n    model.optimize()\n\n    # Check feasibility\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_toy_production()\n    print(f\"Optimal profit: {result}\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "B019",
    "description": "Bright Future Toys wants to build and sell robots, model cars, building blocks, and dolls. The profit for each robot sold is $15, for each model car sold is $8, for each set of building blocks sold is $12, and for each doll sold is $5. How many types of toys should Bright Future Toys manufacture to maximize profit?\nThere are 1200 units of plastic available. Each robot requires 30 units of plastic, each model car requires 10 units of plastic, each set of building blocks requires 20 units of plastic, and each doll requires 15 units of plastic.\n\nThere are 800 units of electronic components available. Each robot requires 8 units of electronic components, each model car requires 5 units of electronic components, each set of building blocks requires 3 units of electronic components, and each doll requires 2 units of electronic components.\n\nIf Bright Future Toys manufactures robots, they will not manufacture dolls.\n\nHowever, if they manufacture model cars, they will also manufacture building blocks.\n\nThe number of dolls manufactured cannot exceed the number of model cars manufactured.",
    "ground_truth": 956.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_toy_production_problem():\n    try:\n        # --- Problem Data ---\n        toys = [\"robots\", \"cars\", \"blocks\", \"dolls\"]\n        profits = {\"robots\": 15, \"cars\": 8, \"blocks\": 12, \"dolls\": 5}\n\n        # Resource consumption per toy\n        plastic_usage = {\"robots\": 30, \"cars\": 10, \"blocks\": 20, \"dolls\": 15}\n        electronics_usage = {\"robots\": 8, \"cars\": 5, \"blocks\": 3, \"dolls\": 2}\n\n        # Resource availability\n        max_plastic = 1200\n        max_electronics = 800\n\n        # --- Model Creation ---\n        model = gp.Model(\"BrightFutureToys\")\n\n        # --- Decision Variables ---\n        # Quantity of each toy to produce (integer, non-negative)\n        qty = model.addVars(toys, vtype=GRB.INTEGER, name=\"qty\", lb=0)\n\n        # Binary variables to indicate if a type of toy is manufactured\n        # use_toy[t] = 1 if qty[t] > 0, 0 otherwise\n        use_toy = model.addVars(toys, vtype=GRB.BINARY, name=\"use\")\n\n        # --- Objective Function ---\n        # Maximize total profit\n        total_profit = gp.quicksum(profits[t] * qty[t] for t in toys)\n        model.setObjective(total_profit, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n\n        # 1. Resource Constraints\n        # Plastic\n        model.addConstr(\n            gp.quicksum(plastic_usage[t] * qty[t] for t in toys)\n            <= max_plastic, \"PlasticLimit\")\n        # Electronic Components\n        model.addConstr(\n            gp.quicksum(electronics_usage[t] * qty[t] for t in toys)\n            <= max_electronics, \"ElectronicsLimit\")\n\n        # 2. Link binary 'use_toy' variables to 'qty' variables\n        # If qty[t] > 0, then use_toy[t] must be 1.\n        # If qty[t] = 0, then use_toy[t] must be 0.\n        # We can use a \"big M\" approach or indicator constraints. Indicators are cleaner.\n        # A large enough M could be max_plastic / min_plastic_usage_per_toy or similar.\n        # For example, max robots = 1200/30 = 40. max cars = 1200/10 = 120.\n        # Let's use a simpler M for now, or better, indicator constraints.\n        for t in toys:\n            # (use_toy[t] == 1) => (qty[t] >= 1)\n            model.addConstr((use_toy[t] == 1) >> (qty[t] >= 1),\n                            f\"Link_use_{t}_if_one\")\n            # (use_toy[t] == 0) => (qty[t] == 0)\n            model.addConstr((use_toy[t] == 0) >> (qty[t] == 0),\n                            f\"Link_use_{t}_if_zero\")\n\n        # 3. Conditional Production Constraints\n        # \"If Bright Future Toys manufactures robots, they will not manufacture dolls.\"\n        # This means if use_toy[\"robots\"] = 1, then use_toy[\"dolls\"] = 0 (which implies qty[\"dolls\"] = 0).\n        # A simple way to write this: use_toy[\"robots\"] + use_toy[\"dolls\"] <= 1\n        model.addConstr(use_toy[\"robots\"] + use_toy[\"dolls\"] <= 1,\n                        \"Robots_No_Dolls\")\n        # Alternatively, using indicator:\n        # model.addConstr((use_toy[\"robots\"] == 1) >> (qty[\"dolls\"] == 0), \"Robots_No_Dolls_Indicator\")\n\n        # \"However, if they manufacture model cars, they will also manufacture building blocks.\"\n        # This means if use_toy[\"cars\"] = 1, then use_toy[\"blocks\"] = 1 (which implies qty[\"blocks\"] >= 1).\n        # use_toy[\"blocks\"] >= use_toy[\"cars\"]\n        model.addConstr(use_toy[\"blocks\"] >= use_toy[\"cars\"],\n                        \"Cars_Implies_Blocks\")\n        # Alternatively, using indicator:\n        # model.addConstr((use_toy[\"cars\"] == 1) >> (qty[\"blocks\"] >= 1), \"Cars_Implies_Blocks_Indicator\")\n\n        # 4. Relationship Constraint\n        # \"The number of dolls manufactured cannot exceed the number of model cars manufactured.\"\n        model.addConstr(qty[\"dolls\"] <= qty[\"cars\"], \"Dolls_leq_Cars\")\n\n        # --- Optimize Model ---\n        model.optimize()\n\n        # --- Results ---\n        print(\"-\" * 40)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found!\")\n            print(f\"Maximum Total Profit: ${model.objVal:,.2f}\")\n            print(\"-\" * 40)\n            print(\"Production Quantities:\")\n            types_manufactured = 0\n            for t in toys:\n                qty_val = qty[t].X\n                if qty_val > 0.5:  # Check if quantity is positive (accounting for potential float issues)\n                    print(f\"  {t.capitalize()}: {qty_val:.0f} units\")\n                    types_manufactured += 1\n                else:\n                    print(f\"  {t.capitalize()}: 0 units\")\n            print(\"-\" * 40)\n            print(f\"Total types of toys to manufacture: {types_manufactured}\")\n            print(\"-\" * 40)\n\n            print(\"Resource Utilization:\")\n            plastic_used = sum(plastic_usage[t] * qty[t].X for t in toys)\n            electronics_used = sum(electronics_usage[t] * qty[t].X\n                                   for t in toys)\n            print(f\"  Plastic Used: {plastic_used:.0f} / {max_plastic} units\")\n            print(\n                f\"  Electronic Components Used: {electronics_used:.0f} / {max_electronics} units\"\n            )\n            print(\"-\" * 40)\n\n            print(\"Status of 'Use Toy' Variables (for verification):\")\n            for t in toys:\n                print(\n                    f\"  Manufacture {t.capitalize()} (use_{t}): {use_toy[t].X:.0f}\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists that satisfies all constraints.\"\n            )\n            print(\n                \"Consider reviewing the constraints, especially the conditional ones and resource limits.\"\n            )\n        elif model.status == GRB.UNBOUNDED:\n            print(\n                \"Model is unbounded. This typically means the objective can be improved indefinitely.\"\n            )\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_toy_production_problem()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "B090",
    "description": "A company produces two products (A and B), with a profit of £3 and £5 per unit sold, respectively. Each product must be assembled on a specific machine, requiring 12 minutes of assembly time per unit for product A and 25 minutes per unit for product B. The company's estimated effective machine working time per week is only 30 hours (due to maintenance or malfunctions). Technical constraints mean that for every five units of product A produced, at least two units of product B must be produced.\n\nTry to formulate a model for this problem.",
    "ground_truth": 408.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_new_production_planning():\n    \"\"\"\n    Solves a production planning problem with a ratio constraint\n    to maximize weekly profit.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['A', 'B']\n\n        # Profit (£/unit)\n        profit = {'A': 3, 'B': 5}\n\n        # Assembly time requirements (minutes/unit)\n        assembly_time_req = {'A': 12, 'B': 25}\n\n        # Available assembly time (minutes/week)\n        avail_assembly_time = 30 * 60  # 1800 minutes\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"NewProductionPlanning\")\n\n        # --- Decision Variables ---\n        # N[p]: Number of units of product p produced per week\n        N = model.addVars(products, name=\"Produce\", vtype=GRB.INTEGER, lb=0)\n\n        # --- Objective Function: Maximize Total Profit ---\n        model.setObjective(gp.quicksum(profit[p] * N[p] for p in products),\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Assembly Time Constraint\n        model.addConstr(gp.quicksum(assembly_time_req[p] * N[p]\n                                    for p in products) <= avail_assembly_time,\n                        name=\"AssemblyTimeLimit\")\n\n        # 2. Technical Ratio Constraint: For every 5 units of A, at least 2 units of B\n        # N_B >= (2/5) * N_A  =>  5 * N_B >= 2 * N_A  =>  2 * N_A - 5 * N_B <= 0\n        model.addConstr(2 * N['A'] - 5 * N['B'] <= 0, name=\"RatioConstraint\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Weekly Profit: £{model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Production Quantities (units per week):\")\n            for p in products:\n                print(f\"  Product {p}: {N[p].X:.0f} units\")\n\n            print(\"\\nResource Utilization:\")\n            assembly_time_used = sum(assembly_time_req[p] * N[p].X\n                                     for p in products)\n            print(\n                f\"  Assembly Time Used: {assembly_time_used:.2f} / {avail_assembly_time} minutes \"\n                f\"({(assembly_time_used/avail_assembly_time*100) if avail_assembly_time > 0 else 0:.1f}%)\"\n            )\n\n            print(\"\\nRatio Constraint Check:\")\n            ratio_val = (2 * N['A'].X - 5 * N['B'].X)\n            print(f\"  2*N_A - 5*N_B = {ratio_val:.2f} (Constraint: <= 0)\")\n            if N['A'].X > 0:\n                print(\n                    f\"  Ratio N_B / N_A = {(N['B'].X / N['A'].X):.3f} (Constraint requires >= 2/5 = 0.4)\"\n                )\n            else:\n                print(\"  Ratio N_B / N_A: N/A (N_A = 0)\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and requirements.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"new_production_iis.ilp\")\n            # print(\"IIS written to new_production_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_new_production_planning()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "E105",
    "description": "A company produces two kinds of products. A product of the first type requires 1/4 hours of assembly labor, 1/8 hours of testing, and $1.2 worth of raw materials. A product of the second type requires 1/3 hours of assembly, 1/3 hours of testing, and $0.9 worth of raw materials. Given the current personnel of the company, there can be at most 90 hours of assembly labor and 80 hours of testing each day. Suppose that up to 50 hours of overtime assembly labor can be scheduled, at a cost of $9 per hour. Products of the first and second type have a market value of $9 and $8 respectively. Try to maximize the daily profit of the company. Provide your answer rounded to the nearest dollar.",
    "ground_truth": 3918.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\na1, a2 = 1/4, 1/3\nt1, t2 = 1/8, 1/3\nm1, m2 = 1.2, 0.9\nv1, v2 = 9, 8\nA_max, T_max = 90, 80\nO_max = 50\nc_o = 9\n\n# Decision Variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"x1\")\nx2 = model.addVar(vtype=GRB.INTEGER, name=\"x2\")\no = model.addVar(vtype=GRB.CONTINUOUS, name=\"o\")\n\n# Objective Function\nmodel.setObjective((v1 - m1) * x1 + (v2 - m2) * x2 - c_o * o, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(a1 * x1 + a2 * x2 <= A_max + o, \"Assembly_Constraint\")\nmodel.addConstr(t1 * x1 + t2 * x2 <= T_max, \"Testing_Constraint\")\nmodel.addConstr(o <= O_max, \"Overtime_Constraint\")\n\n# Non-negativity and Integrality Constraints are automatically handled by variable types\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F188",
    "description": "A audio company make two types of headphones: wired headphones and wireless headphones. Two different teams make each type of headphones. The wired team can make at most 100 wired headphones per day and the wireless team can make at most 170 wireless headphones per day. Both teams require use of a shared audio testing machine, and this machine can be used to make a maximum of 150 headphones per day. The profit per wired headphone is $50 and the profit per wireless headphone $20. How many of each headphone should be made to maximize profit?",
    "ground_truth": 6000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nP_w = 50  # Profit per wired headphone\nP_l = 20  # Profit per wireless headphone\nC_w = 100 # Maximum capacity for wired headphones\nC_l = 170 # Maximum capacity for wireless headphones\nC_t = 150 # Maximum capacity for shared audio testing machine\n\n# Variables\nx_w = model.addVar(vtype=GRB.INTEGER, name=\"x_w\", lb=0)\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\", lb=0)\n\n# Objective: Maximize profit\nmodel.setObjective(P_w * x_w + P_l * x_l, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_w <= C_w, \"C1\")\nmodel.addConstr(x_l <= C_l, \"C2\")\nmodel.addConstr(x_w + x_l <= C_t, \"C3\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F164",
    "description": "A flooring company produces engineered hardwood and vinyl planks. Their sales forecasts show an expected demand of at least 20,000 square foot of hardwood and 10,000 square feet of vinyl planks each week. To satisfy a shipping contract, a total of at least 60,000 square feet of flooring much be shipped each week. Due to a labor shortage issue, no more than 50,000 square feet of hardwood and 30,000  square feet of vinyl  can be produced weekly. If a square foot of hardwood flooring yields a profit of $2.5 and a square foot of vinyl planks produces a $3 profit, how many of each type of flooring should be made weekly to maximize the company's profit?",
    "ground_truth": 215000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Define the variables\nx_h = model.addVar(vtype=GRB.INTEGER, name=\"x_h\", lb=0)\nx_v = model.addVar(vtype=GRB.INTEGER, name=\"x_v\", lb=0)\n\n# Set the objective function\nmodel.setObjective(2.5 * x_h + 3 * x_v, GRB.MAXIMIZE)\n\n# Add the constraints\nmodel.addConstr(x_h >= 20000, \"C1\")\nmodel.addConstr(x_v >= 10000, \"C2\")\nmodel.addConstr(x_h + x_v >= 60000, \"C3\")\nmodel.addConstr(x_h <= 50000, \"C4\")\nmodel.addConstr(x_v <= 30000, \"C5\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F000",
    "description": "An office supply company makes two types of printers: color printers and black and white printers. Different sections of the factory with different teams produce each printer. The color printer team can produce at most 20 color printers per day while the black and white printer team can produce at most 30 black and white printers per day. Both teams require use of the same paper tray installing machine and this machine can make at most 35 printers of either type each day. Color printers generate a profit of $200 per printer while black and white printers generate a profit of $70 per printer. How many of each printer should be made to maximize the company's profit?",
    "ground_truth": 5050.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nP_c = 200  # Profit per color printer\nP_b = 70   # Profit per black and white printer\nM_c = 20   # Max color printers per day\nM_b = 30   # Max black and white printers per day\nM_t = 35   # Max printers with machine per day\n\n# Variables\nx_c = model.addVar(vtype=GRB.INTEGER, name=\"x_c\") # Number of color printers\nx_b = model.addVar(vtype=GRB.INTEGER, name=\"x_b\") # Number of black and white printers\n\n# Objective function\nmodel.setObjective(P_c * x_c + P_b * x_b, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_c <= M_c, \"C1\") # Production capacity for color printers\nmodel.addConstr(x_b <= M_b, \"C2\") # Production capacity for black and white printers\nmodel.addConstr(x_c + x_b <= M_t, \"C3\") # Machine capacity\nmodel.addConstr(x_c >= 0, \"C4\") # Non-negativity for color printers\nmodel.addConstr(x_b >= 0, \"C5\") # Non-negativity for black and white printers\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F186",
    "description": "A bakery makes almond and pistachio croissants. An almond croissant requires 5 units of butter and 8 units of flour. A pistachio croissant requires 3 units of butter and 6 units of flour. The bakery has available 600 units of butter and 800 units of flour. Since the almond croissant is more popular, at least 3 times as many almond croissants should be made as pistachio croissants. If making an almond croissant takes 12 minutes and making a pistachio croissant takes 10 minutes, how many of each should be made to minimize the total production time?",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"CroissantProduction\")\n\n# Parameters\nb_a, f_a, t_a = 5, 8, 12\nb_p, f_p, t_p = 3, 6, 10\nB, F = 600, 800\n\n# Variables\nx_a = model.addVar(vtype=GRB.INTEGER, name=\"x_a\")  # Number of almond croissants\nx_p = model.addVar(vtype=GRB.INTEGER, name=\"x_p\")  # Number of pistachio croissants\n\n# Objective: Minimize total production time\nmodel.setObjective(t_a * x_a + t_p * x_p, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(b_a * x_a + b_p * x_p <= B, \"ButterConstraint\")\nmodel.addConstr(f_a * x_a + f_p * x_p <= F, \"FlourConstraint\")\nmodel.addConstr(x_a >= 3 * x_p, \"PopularityConstraint\")\n\n# Non-negativity implied by variable declaration (integer type)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Food & Beverage"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F162",
    "description": "A lighting company makes desk-lamps and night-lamps. There is an expected demand of at least 30 desk-lamps and 50 night-lamps each day. However, due to the size of their factory, they can make at most 150 desk-lamps and 180 night-lamps per day. To satisfy a contract, a minimum of 100 lamps must be made each day. If the profit per desk-lamp sold is $5 and the profit per night-lamp sold is $8, how many lamps of each type should be made to maximize profit?",
    "ground_truth": 2190.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\np_d = 5  # Profit per desk-lamp ($)\np_n = 8  # Profit per night-lamp ($)\nD_d = 30  # Minimum demand for desk-lamps (units)\nD_n = 50  # Minimum demand for night-lamps (units)\nU_d = 150  # Maximum production capacity for desk-lamps (units)\nU_n = 180  # Maximum production capacity for night-lamps (units)\nT = 100  # Minimum total lamps to be produced (units)\n\n# Variables\nx_d = model.addVar(vtype=GRB.INTEGER, name=\"x_d\")\nx_n = model.addVar(vtype=GRB.INTEGER, name=\"x_n\")\n\n# Objective function\nmodel.setObjective(p_d * x_d + p_n * x_n, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x_d >= D_d, \"C1\")\nmodel.addConstr(x_n >= D_n, \"C2\")\nmodel.addConstr(x_d <= U_d, \"C3\")\nmodel.addConstr(x_n <= U_n, \"C4\")\nmodel.addConstr(x_d + x_n >= T, \"C5\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F092",
    "description": "A flooring company produces engineered laminate planks and carpets. The chief marketer reports an expected demand of at least 15,000 square feet of laminate planks and 5,000 square feet of carpets each week. The shipping contract requires a total of at least 50,000 square feet of products each week. However, due to a shortage of raw materials, no more than 40,000 square feet of laminate planks and 20,000 square feet of carpets can be produced weekly. If a square foot of laminate planks produces a $2.1 profit and a square foot of carpets yields a $3.3 profit, how many of each type of product should be made weekly to maximize the company's profit?",
    "ground_truth": 150000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nL_min = 15000\nC_min = 5000\nTotal_min = 50000\nL_max = 40000\nC_max = 20000\nProfit_L = 2.1\nProfit_C = 3.3\n\n# Variables\nx = model.addVar(vtype=GRB.CONTINUOUS, lb=0, ub=L_max, name=\"laminate_planks\")\ny = model.addVar(vtype=GRB.CONTINUOUS, lb=0, ub=C_max, name=\"carpets\")\n\n# Objective function\nmodel.setObjective(Profit_L * x + Profit_C * y, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(x >= L_min, \"C1_LaminateDemand\")\nmodel.addConstr(y >= C_min, \"C2_CarpetDemand\")\nmodel.addConstr(x + y >= Total_min, \"C3_TotalProduction\")\nmodel.addConstr(x <= L_max, \"C4_LaminateCapacity\")\nmodel.addConstr(y <= C_max, \"C5_CarpetCapacity\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F098",
    "description": "A printing company sells math workbooks and English workbooks. To meet demand, they must make at least 40 math workbooks and at least 60 English workbooks. However, they can make at most 140 math workbooks and at most 170 English workbooks. The company has a contract with a school to send at least 200 workbooks of either type. If the profit per math workbook is $15 and the profit per English workbook is $17, how many of each should the company make to maximize profit?",
    "ground_truth": 4990.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\npm = 15  # Profit per math workbook\npe = 17  # Profit per English workbook\ndm_min = 40  # Minimum number of math workbooks\nde_min = 60  # Minimum number of English workbooks\ndm_max = 140  # Maximum number of math workbooks\nde_max = 170  # Maximum number of English workbooks\nc = 200  # Minimum total number of workbooks\n\n# Variables\nxm = model.addVar(vtype=GRB.INTEGER, name=\"xm\")  # Number of math workbooks\nxe = model.addVar(vtype=GRB.INTEGER, name=\"xe\")  # Number of English workbooks\n\n# Objective\nmodel.setObjective(pm * xm + pe * xe, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(xm >= dm_min, \"C1\")  # Minimum math workbooks constraint\nmodel.addConstr(xe >= de_min, \"C2\")  # Minimum English workbooks constraint\nmodel.addConstr(xm <= dm_max, \"C3\")  # Maximum math workbooks constraint\nmodel.addConstr(xe <= de_max, \"C4\")  # Maximum English workbooks constraint\nmodel.addConstr(xm + xe >= c, \"C5\")  # Total workbooks constraint\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F133",
    "description": "A handmade sports equipment manufacturing company makes basketballs and footballs. Basketballs require 5 units of materials and 1 hour to make whereas footballs require 3 units of materials and 2 hours to make. The manufacturing company has available 1500 units of materials and their workers working at max capacity can work for at most 750 hours. Since basketballs sell better, there must be at least three times as many basketballs as footballs but the manufacturing company would like at least 50 footballs. How many of each should the manufacturing company make to maximize the total number of sports equipment produced?",
    "ground_truth": 333.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Parameters\nM = 1500  # Total available units of materials\nH = 750   # Total available hours\nm_b = 5   # Materials required for one basketball\nh_b = 1   # Hours required for one basketball\nm_f = 3   # Materials required for one football\nh_f = 2   # Hours required for one football\nr = 3     # Minimum ratio of basketballs to footballs\nF_min = 50 # Minimum number of footballs\n\n# Variables\nB = model.addVar(vtype=GRB.INTEGER, name=\"B\")  # Number of basketballs\nF = model.addVar(vtype=GRB.INTEGER, name=\"F\")  # Number of footballs\n\n# Objective: Maximize total number of sports equipment produced\nmodel.setObjective(B + F, GRB.MAXIMIZE)\n\n# Constraints\nmodel.addConstr(m_b * B + m_f * F <= M, \"MaterialConstraint\")  # C1\nmodel.addConstr(h_b * B + h_f * F <= H, \"TimeConstraint\")      # C2\nmodel.addConstr(B >= r * F, \"RatioConstraint\")                 # C3\nmodel.addConstr(F >= F_min, \"MinFootballConstraint\")           # C4\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "F177",
    "description": "A new fast food place makes wraps and platters. Each wrap requires 5 units of meat and 3 units of rice. Each platter requires 7 units of meant and 5 units of rice. While each wrap takes 10 minutes to make, each platter takes 8 minutes to make. The fast food place must use at least 3000 units of meat and 2500 units of rice. Since wraps are easier to eat on the go, at least 3 times as many wraps need to be made as platter. How many of each should the fast food place make to minimize the total production time?",
    "ground_truth": 6794.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"FastFoodProduction\")\n\n# Define parameters\nM = 3000  # units of meat required\nR = 2500  # units of rice required\nm_w = 5   # units of meat per wrap\nr_w = 3   # units of rice per wrap\nt_w = 10  # time in minutes to make one wrap\nm_p = 7   # units of meat per platter\nr_p = 5   # units of rice per platter\nt_p = 8   # time in minutes to make one platter\n\n# Define variables\nx = model.addVar(vtype=GRB.INTEGER, name=\"wraps\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"platters\")\n\n# Set objective\nmodel.setObjective(t_w * x + t_p * y, GRB.MINIMIZE)\n\n# Add constraints\nmodel.addConstr(m_w * x + m_p * y >= M, \"MeatRequirement\")\nmodel.addConstr(r_w * x + r_p * y >= R, \"RiceRequirement\")\nmodel.addConstr(x >= 3 * y, \"WrapsAtLeastThreeTimesPlatters\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Food Service"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "A074",
    "description": "A small chocolate shop makes milk chocolate and dark chocolate bars. Milk chocolate bars require 4 units of cocoa and 7 units of milk. Dark chocolate bars require 6 units of cocoa and 3 units of milk. The shop has 2000 units of cocoa and 1750 units of milk available. In addition since milk chocolate sells better, at least 2 times as many milk chocolate bars need to be made as dark chocolate bars.  If making a milk chocolate bar takes 15 minutes and making a dark chocolate bar takes 12 mins, how many of each should the make to minimize total production time?",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": "def optimize_chocolate_production(cocoa_available=2000, milk_available=1750,\n                                  time_milk=15, time_dark=12):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Chocolate_Production_MinTime\")\n\n    # Decision variables: number of milk and dark chocolate bars\n    x = model.addVar(name=\"MilkBars\", vtype=GRB.INTEGER, lb=0)\n    y = model.addVar(name=\"DarkBars\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: minimize total production time\n    model.setObjective(time_milk * x + time_dark * y, GRB.MINIMIZE)\n\n    # Add resource constraints\n    model.addConstr(4 * x + 6 * y <= cocoa_available, \"CocoaConstraint\")\n    model.addConstr(7 * x + 3 * y <= milk_available, \"MilkConstraint\")\n\n    # Add production ratio constraint\n    model.addConstr(x >= 2 * y, \"MilkDarkRatio\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the minimized total time\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_chocolate_production()\n    if min_time is not None:\n        print(f\"Minimum Total Production Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A106",
    "description": "A company make both liquid and foam hand sanitizer. Liquid hand sanitizer requires 40 units of water and 50 units of alcohol. Foam hand sanitizer requires 60 units of water and 40 units of alcohol. The company has available 2000 units of water and 2100 units of alcohol. The number of foam hand sanitizers made must exceed the number of liquid hand sanitizers. In addition, at most 30 liquid hand sanitizers can be made. If each liquid hand sanitizer can clean 30 hands and each foam hand sanitizer can clean 20 hands, how many of each should the company make to maximize the number of hands that can be cleaned?",
    "ground_truth": 970.0,
    "formulation": null,
    "correct_program": "def optimize_hand_sanitizer_production(\n    water_available=2000,\n    alcohol_available=2100,\n    max_liquid=30\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"SanitizerProduction\")\n\n    # Decision variables: number of liquid and foam sanitizers\n    L = model.addVar(vtype=GRB.INTEGER, name=\"Liquid\")\n    F = model.addVar(vtype=GRB.INTEGER, name=\"Foam\")\n\n    # Set objective: maximize total cleaned hands\n    model.setObjective(30 * L + 20 * F, GRB.MAXIMIZE)\n\n    # Add resource constraints\n    model.addConstr(40 * L + 60 * F <= water_available, \"WaterLimit\")\n    model.addConstr(50 * L + 40 * F <= alcohol_available, \"AlcoholLimit\")\n\n    # Add production constraints\n    model.addConstr(F >= L + 1, \"FoamExceedsLiquid\")\n    model.addConstr(L <= max_liquid, \"LiquidMax\")\n    model.addConstr(L >= 0, \"LiquidNonNeg\")\n    model.addConstr(F >= 0, \"FoamNonNeg\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum number of hands cleaned\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_hands_cleaned = optimize_hand_sanitizer_production()\n    if max_hands_cleaned is not None:\n        print(f\"Maximum Number of Hands Cleaned: {max_hands_cleaned}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "A051",
    "description": "A bakery makes fiber supplemented brownies and lemon squares. Each brownie requires 5 units of chocolate mix and 4 units of fiber. Each lemon square requires 7 units of lemon mix and 6 units of fiber. Lemon squares sell much faster and thus the number of lemon squares made must be larger than the number of brownies made. However, to please all customers, at least 40% of the items made must be brownies. If the bakery has 2500 units of chocolate mix and 3300 units of lemon mix, how many of each should be made to minimize the total amount of fiber needed?",
    "ground_truth": 26.0,
    "formulation": null,
    "correct_program": "def optimize_bakery_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"BakeryProduction\")\n\n    # Decision variables: number of brownies and lemon squares\n    B = m.addVar(name=\"Brownies\", vtype=GRB.INTEGER, lb=0)\n    L = m.addVar(name=\"LemonSquares\", vtype=GRB.INTEGER, lb=0)\n\n    # Set the objective: minimize total fiber\n    m.setObjective(4 * B + 6 * L, GRB.MINIMIZE)\n\n    # Add resource constraints\n    m.addConstr(5 * B <= 2500, name=\"ChocolateConstraint\")\n    m.addConstr(7 * L <= 3300, name=\"LemonConstraint\")\n\n    # Lemon squares must be more than brownies\n    # Note: Gurobi does not support strict inequalities directly.\n    # To model L > B, we can use L >= B + 1\n    m.addConstr(L >= B + 1, name=\"L_greater_than_B\")\n\n    # At least 40% of total items are brownies\n    # The original constraint: 3B >= 2L\n    m.addConstr(3 * B >= 2 * L, name=\"BrowniePercentage\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal fiber usage\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_fiber = optimize_bakery_production()\n    if min_fiber is not None:\n        print(f\"Minimum Total Fiber Usage: {min_fiber}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "IP",
        "industry_sector": "Food & Beverage"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "F210",
    "description": "A small chocolate shop makes milk chocolate and dark chocolate bars. Milk chocolate bars require 4 units of cocoa and 7 units of milk. Dark chocolate bars require 6 units of cocoa and 3 units of milk. The shop has 2000 units of cocoa and 1750 units of milk available. In addition since milk chocolate sells better, at least 2 times as many milk chocolate bars need to be made as dark chocolate bars.  If making a milk chocolate bar takes 15 minutes and making a dark chocolate bar takes 12 mins, how many of each should the make to minimize total production time?",
    "ground_truth": 0.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"ChocolateProduction\")\n\n# Parameters\nCm = 4  # units of cocoa per milk chocolate bar\nMm = 7  # units of milk per milk chocolate bar\nCd = 6  # units of cocoa per dark chocolate bar\nMd = 3  # units of milk per dark chocolate bar\nTm = 15  # minutes to make a milk chocolate bar\nTd = 12  # minutes to make a dark chocolate bar\nAc = 2000  # units of available cocoa\nAm = 1750  # units of available milk\n\n# Variables\nxm = model.addVar(vtype=GRB.INTEGER, name=\"xm\")  # Number of milk chocolate bars\nxd = model.addVar(vtype=GRB.INTEGER, name=\"xd\")  # Number of dark chocolate bars\n\n# Objective: Minimize total production time\nmodel.setObjective(Tm * xm + Td * xd, GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(Cm * xm + Cd * xd <= Ac, \"CocoaConstraint\")\nmodel.addConstr(Mm * xm + Md * xd <= Am, \"MilkConstraint\")\nmodel.addConstr(xm >= 2 * xd, \"ProductionRatioConstraint\")\nmodel.addConstr(xm >= 0, \"NonNegativityConstraintXm\")\nmodel.addConstr(xd >= 0, \"NonNegativityConstraintXd\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "B087",
    "description": "A company uses two machines (Machine 1 and Machine 2) to produce two types of products (liquid fertilizer and solid fertilizer). To produce one unit of liquid fertilizer, it takes 50 minutes on Machine 1 and 30 minutes on Machine 2. To produce one unit of solid fertilizer, it takes 24 minutes on Machine 1 and 33 minutes on Machine 2. At the beginning of the week, there are 30 units of liquid fertilizer and 90 units of solid fertilizer in inventory. The available processing time for Machine 1 this week is expected to be 40 hours, and for Machine 2 it is expected to be 35 hours. The demand for liquid fertilizer this week is estimated at 75 units, and for solid fertilizer at 95 units. The company's policy is to maximize the total number of units of liquid fertilizer and solid fertilizer in inventory at the end of the week.\n\nFormulate a model for this problem.",
    "ground_truth": 1.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_fertilizer_production():\n    \"\"\"\n    Solves the fertilizer production planning problem to maximize\n    the total ending inventory for the week.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['Liquid', 'Solid']\n        machines = [1, 2]\n\n        # Time requirements (minutes/unit)\n        # time_req[product][machine]\n        time_req = {'Liquid': {1: 50, 2: 30}, 'Solid': {1: 24, 2: 33}}\n\n        # Available machine time (minutes/week)\n        avail_machine_time = {\n            1: 40 * 60,  # 2400 minutes\n            2: 35 * 60  # 2100 minutes\n        }\n\n        # Initial inventory (units)\n        initial_inventory = {'Liquid': 30, 'Solid': 90}\n\n        # Demand (units/week)\n        demand = {'Liquid': 75, 'Solid': 95}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"FertilizerProduction\")\n\n        # --- Decision Variables ---\n        # Produce[p]: Number of units of product p produced this week\n        Produce = model.addVars(products,\n                                name=\"Produce\",\n                                vtype=GRB.INTEGER,\n                                lb=0)\n\n        # InvEnd[p]: Inventory of product p at the end of the week\n        # We must ensure it's non-negative, which implicitly forces demand to be met.\n        InvEnd = model.addVars(products,\n                               name=\"InvEnd\",\n                               vtype=GRB.INTEGER,\n                               lb=0)\n\n        # --- Objective Function: Maximize Total Ending Inventory ---\n        model.setObjective(gp.quicksum(InvEnd[p] for p in products),\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Time Constraints\n        for m in machines:\n            model.addConstr(gp.quicksum(time_req[p][m] * Produce[p]\n                                        for p in products)\n                            <= avail_machine_time[m],\n                            name=f\"Machine{m}_TimeLimit\")\n\n        # 2. Inventory Balance Constraints\n        # Ending Inventory = Initial Inventory + Production - Demand\n        for p in products:\n            model.addConstr(InvEnd[p] == initial_inventory[p] + Produce[p] -\n                            demand[p],\n                            name=f\"InventoryBalance_{p}\")\n\n        # Note: The constraint InvEnd[p] >= 0 implicitly handles the demand requirement.\n        # If demand cannot be met, the problem will be infeasible.\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Total Ending Inventory: {model.ObjVal:.0f} units\")\n\n            print(\"\\nProduction Quantities (units per week):\")\n            for p in products:\n                print(f\"  Product {p}: {Produce[p].X:.0f} units\")\n\n            print(\"\\nEnding Inventory (units):\")\n            for p in products:\n                print(f\"  Product {p}: {InvEnd[p].X:.0f} units\")\n\n            print(\"\\nResource Utilization:\")\n            for m in machines:\n                time_used = sum(time_req[p][m] * Produce[p].X\n                                for p in products)\n                print(\n                    f\"  Machine {m} Time Used: {time_used:.2f} / {avail_machine_time[m]} minutes \"\n                    f\"({(time_used/avail_machine_time[m]*100) if avail_machine_time[m] > 0 else 0:.1f}%)\"\n                )\n\n            print(\"\\nDemand Fulfillment Check:\")\n            for p in products:\n                available = initial_inventory[p] + Produce[p].X\n                print(\n                    f\"  Product {p}: Available={available:.0f}, Demand={demand[p]}\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints, demand, and available time.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"fertilizer_production_iis.ilp\")\n            # print(\"IIS written to fertilizer_production_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_fertilizer_production()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 18,
    "retrieved_insights": []
  },
  {
    "task_id": "A084",
    "description": "A drug company is making allergy pills and fever reducing pills in two factories, factory 1 and factory 2. Factory 1 produces 20 allergy pills and 15 fever reducing pills per hour. Factory 2 produces 10 allergy pills and 30 fever reducing pills per hour.  Factory 1 is much more efficient and only requires 20 units of a rare compound while factory 2 requires 30 units of a rare compound. The company only has available 1000 units of the rare compound. If the company must make at least 700 allergy pills and 600 fever reducing pills, how many hours should each factory be run to minimize the total time needed?",
    "ground_truth": 27.5,
    "formulation": null,
    "correct_program": "def optimize_factory_hours():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Factory_Production_MinHours\")\n\n    # Decision variables: hours to run each factory\n    x1 = m.addVar(name=\"x1\", lb=0)\n    x2 = m.addVar(name=\"x2\", lb=0)\n    max_hour = m.addVar(name=\"max_hour\", lb=0)\n\n    # Set the objective: minimize total hours\n    m.setObjective(max_hour, GRB.MINIMIZE)\n\n    # Add production constraints\n    m.addConstr(20 * x1 + 10 * x2 >= 700, name=\"Allergy_Pills\")\n    m.addConstr(15 * x1 + 30 * x2 >= 600, name=\"Fever_Pills\")\n\n    # Add resource constraint\n    m.addConstr(20 * x1 + 30 * x2 <= 1000, name=\"Rare_Compound\")\n\n    # Add maximum hour constraint\n    m.addConstr(max_hour >= x1, name=\"Max_Hour_x1\")\n    m.addConstr(max_hour >= x2, name=\"Max_Hour_x2\")\n    \n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total hours\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nprint(optimize_factory_hours())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "A236",
    "description": "A clinical firm has two factories, a northern factory and a western factory, where they make expensive anti-itch injections and topical cream. Every hour, the northern factory makes 800 g of anti-itch injections and 700 g of topical cream. Every hour, the western factory makes 650 g of anti-itch injections and 750 g of topical cream. The northern factory requires 40 units of plastic per hour while the western factory requires 35 units of plastic to manufacture the packaging. The clinical firm has available 60,000 units of plastic. Further, they must make at least 800,000 g of anti-itch injections and 700,000 g of topical cream. How many hours should each factory be run to minimize the total time needed?",
    "ground_truth": 551.7241379310345,
    "formulation": null,
    "correct_program": "def optimize_factory_hours(\n    injection_target=800000,\n    cream_target=700000,\n    plastic_limit=60000,\n    rate_injection_north=800,\n    rate_cream_north=700,\n    rate_injection_west=650,\n    rate_cream_west=750,\n    plastic_north=40,\n    plastic_west=35\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Factory_Production_MinHours\")\n\n    # Decision variables: hours of operation for each factory\n    x_N = model.addVar(name=\"x_N\", lb=0)\n    x_W = model.addVar(name=\"x_W\", lb=0)\n    max_hour = model.addVar(name=\"max_hour\", lb=0)\n\n    # Set the objective: minimize total hours\n    model.setObjective(max_hour, GRB.MINIMIZE)\n\n    # Add constraints\n    # Anti-itch injections production constraint\n    model.addConstr(\n        rate_injection_north * x_N + rate_injection_west * x_W >= injection_target,\n        name=\"InjectionRequirement\"\n    )\n\n    # Topical cream production constraint\n    model.addConstr(\n        rate_cream_north * x_N + rate_cream_west * x_W >= cream_target,\n        name=\"CreamRequirement\"\n    )\n\n    # Plastic usage constraint\n    model.addConstr(\n        plastic_north * x_N + plastic_west * x_W <= plastic_limit,\n        name=\"PlasticLimit\"\n    )\n    \n    # Maximum hours constraint\n    model.addConstr(max_hour >= x_N, name=\"MaxHour_N\")\n    model.addConstr(max_hour >= x_W, name=\"MaxHour_W\")\n    \n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_hours = model.objVal\n        return total_hours\n    else:\n        return None\n    \n# Example usage\nprint(optimize_factory_hours())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 2,
    "retrieved_insights": []
  },
  {
    "task_id": "B078",
    "description": "A furniture factory needs to decide how many tables, chairs, and bookshelves to produce in order to maximize its profit. The factory can sell each table for $200, each chair for $50, and each bookshelf for $150. The manufacturing costs for each table, chair, and bookshelf are $120, $20, and $90 respectively. The profit is the difference between the selling price and the manufacturing cost. Each table, chair, and bookshelf occupy 5, 2, and 3 square meters of warehouse space respectively. Due to limited warehouse space, the total space cannot exceed 500 square meters. In addition, due to market demand, the factory needs to produce at least 10 tables and 20 bookshelves. Finally, the total number of items produced by the factory cannot exceed 200.",
    "ground_truth": 9800.0,
    "formulation": null,
    "correct_program": "def optimize_furniture_factory():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Furniture_Production\")\n\n    # Decision variables\n    T = m.addVar(vtype=GRB.INTEGER, name=\"Tables\", lb=10)  # at least 10 tables\n    C = m.addVar(vtype=GRB.INTEGER, name=\"Chairs\", lb=0)\n    B = m.addVar(vtype=GRB.INTEGER, name=\"Bookshelves\",\n                 lb=20)  # at least 20 bookshelves\n\n    # Set the objective: maximize profit\n    profit = 80 * T + 30 * C + 60 * B\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Warehouse space constraint\n    m.addConstr(5 * T + 2 * C + 3 * B <= 500, \"Space\")\n    # Total production limit\n    m.addConstr(T + C + B <= 200, \"TotalItems\")\n    # Demand constraints are already enforced via variable lower bounds\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_furniture_factory()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 17,
    "retrieved_insights": []
  },
  {
    "task_id": "A226",
    "description": "A research group is making fabric and plastic using two methods, method A and method B. Method A produces 25 units of fabric and 14 units of plastic per hour. Method B produces 45 units of fabric and 25 units of plastic per hour. Method A requires 60 units of a special element while method B requires 65 units of the same special element. The research group has available 3500 units of the special element and must make at least 1400 units of fabric and 1000 units of plastic. How many of each method should be executed to minimize the total time needed?",
    "ground_truth": 40.0,
    "formulation": null,
    "correct_program": "def optimize_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"fabric_plastic_production\")\n\n    # Decision variables: hours for Method A and Method B\n    x = m.addVar(name=\"MethodA_hours\", lb=0)\n    y = m.addVar(name=\"MethodB_hours\", lb=0)\n\n    # Set the objective: minimize total hours\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Fabric constraint\n    m.addConstr(25 * x + 45 * y >= 1400, name=\"Fabric\")\n    # Plastic constraint\n    m.addConstr(14 * x + 25 * y >= 1000, name=\"Plastic\")\n    # Special element constraint\n    m.addConstr(60 * x + 65 * y <= 3500, name=\"SpecialElement\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total time\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_production()\n    if min_time is not None:\n        print(f\"Minimum Total Production Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B092",
    "description": "A dairy processing plant uses milk to produce two dairy products, \\( A_{1} \\) and \\( A_{2} \\). One barrel of milk can be processed into 3 kg of \\( A_{1} \\) in 12 hours on Type A equipment or into 4 kg of \\( A_{2} \\) in 8 hours on Type B equipment. According to market demand, all produced \\( A_{1} \\) and \\( A_{2} \\) can be sold. The profit is 24 yuan per kilogram of \\( A_{1} \\) and 16 yuan per kilogram of \\( A_{2} \\). The processing plant can get a daily supply of 50 barrels of milk, with a total of 480 hours of labor time available from regular workers each day. The Type A equipment can process up to 100 kg of \\( A_{1} \\) per day, while the processing capacity of Type B equipment is not limited. Formulate a production plan for the plant to maximize daily profit.",
    "ground_truth": 3360.0,
    "formulation": null,
    "correct_program": "def optimize_dairy_production(milk_barrels=50,\n                              max_hours=480,\n                              max_A1=100,\n                              profit_A1=24,\n                              profit_A2=16):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Dairy_Production_Maximization\")\n\n    # Decision variables\n    x_A = model.addVar(name=\"A1_kg\", lb=0, vtype=GRB.CONTINUOUS)\n    x_B = model.addVar(name=\"A2_kg\", lb=0, vtype=GRB.CONTINUOUS)\n\n    # Set objective: maximize profit\n    model.setObjective(profit_A1 * x_A + profit_A2 * x_B, GRB.MAXIMIZE)\n\n    # Constraints\n\n    # Milk supply constraint\n    # (x_A / 3) + (x_B / 4) <= total barrels\n    model.addConstr((x_A / 3) + (x_B / 4) <= milk_barrels, name=\"MilkSupply\")\n\n    # Processing time constraint\n    # 4 * x_A + 2 * x_B <= total hours\n    model.addConstr(4 * x_A + 2 * x_B <= max_hours, name=\"ProcessingTime\")\n\n    # Capacity constraint for A1\n    model.addConstr(x_A <= max_A1, name=\"A1Capacity\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":  # pragma: no cover\n    result = optimize_dairy_production()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B066",
    "description": "The market demand for products I and II is as follows: Product I requires 10,000 units per month from January to April, 30,000 units per month from May to September, and 100,000 units per month from October to December. Product II requires 15,000 units per month from March to September and 50,000 units per month during other months. The cost of producing these two products at a certain factory is as follows: Product I costs 5 yuan per unit to produce from January to May, and 4.50 yuan per unit from June to December; Product II costs 8 yuan per unit to produce from January to May, and 7 yuan per unit from June to December. The factory's combined production capacity for both products should not exceed 120,000 units per month. Product I has a volume of 0.2 cubic meters per unit, Product II has a volume of 0.4 cubic meters per unit, and the factory's warehouse capacity is 15,000 cubic meters. If the factory's warehouse space is insufficient, external warehouse space can be rented. Using the factory’s own warehouse costs 1 yuan per cubic meter per month, while renting an external warehouse increases this cost to 1.5 yuan per cubic meter per month. Given that the initial inventory of both products at the beginning of July is zero, how should production be scheduled from July to December to minimize the total production and inventory costs while meeting market demand?",
    "ground_truth": 3120000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_production_inventory_planning():\n    \"\"\"\n    Solves a multi-period production and inventory planning problem\n    to minimize total production and inventory costs.\n    \"\"\"\n    try:\n        # --- Data ---\n        products = ['ProdI', 'ProdII']\n        # Months: July (0) to December (5)\n        months = list(range(6))\n        month_names = ['Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\n        # Demand (units/month) for ProdI, ProdII\n        demand_data = {\n            'ProdI': [30000, 30000, 30000, 100000, 100000, 100000],  # Jul-Dec\n            'ProdII': [15000, 15000, 15000, 50000, 50000,\n                       50000]  # Jul-Dec (Mar-Sep is 15k, other is 50k)\n        }\n\n        # Production cost (yuan/unit) for ProdI, ProdII\n        # ProdI: Jan-May 5, Jun-Dec 4.5\n        # ProdII: Jan-May 8, Jun-Dec 7\n        production_cost_data = {\n            'ProdI': [4.50] * 6,  # Jul-Dec\n            'ProdII': [7.00] * 6  # Jul-Dec\n        }\n\n        max_combined_production_capacity = 120000  # units/month\n\n        product_volume = {'ProdI': 0.2, 'ProdII': 0.4}  # m^3/unit\n\n        factory_warehouse_capacity = 15000  # m^3\n        factory_warehouse_cost = 1.0  # yuan/m^3/month\n        external_warehouse_cost = 1.5  # yuan/m^3/month\n\n        initial_inventory = {'ProdI': 0, 'ProdII': 0}  # units at start of July\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ProductionInventoryOptimization\")\n\n        # --- Decision Variables ---\n        # Produce[p,t]: units of product p produced in month t\n        produce_vars = model.addVars(products,\n                                     months,\n                                     name=\"Produce\",\n                                     lb=0.0,\n                                     vtype=GRB.INTEGER)\n\n        # InvFact[p,t]: units of product p in factory inventory at end of month t\n        inv_fact_vars = model.addVars(products,\n                                      months,\n                                      name=\"InvFact\",\n                                      lb=0.0,\n                                      vtype=GRB.INTEGER)\n\n        # InvExt[p,t]: units of product p in external inventory at end of month t\n        inv_ext_vars = model.addVars(products,\n                                     months,\n                                     name=\"InvExt\",\n                                     lb=0.0,\n                                     vtype=GRB.INTEGER)\n\n        # --- Objective Function: Minimize Total Costs ---\n        total_production_cost = gp.quicksum(\n            production_cost_data[p][t] * produce_vars[p, t] for p in products\n            for t in months)\n\n        total_factory_inv_cost = gp.quicksum(\n            factory_warehouse_cost * product_volume[p] * inv_fact_vars[p, t]\n            for p in products for t in months)\n\n        total_external_inv_cost = gp.quicksum(\n            external_warehouse_cost * product_volume[p] * inv_ext_vars[p, t]\n            for p in products for t in months)\n\n        model.setObjective(\n            total_production_cost + total_factory_inv_cost +\n            total_external_inv_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        for t in months:\n            # 1. Combined Production Capacity Constraint\n            model.addConstr(gp.quicksum(produce_vars[p, t] for p in products)\n                            <= max_combined_production_capacity,\n                            name=f\"ProdCap_Month{t}\")\n\n            # 2. Factory Warehouse Capacity Constraint\n            model.addConstr(gp.quicksum(product_volume[p] * inv_fact_vars[p, t]\n                                        for p in products)\n                            <= factory_warehouse_capacity,\n                            name=f\"FactWHCap_Month{t}\")\n\n            for p in products:\n                # 3. Inventory Balance Constraint\n                previous_total_inventory = initial_inventory[\n                    p] if t == 0 else (inv_fact_vars[p, t - 1] +\n                                       inv_ext_vars[p, t - 1])\n\n                model.addConstr(\n                    inv_fact_vars[p, t] +\n                    inv_ext_vars[p, t] == previous_total_inventory +\n                    produce_vars[p, t] - demand_data[p][t],\n                    name=f\"InvBalance_{p}_Month{t}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production and inventory plan found.\")\n            print(\n                f\"Minimum Total Cost (Production + Inventory): {model.ObjVal:.2f} Yuan\"\n            )\n\n            print(\"\\nMonthly Production Schedule (units):\")\n            print(f\"{'Month':<5} | {'Product I':<12} | {'Product II':<12}\")\n            print(\"-\" * 35)\n            for t in months:\n                print(\n                    f\"{month_names[t]:<5} | {produce_vars['ProdI',t].X:<12.2f} | {produce_vars['ProdII',t].X:<12.2f}\"\n                )\n\n            print(\"\\nEnd-of-Month Inventory Levels (units):\")\n            print(\n                f\"{'Month':<5} | {'ProdI Fact':<12} | {'ProdI Ext':<12} | {'ProdII Fact':<12} | {'ProdII Ext':<12} | {'Fact Vol':<10} | {'Ext Vol':<10}\"\n            )\n            print(\"-\" * 85)\n            for t in months:\n                vol_fact = product_volume['ProdI'] * inv_fact_vars[\n                    'ProdI', t].X + product_volume['ProdII'] * inv_fact_vars[\n                        'ProdII', t].X\n                vol_ext = product_volume['ProdI'] * inv_ext_vars[\n                    'ProdI', t].X + product_volume['ProdII'] * inv_ext_vars[\n                        'ProdII', t].X\n                print(\n                    f\"{month_names[t]:<5} | \"\n                    f\"{inv_fact_vars['ProdI',t].X:<12.2f} | {inv_ext_vars['ProdI',t].X:<12.2f} | \"\n                    f\"{inv_fact_vars['ProdII',t].X:<12.2f} | {inv_ext_vars['ProdII',t].X:<12.2f} | \"\n                    f\"{vol_fact:<10.2f} | {vol_ext:<10.2f}\")\n\n            print(\n                f\"\\nFactory Warehouse Capacity: {factory_warehouse_capacity} m^3\"\n            )\n\n            total_prod_cost_val = sum(production_cost_data[p][t] *\n                                      produce_vars[p, t].X for p in products\n                                      for t in months)\n            total_fact_inv_cost_val = sum(\n                factory_warehouse_cost * product_volume[p] *\n                inv_fact_vars[p, t].X for p in products for t in months)\n            total_ext_inv_cost_val = sum(\n                external_warehouse_cost * product_volume[p] *\n                inv_ext_vars[p, t].X for p in products for t in months)\n            print(f\"\\nCost Breakdown:\")\n            print(f\"  Total Production Cost: {total_prod_cost_val:.2f} Yuan\")\n            print(\n                f\"  Total Factory Inventory Cost: {total_fact_inv_cost_val:.2f} Yuan\"\n            )\n            print(\n                f\"  Total External Inventory Cost: {total_ext_inv_cost_val:.2f} Yuan\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and data for contradictions.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"prod_inv_iis.ilp\")\n            # print(\"IIS written to prod_inv_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_production_inventory_planning()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B030",
    "description": "A factory produces three types of products, I, II, and III. Each product requires two processing stages, A and B. It is assumed that the factory has two types of equipment to complete the A processing stage, denoted as A1 and A2; and two types of equipment to complete the B processing stage, denoted as B1 and B2. Product I can be processed on any type of A equipment, but for the B processing stage, it can only be processed on B1 equipment; Product III can only be processed on A2 and B2 equipment. The processing time per piece, raw material cost, sales price of products, effective machine hours for various equipment, and costs of equipment at full capacity are given in Table 1-18. The requirement is to arrange the optimal production plan so that the factory's profit is maximized.\n\nTable 1-18\n| Equipment   | Product I | Product II | Product III | Effective Machine Hours | Cost of Equipment at Full Capacity (Yuan) |\n|-------------|-----------|------------|-------------|------------------------|-------------------------------------------|\n| A1          | 5         | 10         |             | 10000                 | 321                                       |\n| A2          | 7         | 9          | 12          | 4000                  | 250                                       |\n| B1          | 6         | 8          |             | 7000                  | 783                                       |\n| B2          | 4         |            | 11          | 4000                  | 200                                       |\n| B3          | 7         |            |             |                       |                                           |\n| Raw Material Cost (Yuan/Piece) | 0.25      | 0.35       | 0.50       |                        |                                           |\n| Unit Price (Yuan/Piece)        | 1.25      | 2.00       | 2.80       |                        |                                           |",
    "ground_truth": 712.875,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_factory_production_revised():\n    \"\"\"\n    Solves the revised factory production planning problem to maximize profit.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"FactoryProductionOptimizationRevised\")\n\n        # --- Data ---\n        # Processing times (hours/piece)\n        proc_times = {\n            ('I', 'A1'): 5,\n            ('I', 'A2'): 7,\n            ('II', 'A1'): 10,\n            ('II', 'A2'): 9,\n            ('III', 'A2'): 12,\n            ('I', 'B1'): 6,\n            ('II', 'B1'): 8,\n            ('III', 'B2'): 11\n        }\n\n        # Effective machine hours (capacity)\n        capacities = {'A1': 10000, 'A2': 4000, 'B1': 7000, 'B2': 4000}\n\n        # Operating costs at full capacity (Yuan)\n        ocfc = {'A1': 321, 'A2': 250, 'B1': 783, 'B2': 200}\n\n        # Variable operating costs per hour (Yuan/hr)\n        # It's good practice to calculate this precisely.\n        voc = {\n            m: ocfc[m] / capacities[m] if capacities[m] > 0 else 0\n            for m in capacities\n        }\n\n        # Raw material costs (Yuan/piece)\n        rmc = {'I': 0.25, 'II': 0.35, 'III': 0.50}\n\n        # Unit sale prices (Yuan/piece)\n        sp = {'I': 1.25, 'II': 2.00, 'III': 2.80}\n\n        products = ['I', 'II', 'III']\n\n        # --- Decision Variables ---\n        # X_p: Total pieces of product p to produce\n        X = model.addVars(products, name=\"X\", lb=0.0, vtype=GRB.INTEGER)\n\n        # x_pm: Quantity of product p processed on specific machine m, based on allowed routes\n        # Process A variables\n        x_IA1 = model.addVar(name=\"x_I_A1\", lb=0.0, vtype=GRB.INTEGER)\n        x_IA2 = model.addVar(name=\"x_I_A2\", lb=0.0, vtype=GRB.INTEGER)\n        x_IIA1 = model.addVar(name=\"x_II_A1\", lb=0.0, vtype=GRB.INTEGER)\n        x_IIA2 = model.addVar(name=\"x_II_A2\", lb=0.0, vtype=GRB.INTEGER)\n        x_IIIA2 = model.addVar(name=\"x_III_A2\", lb=0.0,\n                               vtype=GRB.INTEGER)  # Product III only on A2\n\n        # Process B variables\n        x_IB1 = model.addVar(name=\"x_I_B1\", lb=0.0,\n                             vtype=GRB.INTEGER)  # Product I only on B1\n        x_IIB1 = model.addVar(name=\"x_II_B1\", lb=0.0,\n                              vtype=GRB.INTEGER)  # Product II only on B1\n        x_IIIB2 = model.addVar(name=\"x_III_B2\", lb=0.0,\n                               vtype=GRB.INTEGER)  # Product III only on B2\n\n        # --- Objective Function: Maximize Profit ---\n        # Profit = Total Revenue - Total Raw Material Cost - Total Variable Operating Cost\n\n        total_revenue = gp.quicksum(sp[p] * X[p] for p in products)\n        total_rmc = gp.quicksum(rmc[p] * X[p] for p in products)\n\n        # Variable operating costs for each machine\n        op_cost_A1 = (proc_times[('I', 'A1')] * x_IA1 +\n                      proc_times[('II', 'A1')] * x_IIA1) * voc['A1']\n        op_cost_A2 = (proc_times[('I', 'A2')] * x_IA2 +\n                      proc_times[('II', 'A2')] * x_IIA2 +\n                      proc_times[('III', 'A2')] * x_IIIA2) * voc['A2']\n        op_cost_B1 = (proc_times[('I', 'B1')] * x_IB1 +\n                      proc_times[('II', 'B1')] * x_IIB1) * voc['B1']\n        op_cost_B2 = (proc_times[('III', 'B2')] * x_IIIB2) * voc['B2']\n\n        total_variable_op_cost = op_cost_A1 + op_cost_A2 + op_cost_B1 + op_cost_B2\n\n        profit = total_revenue - total_rmc - total_variable_op_cost\n        model.setObjective(profit, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Capacity Constraints\n        model.addConstr(\n            proc_times[('I', 'A1')] * x_IA1 + proc_times[('II', 'A1')] * x_IIA1\n            <= capacities['A1'], \"Cap_A1\")\n        model.addConstr(\n            proc_times[('I', 'A2')] * x_IA2 +\n            proc_times[('II', 'A2')] * x_IIA2 +\n            proc_times[('III', 'A2')] * x_IIIA2 <= capacities['A2'], \"Cap_A2\")\n        model.addConstr(\n            proc_times[('I', 'B1')] * x_IB1 + proc_times[('II', 'B1')] * x_IIB1\n            <= capacities['B1'], \"Cap_B1\")\n        model.addConstr(proc_times[('III', 'B2')] * x_IIIB2\n                        <= capacities['B2'], \"Cap_B2\")  # Only Prod III uses B2\n\n        # 2. Production Flow Conservation (linking total product X_p to machine allocations)\n        # Product I\n        model.addConstr(\n            x_IA1 + x_IA2 == X['I'],\n            \"Flow_I_A_Total\")  # Sum of A processing for I = Total I\n        model.addConstr(\n            x_IB1 == X['I'],\n            \"Flow_I_B_Total\")  # B processing for I (only on B1) = Total I\n\n        # Product II\n        model.addConstr(\n            x_IIA1 + x_IIA2 == X['II'],\n            \"Flow_II_A_Total\")  # Sum of A processing for II = Total II\n        model.addConstr(\n            x_IIB1 == X['II'],\n            \"Flow_II_B_Total\")  # B processing for II (only on B1) = Total II\n\n        # Product III\n        model.addConstr(x_IIIA2 == X['III'], \"Flow_III_A_Total\"\n                        )  # A processing for III (only on A2) = Total III\n        model.addConstr(x_IIIB2 == X['III'], \"Flow_III_B_Total\"\n                        )  # B processing for III (only on B2) = Total III\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Profit: {model.objVal:.2f} Yuan\")\n            print(\"\\nTotal pieces of each product to produce:\")\n            for p in products:\n                print(f\"  Product {p}: {X[p].X:.2f} pieces\")\n\n            print(\"\\nProduction allocation (pieces on each machine):\")\n            print(\"  Process A:\")\n            if x_IA1.X > 1e-6:\n                print(f\"    Product I on A1 (x_I_A1): {x_IA1.X:.2f}\")\n            if x_IA2.X > 1e-6:\n                print(f\"    Product I on A2 (x_I_A2): {x_IA2.X:.2f}\")\n            if x_IIA1.X > 1e-6:\n                print(f\"    Product II on A1 (x_II_A1): {x_IIA1.X:.2f}\")\n            if x_IIA2.X > 1e-6:\n                print(f\"    Product II on A2 (x_II_A2): {x_IIA2.X:.2f}\")\n            if x_IIIA2.X > 1e-6:\n                print(f\"    Product III on A2 (x_III_A2): {x_IIIA2.X:.2f}\")\n\n            print(\"  Process B:\")\n            if x_IB1.X > 1e-6:\n                print(f\"    Product I on B1 (x_I_B1): {x_IB1.X:.2f}\")\n            if x_IIB1.X > 1e-6:\n                print(f\"    Product II on B1 (x_II_B1): {x_IIB1.X:.2f}\")\n            if x_IIIB2.X > 1e-6:\n                print(f\"    Product III on B2 (x_III_B2): {x_IIIB2.X:.2f}\")\n\n            print(\n                \"\\nMachine Utilization (Hours Used / Capacity | % Utilization):\"\n            )\n            hours_A1 = proc_times.get(\n                ('I', 'A1'), 0) * x_IA1.X + proc_times.get(\n                    ('II', 'A1'), 0) * x_IIA1.X\n            hours_A2 = proc_times.get(\n                ('I', 'A2'), 0) * x_IA2.X + proc_times.get(\n                    ('II', 'A2'), 0) * x_IIA2.X + proc_times.get(\n                        ('III', 'A2'), 0) * x_IIIA2.X\n            hours_B1 = proc_times.get(\n                ('I', 'B1'), 0) * x_IB1.X + proc_times.get(\n                    ('II', 'B1'), 0) * x_IIB1.X\n            hours_B2 = proc_times.get(('III', 'B2'), 0) * x_IIIB2.X\n\n            util_A1 = (hours_A1 / capacities['A1'] *\n                       100) if capacities['A1'] > 0 else 0\n            util_A2 = (hours_A2 / capacities['A2'] *\n                       100) if capacities['A2'] > 0 else 0\n            util_B1 = (hours_B1 / capacities['B1'] *\n                       100) if capacities['B1'] > 0 else 0\n            util_B2 = (hours_B2 / capacities['B2'] *\n                       100) if capacities['B2'] > 0 else 0\n\n            print(\n                f\"  Machine A1: {hours_A1:.2f} / {capacities['A1']} hours | {util_A1:.1f}%\"\n            )\n            print(\n                f\"  Machine A2: {hours_A2:.2f} / {capacities['A2']} hours | {util_A2:.1f}%\"\n            )\n            print(\n                f\"  Machine B1: {hours_B1:.2f} / {capacities['B1']} hours | {util_B1:.1f}%\"\n            )\n            print(\n                f\"  Machine B2: {hours_B2:.2f} / {capacities['B2']} hours | {util_B2:.1f}%\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # To help debug, compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"factory_production_revised_iis.ilp\")\n            # print(\"IIS written to factory_production_revised_iis.ilp\")\n        else:\n            print(f\"Optimization was stopped with status {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_factory_production_revised()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B047",
    "description": "A factory produces two models of microcomputers, A and B. Each model requires the same two processes. The processing time, sales profit, and the factory’s maximum weekly processing capacity for each model are shown in Table 3.1.\n\nTable 3.1\n\n| Process | Model | | Maximum Weekly Processing Capacity |\n| :---: | :---: | :---: | :---: |\n| | $A$ | $B$ | |\n| I (hours/unit) | 4 | 6 | 150 |\n| II (hours/unit) | 3 | 2 | 70 |\n| Profit (yuan/unit) | 300 | 450 | |\n\nGiven the factory's business goals:\n\n$p_{1}$: The total weekly profit should not be less than 10,000 yuan;\n\n$p_{2}$: Due to contract requirements, at least 10 units of model A and at least 15 units of model B must be produced each week;\n\n$p_{3}$: The processing time for Process I should be exactly 150 hours per week, and the processing time for Process II should ideally be fully utilized, with potential for appropriate overtime;\n\n$p_{4}$: If products are produced during overtime in Process II, the profit per unit is reduced by 20 yuan for model A and 25 yuan for model B, and the maximum overtime for Process II is 30 hours per week. Formulate the mathematical model for this problem.",
    "ground_truth": 11250.0,
    "formulation": null,
    "correct_program": "def optimize_microcomputer_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Microcomputer_Production\")\n\n    # Decision variables\n    # Production quantities\n    x_A = m.addVar(name=\"x_A\", lb=10)  # at least 10 units of A\n    x_B = m.addVar(name=\"x_B\", lb=15)  # at least 15 units of B\n\n    # Overtime units produced\n    x_A_OT = m.addVar(name=\"x_A_OT\", lb=0)\n    x_B_OT = m.addVar(name=\"x_B_OT\", lb=0)\n\n    # Overtime hours in Process II\n    overtime_hours = m.addVar(name=\"overtime_hours\", lb=0, ub=30)\n\n    # Set objective: maximize profit considering reductions during overtime\n    profit = (300 * x_A + 450 * x_B - 20 * x_A_OT - 25 * x_B_OT)\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Constraints\n    # Process I exact utilization\n    m.addConstr(4 * x_A + 6 * x_B == 150, name=\"ProcessI_Capacity\")\n\n    # Process II regular hours\n    m.addConstr(3 * x_A + 2 * x_B <= 70, name=\"ProcessII_Regular_Capacity\")\n\n    # Overtime hours constraint\n    # Total overtime hours in Process II: 3 hours per unit of A during overtime, 2 hours per unit of B\n    m.addConstr(3 * x_A_OT + 2 * x_B_OT <= 30, name=\"Overtime_Hours_Limit\")\n\n    # Link overtime units to total production\n    m.addConstr(x_A_OT <= x_A, name=\"X_A_OT_Limit\")\n    m.addConstr(x_B_OT <= x_B, name=\"X_B_OT_Limit\")\n\n    # Calculate total overtime hours used\n    # Total overtime hours in Process II:\n    # 3 hours per unit of A during overtime, 2 hours per unit of B during overtime\n    m.addConstr(overtime_hours == 3 * x_A_OT + 2 * x_B_OT,\n                name=\"Total_Overtime_Hours\")\n\n    # Overtime hours cannot exceed 30\n    m.addConstr(overtime_hours <= 30, name=\"Max_Overtime_Hours\")\n\n    # Profit constraint\n    total_profit = (300 * x_A + 450 * x_B - 20 * x_A_OT - 25 * x_B_OT)\n    m.addConstr(total_profit >= 10000, name=\"Profit_Minimum\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_microcomputer_production()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B094",
    "description": "A beverage factory produces a kind of beverage to meet market demand. According to market forecasts, the sales department of the factory has determined the demand for the beverage for the next 4 weeks. The planning department, based on the actual situation of the factory, has provided the production capacity and production cost for the next 4 weeks, as shown in Table 1. When there is a surplus of beverages after meeting the demand each week, a storage cost of 0.2 thousand yuan per week per thousand boxes of beverages needs to be paid. How should the production plan be arranged to minimize the total cost (the sum of production cost and storage cost) over the four weeks while meeting the weekly market demand?\n\nTable 1 Beverage Production and Demand Data:\n\n\\begin{tabular}{c|c|c|c}\n\\hline \nWeek & Demand/1000 boxes & Production Capacity/1000 boxes & Cost per 1000 boxes/1000 yuan \\\\\n\\hline \n1 & 15 & 30 & 5.0 \\\\\n\\hline \n2 & 25 & 40 & 5.1 \\\\\n\\hline \n3 & 35 & 45 & 5.4 \\\\\n\\hline \n4 & 25 & 20 & 5.5 \\\\\n\\hline \nTotal & 100 & 135 & \\\\\n\\hline\n\\end{tabular}",
    "ground_truth": 528.0,
    "formulation": null,
    "correct_program": "def optimize_beverage_production():\n    from gurobipy import Model, GRB\n\n    # Data parameters\n    demand = [15, 25, 35, 25]  # demand for weeks 1-4\n    capacity = [30, 40, 45, 20]  # production capacity for weeks 1-4\n    cost = [5.0, 5.1, 5.4, 5.5]  # production cost per 1000 boxes\n    storage_cost = 0.2  # storage cost per 1000 boxes per week\n\n    # Create model\n    m = Model(\"BeverageProduction\")\n\n    # Decision variables\n    P = m.addVars(4, lb=0, name=\"Production\")  # production in each week\n    I = m.addVars(4, lb=0, name=\"Inventory\")  # inventory at end of each week\n\n    # Initial inventory constraint\n    # I_0 = 0 (not a variable, but initial condition)\n    # Inventory balance constraints\n    for t in range(4):\n        if t == 0:\n            m.addConstr(P[t] + 0 == demand[t] + I[t],\n                        name=f\"Balance_week_{t+1}\")\n        else:\n            m.addConstr(I[t - 1] + P[t] == demand[t] + I[t],\n                        name=f\"Balance_week_{t+1}\")\n\n    # Production capacity constraints\n    for t in range(4):\n        m.addConstr(P[t] <= capacity[t], name=f\"Cap_week_{t+1}\")\n\n    # Objective function\n    total_cost = 0\n    for t in range(4):\n        total_cost += cost[t] * P[t] + storage_cost * I[t]\n    m.setObjective(total_cost, GRB.MINIMIZE)\n\n    # Optimize\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":  # pragma: no cover\n    result = optimize_beverage_production()\n    if result is not None:\n        print(f\"Optimal total cost: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B053",
    "description": "Given that a certain factory plans to produce three types of products, I, II, and III, each product needs to be processed on equipment $A, B, C$ as shown in Table 2-3:\n\nTable 2-3\n| Equipment Code | I  | II | III | Effective Monthly Equipment Hours |\n|----------------|----|----|-----|----------------------------------|\n| A              | 8  | 2  | 10  | 300                              |\n| B              | 10 | 5  | 8   | 400                              |\n| C              | 2  | 13 | 10  | 420                              |\n| Unit Product Profit (per thousand yuan) | 3  | 2  | 2.9 |           |\n\nHow can the equipment capacity be fully utilized to maximize production profit?",
    "ground_truth": 135.26666666666668,
    "formulation": null,
    "correct_program": "def optimize_factory_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"FactoryProductionMaxProfit\")\n\n    # Decision variables: production quantities of products I, II, III\n    x_I = m.addVar(name=\"x_I\", lb=0)\n    x_II = m.addVar(name=\"x_II\", lb=0)\n    x_III = m.addVar(name=\"x_III\", lb=0)\n\n    # Set the objective: maximize total profit\n    profit = 3 * x_I + 2 * x_II + 2.9 * x_III\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Add equipment capacity constraints\n    m.addConstr(8 * x_I + 2 * x_II + 10 * x_III <= 300, name=\"A_capacity\")\n    m.addConstr(10 * x_I + 5 * x_II + 8 * x_III <= 400, name=\"B_capacity\")\n    m.addConstr(2 * x_I + 13 * x_II + 10 * x_III <= 420, name=\"C_capacity\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit value\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":  \n    result = optimize_factory_production()\n    if result is not None:\n        print(f\"Optimal total profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B021",
    "description": "A company plans to produce 3 types of products $A_{1}, A_{2}, A_{3}$. It can produce for 22 days in a month. The following table gives the maximum demand (unit $=100 \\mathrm{~kg}$), price ($\\$ / 100 \\mathrm{Kg}$), production cost (per 100Kg product), and production quota (the maximum number of 100kg units that can be produced in one day if all production lines are devoted to this product).\n\n| Product | $A_{1}$ | $A_{2}$ | $A_{3}$ |\n| :---: | :---: | :---: | :---: |\n| Maximum Demand | 5300 | 4500 | 5400 |\n| Selling Price | $124$ | $109$ | $115$ |\n| Production Cost | $73.30$ | $52.90$ | $65.40$ |\n| Production Quota | 500 | 450 | 550 |\n\nThe fixed activation cost of the production line is as follows:\n\n| Product | $A_{1}$ | $A_{2}$ | $A_{3}$ |\n| :---: | :---: | :---: | :---: |\n| Activation Cost | $170000$ | $150000$ | $100000$ |\n\nMinimum production batch:\n\n$$\n\\begin{array}{c|ccc}\nProduct & A_{1} & A_{2} & A_{3} \\\\\n\\hline\nMinimum Batch & 20 & 20 & 16\n\\end{array}\n$$\n\nPlease formulate an operations research model to determine a production plan that maximizes total revenue while accommodating fixed activation costs and minimum production batch constraints.",
    "ground_truth": 270290.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_complete_production_planning():\n    \"\"\"\n    Solves the production planning problem with fixed activation costs,\n    minimum batch sizes, and a shared time resource constraint.\n    \"\"\"\n    try:\n        # --- 1. Problem Data ---\n        products = ['A1', 'A2', 'A3']\n\n        max_demand = {'A1': 5300, 'A2': 4500, 'A3': 5400}  # units of 100kg\n        selling_price = {'A1': 124, 'A2': 109, 'A3': 115}  # $/100kg\n        production_cost = {'A1': 73.30, 'A2': 52.90, 'A3': 65.40}  # $/100kg\n        production_quota = {'A1': 500, 'A2': 450, 'A3': 550}  # 100kg units/day\n\n        activation_cost = {'A1': 170000, 'A2': 150000, 'A3': 100000}  # $\n        min_batch = {'A1': 20, 'A2': 20, 'A3': 16}  # units of 100kg\n\n        available_days = 22\n\n        # Pre-calculate profit per unit for clarity\n        profit_per_unit = {\n            p: selling_price[p] - production_cost[p]\n            for p in products\n        }\n\n        # --- 2. Model Creation ---\n        model = gp.Model(\"CompleteProductionPlanning\")\n\n        # --- 3. Decision Variables ---\n        # produce_qty[p]: quantity of product p to produce (in 100kg units)\n        produce_qty = model.addVars(products,\n                                    vtype=GRB.INTEGER,\n                                    name=\"produce_qty\",\n                                    lb=0)\n\n        # use_product[p]: binary variable, 1 if product p is produced, 0 otherwise\n        use_product = model.addVars(products,\n                                    vtype=GRB.BINARY,\n                                    name=\"use_product\")\n\n        # --- 4. Objective Function ---\n        # Maximize total profit = (sum of unit profits * quantity) - (sum of activation costs if produced)\n\n        # Variable profit from units produced\n        total_variable_profit = gp.quicksum(profit_per_unit[p] * produce_qty[p]\n                                            for p in products)\n\n        # Conditional activation costs\n        total_activation_cost = gp.quicksum(activation_cost[p] * use_product[p]\n                                            for p in products)\n\n        model.setObjective(total_variable_profit - total_activation_cost,\n                           GRB.MAXIMIZE)\n\n        # --- 5. Constraints ---\n\n        # Constraint 5.1: Shared Resource Constraint (Total Production Time)\n        # The one that was missing from the \"incorrect\" code.\n        model.addConstr(\n            gp.quicksum(produce_qty[p] / production_quota[p] for p in products)\n            <= available_days, \"TotalProductionTime\")\n\n        # Constraints applied to each product individually\n        for p in products:\n            # Constraint 5.2: Maximum Demand Constraint\n            # The production quantity cannot exceed market demand.\n            model.addConstr(produce_qty[p] <= max_demand[p], f\"MaxDemand_{p}\")\n\n            # Constraint 5.3: Link production quantity to the binary decision variable\n            # If we decide to produce (use_product[p] = 1), then production quantity must be >= min_batch.\n            # This correctly models the minimum batch size condition.\n            model.addConstr(produce_qty[p] >= min_batch[p] * use_product[p],\n                            f\"MinBatchLink_{p}\")\n\n            # Constraint 5.4: Link the binary variable to an upper bound on production.\n            # If we do not produce (use_product[p] = 0), quantity must be 0.\n            # If we do produce (use_product[p] = 1), quantity is limited by a large number (\"Big M\").\n            # A good \"Big M\" is the maximum possible demand for that product.\n            model.addConstr(produce_qty[p] <= max_demand[p] * use_product[p],\n                            f\"ActivationLink_{p}\")\n\n        # --- 6. Optimize Model ---\n        model.optimize()\n\n        # --- 7. Results ---\n        print(\"-\" * 50)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found!\")\n            print(f\"Maximum Total Profit: ${model.objVal:,.2f}\")\n            print(\"-\" * 50)\n            print(\"Production Details:\")\n            total_days_used = 0\n            for p in products:\n                qty = produce_qty[p].X\n                days_for_p = qty / production_quota[p]\n                total_days_used += days_for_p\n\n                print(f\"  Product {p}:\")\n                if use_product[\n                        p].X > 0.5:  # Check if this product was activated\n                    print(f\"    Status: PRODUCED\")\n                    print(f\"    Produce Quantity (100kg units): {qty:.0f}\")\n                    print(f\"    Days Used: {days_for_p:.2f} days\")\n                    net_profit_p = (profit_per_unit[p] *\n                                    qty) - activation_cost[p]\n                    print(\n                        f\"    Net Profit (incl. activation cost): ${net_profit_p:,.2f}\"\n                    )\n                else:\n                    print(f\"    Status: NOT PRODUCED\")\n                print(\"-\" * 25)\n\n            print(\"Overall Resource Utilization:\")\n            print(\n                f\"  Total Production Days Used: {total_days_used:.2f} / {available_days} days\"\n            )\n            print(\"-\" * 50)\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists that satisfies all constraints.\"\n            )\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_complete_production_planning()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B031",
    "description": "A product consists of three components produced by four workshops, each with a limited number of production hours. Table 1.4 below provides the production rates of the three components. The objective is to determine the number of hours each workshop should allocate to each component to maximize the number of completed products. Formulate this problem as a linear programming problem.\n\nTable 1.4\n\n| Workshop | Production Capacity (hours) | Production Rate (units/hour) |   |   |\n| :------: | :-------------------------: | :--------------------------: | - | - |\n|          |                             | Component 1 | Component 2  | Component 3 |\n|    A     |           100               |      10      |      15     |      5      |\n|    B     |           150               |      15      |      10     |      5      |\n|    C     |           80                |      20      |      5      |      10     |\n|    D     |           200               |      10      |      15     |      20     |",
    "ground_truth": 2924.0,
    "formulation": null,
    "correct_program": "from gurobipy import Model, GRB\n\n# Data from Table 1.4\nworkshops = ['A', 'B', 'C', 'D']\ncomponents = [1, 2, 3]\n\n# Production capacity (in hours) for each workshop\nprod_capacity = {'A': 100, 'B': 150, 'C': 80, 'D': 200}\n\n# Production rate (units/hour) for each component in each workshop\nprod_rate = {\n    ('A', 1): 10,\n    ('A', 2): 15,\n    ('A', 3): 5,\n    ('B', 1): 15,\n    ('B', 2): 10,\n    ('B', 3): 5,\n    ('C', 1): 20,\n    ('C', 2): 5,\n    ('C', 3): 10,\n    ('D', 1): 10,\n    ('D', 2): 15,\n    ('D', 3): 20\n}\n\n# Create model\nmodel = Model(\"Maximize_Complete_Products\")\n\n# Add variables\nx = model.addVars(workshops, components, lb=0, name=\"x\")  # Hours allocated\nz = model.addVar(name=\"z\", vtype=GRB.INTEGER)  # Number of complete products\n\n# Set objective: maximize z\nmodel.setObjective(z, GRB.MAXIMIZE)\n\n# Add constraints:\n\n# 1. For each component, total produced >= z\nfor j in components:\n    model.addConstr(sum(prod_rate[i, j] * x[i, j] for i in workshops) >= z,\n                    name=f\"Component_{j}_enough_for_z\")\n\n# 2. Workshop time availability constraint\nfor i in workshops:\n    model.addConstr(sum(x[i, j] for j in components) <= prod_capacity[i],\n                    name=f\"Workshop_{i}_time_limit\")\n\n# Optimize\nmodel.optimize()\n\n# Output results\nif model.status == GRB.OPTIMAL:\n    print(f\"\\nMaximum number of complete products: {z.X:.2f}\\n\")\n\n    print(\"Hours allocated per component:\")\n    for i in workshops:\n        for j in components:\n            if x[i, j].X > 0:\n                print(f\"Workshop {i}, Component {j}: {x[i, j].X:.2f} hours\")\nelse:\n    print(\"No optimal solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B097",
    "description": "A company uses steel and aluminum as raw materials to produce two products (A and B). A single unit of product A requires 6 kg of steel, 8 kg of aluminum, 11 hours of labor, and yields a profit of 5000 yuan (excluding worker overtime pay). A single unit of product B requires 12 kg of steel, 20 kg of aluminum, 24 hours of labor, and yields a profit of 11000 yuan (excluding worker overtime pay). The company currently has 200 kg of steel, 300 kg of aluminum, and 300 hours of labor available. If workers need to work overtime, the overtime pay is 100 yuan per hour. Please develop a production plan to maximize the company's profit and minimize worker overtime.",
    "ground_truth": 165900.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_production_planning_with_overtime():\n    \"\"\"\n    Solves the production planning problem to maximize net profit,\n    considering resource constraints and overtime pay.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['A', 'B']\n\n        # Profit per unit (excluding worker overtime pay) (yuan/unit)\n        gross_profit = {'A': 5000, 'B': 11000}\n\n        # Resource requirements per unit\n        steel_req = {'A': 6, 'B': 12}  # kg/unit\n        aluminum_req = {'A': 8, 'B': 20}  # kg/unit\n        labor_req = {'A': 11, 'B': 24}  # hours/unit\n\n        # Resource availability\n        avail_steel = 200  # kg\n        avail_aluminum = 300  # kg\n        avail_labor_regular = 300  # hours\n\n        # Overtime pay (yuan/hour)\n        overtime_pay_per_hour = 100\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ProductionPlanningOvertime\")\n\n        # --- Decision Variables ---\n        # X[p]: Number of units of product p to produce\n        X = model.addVars(products, name=\"Produce\", vtype=GRB.INTEGER, lb=0)\n\n        # OT: Total overtime hours used\n        OT = model.addVar(name=\"OvertimeHours\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Net Profit ---\n        # Net Profit = Gross Profit from Products - Cost of Overtime\n        total_gross_profit = gp.quicksum(gross_profit[p] * X[p]\n                                         for p in products)\n        total_overtime_cost = overtime_pay_per_hour * OT\n\n        model.setObjective(total_gross_profit - total_overtime_cost,\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Steel Constraint\n        model.addConstr(gp.quicksum(steel_req[p] * X[p] for p in products)\n                        <= avail_steel,\n                        name=\"SteelLimit\")\n\n        # 2. Aluminum Constraint\n        model.addConstr(gp.quicksum(aluminum_req[p] * X[p] for p in products)\n                        <= avail_aluminum,\n                        name=\"AluminumLimit\")\n\n        # 3. Labor Constraint\n        # Total labor hours required can be met by regular hours + overtime hours\n        # TotalLaborRequired <= RegularLaborAvailable + Overtime\n        # TotalLaborRequired - Overtime <= RegularLaborAvailable\n        total_labor_needed = gp.quicksum(labor_req[p] * X[p] for p in products)\n        model.addConstr(total_labor_needed <= avail_labor_regular + OT,\n                        name=\"LaborAvailability\")\n\n        # Alternative for Labor Constraint (explicitly defines OT if positive):\n        # model.addConstr(total_labor_needed - OT <= avail_labor_regular, name=\"LaborConstraint\")\n        # This is equivalent to the one above given OT >= 0.\n        # The objective function will naturally try to minimize OT if it costs money.\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Net Profit: {model.ObjVal:.2f} Yuan\")\n\n            print(\"\\nOptimal Production Quantities (units):\")\n            for p in products:\n                print(f\"  Product {p}: {X[p].X:.0f} units\")\n\n            print(f\"\\nOvertime Hours Used: {OT.X:.2f} hours\")\n            print(\n                f\"Cost of Overtime: {(overtime_pay_per_hour * OT.X):.2f} Yuan\")\n\n            print(\"\\nResource Utilization:\")\n            steel_used = sum(steel_req[p] * X[p].X for p in products)\n            aluminum_used = sum(aluminum_req[p] * X[p].X for p in products)\n            labor_needed_val = sum(labor_req[p] * X[p].X for p in products)\n\n            print(\n                f\"  Steel Used: {steel_used:.2f} / {avail_steel} kg \"\n                f\"({(steel_used/avail_steel*100) if avail_steel > 0 else 0:.1f}%)\"\n            )\n            print(\n                f\"  Aluminum Used: {aluminum_used:.2f} / {avail_aluminum} kg \"\n                f\"({(aluminum_used/avail_aluminum*100) if avail_aluminum > 0 else 0:.1f}%)\"\n            )\n            print(f\"  Total Labor Needed: {labor_needed_val:.2f} hours\")\n            print(\n                f\"    Met by Regular Hours: {min(labor_needed_val, avail_labor_regular):.2f} / {avail_labor_regular} hours\"\n            )\n            if OT.X > 1e-6:\n                print(f\"    Met by Overtime Hours: {OT.X:.2f} hours\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and resource availability.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"production_overtime_iis.ilp\")\n            # print(\"IIS written to production_overtime_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_production_planning_with_overtime()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B064",
    "description": "A company produces two types of products: microwave ovens and water heaters, which are manufactured in both workshops A and B. It is known that apart from the purchased parts, the production of one microwave oven requires 2 hours of processing in workshop A and 1 hour of assembly in workshop B. The production of one water heater requires 1 hour of processing in workshop A and 3 hours of assembly in workshop B. After production, both products need inspection, sales, and other procedures. The inspection and sales cost for each microwave oven is 30 yuan, and for each water heater is 50 yuan. Workshop A has 250 hours of available production time per month, with each hour costing 80 yuan; workshop B has 150 hours of available production time per month, with each hour costing 20 yuan. It is estimated that an average of 80 microwave ovens and 50 water heaters can be sold per month next year. Based on these actual conditions, the company has established the following monthly plan constraints:\n\n1. Inspection and sales costs should not exceed 5500 yuan per month;\n2. At least 80 microwave ovens should be sold per month;\n3. The production hours of both workshops A and B should be fully utilized;\n4. Overtime in workshop A should not exceed 20 hours;\n5. At least 50 water heaters should be sold per month.\n\nTry to determine the monthly production plan for the company.",
    "ground_truth": 30500.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Manufacturing_Plan\")\n\n# Decision variables\n# x = number of microwave ovens to produce per month\n# y = number of water heaters to produce per month\n# oa = overtime hours in workshop A\nx = model.addVar(lb=0, vtype=GRB.INTEGER, name=\"microwave_ovens\")\ny = model.addVar(lb=0, vtype=GRB.INTEGER, name=\"water_heaters\")\noa = model.addVar(lb=0, ub=20, vtype=GRB.CONTINUOUS, name=\"overtime_A\")\nob = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"overtime_B\")\n\n# Parameters\n# Workshop hours required per product\nhours_A_microwave = 2  # hours in workshop A per microwave\nhours_B_microwave = 1  # hours in workshop B per microwave\nhours_A_heater = 1  # hours in workshop A per water heater\nhours_B_heater = 3  # hours in workshop B per water heater\n\n# Workshop capacities\ncapacity_A = 250  # regular hours in workshop A\ncapacity_B = 150  # hours in workshop B\n\n# Costs\ncost_per_hour_A = 80  # yuan per hour in workshop A\ncost_per_hour_B = 20  # yuan per hour in workshop B\ninspection_sales_microwave = 30  # yuan per microwave\ninspection_sales_heater = 50  # yuan per water heater\n\n# Sales estimates\nestimated_demand_microwave = 80  # microwave ovens per month\nestimated_demand_heater = 50  # water heaters per month\n\n# Constraints\n\n# 1. Inspection and sales costs constraint\nmodel.addConstr(\n    inspection_sales_microwave * x + inspection_sales_heater * y <= 5500,\n    \"inspection_sales_cost\")\n\n# 2. Minimum microwave oven sales requirement\nmodel.addConstr(x >= estimated_demand_microwave, \"min_microwave_sales\")\n\n# 3a. Workshop A hours must be fully utilized (including potential overtime)\nmodel.addConstr(hours_A_microwave * x + hours_A_heater * y == capacity_A + oa,\n                \"workshop_A_utilization\")\n\n# 3b. Workshop B hours must be fully utilized\nmodel.addConstr(hours_B_microwave * x + hours_B_heater * y == capacity_B + ob,\n                \"workshop_B_utilization\")\n\n# 4. Overtime constraint for workshop A (Already handled in variable definition with ub=20)\n\n# 5. Minimum water heater sales requirement\nmodel.addConstr(y >= estimated_demand_heater, \"min_heater_sales\")\n\n# Objective: Maximize profit\n# Revenue isn't specified, so we'll minimize costs instead\ntotal_cost = (\n    # Production costs\n    cost_per_hour_A * (capacity_A + oa) +  # Regular + overtime for workshop A\n    cost_per_hour_B * (capacity_B + ob) +  # Regular hours for workshop B\n    # Inspection and sales costs\n    inspection_sales_microwave * x + inspection_sales_heater * y)\n\nmodel.setObjective(total_cost, GRB.MINIMIZE)\n\n# Solve the model\nmodel.optimize()\n\n# Check if a solution was found\nif model.status == GRB.OPTIMAL:\n    print(\"\\n=== OPTIMAL MONTHLY PRODUCTION PLAN ===\")\n    print(f\"Microwave Ovens: {int(x.X)} units\")\n    print(f\"Water Heaters: {int(y.X)} units\")\n    print(f\"Overtime Hours in Workshop A: {oa.X:.2f} hours\")\n\n    # Calculate resource utilization\n    hours_used_A = hours_A_microwave * x.X + hours_A_heater * y.X\n    hours_used_B = hours_B_microwave * x.X + hours_B_heater * y.X\n\n    print(\"\\n=== RESOURCE UTILIZATION ===\")\n    print(\n        f\"Workshop A: {hours_used_A:.2f} hours used (including {oa.X:.2f} overtime hours)\"\n    )\n    print(f\"Workshop B: {hours_used_B:.2f} hours used (out of {capacity_B})\")\n\n    # Calculate costs\n    production_cost_A = cost_per_hour_A * hours_used_A\n    production_cost_B = cost_per_hour_B * hours_used_B\n    inspection_sales_cost = inspection_sales_microwave * x.X + inspection_sales_heater * y.X\n\n    print(\"\\n=== COST BREAKDOWN ===\")\n    print(f\"Workshop A Production Cost: {production_cost_A:.2f} yuan\")\n    print(f\"Workshop B Production Cost: {production_cost_B:.2f} yuan\")\n    print(f\"Inspection and Sales Cost: {inspection_sales_cost:.2f} yuan\")\n    print(f\"Total Cost: {model.objVal:.2f} yuan\")\n\n    # Check constraint satisfaction\n    print(\"\\n=== CONSTRAINT VERIFICATION ===\")\n    print(\n        f\"1. Inspection and Sales Cost: {inspection_sales_cost:.2f} yuan (Max: 5500 yuan)\"\n    )\n    print(\n        f\"2. Microwave Oven Production: {int(x.X)} units (Min: {estimated_demand_microwave} units)\"\n    )\n    print(\n        f\"3. Workshop A Utilization: {hours_used_A:.2f} hours (Regular: {capacity_A} hours, Overtime: {oa.X:.2f} hours)\"\n    )\n    print(\n        f\"   Workshop B Utilization: {hours_used_B:.2f} hours (Capacity: {capacity_B} hours)\"\n    )\n    print(f\"4. Workshop A Overtime: {oa.X:.2f} hours (Max: 20 hours)\")\n    print(\n        f\"5. Water Heater Production: {int(y.X)} units (Min: {estimated_demand_heater} units)\"\n    )\n\n    # Check for binding constraints\n    print(\"\\n=== BINDING CONSTRAINTS ===\")\n    for c in model.getConstrs():\n        if abs(c.slack) < 1e-6:\n            print(f\"- {c.ConstrName} is binding\")\n\nelif model.status == GRB.INFEASIBLE:\n    print(\n        \"The model is infeasible - there is no solution that satisfies all constraints.\"\n    )\n    # Compute and display the Irreducible Inconsistent Subsystem (IIS)\n    print(\"Computing IIS to find conflicting constraints...\")\n    model.computeIIS()\n    print(\"\\nThe following constraints are in conflict:\")\n    for c in model.getConstrs():\n        if c.IISConstr:\n            print(f\"- {c.ConstrName}\")\nelse:\n    print(\n        f\"Optimization did not complete normally. Status code: {model.status}\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B074",
    "description": "There are $\\mathrm{A}$ and $\\mathrm{B}$ two products, both requiring two successive chemical reaction processes. Each unit of product $\\mathrm{A}$ needs 2 hours for the first process and 3 hours for the second process. Each unit of product $\\mathrm{B}$ needs 3 hours for the first process and 4 hours for the second process. Available time for the first process is 16 hours, and available time for the second process is 24 hours.\n\nFor each unit of product $\\mathrm{B}$ produced, 2 units of by-product $\\mathrm{C}$ are generated simultaneously, requiring no additional cost. By-product $\\mathrm{C}$ can be sold up to 5 units, and the rest must be disposed of at a cost of 2 yuan per unit.\n\nEach unit of product $\\mathrm{A}$ sold yields a profit of 4 yuan, each unit of product $\\mathrm{B}$ yields a profit of 10 yuan, and each unit of by-product $\\mathrm{C}$ sold yields a profit of 3 yuan.\n\nIn order to maximize total profit, establish the linear programming model for this problem.",
    "ground_truth": 57.0,
    "formulation": null,
    "correct_program": "def optimize_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Production_Optimization\")\n\n    # Decision variables\n    x_A = m.addVar(name=\"x_A\", lb=0)  # Units of product A\n    x_B = m.addVar(name=\"x_B\", lb=0)  # Units of product B\n    s_C = m.addVar(name=\"s_C\", lb=0, ub=5)  # Units of by-product C sold\n    d = m.addVar(name=\"d\", lb=0)  # Units of C disposed\n\n    # Set objective: maximize profit\n    # profit = 4*x_A + 10*x_B + 3*s_C - 2*d\n    m.setObjective(4 * x_A + 10 * x_B + 3 * s_C - 2 * d, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Time constraints\n    m.addConstr(2 * x_A + 3 * x_B <= 16, \"Time_Process1\")\n    m.addConstr(3 * x_A + 4 * x_B <= 24, \"Time_Process2\")\n    # By-product C sale limit\n    m.addConstr(s_C <= 5, \"Max_C_Sale\")\n    # C sold cannot exceed generated\n    m.addConstr(s_C <= 2 * x_B, \"C_Sale_Limit\")\n    # Disposal constraint\n    m.addConstr(2 * x_B - s_C <= d, \"Disposal_Constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit value\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\nif __name__ == \"__main__\":\n    result = optimize_production()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B060",
    "description": "A product can be processed on any one of the four devices: A, B, C, or D. The preparation completion costs when each device is enabled, the unit production cost for the product, and the maximum processing capacity of each device are shown in Table 5-7. If 2000 units of the product need to be produced, how can the total cost be minimized? Try to establish a mathematical model.\n\nTable 5-7\n| Device | Prep Completion Cost (Yuan) | Unit Production Cost (Yuan/Unit) | Maximum Processing Capacity (Units) |\n|--------|------------------------------|----------------------------------|------------------------------------|\n| A      | 1000                         | 20                               | 900                                |\n| B      | 920                          | 24                               | 1000                               |\n| C      | 800                          | 16                               | 1200                               |\n| D      | 700                          | 28                               | 1600                               |",
    "ground_truth": 37000.0,
    "formulation": null,
    "correct_program": "def optimize_production():\n    from gurobipy import Model, GRB\n\n    # Data from the problem\n    prep_costs = {'A': 1000, 'B': 920, 'C': 800, 'D': 700}\n    unit_costs = {'A': 20, 'B': 24, 'C': 16, 'D': 28}\n    capacities = {'A': 900, 'B': 1000, 'C': 1200, 'D': 1600}\n    total_units = 2000\n\n    # Initialize model\n    m = Model(\"Production_Optimization\")\n    m.setParam('OutputFlag', 0)  # Suppress output\n\n    # Decision variables\n    y = m.addVars(prep_costs.keys(), vtype=GRB.BINARY, name='y')\n    x = m.addVars(prep_costs.keys(), lb=0, vtype=GRB.CONTINUOUS, name='x')\n\n    # Objective function\n    m.setObjective(\n        sum(prep_costs[i] * y[i] + unit_costs[i] * x[i] for i in prep_costs),\n        GRB.MINIMIZE)\n\n    # Constraints\n    # Demand satisfaction\n    m.addConstr(sum(x[i] for i in prep_costs) == total_units, name='Demand')\n\n    # Capacity constraints linked with activation\n    for i in prep_costs:\n        m.addConstr(x[i] <= capacities[i] * y[i], name=f'Cap_{i}')\n\n    # Optimize\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_cost = m.objVal\n        return total_cost\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_production()\n    if result is not None:\n        print(f\"Optimal total cost for production: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "E110",
    "description": "Sailco Corporation must determine how many sailboats should be produced during each of the next four quarters (one quarter  three months). The demand during each of the next four quarters is as follows: first quarter, 40 sailboats; second quarter, 60 sailboats; third quarter, 75 sailboats; fourth quarter, 25 sailboats. Sailco must meet demands on time. At the beginning of the first quarter, Sailco has an inventory of 10 sailboats. At the beginning of each quarter, Sailco must decide how many sailboats should be produced during that quarter. For simplicity, we assume that sailboats manufactured during a quarter can be used to meet demand for that quarter. During each quarter, Sailco can produce up to 40 sailboats with regular-time labor at a total cost of $400 per sailboat. By having employees work overtime during a quarter, Sailco can produce additional sailboats with overtime labor at a total cost of $450 per sailboat. At the end of each quarter (after production has occurred and the current quarter’s demand has been satisfied), a carrying or holding cost of $20 per sailboat is incurred. Use linear programming to determine a production schedule to minimize the sum of production and inventory costs during the next four quarters. Find the minimal sum.",
    "ground_truth": 78450.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Sailco_Production\")\n\n# Parameters\nD = [40, 60, 75, 25]  # Demands for each quarter\nI0 = 10               # Initial inventory\nP_max = 40            # Max regular-time production per quarter\nC_r = 400             # Cost per sailboat with regular-time labor\nC_o = 450             # Cost per sailboat with overtime labor\nC_h = 20              # Holding cost per sailboat at the end of each quarter\n\n# Variables\nx = model.addVars(4, vtype=GRB.INTEGER, lb=0, ub=P_max, name=\"RegularTimeProduction\")\ny = model.addVars(4, vtype=GRB.INTEGER, lb=0, name=\"OvertimeProduction\")\nI = model.addVars(4, vtype=GRB.INTEGER, lb=0, name=\"Inventory\")\n\n# Objective: Minimize the sum of production and inventory costs\nmodel.setObjective(\n    gp.quicksum(C_r * x[t] + C_o * y[t] + C_h * I[t] for t in range(4)),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Inventory balance constraints\nmodel.addConstr(I0 + x[0] + y[0] - D[0] == I[0], \"InventoryBalance_Quarter1\")\nfor t in range(1, 4):\n    model.addConstr(I[t-1] + x[t] + y[t] - D[t] == I[t], f\"InventoryBalance_Quarter{t+1}\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B000",
    "description": "A factory produces two types of food, I and II, and currently has 50 skilled workers. It is known that one skilled worker can produce $10 \\ \\mathrm{kg} / \\ \\mathrm{h}$ of food I or $6 \\ \\mathrm{kg} / \\ \\mathrm{h}$ of food II. According to contract bookings, the weekly demand for these two foods will rise sharply, as shown in Table 1-11. Therefore, the factory has decided to train 50 new workers by the end of the 8th week. It is known that a worker works $40 \\ \\mathrm{h}$ per week, and a skilled worker can train up to three new workers in two weeks (during the training period, both the skilled worker and the trainees do not participate in production). The weekly wage of a skilled worker is 360 yuan, the weekly wage of a trainee during the training period is 120 yuan, and after training, the wage is 240 yuan per week, with the same production efficiency as skilled workers. During the transition period of training, many skilled workers are willing to work overtime, and the factory has decided to arrange some workers to work $60 \\ \\mathrm{h}$ per week, with a weekly wage of 540 yuan. If the booked food cannot be delivered on time, the compensation fee for each week of delay per $ \\ \\mathrm{kg}$ is 0.5 yuan for food I and 0.6 yuan for food II. Under these conditions, how should the factory make comprehensive arrangements to minimize the total cost?\n\nTable 1-11\n\n| Week | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |\n|------|---|---|---|---|---|---|---|---|\n| I    | 10000 | 10000  | 12000  | 12000  | 16000  | 16000  | 20000  | 20000  |\n| II   | 6000 | 7200 | 8400 | 10800 | 10800 | 12000  | 12000  | 12000  |",
    "ground_truth": 219600.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_factory_problem():\n    model = gp.Model(\"FactoryProductionTraining\")\n\n    # --- Parameters ---\n    weeks = range(1, 9)  # 1 to 8\n    products = [1, 2]  # Food I and II\n\n    initial_skilled_workers = 50\n    new_workers_to_train_total = 50\n\n    # Demand (kg)\n    demand_data = {\n        1: {\n            1: 10000,\n            2: 10000,\n            3: 12000,\n            4: 12000,\n            5: 16000,\n            6: 16000,\n            7: 20000,\n            8: 20000\n        },\n        2: {\n            1: 6000,\n            2: 7200,\n            3: 8400,\n            4: 10800,\n            5: 10800,\n            6: 12000,\n            7: 12000,\n            8: 12000\n        }\n    }\n\n    # Production rates (kg/h per worker)\n    prod_rate = {1: 10, 2: 6}\n\n    # Work hours per week\n    hours_normal = 40\n    hours_overtime = 60\n\n    # Wages (yuan per week)\n    wage_skilled_normal = 360\n    wage_skilled_overtime = 540\n    wage_trainee = 120\n    wage_newly_skilled = 240  # After training\n\n    # Training: 1 skilled trains up to 3 new workers in 2 weeks\n    training_ratio = 3  # new workers per skilled trainer\n    training_duration = 2  # weeks\n\n    # Compensation fee for delay (yuan per kg per week of delay)\n    delay_penalty = {1: 0.5, 2: 0.6}\n\n    initial_inventory = {\n        1: 0,\n        2: 0\n    }  # Assuming no initial inventory or backlog\n\n    # --- Decision Variables ---\n\n    # Original skilled workers allocation\n    sw_normal = model.addVars(weeks, name=\"SW_Normal\", vtype=GRB.INTEGER, lb=0)\n    sw_overtime = model.addVars(weeks,\n                                name=\"SW_Overtime\",\n                                vtype=GRB.INTEGER,\n                                lb=0)\n    sw_train = model.addVars(weeks, name=\"SW_Train\", vtype=GRB.INTEGER, lb=0)\n    sw_train_start = model.addVars(weeks,\n                                   name=\"SW_Train_Start\",\n                                   vtype=GRB.INTEGER,\n                                   lb=0)\n    # New workers\n    nw_start_training = model.addVars(weeks,\n                                      name=\"NW_Start_Training\",\n                                      vtype=GRB.INTEGER,\n                                      lb=0)\n    nw_training = model.addVars(weeks,\n                                name=\"NW_Training\",\n                                vtype=GRB.INTEGER,\n                                lb=0)  # Workers currently in training\n    nw_newly_skilled_prod = model.addVars(weeks,\n                                          name=\"NW_Newly_Skilled_Prod\",\n                                          vtype=GRB.INTEGER,\n                                          lb=0)\n\n    # Hours allocation by worker type and product\n    h_sw_normal = model.addVars(weeks,\n                                products,\n                                name=\"H_SW_Normal\",\n                                vtype=GRB.CONTINUOUS,\n                                lb=0)\n    h_sw_overtime = model.addVars(weeks,\n                                  products,\n                                  name=\"H_SW_Overtime\",\n                                  vtype=GRB.CONTINUOUS,\n                                  lb=0)\n    h_nw_newly_skilled = model.addVars(weeks,\n                                       products,\n                                       name=\"H_NW_Newly_Skilled\",\n                                       vtype=GRB.CONTINUOUS,\n                                       lb=0)\n\n    # Production quantities\n    P = model.addVars(weeks,\n                      products,\n                      name=\"Production\",\n                      vtype=GRB.CONTINUOUS,\n                      lb=0)\n\n    # Inventory and Backlog\n    Inv = model.addVars(weeks,\n                        products,\n                        name=\"Inventory\",\n                        vtype=GRB.CONTINUOUS,\n                        lb=-GRB.INFINITY)\n    Backlog_Surrogate = model.addVars(weeks,\n                                      products,\n                                      name=\"Backlog_Surrogate\",\n                                      vtype=GRB.CONTINUOUS,\n                                      lb=0)\n\n    # --- Objective Function: Minimize Total Cost ---\n    total_cost = gp.LinExpr()\n\n    for w in weeks:\n        # Wages for original skilled workers\n        total_cost += sw_normal[w] * wage_skilled_normal\n        total_cost += sw_overtime[w] * wage_skilled_overtime\n        total_cost += sw_train[w] * wage_skilled_normal\n\n        # Wages for trainees\n        total_cost += nw_training[w] * wage_trainee\n\n        # Wages for newly skilled workers (once they complete training and start producing)\n        total_cost += nw_newly_skilled_prod[w] * wage_newly_skilled\n\n        # Penalties for backlog\n        for p in products:\n            total_cost += Backlog_Surrogate[w, p] * delay_penalty[p]\n\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # --- Constraints ---\n\n    # C1: Original Skilled Worker Pool Allocation\n    for w in weeks:\n        model.addConstr(sw_normal[w] + sw_overtime[w] +\n                        sw_train[w] == initial_skilled_workers,\n                        name=f\"OriginalSW_Allocation_w{w}\")\n        if w < training_duration:\n            model.addConstr(sw_train[w] == sum(sw_train_start[w_inner]\n                                               for w_inner in range(1, w + 1)),\n                            name=f\"SW_TrainStart_Accumulation_w{w}\")\n        else:\n            model.addConstr(sw_train[w] == sum(sw_train_start[w_inner]\n                                               for w_inner in range(w - training_duration + 1, w + 1)),\n                            name=f\"SW_TrainStart_Accumulation_w{w}\")\n\n    # C2: New Worker Training Target\n    model.addConstr(\n        gp.quicksum(nw_start_training[w] for w in range(1, 8)) ==\n        new_workers_to_train_total,  # Weeks 1 to 7 for starting\n        name=\"TotalNewWorkersTrained\")\n    model.addConstr(nw_start_training[8] == 0, name=\"NoTrainingStartInWeek8\")\n    for w in weeks:\n        if w == 1:\n            model.addConstr(nw_training[w] == nw_start_training[w],\n                            name=f\"NewWorkersTrainingStart_w{w}\")\n        else:\n            model.addConstr(nw_training[w] == sum(nw_start_training[w_inner]\n                                                   for w_inner in range(w - training_duration + 1, w + 1)),\n                            name=f\"NewWorkersTraining_w{w}\")\n\n    # C3: Newly Skilled Worker Availability for Production\n    for w in weeks:\n        if w <= training_duration:\n            model.addConstr(nw_newly_skilled_prod[w] == 0,\n                            name=f\"NoNewlySkilled_w{w}\")\n        else:\n            model.addConstr(nw_newly_skilled_prod[w] == nw_newly_skilled_prod[w-1] +\n                            nw_start_training[w - training_duration],\n                            name=f\"NewlySkilledAvailability_w{w}\")\n\n    # C4: Training Capacity\n    for w in weeks:\n        model.addConstr(nw_start_training[w] <= training_ratio * sw_train_start[w],\n                        name=f\"TrainingCapacity_w{w}\")\n\n    # C5: Production Hours Allocation by Worker Type\n    for w in weeks:\n        # for p_idx, p_val in enumerate(\n        #         products\n        # ):  # Use p_val for keys, p_idx for list access if needed\n        # Original skilled workers - normal time\n        model.addConstr(gp.quicksum(h_sw_normal[w, p_inner]\n                                    for p_inner in products)\n                        == sw_normal[w] * hours_normal,\n                        name=f\"Hours_SW_Normal_Total_w{w}\"\n                        )  # Sum hours over products for this worker group\n        # Original skilled workers - overtime\n        model.addConstr(gp.quicksum(h_sw_overtime[w, p_inner]\n                                    for p_inner in products)\n                        == sw_overtime[w] * hours_overtime,\n                        name=f\"Hours_SW_Overtime_Total_w{w}\")\n        # Newly skilled workers - normal time\n        model.addConstr(gp.quicksum(h_nw_newly_skilled[w, p_inner]\n                                    for p_inner in products)\n                        == nw_newly_skilled_prod[w] * hours_normal,\n                        name=f\"Hours_NW_NewlySkilled_Total_w{w}\")\n    # Correction for C5: The constraints should be for the sum of hours for *that worker group* not per product.\n    # The above was trying to do it per product, fixed it to be per worker group total hours.\n\n    # C6: Production Calculation\n    for w in weeks:\n        for p in products:\n            total_hours_on_p = h_sw_normal[w, p] + h_sw_overtime[\n                w, p] + h_nw_newly_skilled[w, p]\n            model.addConstr(P[w, p] == total_hours_on_p * prod_rate[p],\n                            name=f\"ProductionCalc_w{w}_p{p}\")\n\n    # C7: Inventory Balance and Backlog Surrogate\n    for p in products:\n        for w in weeks:\n            prev_inv = Inv[w - 1, p] if w > 1 else initial_inventory[p]\n            model.addConstr(Inv[w, p] == prev_inv + P[w, p] - demand_data[p][w],\n                            name=f\"InventoryBalance_w{w}_p{p}\")\n            model.addConstr(Backlog_Surrogate[w, p] >= -Inv[w, p],\n                            name=f\"BacklogDef_w{w}_p{p}\")\n            # Backlog_Surrogate[w,p] >= 0 is already defined by lb=0 on the variable.\n    model.addConstrs((Backlog_Surrogate[8, p] == 0 for p in products),\n                     name=\"NoBacklogInWeek8\")  # No backlog in week 8\n\n    # --- Solve ---\n    model.optimize()\n\n    # --- Output Results ---\n    if model.status == GRB.OPTIMAL:\n        print(f\"\\nOptimal total cost: {model.ObjVal:.2f} yuan\\n\")\n\n        # Summary of workers allocation\n        print(\"--- Workers Allocation Summary ---\")\n        print(\n            \"Week | SW_Normal | SW_Overtime | SW_Train| NW_Training_Start | NW_Training | NW_Prod\"\n        )\n        for w in weeks:\n            print(\n                f\"{w:4} | {sw_normal[w].X:9.0f} | {sw_overtime[w].X:11.0f} | {sw_train[w].X:8.0f}| {nw_start_training[w].X:16.0f}  | {nw_training[w].X:11.0f} | {nw_newly_skilled_prod[w].X:7.0f}\"\n            )\n\n        # Production and backlog summary for each product\n        for p in products:\n            print(f\"\\n--- Production & Backlog Summary (Food {p}) ---\")\n            print(\"Week | Demand | Produced | Inventory_End | Backlog | Backlog_Penalty\")\n            for w in weeks:\n                backlog_penalty = Backlog_Surrogate[w, p].X * delay_penalty[p]\n                print(f\"{w:4} | {demand_data[p][w]:6} | {P[w, p].X:8.2f} | {Inv[w, p].X:14.2f} | {Backlog_Surrogate[w, p].X:7.2f} | {backlog_penalty:15.2f}\")\n\n    elif model.status == GRB.INFEASIBLE:\n        print(\"Model is infeasible. Computing IIS to find conflicting constraints...\")\n        model.computeIIS()\n        model.write(\"factory_model.ilp\")  # Write the IIS to a file\n        print(\"IIS written to factory_model.ilp. Please check this file to identify the cause of infeasibility.\")\n    else:\n        print(f\"Optimization ended with status: {model.status}\")\n\n    return model\n\n\nif __name__ == '__main__':\n    # Correcting the C5 constraint definition logic which was duplicated per product inside the loop.\n    # It should be one constraint per worker group per week.\n\n    # Create a temporary model instance to correct C5 structure before calling solve_factory_problem\n    temp_model = gp.Model()\n    weeks_param = range(1, 9)\n    products_param = [1, 2]\n    sw_normal_param = temp_model.addVars(\n        weeks_param, name=\"SW_Normal_param\")  # dummy for structure\n    h_sw_normal_param = temp_model.addVars(weeks_param,\n                                           products_param,\n                                           name=\"H_SW_Normal_param\")\n\n    # Corrected C5 logic demonstration (this is conceptual, actual fix is in the main function)\n    # for w_param in weeks_param:\n    #     temp_model.addConstr(gp.quicksum(h_sw_normal_param[w_param, p_param] for p_param in products_param) <= sw_normal_param[w_param] * hours_normal,\n    #                     name=f\"Hours_SW_Normal_Total_w{w_param}\")\n    # This logic IS correctly implemented in the solve_factory_problem function. The loop for 'p_idx, p_val' in C5 was misleading in my thought process but the gurobipy quicksum over products for each worker group is the correct implementation.\n\n    solved_model = solve_factory_problem()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 21,
    "retrieved_insights": []
  },
  {
    "task_id": "B039",
    "description": "The independent country of Carelland mainly exports four commodities: steel, engines, electronic components, and plastic. Carelland's Minister of Finance (i.e., Minister of Economy) wants to maximize exports and minimize imports. The unit prices of steel, engines, electronics, and plastic on the world market are, in local currency (Klunz), 500, 1500, 300, 1200 respectively. Producing 1 unit of steel requires 0.02 units of engines, 0.01 units of plastic, 250 Klunz of other imported goods, and 6 person-months of labor. Producing 1 unit of engines requires 0.8 units of steel, 0.15 units of electronic components, 0.11 units of plastic, 300 Klunz of imported goods, and 1 person-year. One unit of electronics requires: 0.01 units of steel, 0.01 units of engines, 0.05 units of plastic, 50 Klunz of imported goods, and 6 person-months of labor. One unit of plastic requires: 0.03 units of engines, 0.2 units of steel, 0.05 units of electronic components, 300 Klunz of imported goods, and 2 person-years. Engine production is limited to 650000 units, and plastic production is limited to 60000 units. The total available labor force per year is 830000 person-months. Write a mathematical program to maximize domestic GDP and solve the problem using AMPL.",
    "ground_truth": 36288567.04,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Carelland_GDP_Maximization\")\n\n# Define the commodities\ncommodities = [\"steel\", \"engines\", \"electronics\", \"plastic\"]\n\n# Unit prices in local currency (Klunz)\nunit_price = {\n    \"steel\": 500,\n    \"engines\": 1500,\n    \"electronics\": 300,\n    \"plastic\": 1200\n}\n\n# Input requirements matrix:\n# input_requirements[output][input] = amount of input needed to produce 1 unit of output\ninput_requirements = {\n    \"steel\": {\n        \"engines\": 0.02,\n        \"plastic\": 0.01,\n        \"steel\": 0,\n        \"electronics\": 0\n    },\n    \"engines\": {\n        \"steel\": 0.8,\n        \"electronics\": 0.15,\n        \"plastic\": 0.11,\n        \"engines\": 0\n    },\n    \"electronics\": {\n        \"steel\": 0.01,\n        \"engines\": 0.01,\n        \"plastic\": 0.05,\n        \"electronics\": 0\n    },\n    \"plastic\": {\n        \"steel\": 0.2,\n        \"engines\": 0.03,\n        \"electronics\": 0.05,\n        \"plastic\": 0\n    }\n}\n\n# Additional imported goods required (in Klunz)\nimported_goods = {\n    \"steel\": 250,\n    \"engines\": 300,\n    \"electronics\": 50,\n    \"plastic\": 300\n}\n\n# Labor requirements (in person-months)\nlabor_requirements = {\n    \"steel\": 6,  # 6 person-months\n    \"engines\": 12,  # 1 person-year = 12 person-months\n    \"electronics\": 6,  # 6 person-months\n    \"plastic\": 24  # 2 person-years = 24 person-months\n}\n\n# Production limits\nproduction_limits = {\"engines\": 650000, \"plastic\": 60000}\n\n# Total available labor force (in person-months)\ntotal_labor = 830000\n\n# Decision variables: quantity of each commodity to produce\nx = {}\nfor commodity in commodities:\n    x[commodity] = model.addVar(vtype=GRB.CONTINUOUS,\n                                name=f\"produce_{commodity}\")\n\n# Net export variables (production minus domestic consumption)\nnet_export = {}\nfor commodity in commodities:\n    net_export[commodity] = model.addVar(vtype=GRB.CONTINUOUS,\n                                         name=f\"net_export_{commodity}\")\n\n# Add constraints\n# 1. Commodity balance constraints\nfor commodity in commodities:\n    # Net export = production - domestic consumption\n    model.addConstr(\n        net_export[commodity] == x[commodity] -\n        gp.quicksum(input_requirements[other][commodity] * x[other]\n                    for other in commodities), f\"balance_{commodity}\")\n\n# 2. Production limit constraints\nfor commodity, limit in production_limits.items():\n    model.addConstr(x[commodity] <= limit, f\"limit_{commodity}\")\n\n# 3. Labor constraint\nmodel.addConstr(\n    gp.quicksum(labor_requirements[commodity] * x[commodity]\n                for commodity in commodities) <= total_labor,\n    \"labor_constraint\")\n\n# 4. Non-negativity constraint for net exports (assuming we can't import these commodities)\nfor commodity in commodities:\n    model.addConstr(net_export[commodity] >= 0,\n                    f\"non_negative_export_{commodity}\")\n\n# Objective function: Maximize GDP (value of production minus cost of imported goods)\ngdp = gp.quicksum(unit_price[commodity] * net_export[commodity]\n                  for commodity in commodities) - gp.quicksum(\n                      imported_goods[commodity] * x[commodity]\n                      for commodity in commodities)\n\nmodel.setObjective(gdp, GRB.MAXIMIZE)\n\n# Optimize the model\nmodel.optimize()\n\n# Print the results\nprint(\"\\n=== OPTIMAL SOLUTION ===\")\nif model.status == GRB.OPTIMAL:\n    print(\"\\nProduction Quantities:\")\n    for commodity in commodities:\n        print(f\"{commodity.capitalize()}: {x[commodity].X:.2f} units\")\n\n    print(\"\\nNet Exports:\")\n    for commodity in commodities:\n        print(f\"{commodity.capitalize()}: {net_export[commodity].X:.2f} units\")\n\n    print(\"\\nCost of Imported Goods:\")\n    total_import_cost = sum(imported_goods[commodity] * x[commodity].X\n                            for commodity in commodities)\n    print(f\"Total: {total_import_cost:.2f} Klunz\")\n\n    print(\"\\nValue of Exported Goods:\")\n    total_export_value = sum(unit_price[commodity] * net_export[commodity].X\n                             for commodity in commodities)\n    print(f\"Total: {total_export_value:.2f} Klunz\")\n\n    print(f\"\\nMaximum GDP: {model.ObjVal:.2f} Klunz\")\n\n    # Calculate and print resource utilization\n    labor_used = sum(labor_requirements[commodity] * x[commodity].X\n                     for commodity in commodities)\n    print(\n        f\"\\nLabor Used: {labor_used:.2f} person-months (out of {total_labor})\")\n\n    for commodity, limit in production_limits.items():\n        utilization = (x[commodity].X / limit) * 100 if limit > 0 else 0\n        print(\n            f\"{commodity.capitalize()} Production Capacity Used: {utilization:.2f}%\"\n        )\nelse:\n    print(f\"Optimization failed. Status code: {model.status}\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "National Economy"
      }
    ],
    "cluster": 9,
    "retrieved_insights": []
  },
  {
    "task_id": "A016",
    "description": "An electronics store wants to optimize how many phones and laptops are enough to keep in inventory. A phone will earn the store $120 in profits, and a laptop will earn $40. A phone requires 1 sq ft of floor space, whereas a laptop requires 4 sq ft. In total, 400 sq ft of floor space is available. The store stocks only phones and laptops. Corporate has required that at least 80% of all appliances in stock be laptops. Finally, a phone costs $400 for the store, and a laptop, $100. The store wants to spend at most $6000. Formulate an LP that can be used to maximize the store's profit.",
    "ground_truth": 2400.0,
    "formulation": null,
    "correct_program": "def optimize_inventory(\n    max_floor_space=400,\n    profit_phone=120,\n    profit_laptop=40,\n    space_phone=1,\n    space_laptop=4,\n    max_budget=6000,\n    cost_phone=400,\n    cost_laptop=100,\n    min_laptop_ratio=0.8\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"InventoryOptimization\")\n\n    # Decision variables: number of phones and laptops\n    x = model.addVar(name=\"phones\", vtype=GRB.INTEGER, lb=0)\n    y = model.addVar(name=\"laptops\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: maximize profit\n    model.setObjective(profit_phone * x + profit_laptop * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Floor space constraint\n    model.addConstr(space_phone * x + space_laptop * y <= max_floor_space, \"FloorSpace\")\n    # Stock composition constraint: y >= 4x (80% laptops)\n    model.addConstr(y >= min_laptop_ratio * (x + y), \"LaptopRatio\")\n    # Budget constraint\n    model.addConstr(cost_phone * x + cost_laptop * y <= max_budget, \"Budget\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_inventory()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Inventory Management",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 5,
    "retrieved_insights": []
  },
  {
    "task_id": "B015",
    "description": "A store plans to formulate the purchasing and sales plan for a certain product for the first quarter of next year. It is known that the warehouse capacity of the store can store up to 500 units of the product, and there are 200 units in stock at the end of this year. The store purchases goods once at the beginning of each month. The purchasing and selling prices of the product in each month are shown in Table 1.3.\n\nTable 1.3\n\n| Month | 1 | 2 | 3 |\n| :---: | :---: | :---: | :---: |\n| Purchasing Price (Yuan) | 8 | 6 | 9 |\n| Selling Price (Yuan) | 9 | 8 | 10 |\n\nNow, determine how many units should be purchased and sold each month to maximize the total profit, and express this problem as a linear programming model.",
    "ground_truth": 4100.0,
    "formulation": null,
    "correct_program": "from gurobipy import Model, GRB\n\n# 创建模型\nmodel = Model(\"Procurement_and_Sales_Plan\")\n\n# 数据输入\npurchase_prices = [8, 6, 9]\nsell_prices = [9, 8, 10]\nmonths = range(3)  # 0-based index for months 1, 2, 3\n\n# 变量定义\nx = model.addVars(months, vtype=GRB.INTEGER, name=\"Purchase\", lb=0)  # 采购量\ny = model.addVars(months, vtype=GRB.INTEGER, name=\"Sell\", lb=0)  # 销售量\ns = model.addVars(months, vtype=GRB.INTEGER, name=\"Inventory\", lb=0)  # 库存量\n\n# 初始库存\ninitial_inventory = 200\n\n# 添加库存约束\nfor t in months:\n    if t == 0:\n        prev_inventory = initial_inventory\n    else:\n        prev_inventory = s[t - 1]\n\n    # 库存平衡方程\n    model.addConstr(s[t] == prev_inventory + x[t] - y[t],\n                    name=f\"Inventory_Balance_{t+1}\")\n\n    # 库存不超过容量\n    model.addConstr(s[t] <= 500, name=f\"Inventory_Capacity_{t+1}\")\n    model.addConstr(prev_inventory + x[t] <= 500, name=f\"Inventory_Capacity2_{t+1}\")\n\n    # 销售不能超过当前库存\n    model.addConstr(y[t] <= prev_inventory + x[t], name=f\"Sales_Limit_{t+1}\")\n\n# 目标函数：最大化利润\nprofit = sum(\n    (sell_prices[t] * y[t] - purchase_prices[t] * x[t]) for t in months)\nmodel.setObjective(profit, GRB.MAXIMIZE)\n\n# 求解\nmodel.optimize()\n\n# 输出结果\nif model.status == GRB.OPTIMAL:\n    print(\"\\nOptimal solution found:\")\n    for t in months:\n        print(\n            f\"Month {t+1}: \"\n            f\"Purchased = {x[t].X:.0f}, Sold = {y[t].X:.0f}, Inventory = {s[t].X:.0f}\"\n        )\n    print(f\"\\nTotal Profit = {model.objVal:.2f} yuan\")\nelse:\n    print(\"No optimal solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Inventory Management",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B049",
    "description": "A store has formulated a purchase and sales plan for a certain product from July to December. It is known that the warehouse capacity must not exceed 500 units, with 200 units in stock at the end of June. Thereafter, purchases are made at the beginning of each month. Assume the purchase and selling prices of this product for each month are shown in Table 1-21. How much should be purchased and sold each month to maximize the total revenue?\n\nTable 1-21\n| Month | 7  | 8  | 9  | 10 | 11 | 12 |\n|-------|----|----|----|----|----|----|\n| Buy   | 28 | 24 | 25 | 27 | 23 | 23 |\n| Sell  | 29 | 24 | 26 | 28 | 22 | 25 |",
    "ground_truth": 9100.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_purchase_sales_plan():\n    \"\"\"\n    Solves the purchase and sales planning problem to maximize total profit\n    over a 6-month period, subject to warehouse capacity and inventory flow.\n    \"\"\"\n    try:\n        # --- Data ---\n        months = ['Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n        num_months = len(months)\n\n        # Purchase prices (yuan/unit) for each month\n        purchase_prices = [28, 24, 25, 27, 23, 23]\n\n        # Selling prices (yuan/unit) for each month\n        selling_prices = [29, 24, 26, 28, 22, 25]\n\n        # Warehouse capacity\n        warehouse_capacity = 500  # units\n\n        # Initial inventory at the end of June (start of July)\n        initial_inventory = 200  # units\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"PurchaseSalesPlan\")\n\n        # --- Decision Variables ---\n        # Buy[t]: quantity purchased at the beginning of month t\n        buy_vars = model.addVars(num_months,\n                                 name=\"Buy\",\n                                 lb=0.0,\n                                 vtype=GRB.INTEGER)\n\n        # Sell[t]: quantity sold during month t\n        sell_vars = model.addVars(num_months,\n                                  name=\"Sell\",\n                                  lb=0.0,\n                                  vtype=GRB.INTEGER)\n\n        # Inv[t]: inventory at the end of month t\n        inventory_vars = model.addVars(num_months,\n                                       name=\"Inventory\",\n                                       lb=0.0,\n                                       vtype=GRB.INTEGER)\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = (Selling Price * Amount Sold) - (Purchase Price * Amount Purchased)\n        total_profit = gp.quicksum(selling_prices[t] * sell_vars[t] -\n                                   purchase_prices[t] * buy_vars[t]\n                                   for t in range(num_months))\n        model.setObjective(total_profit, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        for t in range(num_months):\n            # Inventory at the start of the current month t\n            inventory_at_start_of_month_t = initial_inventory if t == 0 else inventory_vars[\n                t - 1]\n\n            # 1. Inventory Balance Constraint\n            # Inv[t] = Inv_at_start_of_month_t + Buy[t] - Sell[t]\n            model.addConstr(\n                inventory_vars[t] == inventory_at_start_of_month_t +\n                buy_vars[t] - sell_vars[t],\n                name=f\"InventoryBalance_{months[t]}\")\n\n            # 2. Warehouse Capacity Constraint\n            # Inv[t] <= warehouse_capacity\n            model.addConstr(inventory_vars[t] <= warehouse_capacity,\n                            name=f\"WarehouseCapacity_{months[t]}\")\n\n            # 3. Sales Constraint\n            # Sell[t] <= Inv_at_start_of_month_t + Buy[t]\n            model.addConstr(sell_vars[t]\n                            <= inventory_at_start_of_month_t + buy_vars[t],\n                            name=f\"SalesLimit_{months[t]}\")\n            model.addConstr(inventory_at_start_of_month_t + buy_vars[t] <= warehouse_capacity, name=f\"InventoryLimit_{months[t]}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal purchase and sales plan found.\")\n            print(f\"Maximum Total Profit: {model.ObjVal:.2f} Yuan\")\n\n            print(\"\\nMonthly Plan Details:\")\n            print(\n                f\"{'Month':<5} | {'Purchase Price':<15} | {'Selling Price':<15} | {'Buy (Units)':<12} | {'Sell (Units)':<12} | {'End Inventory':<15}\"\n            )\n            print(\"-\" * 90)\n\n            current_inventory = initial_inventory\n            for t in range(num_months):\n                print(\n                    f\"{months[t]:<5} | {purchase_prices[t]:<15.2f} | {selling_prices[t]:<15.2f} | \"\n                    f\"{buy_vars[t].X:<12.2f} | {sell_vars[t].X:<12.2f} | {inventory_vars[t].X:<15.2f}\"\n                )\n                current_inventory = inventory_vars[\n                    t].X  # For manual check if needed\n\n            print(\"-\" * 90)\n            print(\n                f\"\\nInitial Inventory (End of June): {initial_inventory:.2f} units\"\n            )\n            print(\n                f\"Final Inventory (End of December): {inventory_vars[num_months-1].X:.2f} units\"\n            )\n\n            # Note on \"total revenue\" interpretation\n            print(\n                \"\\nNote: The objective was interpreted as maximizing total profit (Sales Revenue - Purchase Costs).\"\n            )\n            print(\n                \"If 'total revenue' strictly means only Sales Revenue, the objective function would need to be changed.\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"purchase_sales_iis.ilp\")\n            # print(\"IIS written to purchase_sales_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_purchase_sales_plan()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Inventory Management",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "B023",
    "description": "A manufacturing company needs to transport 1800 units of product from the warehouse to three different sales points. The company has four transportation options to choose from: truck, van, motorcycle, and electric vehicle. Since the van and electric vehicle both consume a lot of energy, the company wants to choose only one of these two options. Each trip with a truck generates 100 units of pollution, a van generates 50 units of pollution, a motorcycle generates 10 units of pollution, and an electric vehicle generates 0 units of pollution. The total pollution generated from all trips cannot exceed 2000 units. At least 10 trips must use a truck. Trucks, vans, motorcycles, and electric vehicles can transport 100 units, 80 units, 40 units, and 60 units of product per trip, respectively. The company needs to ensure that the total amount of transported product is at least 1800 units.",
    "ground_truth": 1000.0,
    "formulation": null,
    "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TransportationOptimization\")\n\n    # Decision variables\n    T = m.addVar(name=\"TruckTrips\", lb=10, vtype=GRB.INTEGER)\n    V = m.addVar(name=\"VanTrips\", lb=0, vtype=GRB.INTEGER)\n    M = m.addVar(name=\"MotorcycleTrips\", lb=0, vtype=GRB.INTEGER)\n    E = m.addVar(name=\"ElectricTrips\", lb=0, vtype=GRB.INTEGER)\n\n    y_V = m.addVar(name=\"UseVan\", vtype=GRB.BINARY)\n    y_E = m.addVar(name=\"UseElectric\", vtype=GRB.BINARY)\n\n    m.update()\n\n    # Set objective: minimize total pollution\n    m.setObjective(100 * T + 50 * V * y_V + 10 * M, GRB.MINIMIZE)\n\n    # Constraints\n    # Total units transported\n    m.addConstr(100 * T + 80 * V * y_V + 40 * M + 60 * E * y_E >= 1800,\n                name=\"Demand\")\n\n    # Pollution limit\n    m.addConstr(100 * T + 50 * V * y_V + 10 * M <= 2000, name=\"PollutionLimit\")\n\n    # Van/Electric vehicle exclusivity\n    m.addConstr(y_V + y_E <= 1, name=\"ModeChoice\")\n\n    # Minimum truck trips\n    m.addConstr(T >= 10, name=\"MinTruckTrips\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_transportation()\n    if result is not None:\n        print(f\"Optimal total pollution: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Transportation Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 13,
    "retrieved_insights": []
  },
  {
    "task_id": "B082",
    "description": "A certain restaurant operates around the clock, and the number of waiters needed in 24 hours is shown in Table 1.1.\n\nTable 1.1\n\n| Time        | Minimum Number of Waiters Needed | Time        | Minimum Number of Waiters Needed |\n|:-----------:|:-------------------------------:|:-----------:|:-------------------------------:|\n| $2 \\sim 6$  | 4                                | $14 \\sim 18$| 7                                |\n| $6 \\sim 10$ | 8                                | $18 \\sim 22$| 12                               |\n| $10 \\sim 14$| 10                               | $22 \\sim 2$ | 4                                |\n\nEach waiter works continuously for 8 hours a day. The goal is to find the minimum number of waiters that meet the above conditions and represent this problem as a linear programming model.",
    "ground_truth": 26.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_restaurant_staffing():\n    \"\"\"\n    Solves the restaurant waiter staffing problem to minimize the total number of\n    waiters needed, subject to demand coverage constraints.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"RestaurantStaffing\")\n\n        # --- Data ---\n        # Demands for each 4-hour period, ordered chronologically\n        # Period 0: 2:00-6:00\n        # Period 1: 6:00-10:00\n        # Period 2: 10:00-14:00\n        # Period 3: 14:00-18:00\n        # Period 4: 18:00-22:00\n        # Period 5: 22:00-2:00 (next day)\n        demands = {\n            0: 4,  # 2:00 - 6:00\n            1: 8,  # 6:00 - 10:00\n            2: 10,  # 10:00 - 14:00\n            3: 7,  # 14:00 - 18:00\n            4: 12,  # 18:00 - 22:00\n            5: 4  # 22:00 - 2:00 (next day)\n        }\n        num_periods = len(demands)  # Should be 6\n\n        # Shift start times descriptions for output\n        shift_start_times_desc = [\n            \"2:00\", \"6:00\", \"10:00\", \"14:00\", \"18:00\", \"22:00\"\n        ]\n        period_desc = [\n            \"2:00-6:00\", \"6:00-10:00\", \"10:00-14:00\", \"14:00-18:00\",\n            \"18:00-22:00\", \"22:00-2:00\"\n        ]\n\n        # --- Decision Variables ---\n        # x[t]: number of waiters starting their 8-hour shift at the beginning of period t\n        x = model.addVars(num_periods,\n                          vtype=GRB.INTEGER,\n                          name=\"x_waiters\",\n                          lb=0)\n\n        # --- Objective Function ---\n        # Minimize the total number of waiters hired\n        model.setObjective(gp.quicksum(x[t] for t in range(num_periods)),\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # Demand coverage for each period.\n        # Each waiter works for 8 hours, covering two 4-hour periods.\n\n        # Period 0 (2:00-6:00): Covered by staff starting at 22:00 (x[5]) and 2:00 (x[0])\n        model.addConstr(x[5] + x[0] >= demands[0], \"Demand_P0\")\n\n        # Period 1 (6:00-10:00): Covered by staff starting at 2:00 (x[0]) and 6:00 (x[1])\n        model.addConstr(x[0] + x[1] >= demands[1], \"Demand_P1\")\n\n        # Period 2 (10:00-14:00): Covered by staff starting at 6:00 (x[1]) and 10:00 (x[2])\n        model.addConstr(x[1] + x[2] >= demands[2], \"Demand_P2\")\n\n        # Period 3 (14:00-18:00): Covered by staff starting at 10:00 (x[2]) and 14:00 (x[3])\n        model.addConstr(x[2] + x[3] >= demands[3], \"Demand_P3\")\n\n        # Period 4 (18:00-22:00): Covered by staff starting at 14:00 (x[3]) and 18:00 (x[4])\n        model.addConstr(x[3] + x[4] >= demands[4], \"Demand_P4\")\n\n        # Period 5 (22:00-2:00): Covered by staff starting at 18:00 (x[4]) and 22:00 (x[5])\n        model.addConstr(x[4] + x[5] >= demands[5], \"Demand_P5\")\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal staffing plan found.\")\n            print(f\"Minimum total waiters needed: {model.ObjVal:.0f}\")\n\n            print(\"\\nNumber of Waiters Starting Each Shift:\")\n            print(f\"{'Start Time':<12} | {'Number of Waiters':<15}\")\n            print(\"-\" * 30)\n            for t in range(num_periods):\n                print(f\"{shift_start_times_desc[t]:<12} | {x[t].X:<15.0f}\")\n\n            print(\"\\nVerification of Coverage per Period:\")\n            coverage = [0] * num_periods\n            coverage[0] = x[5].X + x[0].X\n            coverage[1] = x[0].X + x[1].X\n            coverage[2] = x[1].X + x[2].X\n            coverage[3] = x[2].X + x[3].X\n            coverage[4] = x[3].X + x[4].X\n            coverage[5] = x[4].X + x[5].X\n\n            for p_idx in range(num_periods):\n                print(\n                    f\"  Period {period_desc[p_idx]} (Demand: {demands[p_idx]}): Covered by {coverage[p_idx]:.0f} waiters\"\n                )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_restaurant_staffing()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Scheduling",
        "modeling_type": "MILP",
        "industry_sector": "Hospitality"
      }
    ],
    "cluster": 10,
    "retrieved_insights": []
  },
  {
    "task_id": "B037",
    "description": "There are three different products to be processed on three machine tools. Each product must first be processed on machine 1, then sequentially on machines 2 and 3. The order of processing the three products on each machine should remain the same. Assuming $t_{ij}$ represents the time to process the $i$-th product on the $j$-th machine, how should the schedule be arranged to minimize the total processing cycle for the three products? The timetable is as follows:\n| Product | Machine 1 | Machine 2 | Machine 3 |\n|---------|-----------|-----------|-----------|\n| Product 1 | 2           | 3           | 1           |\n| Product 2 | 4           | 2           | 3           |\n| Product 3 | 3           | 5           | 2           |",
    "ground_truth": 14.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_permutation_flow_shop():\n    \"\"\"\n    Solves a 3-product, 3-machine permutation flow shop scheduling problem\n    to minimize the makespan (total processing cycle).\n    \"\"\"\n    try:\n        # --- Data ---\n        # Processing times: t[product_idx][machine_idx]\n        # Product 1 (idx 0), Product 2 (idx 1), Product 3 (idx 2)\n        # Machine 1 (idx 0), Machine 2 (idx 1), Machine 3 (idx 2)\n        processing_times_data = [\n            [2, 3, 1],  # Product 1\n            [4, 2, 3],  # Product 2\n            [3, 5, 2]  # Product 3\n        ]\n\n        num_products = len(processing_times_data)\n        num_machines = len(processing_times_data[0])\n\n        products = range(num_products)  # Indices {0, 1, 2}\n        machines = range(num_machines)  # Indices {0, 1, 2}\n        positions = range(num_products)  # Sequence positions {0, 1, 2}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"PermutationFlowShop\")\n\n        # --- Decision Variables ---\n        # z[p,k]: 1 if product p is in k-th sequence position, 0 otherwise\n        z = model.addVars(products, positions, vtype=GRB.BINARY, name=\"z\")\n\n        # S[k,m]: Start time of the product in k-th sequence position on machine m\n        S = model.addVars(positions,\n                          machines,\n                          vtype=GRB.CONTINUOUS,\n                          name=\"S\",\n                          lb=0.0)\n\n        # C_max: Makespan (total processing cycle)\n        C_max = model.addVar(vtype=GRB.CONTINUOUS, name=\"C_max\", lb=0.0)\n\n        # --- Objective Function: Minimize Makespan ---\n        model.setObjective(C_max, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Assignment Constraints:\n        # Each product p is assigned to exactly one position k\n        for p in products:\n            model.addConstr(gp.quicksum(z[p, k] for k in positions) == 1,\n                            name=f\"ProductPos_{p}\")\n\n        # Each position k is filled by exactly one product p\n        for k in positions:\n            model.addConstr(gp.quicksum(z[p, k] for p in products) == 1,\n                            name=f\"PosProduct_{k}\")\n\n        # 2. Scheduling Constraints:\n        # PT[k,m] = processing time of product in k-th position on machine m\n        # This is not a variable but an expression used in constraints.\n\n        for k in positions:\n            for m in machines:\n                # Processing time of the job in k-th position on machine m\n                pt_km = gp.quicksum(z[p, k] * processing_times_data[p][m]\n                                    for p in products)\n\n                # Constraint for job processing sequence (same product, different machines)\n                if m > 0:\n                    # Processing time of the job in k-th position on machine m-1\n                    pt_k_m_minus_1 = gp.quicksum(\n                        z[p, k] * processing_times_data[p][m - 1]\n                        for p in products)\n                    model.addConstr(S[k, m] >= S[k, m - 1] + pt_k_m_minus_1,\n                                    name=f\"JobSeq_pos{k}_mach{m}\")\n\n                # Constraint for machine processing sequence (same machine, different products)\n                if k > 0:\n                    # Processing time of the job in (k-1)-th position on machine m\n                    pt_k_minus_1_m = gp.quicksum(z[p, k - 1] *\n                                                 processing_times_data[p][m]\n                                                 for p in products)\n                    model.addConstr(S[k, m] >= S[k - 1, m] + pt_k_minus_1_m,\n                                    name=f\"MachSeq_pos{k}_mach{m}\")\n\n        # The start time of the first product (position 0) on the first machine (machine 0)\n        # S[0,0] >= 0 is already handled by lb=0.0.\n        # We can fix it to 0 if desired: S[0,0].ub = 0 or model.addConstr(S[0,0] == 0)\n\n        # 3. Makespan Definition:\n        # C_max >= Completion time of the last product (pos N-1) on the last machine (mach NM-1)\n        last_pos = num_products - 1\n        last_mach = num_machines - 1\n        pt_last_job_last_machine = gp.quicksum(\n            z[p, last_pos] * processing_times_data[p][last_mach]\n            for p in products)\n        model.addConstr(C_max\n                        >= S[last_pos, last_mach] + pt_last_job_last_machine,\n                        name=\"MakespanDef\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal schedule found.\")\n            print(\n                f\"Minimum Total Processing Cycle (Makespan): {C_max.X:.2f} hours\"\n            )\n\n            print(\"\\nOptimal Product Sequence:\")\n            optimal_sequence_indices = [0] * num_products\n            for p in products:\n                for k in positions:\n                    if z[p, k].X > 0.5:  # Check if z[p,k] is 1\n                        optimal_sequence_indices[\n                            k] = p + 1  # Store product number (1-indexed)\n            print(\" -> \".join(map(str, optimal_sequence_indices)))\n\n            print(\n                \"\\nDetailed Schedule (Start Times S_km for product in k-th position on machine m):\"\n            )\n            print(\n                \"Pos = Position in Sequence, P# = Product Number, M# = Machine Number\"\n            )\n            for k in positions:\n                actual_product_idx = -1\n                for p_idx in products:\n                    if z[p_idx, k].X > 0.5:\n                        actual_product_idx = p_idx\n                        break\n\n                print(\n                    f\"\\n  Product at Sequence Position {k+1} (Actual Product {actual_product_idx+1}):\"\n                )\n                for m in machines:\n                    pt_val = processing_times_data[actual_product_idx][m]\n                    completion_time = S[k, m].X + pt_val\n                    print(\n                        f\"    Machine {m+1}: Start = {S[k,m].X:.2f}, Processing Time = {pt_val:.2f}, Completion = {completion_time:.2f}\"\n                    )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_permutation_flow_shop()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Scheduling",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 16,
    "retrieved_insights": []
  },
  {
    "task_id": "B034",
    "description": "A fabric dyeing plant has 3 dyeing vats. Each batch of fabric must be dyed in sequence in each vat: first, the second, and third vats. The plant must color five batches of fabric of different sizes. The time required in hours to dye batch $i$ in vat $j$ is given in the following matrix:\n\n$$\n\\left(\\begin{array}{ccc}\n3 & 1 & 1 \\\\\n2 & 1.5 & 1 \\\\\n3 & 1.2 & 1.3 \\\\\n2 & 2 & 2 \\\\\n2.1 & 2 & 3\n\\end{array}\\right)\n$$\n\nSchedule the dyeing operations in the vats to minimize the completion time of the last batch.",
    "ground_truth": 14.1,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_dyeing_plant_scheduling():\n    \"\"\"\n    Solves the dyeing plant scheduling problem to minimize the makespan (completion time of the last batch).\n    This is a flow shop scheduling problem.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Processing times p[i][j] for batch i on vat j (hours)\n        # Rows: Batches (0 to 4), Columns: Vats (0 to 2)\n        processing_times = [\n            [3, 1, 1],  # Batch 0\n            [2, 1.5, 1],  # Batch 1\n            [3, 1.2, 1.3],  # Batch 2\n            [2, 2, 2],  # Batch 3\n            [2.1, 2, 3]  # Batch 4\n        ]\n\n        num_batches = len(processing_times)\n        num_vats = len(processing_times[0])\n\n        batches = range(num_batches)\n        vats = range(num_vats)\n\n        # Calculate Big-M: Sum of all processing times is a safe upper bound for L\n        # and also an upper bound for any start time or makespan.\n        L = sum(sum(row)\n                for row in processing_times) * 2  # A sufficiently large number\n\n        # --- Create a new model ---\n        model = gp.Model(\"DyeingPlantScheduling\")\n\n        # --- Decision Variables ---\n        # s[i,j]: start time of batch i on vat j\n        s = model.addVars(batches,\n                          vats,\n                          name=\"s\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # C_max: makespan (completion time of the last batch on the last vat)\n        C_max = model.addVar(name=\"C_max\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # x[i,k,j]: binary variable, 1 if batch i precedes batch k on vat j, 0 otherwise\n        # Defined for i < k to avoid redundant pairs\n        x = {}\n        for j in vats:\n            for i in batches:\n                for k in batches:\n                    if i < k:\n                        x[i, k, j] = model.addVar(vtype=GRB.BINARY,\n                                                  name=f\"x_{i}_{k}_{j}\")\n\n        # --- Objective Function ---\n        # Minimize the makespan\n        model.setObjective(C_max, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Job Precedence Constraints (operations within the same batch)\n        # s_ij >= s_i,(j-1) + p_i,(j-1)\n        for i in batches:\n            for j in vats:\n                if j > 0:  # For vats 1 and 2 (0-indexed)\n                    model.addConstr(s[i, j] >= s[i, j - 1] +\n                                    processing_times[i][j - 1],\n                                    name=f\"JobPrecedence_b{i}_v{j}\")\n\n        # 2. Machine Capacity Constraints (Disjunctive constraints for operations on the same vat)\n        # For each vat j, and for each pair of batches i, k where i < k:\n        # s_kj >= s_ij + p_ij - L * (1 - x_ikj)\n        # s_ij >= s_kj + p_kj - L * x_ikj\n        for j in vats:\n            for i in batches:\n                for k in batches:\n                    if i < k:\n                        model.addConstr(s[k, j]\n                                        >= s[i, j] + processing_times[i][j] -\n                                        L * (1 - x[i, k, j]),\n                                        name=f\"MachineCap1_v{j}_b{i}_b{k}\")\n                        model.addConstr(s[i, j]\n                                        >= s[k, j] + processing_times[k][j] -\n                                        L * x[i, k, j],\n                                        name=f\"MachineCap2_v{j}_b{i}_b{k}\")\n\n        # 3. Makespan Definition\n        # C_max >= completion time of batch i on the last vat\n        # C_max >= s_i,(M-1) + p_i,(M-1)\n        last_vat_idx = num_vats - 1\n        for i in batches:\n            model.addConstr(C_max >= s[i, last_vat_idx] +\n                            processing_times[i][last_vat_idx],\n                            name=f\"Makespan_b{i}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n        model.setParam('MIPGap',\n                       0.01)  # Set a MIP gap for faster convergence if needed\n        model.setParam('TimeLimit',\n                       120)  # Set a time limit (e.g., 120 seconds)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL or model.status == GRB.TIME_LIMIT and model.SolCount > 0:\n            if model.status == GRB.TIME_LIMIT:\n                print(\n                    \"Optimal solution not found within time limit. Displaying best solution found.\"\n                )\n            else:\n                print(\"Optimal solution found.\")\n\n            print(f\"\\nMinimum Makespan (C_max): {C_max.X:.2f} hours\")\n\n            print(\"\\nSchedule (Start Times s_ij):\")\n            for i in batches:\n                print(f\"  Batch {i+1}:\")\n                for j in vats:\n                    completion_time = s[i, j].X + processing_times[i][j]\n                    print(\n                        f\"    Vat {j+1}: Start = {s[i,j].X:.2f}, End = {completion_time:.2f} (Duration: {processing_times[i][j]})\"\n                    )\n\n            print(\"\\nSequence on Vats (derived from start times):\")\n            for j in vats:\n                vat_schedule = []\n                for i in batches:\n                    vat_schedule.append({\n                        'batch': i + 1,\n                        'start_time': s[i, j].X,\n                        'proc_time': processing_times[i][j]\n                    })\n\n                # Sort batches by start time on this vat\n                vat_schedule.sort(key=lambda e: e['start_time'])\n\n                sequence_str = \" -> \".join([\n                    f\"B{e['batch']}({e['start_time']:.2f}-{e['start_time']+e['proc_time']:.2f})\"\n                    for e in vat_schedule\n                ])\n                print(f\"  Vat {j+1} Sequence: {sequence_str}\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"dyeing_plant_iis.ilp\")\n            # print(\"IIS written to dyeing_plant_iis.ilp.\")\n        elif model.status == GRB.TIME_LIMIT and model.SolCount == 0:\n            print(\"No solution found within the time limit.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_dyeing_plant_scheduling()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Scheduling",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 16,
    "retrieved_insights": []
  },
  {
    "task_id": "B073",
    "description": "A project includes the following 7 activities, with their durations (in days) as follows: $A(4), B(3), C(5), D(2), E(10), F(10), G(1)$. The precedence relationships are also given as: $A \\rightarrow G, D ; E, G \\rightarrow F; D, F \\rightarrow C ; F \\rightarrow B$. The cost of work per day is 1000 Euros; additionally, a special machine must be rented from the start of activity $A$ to the end of activity $B$, costing 5000 Euros per day. Formulate this as a linear programming problem and solve it using COPTPY.",
    "ground_truth": 115000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_project_scheduling_cost_minimization():\n    \"\"\"\n    Solves the project scheduling problem to minimize total cost,\n    including work costs and special machine rental costs.\n    \"\"\"\n    try:\n        # --- Data ---\n        activities = ['A', 'B', 'C', 'D', 'E', 'F', 'G']\n\n        durations = {\n            'A': 4,\n            'B': 3,\n            'C': 5,\n            'D': 2,\n            'E': 10,\n            'F': 10,\n            'G': 1\n        }  # days\n\n        cost_work_per_day = 1000  # Euros/day\n        cost_machine_per_day = 5000  # Euros/day\n\n        # Precedence relationships: predecessor -> successor(s)\n        # A -> G, D\n        # E, G -> F (meaning F starts after both E and G are complete)\n        # D, F -> C\n        # F -> B\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ProjectSchedulingCostMinimization\")\n\n        # --- Decision Variables ---\n        # S[act]: Start time of activity act\n        S = model.addVars(activities,\n                          name=\"StartTime\",\n                          lb=0.0,\n                          vtype=GRB.INTEGER)\n\n        # Makespan: Total project duration\n        Makespan = model.addVar(name=\"Makespan\", lb=0.0, vtype=GRB.INTEGER)\n\n        # MachineRentalDuration: Duration for which the special machine is rented\n        MachineRentalDuration = model.addVar(name=\"MachineRentalDuration\",\n                                             lb=0.0,\n                                             vtype=GRB.INTEGER)\n\n        # --- Objective Function: Minimize Total Cost ---\n        # TotalCost = (CostWorkPerDay * Makespan) + (CostMachinePerDay * MachineRentalDuration)\n        objective = cost_work_per_day * Makespan + cost_machine_per_day * MachineRentalDuration\n        model.setObjective(objective, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Precedence Constraints\n        # Completion time of activity X is S[X] + durations[X]\n\n        # A -> G\n        model.addConstr(S['G'] >= S['A'] + durations['A'], name=\"Prec_A_G\")\n        # A -> D\n        model.addConstr(S['D'] >= S['A'] + durations['A'], name=\"Prec_A_D\")\n\n        # E -> F\n        model.addConstr(S['F'] >= S['E'] + durations['E'], name=\"Prec_E_F\")\n        # G -> F\n        model.addConstr(S['F'] >= S['G'] + durations['G'], name=\"Prec_G_F\")\n\n        # D -> C\n        model.addConstr(S['C'] >= S['D'] + durations['D'], name=\"Prec_D_C\")\n        # F -> C\n        model.addConstr(S['C'] >= S['F'] + durations['F'], name=\"Prec_F_C\")\n\n        # F -> B\n        model.addConstr(S['B'] >= S['F'] + durations['F'], name=\"Prec_F_B\")\n\n        # 2. Makespan Definition\n        # Makespan >= Completion time of all final activities (B and C)\n        model.addConstr(Makespan >= S['B'] + durations['B'],\n                        name=\"Makespan_vs_B\")\n        model.addConstr(Makespan >= S['C'] + durations['C'],\n                        name=\"Makespan_vs_C\")\n        # Also ensure makespan is greater than or equal to completion of any activity\n        for act in activities:\n            model.addConstr(Makespan >= S[act] + durations[act],\n                            name=f\"Makespan_vs_{act}\")\n\n        # 3. Machine Rental Duration Definition\n        # Machine rented from start of A (S['A']) to end of B (S['B'] + durations['B'])\n        # MachineRentalDuration >= (Completion Time of B) - (Start Time of A)\n        model.addConstr(MachineRentalDuration\n                        >= (S['B'] + durations['B']) - S['A'],\n                        name=\"MachineRentalDurationDef\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal project schedule found.\")\n            print(f\"Minimum Total Project Cost: {model.ObjVal:.2f} Euros\")\n            print(f\"  Calculated Makespan: {Makespan.X:.2f} days\")\n            print(\n                f\"  Calculated Machine Rental Duration: {MachineRentalDuration.X:.2f} days\"\n            )\n\n            print(\"\\nActivity Schedule (Start Times):\")\n            completion_times = {}\n            for act in activities:\n                completion_times[act] = S[act].X + durations[act]\n                print(\n                    f\"  Activity {act}: Start = {S[act].X:.2f} days, Duration = {durations[act]}, End = {completion_times[act]:.2f} days\"\n                )\n\n            print(\"\\nCost Breakdown:\")\n            work_cost = cost_work_per_day * Makespan.X\n            machine_cost = cost_machine_per_day * MachineRentalDuration.X\n            print(\n                f\"  Cost of Work (Makespan * {cost_work_per_day}): {work_cost:.2f} Euros\"\n            )\n            print(\n                f\"  Cost of Machine Rental (RentalDuration * {cost_machine_per_day}): {machine_cost:.2f} Euros\"\n            )\n\n            # Verify machine rental calculation\n            start_A = S['A'].X\n            end_B = S['B'].X + durations['B']\n            print(\n                f\"  Machine Rental Period: From start of A ({start_A:.2f}) to end of B ({end_B:.2f})\"\n            )\n            print(\n                f\"  Calculated duration for rental if positive: {(end_B - start_A):.2f} days\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check precedence constraints or activity durations.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"project_scheduling_iis.ilp\")\n            # print(\"IIS written to project_scheduling_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_project_scheduling_cost_minimization()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Scheduling",
        "modeling_type": "IP",
        "industry_sector": "Project Management"
      }
    ],
    "cluster": 40,
    "retrieved_insights": []
  },
  {
    "task_id": "B025",
    "description": "The number of salespeople required at a 24-hour convenience store in different time periods is as follows: 2:00-6:00 - 10 people, 6:00-10:00 - 15 people, 10:00-14:00 - 25 people, 14:00-18:00 - 20 people, 18:00-22:00 - 18 people, 22:00-2:00 - 12 people. Salespeople start their shifts at 2:00, 6:00, 10:00, 14:00, 18:00, and 22:00, working continuously for 8 hours. Determine the minimum number of salespeople needed to meet the requirements.",
    "ground_truth": 53.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_staffing_problem():\n    \"\"\"\n    Solves the salespeople staffing problem using Gurobi.\n    Minimizes the total number of salespeople required to meet demand\n    across different time periods, with 8-hour shifts.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"StaffingOptimization\")\n\n        # --- Data ---\n        # Time periods (start_hour, end_hour) and demand\n        # For clarity, let's map period indices to actual start times for variables\n        # P0: 2:00-6:00, P1: 6:00-10:00, ..., P5: 22:00-2:00\n        demands = {\n            0: 10,  # 2:00 - 6:00\n            1: 15,  # 6:00 - 10:00\n            2: 25,  # 10:00 - 14:00\n            3: 20,  # 14:00 - 18:00\n            4: 18,  # 18:00 - 22:00\n            5: 12  # 22:00 - 2:00 (next day)\n        }\n        num_periods = len(demands)  # Should be 6\n\n        # Shift start times (represented by an index for variables)\n        # x[0] starts at 2:00\n        # x[1] starts at 6:00\n        # x[2] starts at 10:00\n        # x[3] starts at 14:00\n        # x[4] starts at 18:00\n        # x[5] starts at 22:00\n        shift_start_times_desc = [\n            \"2:00\", \"6:00\", \"10:00\", \"14:00\", \"18:00\", \"22:00\"\n        ]\n\n        # --- Decision Variables ---\n        # x[i]: number of salespeople starting their shift at the i-th possible start time\n        x = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"x\", lb=0)\n\n        # --- Objective Function ---\n        # Minimize the total number of salespeople\n        model.setObjective(gp.quicksum(x[i] for i in range(num_periods)),\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # Demand coverage for each period.\n        # Each salesperson works for 8 hours, covering two 4-hour periods.\n\n        # Period 0 (2:00-6:00): Covered by staff starting at 22:00 (x[5]) and 2:00 (x[0])\n        model.addConstr(x[5] + x[0] >= demands[0], \"Demand_02_06\")\n\n        # Period 1 (6:00-10:00): Covered by staff starting at 2:00 (x[0]) and 6:00 (x[1])\n        model.addConstr(x[0] + x[1] >= demands[1], \"Demand_06_10\")\n\n        # Period 2 (10:00-14:00): Covered by staff starting at 6:00 (x[1]) and 10:00 (x[2])\n        model.addConstr(x[1] + x[2] >= demands[2], \"Demand_10_14\")\n\n        # Period 3 (14:00-18:00): Covered by staff starting at 10:00 (x[2]) and 14:00 (x[3])\n        model.addConstr(x[2] + x[3] >= demands[3], \"Demand_14_18\")\n\n        # Period 4 (18:00-22:00): Covered by staff starting at 14:00 (x[3]) and 18:00 (x[4])\n        model.addConstr(x[3] + x[4] >= demands[4], \"Demand_18_22\")\n\n        # Period 5 (22:00-2:00): Covered by staff starting at 18:00 (x[4]) and 22:00 (x[5])\n        model.addConstr(x[4] + x[5] >= demands[5], \"Demand_22_02\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found.\")\n            print(f\"Minimum total salespeople needed: {model.objVal:.0f}\")\n            print(\"\\nNumber of salespeople starting at each shift:\")\n            for i in range(num_periods):\n                print(\n                    f\"  Start at {shift_start_times_desc[i]}: {x[i].X:.0f} salespeople\"\n                )\n\n            print(\"\\nVerification of coverage:\")\n            print(\n                f\"  Period 2:00-6:00 (Demand: {demands[0]}): Covered by {x[5].X + x[0].X:.0f} (x5={x[5].X:.0f} + x0={x[0].X:.0f})\"\n            )\n            print(\n                f\"  Period 6:00-10:00 (Demand: {demands[1]}): Covered by {x[0].X + x[1].X:.0f} (x0={x[0].X:.0f} + x1={x[1].X:.0f})\"\n            )\n            print(\n                f\"  Period 10:00-14:00 (Demand: {demands[2]}): Covered by {x[1].X + x[2].X:.0f} (x1={x[1].X:.0f} + x2={x[2].X:.0f})\"\n            )\n            print(\n                f\"  Period 14:00-18:00 (Demand: {demands[3]}): Covered by {x[2].X + x[3].X:.0f} (x2={x[2].X:.0f} + x3={x[3].X:.0f})\"\n            )\n            print(\n                f\"  Period 18:00-22:00 (Demand: {demands[4]}): Covered by {x[3].X + x[4].X:.0f} (x3={x[3].X:.0f} + x4={x[4].X:.0f})\"\n            )\n            print(\n                f\"  Period 22:00-2:00 (Demand: {demands[5]}): Covered by {x[4].X + x[5].X:.0f} (x4={x[4].X:.0f} + x5={x[5].X:.0f})\"\n            )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_staffing_problem()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Staffing",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 10,
    "retrieved_insights": []
  },
  {
    "task_id": "B071",
    "description": "The Li family plans to invest their retirement fund in commercial real estate. The annual income from Property 1 is $12,500, Property 2 is $35,000, Property 3 is $23,000, and Property 4 is $100,000. The decision to be made is whether to buy each property or not, rather than how many to buy, as there is only one of each property available. Help them decide which properties to purchase to maximize their annual income.\n\nThe cost of Property 1 is $1.5 million, Property 2 is $2.1 million, Property 3 is $2.3 million, and Property 4 is $4.2 million. The Li family's budget is $7 million.\n\nIf they purchase Property 4, they cannot purchase Property 3.",
    "ground_truth": 135000.0,
    "formulation": null,
    "correct_program": "def optimize_property_selection(income_property1=12500,\n                                income_property2=35000,\n                                income_property3=23000,\n                                income_property4=100000,\n                                cost_property1=1.5,\n                                cost_property2=2.1,\n                                cost_property3=2.3,\n                                cost_property4=4.2,\n                                budget=7):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Property_Selection_MaxIncome\")\n\n    # Decision variables: binary for each property\n    y1 = model.addVar(vtype=GRB.BINARY, name=\"Property1\")\n    y2 = model.addVar(vtype=GRB.BINARY, name=\"Property2\")\n    y3 = model.addVar(vtype=GRB.BINARY, name=\"Property3\")\n    y4 = model.addVar(vtype=GRB.BINARY, name=\"Property4\")\n\n    # Set objective: maximize total income\n    model.setObjective(\n        income_property1 * y1 + income_property2 * y2 + income_property3 * y3 +\n        income_property4 * y4, GRB.MAXIMIZE)\n\n    # Add budget constraint\n    model.addConstr(cost_property1 * y1 + cost_property2 * y2 +\n                    cost_property3 * y3 + cost_property4 * y4 <= budget,\n                    name=\"BudgetConstraint\")\n\n    # Add property exclusivity constraint\n    model.addConstr(y4 + y3 <= 1, name=\"Property3_Property4_Exclusion\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total income\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":\n    result = optimize_property_selection()\n    if result is not None:\n        print(f\"Optimal total income: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Selection",
        "modeling_type": "MILP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 26,
    "retrieved_insights": []
  },
  {
    "task_id": "B083",
    "description": "A company hopes to recruit new employees for its team. The salary requirements for candidates A, B, C, D, and E are $8100, $20000, $21000, $3000, and $8000 respectively. They need to decide whether to hire each candidate. The team wants to minimize the total amount paid to the candidates.\n\nThey hope to hire a maximum of 3 new employees.\n\nThe team has a limited budget of $35,000. They need to ensure that the total payment to the selected candidates does not exceed the budget.\n\nThe qualifications of the five candidates are as follows:\nCandidate A: Bachelor's degree;\nCandidate B: Master's degree;\nCandidate C: Doctoral degree;\nCandidate D: No degree;\nCandidate E: No degree.\nThey will select at least one candidate with a Master's or Doctoral degree.\n\nThe work experience of the five candidates is as follows:\nCandidate A: 3 years of work experience;\nCandidate B: 10 years of work experience;\nCandidate C: 4 years of work experience;\nCandidate D: 3 years of work experience;\nCandidate E: 7 years of work experience.\nThey hope the total work experience of the selected candidates is no less than 12 years.\n\nDue to the equivalent professional skills of candidates A and E, the company will choose at most one from the two.\n\nThey will hire at least 2 new employees.",
    "ground_truth": 23000.0,
    "formulation": null,
    "correct_program": "def optimize_candidate_selection():\n    from gurobipy import Model, GRB\n\n    # Candidate data\n    salaries = {'A': 8100, 'B': 20000, 'C': 21000, 'D': 3000, 'E': 8000}\n    # Initialize model\n    m = Model(\"Candidate_Selection\")\n    m.setParam('OutputFlag', 0)  # Suppress output\n\n    # Decision variables\n    y_A = m.addVar(vtype=GRB.BINARY, name='A')\n    y_B = m.addVar(vtype=GRB.BINARY, name='B')\n    y_C = m.addVar(vtype=GRB.BINARY, name='C')\n    y_D = m.addVar(vtype=GRB.BINARY, name='D')\n    y_E = m.addVar(vtype=GRB.BINARY, name='E')\n\n    # Update model to integrate variables\n    m.update()\n\n    # Objective: Minimize total salary\n    m.setObjective(\n        salaries['A'] * y_A + salaries['B'] * y_B + salaries['C'] * y_C +\n        salaries['D'] * y_D + salaries['E'] * y_E, GRB.MINIMIZE)\n\n    # Constraints\n    # Max 3 hires\n    m.addConstr(y_A + y_B + y_C + y_D + y_E <= 3, \"max_hires\")\n    # At least 2 hires\n    m.addConstr(y_A + y_B + y_C + y_D + y_E >= 2, \"min_hires\")\n    # Budget constraint\n    m.addConstr(\n        salaries['A'] * y_A + salaries['B'] * y_B + salaries['C'] * y_C +\n        salaries['D'] * y_D + salaries['E'] * y_E <= 35000, \"budget\")\n    # Qualification constraint: at least one with Master's or Doctoral degree\n    m.addConstr(y_B + y_C >= 1, \"qualification\")\n    # Experience constraint\n    m.addConstr(3 * y_A + 10 * y_B + 4 * y_C + 3 * y_D + 7 * y_E >= 12,\n                \"experience\")\n    # Skill equivalence constraint: at most one of A and E\n    m.addConstr(y_A + y_E <= 1, \"skill_equivalence\")\n\n    # Optimize\n    m.optimize()\n\n    # Check feasibility and return result\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_candidate_selection()\n    if result is not None:\n        print(f\"Optimal total salary: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Selection",
        "modeling_type": "MILP",
        "industry_sector": "Human Resources"
      }
    ],
    "cluster": 0,
    "retrieved_insights": []
  },
  {
    "task_id": "B072",
    "description": "The Li family has 5 children: Alice, Bob, Charlie, Diana, and Ella. The cost to take Alice is $1000, Bob is $900, Charlie is $600, Diana is $500, and Ella is $700. Which children should the couple take to minimize the total cost of taking the children?\n\nThey can take up to 3 children on the upcoming trip.\n\nBob is the youngest, so the Li family will definitely take him.\n\nIf the couple takes Alice, they will not take Diana because Alice does not get along with her.\n\nIf the couple takes Bob, they will not take Charlie because Bob does not get along with him.\n\nIf they take Charlie, they must also take Diana.\n\nIf they take Diana, they must also take Ella.\n\nDespite the cost, the Li family has decided to take at least two children.",
    "ground_truth": 1600.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_child_selection():\n    \"\"\"\n    Solves the Li family child selection problem to minimize cost\n    subject to various constraints.\n    \"\"\"\n    try:\n        # --- Data ---\n        children = ['Alice', 'Bob', 'Charlie', 'Diana', 'Ella']\n        costs = {\n            'Alice': 1000,\n            'Bob': 900,\n            'Charlie': 600,\n            'Diana': 500,\n            'Ella': 700\n        }\n\n        max_children_allowed = 3\n        min_children_required = 2\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ChildSelection\")\n\n        # --- Decision Variables ---\n        # x[c]: 1 if child c is taken, 0 otherwise\n        x = model.addVars(children, vtype=GRB.BINARY, name=\"TakeChild\")\n\n        # --- Objective Function: Minimize Total Cost ---\n        model.setObjective(gp.quicksum(costs[c] * x[c] for c in children),\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Max Children: Take up to 3 children\n        model.addConstr(gp.quicksum(x[c] for c in children)\n                        <= max_children_allowed,\n                        name=\"MaxChildren\")\n\n        # 2. Must Take Bob\n        model.addConstr(x['Bob'] == 1, name=\"MustTakeBob\")\n\n        # 3. Alice vs Diana: If Alice is taken, Diana is not (x_A + x_D <= 1)\n        model.addConstr(x['Alice'] + x['Diana'] <= 1, name=\"Alice_vs_Diana\")\n\n        # 4. Bob vs Charlie: If Bob is taken, Charlie is not.\n        # Since Bob must be taken (Constraint 2), this implies Charlie cannot be taken.\n        model.addConstr(x['Charlie'] == 0, name=\"NoCharlie_due_to_Bob\")\n        # Original constraint: x['Charlie'] <= (1 - x['Bob']). Since x['Bob'] = 1, this becomes x['Charlie'] <= 0.\n\n        # 5. Charlie implies Diana: If Charlie is taken, Diana must be taken (x_C <= x_D)\n        # This constraint becomes redundant due to Constraint 4 (x_C = 0), but included for completeness.\n        model.addConstr(x['Charlie'] <= x['Diana'],\n                        name=\"Charlie_implies_Diana\")\n\n        # 6. Diana implies Ella: If Diana is taken, Ella must be taken (x_D <= x_E)\n        model.addConstr(x['Diana'] <= x['Ella'], name=\"Diana_implies_Ella\")\n\n        # 7. Min Children: Take at least two children\n        model.addConstr(gp.quicksum(x[c] for c in children)\n                        >= min_children_required,\n                        name=\"MinChildren\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal selection found.\")\n            print(f\"Minimum Total Cost: ${model.ObjVal:.2f}\")\n\n            print(\"\\nChildren to take:\")\n            selected_children = []\n            for c in children:\n                if x[c].X > 0.5:  # Check if x[c] is 1\n                    selected_children.append(c)\n                    print(f\"  - {c} (Cost: ${costs[c]})\")\n            print(\n                f\"\\nTotal number of children taken: {len(selected_children)}\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The constraints cannot be satisfied simultaneously.\"\n            )\n            print(\"Please review the constraints:\")\n            print(f\" - Max Children <= {max_children_allowed}\")\n            print(f\" - Min Children >= {min_children_required}\")\n            print(f\" - Must take Bob (Cost: ${costs['Bob']})\")\n            print(f\" - Cannot take Charlie (due to Bob)\")\n            print(f\" - If Alice taken, Diana not taken\")\n            print(f\" - If Diana taken, Ella must be taken\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"child_selection_iis.ilp\")\n            print(\"IIS written to child_selection_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_child_selection()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Selection",
        "modeling_type": "IP",
        "industry_sector": "Family/Household Management"
      }
    ],
    "cluster": 19,
    "retrieved_insights": []
  },
  {
    "task_id": "B061",
    "description": "The Zhang family is deciding to invest in several different restaurants. The annual revenue of Restaurant A is $15,000, Restaurant B is $40,000, Restaurant C is $30,000, and Restaurant D is $50,000. They need to decide whether to purchase each restaurant, with each restaurant being able to be purchased only once. Help them decide which restaurants to buy to maximize their annual income.\nThe cost of Restaurant A is 1.6 million, Restaurant B is 2.5 million, Restaurant C is 1.8 million, and Restaurant D is 3 million. The Zhang family's investment budget is 6 million.\n\nIf they purchase Restaurant D, then they cannot purchase Restaurant A.",
    "ground_truth": 90000.0,
    "formulation": null,
    "correct_program": "def optimize_restaurant_investment(revenue_A=15000,\n                                   revenue_B=40000,\n                                   revenue_C=30000,\n                                   revenue_D=50000,\n                                   cost_A=1.6,\n                                   cost_B=2.5,\n                                   cost_C=1.8,\n                                   cost_D=3.0,\n                                   budget=6):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Restaurant Investment Optimization\")\n\n    # Decision variables: binary for each restaurant\n    y_A = model.addVar(vtype=GRB.BINARY, name=\"y_A\")\n    y_B = model.addVar(vtype=GRB.BINARY, name=\"y_B\")\n    y_C = model.addVar(vtype=GRB.BINARY, name=\"y_C\")\n    y_D = model.addVar(vtype=GRB.BINARY, name=\"y_D\")\n\n    # Set objective: maximize total revenue\n    model.setObjective(\n        revenue_A * y_A + revenue_B * y_B + revenue_C * y_C + revenue_D * y_D,\n        GRB.MAXIMIZE)\n\n    # Add budget constraint\n    model.addConstr(cost_A * y_A + cost_B * y_B + cost_C * y_C + cost_D * y_D\n                    <= budget,\n                    name=\"BudgetConstraint\")\n\n    # Add mutual exclusivity constraint\n    model.addConstr(y_A + y_D <= 1, name=\"MutualExclusion\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_restaurant_investment()\n    if result is not None:\n        print(f\"Optimal total revenue: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Selection",
        "modeling_type": "IP",
        "industry_sector": "Finance"
      }
    ],
    "cluster": 19,
    "retrieved_insights": []
  },
  {
    "task_id": "B052",
    "description": "The Zhang family has 6 children: Harry, Hermione, Ron, Fred, George, and Ginny. The cost of taking Harry is $1200, Hermione is $1650, Ron is $750, Fred is $800, George is $800, and Ginny is $1500. Which children should the couple take to minimize the total cost of taking the children? They can take up to four children on the upcoming trip.\n\nGinny is the youngest, so the Zhang family will definitely take her.\n\nIf the couple takes Harry, they will not take Fred because Harry does not get along with him.\n\nIf the couple takes Harry, they will not take George because Harry does not get along with him.\n\nIf they take George, they must also take Fred.\n\nIf they take George, they must also take Hermione.\n\nEven though it will cost them a lot of money, the Zhang family has decided to take at least three children.",
    "ground_truth": 3050.0,
    "formulation": null,
    "correct_program": "def optimize_children_trip():\n    from gurobipy import Model, GRB\n\n    # Costs\n    cost_Harry = 1200\n    cost_Hermione = 1650\n    cost_Ron = 750\n    cost_Fred = 800\n    cost_George = 800\n    cost_Ginny = 1500  # always taken\n\n    # Initialize model\n    m = Model(\"Children_Trip_Optimization\")\n    m.setParam('OutputFlag', 0)  # suppress output\n\n    # Decision variables\n    y_Harry = m.addVar(vtype=GRB.BINARY, name='Harry')\n    y_Hermione = m.addVar(vtype=GRB.BINARY, name='Hermione')\n    y_Ron = m.addVar(vtype=GRB.BINARY, name='Ron')\n    y_Fred = m.addVar(vtype=GRB.BINARY, name='Fred')\n    y_George = m.addVar(vtype=GRB.BINARY, name='George')\n    y_Ginny = 1  # always taken\n\n    # Set objective\n    m.setObjective(\n        cost_Harry * y_Harry + cost_Hermione * y_Hermione + cost_Ron * y_Ron +\n        cost_Fred * y_Fred + cost_George * y_George + cost_Ginny, GRB.MINIMIZE)\n\n    # Constraints\n    total_children = y_Harry + y_Hermione + y_Ron + y_Fred + y_George + y_Ginny\n    m.addConstr(total_children >= 3, name='MinChildren')\n    m.addConstr(total_children <= 4, name='MaxChildren')\n\n    # Harry-Fred exclusion\n    m.addConstr(y_Harry + y_Fred <= 1, name='HarryFredExcl')\n    # Harry-Gorge exclusion\n    m.addConstr(y_Harry + y_George <= 1, name='HarryGeorgeExcl')\n    # George-Fred relationship\n    m.addConstr(y_George <= y_Fred, name='GeorgeFred')\n    # George-Hermione relationship\n    m.addConstr(y_George <= y_Hermione, name='GeorgeHermione')\n\n    # Optimize\n    m.optimize()\n\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_children_trip()\n    if result is not None:\n        print(f\"Optimal total cost for the trip: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Selection",
        "modeling_type": "MILP",
        "industry_sector": "Family/Personal"
      }
    ],
    "cluster": 19,
    "retrieved_insights": []
  },
  {
    "task_id": "B018",
    "description": "A furniture store can choose to order chairs from three different manufacturers: A, B, and C. The cost of ordering each chair from manufacturer A is $50, from manufacturer B is $45, and from manufacturer C is $40. The store needs to minimize the total cost of the order.\n\nAdditionally, each order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The number of orders must be an integer. The store needs to order at least 100 chairs.\n\nEach order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The store needs to order at most 500 chairs.\n\nIf the store decides to order chairs from manufacturer A, it must also order at least 10 chairs from manufacturer B.\n\nFurthermore, if the store decides to order chairs from manufacturer B, it must also order chairs from manufacturer C.",
    "ground_truth": 4000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_furniture_order_problem():\n    try:\n        # --- Problem Data ---\n        # Costs per chair\n        cost_per_chair_A = 50\n        cost_per_chair_B = 45\n        cost_per_chair_C = 40\n\n        # Chairs per order\n        chairs_per_order_A = 15\n        chairs_per_order_B = 10\n        chairs_per_order_C = 10\n\n        # Cost per order\n        cost_per_order_A = cost_per_chair_A * chairs_per_order_A\n        cost_per_order_B = cost_per_chair_B * chairs_per_order_B\n        cost_per_order_C = cost_per_chair_C * chairs_per_order_C\n\n        # Chair limits\n        min_total_chairs = 100\n        max_total_chairs = 500\n\n        # --- Model Creation ---\n        model = gp.Model(\"FurnitureOrderOptimization\")\n\n        # --- Decision Variables ---\n        # Number of orders from each manufacturer (must be integer)\n        orders_A = model.addVar(vtype=GRB.INTEGER, name=\"Orders_A\", lb=0)\n        orders_B = model.addVar(vtype=GRB.INTEGER, name=\"Orders_B\", lb=0)\n        orders_C = model.addVar(vtype=GRB.INTEGER, name=\"Orders_C\", lb=0)\n\n        # Binary variables to indicate if any order is placed with a manufacturer\n        # use_A = 1 if orders_A > 0, 0 otherwise\n        # use_B = 1 if orders_B > 0, 0 otherwise\n        use_A = model.addVar(vtype=GRB.BINARY, name=\"Use_A\")\n        use_B = model.addVar(vtype=GRB.BINARY, name=\"Use_B\")\n        # use_C is not strictly needed for the B->C condition if directly linking orders_C to use_B\n\n        # --- Objective Function ---\n        # Minimize the total cost of ordering\n        total_cost = (orders_A * cost_per_order_A +\n                      orders_B * cost_per_order_B +\n                      orders_C * cost_per_order_C)\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n\n        # 1. Calculate total number of chairs ordered\n        total_chairs = (orders_A * chairs_per_order_A +\n                        orders_B * chairs_per_order_B +\n                        orders_C * chairs_per_order_C)\n\n        # 2. Total chairs constraints\n        model.addConstr(total_chairs >= min_total_chairs, \"MinTotalChairs\")\n        model.addConstr(total_chairs <= max_total_chairs, \"MaxTotalChairs\")\n\n        # 3. Link binary 'use' variables to the number of orders\n        # If orders_A > 0, then use_A must be 1.\n        # If orders_A = 0, then use_A must be 0.\n        # Gurobi's indicator constraints are suitable here.\n        # (use_A == 1) => (orders_A >= 1)\n        # (use_A == 0) => (orders_A == 0)\n        model.addConstr((use_A == 1) >> (orders_A >= 1), \"Link_use_A_if_one\")\n        model.addConstr((use_A == 0) >> (orders_A == 0), \"Link_use_A_if_zero\")\n\n        # Similarly for use_B and orders_B\n        model.addConstr((use_B == 1) >> (orders_B >= 1), \"Link_use_B_if_one\")\n        model.addConstr((use_B == 0) >> (orders_B == 0), \"Link_use_B_if_zero\")\n\n        # 4. Conditional ordering constraints:\n        # \"If the store decides to order chairs from manufacturer A (orders_A > 0, so use_A = 1),\n        # it must also order at least 10 chairs from manufacturer B (orders_B * 10 >= 10, so orders_B >= 1).\"\n        model.addConstr((use_A == 1) >> (orders_B >= 1),\n                        \"Conditional_A_implies_B\")\n\n        # \"If the store decides to order chairs from manufacturer B (orders_B > 0, so use_B = 1),\n        # it must also order chairs from manufacturer C (orders_C >= 1).\"\n        model.addConstr((use_B == 1) >> (orders_C >= 1),\n                        \"Conditional_B_implies_C\")\n\n        # --- Optimize Model ---\n        model.optimize()\n\n        # --- Results ---\n        print(\"-\" * 40)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found!\")\n            print(f\"Minimum Total Cost: ${model.objVal:,.2f}\")\n            print(\"-\" * 40)\n            print(\"Order Plan:\")\n            print(f\"  Orders from Manufacturer A: {orders_A.X:.0f}\")\n            print(f\"    Chairs from A: {orders_A.X * chairs_per_order_A:.0f}\")\n            print(f\"  Orders from Manufacturer B: {orders_B.X:.0f}\")\n            print(f\"    Chairs from B: {orders_B.X * chairs_per_order_B:.0f}\")\n            print(f\"  Orders from Manufacturer C: {orders_C.X:.0f}\")\n            print(f\"    Chairs from C: {orders_C.X * chairs_per_order_C:.0f}\")\n            print(\"-\" * 40)\n\n            actual_total_chairs = (orders_A.X * chairs_per_order_A +\n                                   orders_B.X * chairs_per_order_B +\n                                   orders_C.X * chairs_per_order_C)\n            print(f\"Total Chairs Ordered: {actual_total_chairs:.0f}\")\n            print(\"-\" * 40)\n\n            print(\"Status of 'Use' Variables (for verification):\")\n            print(f\"  Use Manufacturer A (use_A): {use_A.X:.0f}\")\n            print(f\"  Use Manufacturer B (use_B): {use_B.X:.0f}\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists that satisfies all constraints.\"\n            )\n            print(\n                \"Consider reviewing the constraints, especially the conditional ones and chair limits.\"\n            )\n        elif model.status == GRB.UNBOUNDED:\n            print(\n                \"Model is unbounded. This typically means the objective can be improved indefinitely,\"\n            )\n            print(\n                \"which might indicate an issue with constraints or objective direction for minimization.\"\n            )\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_furniture_order_problem()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Purchasing & Procurement",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 17,
    "retrieved_insights": []
  },
  {
    "task_id": "B020",
    "description": "A restaurant needs to order dining tables from three different suppliers, A, B, and C. The cost of ordering each dining table from Supplier A is $120, from Supplier B is $110, and from Supplier C is $100. The restaurant needs to minimize the total cost of the order.\n\nAdditionally, each order from Supplier A will include 20 tables, while each order from Suppliers B and C will include 15 tables. The number of orders must be an integer. The restaurant needs to order at least 150 tables.\n\nEach order from Supplier A will include 20 tables, and each order from Suppliers B and C will include 15 tables. The restaurant needs to order no more than 600 tables.\n\nIf the restaurant decides to order tables from Supplier A, it must also order at least 30 tables from Supplier B.\n\nAdditionally, if the restaurant decides to order tables from Supplier B, it must also order tables from Supplier C.",
    "ground_truth": 15000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_restaurant_table_order_problem():\n    try:\n        # --- Problem Data ---\n        # Costs per table\n        cost_per_table_A = 120\n        cost_per_table_B = 110\n        cost_per_table_C = 100\n\n        # Tables per order\n        tables_per_order_A = 20\n        tables_per_order_B = 15\n        tables_per_order_C = 15\n\n        # Cost per order (derived)\n        cost_per_order_A = cost_per_table_A * tables_per_order_A\n        cost_per_order_B = cost_per_table_B * tables_per_order_B\n        cost_per_order_C = cost_per_table_C * tables_per_order_C\n\n        # Total table quantity limits\n        min_total_tables = 150\n        max_total_tables = 600\n\n        # Conditional requirement: if A is used, at least 30 tables from B\n        min_tables_from_B_if_A = 30\n        # Calculate minimum orders from B if A is used\n        min_orders_from_B_if_A = -(\n            -min_tables_from_B_if_A // tables_per_order_B)  # Ceiling division\n\n        # --- Model Creation ---\n        model = gp.Model(\"RestaurantTableOrderOptimization\")\n\n        # --- Decision Variables ---\n        # Number of orders from each supplier (must be integer, non-negative)\n        orders_A = model.addVar(vtype=GRB.INTEGER, name=\"Orders_A\", lb=0)\n        orders_B = model.addVar(vtype=GRB.INTEGER, name=\"Orders_B\", lb=0)\n        orders_C = model.addVar(vtype=GRB.INTEGER, name=\"Orders_C\", lb=0)\n\n        # Binary variables to indicate if any order is placed with a supplier\n        # use_A = 1 if orders_A > 0, 0 otherwise\n        # use_B = 1 if orders_B > 0, 0 otherwise\n        use_A = model.addVar(vtype=GRB.BINARY, name=\"Use_A\")\n        use_B = model.addVar(vtype=GRB.BINARY, name=\"Use_B\")\n        # use_C is not strictly needed for the B->C condition if directly linking orders_C to use_B,\n        # but can be added for clarity if desired. For now, we'll derive its usage.\n\n        # --- Objective Function ---\n        # Minimize the total cost of ordering\n        total_cost = (orders_A * cost_per_order_A +\n                      orders_B * cost_per_order_B +\n                      orders_C * cost_per_order_C)\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n\n        # 1. Calculate total number of tables ordered\n        total_tables_ordered = (orders_A * tables_per_order_A +\n                                orders_B * tables_per_order_B +\n                                orders_C * tables_per_order_C)\n\n        # 2. Total tables constraints\n        model.addConstr(total_tables_ordered >= min_total_tables,\n                        \"MinTotalTables\")\n        model.addConstr(total_tables_ordered <= max_total_tables,\n                        \"MaxTotalTables\")\n\n        # 3. Link binary 'use' variables to the number of orders\n        # Gurobi's indicator constraints are suitable here.\n        # (use_A == 1) => (orders_A >= 1)\n        # (use_A == 0) => (orders_A == 0)\n        model.addConstr((use_A == 1) >> (orders_A >= 1), \"Link_use_A_if_one\")\n        model.addConstr((use_A == 0) >> (orders_A == 0), \"Link_use_A_if_zero\")\n\n        # Similarly for use_B and orders_B\n        model.addConstr((use_B == 1) >> (orders_B >= 1), \"Link_use_B_if_one\")\n        model.addConstr((use_B == 0) >> (orders_B == 0), \"Link_use_B_if_zero\")\n\n        # 4. Conditional ordering constraints:\n        # \"If the restaurant decides to order tables from Supplier A (use_A = 1),\n        # it must also order at least 30 tables from Supplier B.\"\n        # This means orders_B * tables_per_order_B >= 30, so orders_B >= min_orders_from_B_if_A.\n        model.addConstr((use_A == 1) >> (orders_B >= min_orders_from_B_if_A),\n                        \"Conditional_A_implies_B_orders\")\n\n        # \"Additionally, if the restaurant decides to order tables from Supplier B (use_B = 1),\n        # it must also order tables from Supplier C (orders_C >= 1).\"\n        model.addConstr((use_B == 1) >> (orders_C >= 1),\n                        \"Conditional_B_implies_C_orders\")\n\n        # --- Optimize Model ---\n        model.optimize()\n\n        # --- Results ---\n        print(\"-\" * 40)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found!\")\n            print(f\"Minimum Total Cost: ${model.objVal:,.2f}\")\n            print(\"-\" * 40)\n            print(\"Order Plan:\")\n            print(f\"  Orders from Supplier A: {orders_A.X:.0f}\")\n            print(f\"    Tables from A: {orders_A.X * tables_per_order_A:.0f}\")\n            print(f\"  Orders from Supplier B: {orders_B.X:.0f}\")\n            print(f\"    Tables from B: {orders_B.X * tables_per_order_B:.0f}\")\n            print(f\"  Orders from Supplier C: {orders_C.X:.0f}\")\n            print(f\"    Tables from C: {orders_C.X * tables_per_order_C:.0f}\")\n            print(\"-\" * 40)\n\n            actual_total_tables = (orders_A.X * tables_per_order_A +\n                                   orders_B.X * tables_per_order_B +\n                                   orders_C.X * tables_per_order_C)\n            print(f\"Total Tables Ordered: {actual_total_tables:.0f}\")\n            print(\n                f\"  (Min required: {min_total_tables}, Max allowed: {max_total_tables})\"\n            )\n            print(\"-\" * 40)\n\n            print(\"Status of 'Use Supplier' Variables (for verification):\")\n            print(f\"  Use Supplier A (use_A): {use_A.X:.0f}\")\n            print(f\"  Use Supplier B (use_B): {use_B.X:.0f}\")\n            if orders_C.X > 0.5:  # Check if C was used\n                print(f\"  Use Supplier C: 1 (derived from orders_C > 0)\")\n            else:\n                print(f\"  Use Supplier C: 0 (derived from orders_C == 0)\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists that satisfies all constraints.\"\n            )\n            print(\n                \"Consider reviewing the constraints, especially the conditional ones and table limits.\"\n            )\n            # You can compute and print an Irreducible Inconsistent Subsystem (IIS)\n            # to help debug infeasibility:\n            # model.computeIIS()\n            # model.write(\"model_iis.ilp\")\n            # print(\"IIS written to model_iis.ilp\")\n        elif model.status == GRB.UNBOUNDED:\n            print(\n                \"Model is unbounded. This typically means the objective can be improved indefinitely,\"\n            )\n            print(\n                \"which might indicate an issue with constraints or objective direction for minimization.\"\n            )\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_restaurant_table_order_problem()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Purchasing",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 17,
    "retrieved_insights": []
  },
  {
    "task_id": "B068",
    "description": "A steel reinforcement workshop produces a batch of steel bars (with the same diameter), consisting of 90 pieces of 3 meters in length and 60 pieces of 4 meters in length. It is known that each piece of raw steel bar used is 10 meters in length. How can the raw material be cut most efficiently? Establish a linear programming model for this problem.",
    "ground_truth": 53.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_steel_bar_cutting():\n    \"\"\"\n    Solves the steel bar cutting stock problem to minimize the number of raw bars used.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Demands for cut pieces\n        demand_3m = 90  # pieces\n        demand_4m = 60  # pieces\n\n        # Raw steel bar length (not directly used in this formulation with pre-defined patterns,\n        # but useful for understanding pattern generation)\n        # raw_bar_length = 10 # meters\n\n        # Cutting Patterns:\n        # Pattern: (yield_3m_pieces, yield_4m_pieces)\n        # Pattern A: 3 pieces of 3m, 0 pieces of 4m. Waste: 1m.\n        # Pattern B: 2 pieces of 3m, 1 piece of 4m. Waste: 0m.\n        # Pattern C: 0 pieces of 3m, 2 pieces of 4m. Waste: 2m.\n\n        patterns = {\n            'A': {\n                'yield_3m': 3,\n                'yield_4m': 0,\n                'waste': 1\n            },\n            'B': {\n                'yield_3m': 2,\n                'yield_4m': 1,\n                'waste': 0\n            },\n            'C': {\n                'yield_3m': 0,\n                'yield_4m': 2,\n                'waste': 2\n            }\n        }\n        pattern_ids = list(patterns.keys())\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"SteelBarCuttingStock\")\n\n        # --- Decision Variables ---\n        # x[p_id]: number of raw steel bars cut using pattern p_id\n        x = model.addVars(pattern_ids, name=\"NumCuts\", vtype=GRB.INTEGER, lb=0)\n\n        # --- Objective Function: Minimize Total Number of Raw Bars Used ---\n        model.setObjective(gp.quicksum(x[p_id] for p_id in pattern_ids),\n                           GRB.MINIMIZE)\n\n        # Alternative objective: Minimize total waste\n        # total_waste = gp.quicksum(patterns[p_id]['waste'] * x[p_id] for p_id in pattern_ids)\n        # model.setObjective(total_waste, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Demand for 3-meter pieces\n        model.addConstr(gp.quicksum(patterns[p_id]['yield_3m'] * x[p_id]\n                                    for p_id in pattern_ids) >= demand_3m,\n                        name=\"Demand_3m\")\n\n        # 2. Demand for 4-meter pieces\n        model.addConstr(gp.quicksum(patterns[p_id]['yield_4m'] * x[p_id]\n                                    for p_id in pattern_ids) >= demand_4m,\n                        name=\"Demand_4m\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal cutting plan found.\")\n            print(\n                f\"Minimum number of raw steel bars to use: {model.ObjVal:.0f}\")\n\n            print(\"\\nNumber of times each pattern is used:\")\n            total_waste_calculated = 0\n            for p_id in pattern_ids:\n                if x[p_id].X > 0.5:  # If pattern is used\n                    print(\n                        f\"  Pattern {p_id} (Yields: {patterns[p_id]['yield_3m']} of 3m, {patterns[p_id]['yield_4m']} of 4m; Waste/bar: {patterns[p_id]['waste']}m): \"\n                        f\"{x[p_id].X:.0f} times\")\n                    total_waste_calculated += patterns[p_id]['waste'] * x[\n                        p_id].X\n\n            print(\n                f\"\\nCalculated Total Waste: {total_waste_calculated:.0f} meters (based on minimizing raw bars)\"\n            )\n\n            print(\"\\nVerification of Production:\")\n            produced_3m = sum(patterns[p_id]['yield_3m'] * x[p_id].X\n                              for p_id in pattern_ids)\n            produced_4m = sum(patterns[p_id]['yield_4m'] * x[p_id].X\n                              for p_id in pattern_ids)\n            print(\n                f\"  Total 3m pieces produced: {produced_3m:.0f} (Demand: {demand_3m})\"\n            )\n            print(\n                f\"  Total 4m pieces produced: {produced_4m:.0f} (Demand: {demand_60})\"\n            )  # Corrected to demand_4m\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check patterns and demands.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"steel_cutting_iis.ilp\")\n            # print(\"IIS written to steel_cutting_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    # Correcting a typo in the verification print statement\n    demand_60 = 60  # This variable was used in print but not defined, should be demand_4m\n    solve_steel_bar_cutting()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Cutting Stock",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing"
      }
    ],
    "cluster": 11,
    "retrieved_insights": []
  },
  {
    "task_id": "E061",
    "description": "Imagine a futuristic transportation network connecting 9 bustling sectors of a newly established colony on Mars, where each sector specializes in different aspects of Martian life, from agriculture to tech development. The network is designed to transport vital resources, such as water, food, and technology, from the colony's central supply hub (Sector 0) to its farthest outpost (Sector 8). The sectors are interconnected through a series of high-speed transport tubes, each with a specific capacity for carrying resources per Martian day.\n\nThe capacity for resource flow from one sector to another is as follows:\n\n- From Sector 0 (Central Supply Hub): Can send resources to Sector 1 (7 units), Sector 2 (4 units), Sector 3 (17 units), Sector 4 (4 units), Sector 5 (18 units), Sector 6 (17 units), Sector 7 (5 units), and Sector 8 (14 units).\n- From Sector 1: Can send resources to Sector 0 (2 units), Sector 2 (11 units), Sector 3 (10 units), Sector 4 (1 unit), Sector 5 (19 units), Sector 6 (6 units), Sector 7 (16 units), and Sector 8 (13 units).\n- From Sector 2: Can send resources to Sector 0 (8 units), Sector 1 (15 units), Sector 3 (5 units), Sector 4 (1 unit), Sector 5 (5 units), Sector 6 (11 units), Sector 7 (17 units), and Sector 8 (18 units).\n- From Sector 3: Can send resources to Sector 0 (2 units), Sector 1 (5 units), Sector 4 (6 units), Sector 5 (17 units), Sector 6 (1 unit), Sector 7 (16 units), and Sector 8 (14 units).\n- From Sector 4: Can send resources to Sector 0 (15 units), Sector 1 (6 units), Sector 2 (20 units), Sector 3 (15 units), Sector 5 (7 units), Sector 6 (13 units), Sector 7 (6 units), and Sector 8 (19 units).\n- From Sector 5: Can send resources to Sector 0 (15 units), Sector 1 (2 units), Sector 2 (8 units), Sector 3 (2 units), Sector 4 (3 units), Sector 6 (2 units), Sector 7 (9 units), and Sector 8 (2 units).\n- From Sector 6: Can send resources to Sector 0 (10 units), Sector 1 (12 units), Sector 2 (11 units), Sector 3 (10 units), Sector 4 (19 units), Sector 5 (9 units), Sector 7 (17 units), and Sector 8 (1 unit).\n- From Sector 7: Can send resources to Sector 0 (0 units), Sector 1 (20 units), Sector 2 (15 units), Sector 3 (19 units), Sector 4 (20 units), Sector 5 (18 units), Sector 6 (14 units), and Sector 8 (8 units).\n- From Sector 8 (Farthest Outpost): Can send resources back to Sector 0 (16 units), Sector 1 (13 units), Sector 2 (3 units), Sector 3 (3 units), Sector 4 (20 units), Sector 5 (19 units), Sector 6 (2 units), and Sector 7 (7 units).\n\nIn this Martian colony, a capacity of \"0\" means there is no direct transport tube connection between those two sectors.\n\nYour task is to calculate the maximum amount of resources that can be transported from the Central Supply Hub (Sector 0) to the Farthest Outpost (Sector 8) per Martian day, ensuring that the flow through each transport tube does not exceed its specified capacity. What is the maximum amount of resources that can be sent from the Central Supply Hub to the Farthest Outpost in units per Martian day?",
    "ground_truth": 86.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MarsTransportNetwork\")\n\n# Set of sectors\nS = range(9)\n\n# Capacity (C_ij) for each transport tube\ncapacities = {\n    (0, 1): 7, (0, 2): 4, (0, 3): 17, (0, 4): 4, (0, 5): 18, (0, 6): 17, (0, 7): 5, (0, 8): 14,\n    (1, 0): 2, (1, 2): 11, (1, 3): 10, (1, 4): 1, (1, 5): 19, (1, 6): 6, (1, 7): 16, (1, 8): 13,\n    (2, 0): 8, (2, 1): 15, (2, 3): 5, (2, 4): 1, (2, 5): 5, (2, 6): 11, (2, 7): 17, (2, 8): 18,\n    (3, 0): 2, (3, 1): 5, (3, 4): 6, (3, 5): 17, (3, 6): 1, (3, 7): 16, (3, 8): 14,\n    (4, 0): 15, (4, 1): 6, (4, 2): 20, (4, 3): 15, (4, 5): 7, (4, 6): 13, (4, 7): 6, (4, 8): 19,\n    (5, 0): 15, (5, 1): 2, (5, 2): 8, (5, 3): 2, (5, 4): 3, (5, 6): 2, (5, 7): 9, (5, 8): 2,\n    (6, 0): 10, (6, 1): 12, (6, 2): 11, (6, 3): 10, (6, 4): 19, (6, 5): 9, (6, 7): 17, (6, 8): 1,\n    (7, 0): 0, (7, 1): 20, (7, 2): 15, (7, 3): 19, (7, 4): 20, (7, 5): 18, (7, 6): 14, (7, 8): 8,\n    (8, 0): 16, (8, 1): 13, (8, 2): 3, (8, 3): 3, (8, 4): 20, (8, 5): 19, (8, 6): 2, (8, 7): 7\n}\n\n# Add flow variables (f_ij) for each possible connection with capacity > 0\nflow = model.addVars(capacities.keys(), name=\"flow\", lb=0)\n\n# Objective: Maximize the total flow into Sector 8\nmodel.setObjective(gp.quicksum(flow[i, 8] for i in S if (i, 8) in capacities), GRB.MAXIMIZE)\n\n# Add Capacity Constraints: f_ij <= C_ij\nmodel.addConstrs((flow[i, j] <= capacities[i, j] for i, j in capacities), \"Capacity\")\n\n# Add Flow Conservation Constraints: sum(f_ik) = sum(f_kj) for all k in S \\\\ {0, 8}\nmodel.addConstrs(\n    (gp.quicksum(flow[i, k] for i in S if (i, k) in capacities) ==\n     gp.quicksum(flow[k, j] for j in S if (k, j) in capacities)\n     for k in S if k not in [0, 8]), \"Flow_Conservation\"\n)\n\n# Add Source Flow Constraint: sum(f_0j) - sum(f_i0) = total flow out of source\nmodel.addConstr(\n    gp.quicksum(flow[0, j] for j in S if (0, j) in capacities) -\n    gp.quicksum(flow[i, 0] for i in S if (i, 0) in capacities) == \n    gp.quicksum(flow[i, 8] for i in S if (i, 8) in capacities), \n    \"Source_Flow\"\n)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E064",
    "description": "In the heart of a bustling metropolis, there lies an intricate network of digital information pipelines connecting 8 crucial data centers. These centers, from the main server hub to the final relay station, are vital for processing and distributing vast amounts of data across the city. The connections between these data centers have specific bandwidth capacities that dictate the maximum flow of data (measured in terabytes per hour) that can be transmitted from one center to another.\n\nHere's a breakdown of the network's layout and its capacities:\n\n- From Data Center 0 (Source): Data can be sent to Center 1 (6 TB/h), Center 2 (16 TB/h), Center 3 (5 TB/h), Center 4 (6 TB/h), Center 5 (11 TB/h), Center 6 (6 TB/h), and Center 7 (4 TB/h).\n- From Data Center 1: Data can be transmitted to Center 2 (8 TB/h), Center 3 (10 TB/h), Center 4 (6 TB/h), Center 5 (3 TB/h), Center 6 (6 TB/h), and Center 7 (14 TB/h).\n- From Data Center 2: Can send data to Center 1 (6 TB/h), Center 3 (20 TB/h), Center 4 (7 TB/h), Center 5 (16 TB/h), Center 6 (13 TB/h), and Center 7 (14 TB/h).\n- From Data Center 3: Has capacities to Center 1 (11 TB/h), Center 2 (19 TB/h), Center 4 (18 TB/h), Center 5 (5 TB/h), and Center 7 (8 TB/h).\n- From Data Center 4: Can route data to Center 1 (1 TB/h), Center 2 (14 TB/h), Center 3 (18 TB/h), Center 5 (12 TB/h), Center 6 (4 TB/h), and Center 7 (7 TB/h).\n- From Data Center 5: Can dispatch data to Center 1 (16 TB/h), Center 2 (3 TB/h), Center 3 (20 TB/h), Center 4 (7 TB/h), Center 6 (15 TB/h), and Center 7 (6 TB/h).\n- From Data Center 6: Capable of sending to Center 1 (11 TB/h), Center 2 (4 TB/h), Center 3 (19 TB/h), Center 4 (7 TB/h), Center 5 (6 TB/h), and Center 7 (17 TB/h).\n- From Data Center 7 (Destination): Can receive return data flow from Center 1 (5 TB/h), Center 2 (8 TB/h), Center 3 (17 TB/h), Center 4 (2 TB/h), Center 5 (5 TB/h), and Center 6 (4 TB/h).\n\nIn this network, a capacity of \"0\" signifies an absence of direct data transmission capability between any two given data centers.\n\nThe challenge is to determine the maximum amount of data that can be efficiently transmitted from Data Center 0 (the main server hub) to Data Center 7 (the final relay station) per hour, without exceeding the bandwidth capacities of the connections between the centers. What is the optimal value of data flow (in terabytes per hour) that can be achieved from the source to the destination?",
    "ground_truth": 54.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MaximizeFlow\")\n\n# Define sets and parameters\nN = range(8)  # Data centers\ncapacities = {\n    (0, 1): 6, (0, 2): 16, (0, 3): 5, (0, 4): 6, (0, 5): 11, (0, 6): 6, (0, 7): 4,\n    (1, 2): 8, (1, 3): 10, (1, 4): 6, (1, 5): 3, (1, 6): 6, (1, 7): 14,\n    (2, 1): 6, (2, 3): 20, (2, 4): 7, (2, 5): 16, (2, 6): 13, (2, 7): 14,\n    (3, 1): 11, (3, 2): 19, (3, 4): 18, (3, 5): 5, (3, 7): 8,\n    (4, 1): 1, (4, 2): 14, (4, 3): 18, (4, 5): 12, (4, 6): 4, (4, 7): 7,\n    (5, 1): 16, (5, 2): 3, (5, 3): 20, (5, 4): 7, (5, 6): 15, (5, 7): 6,\n    (6, 1): 11, (6, 2): 4, (6, 3): 19, (6, 4): 7, (6, 5): 6, (6, 7): 17\n}\n\n# Add variables\nflow = model.addVars(capacities.keys(), lb=0, ub=capacities, name=\"flow\")\n\n# Set objective\nmodel.setObjective(gp.quicksum(flow[i, 7] for i in N if (i, 7) in capacities), GRB.MAXIMIZE)\n\n# Add flow conservation constraints\nfor i in N:\n    if i != 0 and i != 7:\n        model.addConstr(gp.quicksum(flow[i, j] for j in N if (i, j) in capacities) ==\n                        gp.quicksum(flow[k, i] for k in N if (k, i) in capacities),\n                        name=f\"flow_conservation_{i}\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Telecommunications"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E072",
    "description": "Imagine a network of highways that connect six major cities in a country. These highways are designed to facilitate the transportation of goods from a central warehouse (City 0) to a main retail hub (City 5). Each highway has a specific transportation capacity, indicating the maximum number of trucks it can accommodate per hour.\n\nHere is the transportation capacity of each highway connecting the cities:\n\n- From City 0 (Warehouse): Can send goods to City 1 (14 trucks), City 2 (15 trucks), City 3 (13 trucks), and City 5 (4 trucks).\n- From City 1: Can send goods to City 0 (10 trucks), City 2 (7 trucks), City 3 (18 trucks), City 4 (9 trucks), and City 5 (5 trucks).\n- From City 2: Can send goods to City 0 (11 trucks), City 3 (7 trucks), City 4 (13 trucks), and City 5 (6 trucks).\n- From City 3: Can send goods to City 0 (7 trucks), City 1 (11 trucks), City 2 (18 trucks), City 4 (17 trucks), and City 5 (2 trucks).\n- From City 4: Can send goods to City 0 (19 trucks), City 1 (8 trucks), City 2 (15 trucks), City 3 (15 trucks), and City 5 (5 trucks).\n- From City 5 (Retail Hub): Can send goods back to City 0 (10 trucks), City 1 (19 trucks), City 2 (17 trucks), City 3 (2 trucks), and City 4 (3 trucks).\n\nA capacity of \"0\" indicates that there is no direct highway link between those two cities.\n\nNow, consider a situation where you're tasked with finding the maximum number of trucks that can be dispatched from the warehouse in City 0 to the retail hub in City 5 per hour, without exceeding the transportation capacity of any highway. \n\nWhat is the maximum number of trucks that can be dispatched from the warehouse to the retail hub per hour, while maintaining the transportation capacity of each highway?",
    "ground_truth": 22.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Initialize a Gurobi model\nmodel = gp.Model(\"MaxFlowNetwork\")\n\n# Sets\ncities = [0, 1, 2, 3, 4, 5]\n\n# Parameters\ncapacities = {\n    (0, 1): 14, (0, 2): 15, (0, 3): 13, (0, 5): 4,\n    (1, 0): 10, (1, 2): 7, (1, 3): 18, (1, 4): 9, (1, 5): 5,\n    (2, 0): 11, (2, 3): 7, (2, 4): 13, (2, 5): 6,\n    (3, 0): 7, (3, 1): 11, (3, 2): 18, (3, 4): 17, (3, 5): 2,\n    (4, 0): 19, (4, 1): 8, (4, 2): 15, (4, 3): 15, (4, 5): 5,\n    (5, 0): 10, (5, 1): 19, (5, 2): 17, (5, 3): 2, (5, 4): 3\n}\n\n# Variables\nflow = model.addVars(cities, cities, vtype=GRB.CONTINUOUS, name=\"flow\")\n\n# Objective: Maximize the flow from City 0 to City 5\nmodel.setObjective(gp.quicksum(flow[i, 5] for i in range(5)), GRB.MAXIMIZE)\n\n# Capacity constraints\nfor (i, j), cap in capacities.items():\n    model.addConstr(flow[i, j] <= cap, f\"cap_{i}_{j}\")\n\n# Flow conservation constraints for intermediate cities\nfor city in range(1, 5):\n    model.addConstr(gp.quicksum(flow[i, city] for i in cities if (i, city) in capacities) ==\n                    gp.quicksum(flow[city, j] for j in cities if (city, j) in capacities),\n                    f\"flow_conservation_{city}\")\n\n# Net flow conservation for source (City 0)\nmodel.addConstr(gp.quicksum(flow[0, j] for j in range(1, 6) if (0, j) in capacities) -\n                gp.quicksum(flow[j, 0] for j in range(1, 6) if (j, 0) in capacities) == \n                gp.quicksum(flow[i, 5] for i in range(5)), \"net_flow_conservation_0\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "not_optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E068",
    "description": "In the heart of a bustling metropolis, there exists a complex network of tunnels designed to transport electricity from a central power plant to various substations across the city. This network is composed of 8 crucial nodes, each representing a key junction point in the electrical distribution system. The nodes range from the primary power plant, where electricity is generated, to a final distribution center, from which electricity is routed to meet the city's demands.\n\nThe capacity of each tunnel, measured in thousands of kilowatts per hour (kWh), dictates the maximum amount of electricity that can flow between any two nodes. The connections and their capacities are as follows:\n\n- From the Power Plant (Node 0): Electricity can be sent to Node 1 (2 kWh), Node 2 (1 kWh), Node 3 (1 kWh), Node 4 (8 kWh), Node 5 (17 kWh), Node 6 (6 kWh), and Node 7 (7 kWh).\n- From Node 1: Electricity can flow to the Power Plant (4 kWh), Node 2 (14 kWh), Node 3 (14 kWh), Node 4 (13 kWh), Node 5 (19 kWh), Node 6 (4 kWh), and Node 7 (19 kWh).\n- From Node 2: Electricity can be distributed to the Power Plant (6 kWh), Node 1 (16 kWh), Node 3 (3 kWh), Node 4 (10 kWh), Node 5 (7 kWh), Node 6 (18 kWh), and Node 7 (10 kWh).\n- From Node 3: Electricity can travel to the Power Plant (19 kWh), Node 1 (4 kWh), Node 2 (15 kWh), Node 4 (6 kWh), Node 5 (1 kWh), Node 6 (17 kWh), and Node 7 (9 kWh).\n- From Node 4: Electricity can be dispatched to the Power Plant (12 kWh), Node 1 (15 kWh), Node 2 (3 kWh), Node 3 (14 kWh), Node 5 (18 kWh), Node 6 (20 kWh), and Node 7 (14 kWh).\n- From Node 5: Electricity can move to the Power Plant (20 kWh), Node 1 (5 kWh), Node 2 (19 kWh), Node 3 (9 kWh), Node 4 (20 kWh), Node 6 (10 kWh), and Node 7 (6 kWh).\n- From Node 6: Electricity can be sent to the Power Plant (9 kWh), Node 1 (14 kWh), Node 2 (12 kWh), Node 3 (16 kWh), Node 4 (19 kWh), Node 5 (3 kWh), and Node 7 (10 kWh).\n- From Node 7 (Final Distribution Center): Electricity can return to the Power Plant (20 kWh), Node 1 (16 kWh), Node 2 (6 kWh), Node 3 (16 kWh), Node 4 (8 kWh), Node 5 (16 kWh), and Node 6 (4 kWh).\n\nIn this electrical network, a capacity of \"0\" indicates no direct tunnel connection for electricity flow between those two nodes.\n\nThe challenge is to compute the maximum amount of electricity that can be efficiently distributed from the Power Plant (Node 0) to the Final Distribution Center (Node 7) per hour, ensuring that the flow through each tunnel does not exceed its maximum capacity. What is the optimal value of electricity (in thousands of kilowatts per hour) that can be transported from the source to the sink in this network?",
    "ground_truth": 42.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MaxFlow\")\n\n# Set of nodes\nN = [0, 1, 2, 3, 4, 5, 6, 7]\n\n# Capacity of tunnels between nodes (i, j): C[i][j]\nC = {\n    (0, 1): 2, (0, 2): 1, (0, 3): 1, (0, 4): 8, (0, 5): 17, (0, 6): 6, (0, 7): 7,\n    (1, 0): 4, (1, 2): 14, (1, 3): 14, (1, 4): 13, (1, 5): 19, (1, 6): 4, (1, 7): 19,\n    (2, 0): 6, (2, 1): 16, (2, 3): 3, (2, 4): 10, (2, 5): 7, (2, 6): 18, (2, 7): 10,\n    (3, 0): 19, (3, 1): 4, (3, 2): 15, (3, 4): 6, (3, 5): 1, (3, 6): 17, (3, 7): 9,\n    (4, 0): 12, (4, 1): 15, (4, 2): 3, (4, 3): 14, (4, 5): 18, (4, 6): 20, (4, 7): 14,\n    (5, 0): 20, (5, 1): 5, (5, 2): 19, (5, 3): 9, (5, 4): 20, (5, 6): 10, (5, 7): 6,\n    (6, 0): 9, (6, 1): 14, (6, 2): 12, (6, 3): 16, (6, 4): 19, (6, 5): 3, (6, 7): 10,\n    (7, 0): 20, (7, 1): 16, (7, 2): 6, (7, 3): 16, (7, 4): 8, (7, 5): 16, (7, 6): 4\n}\n\n# Add variables: flow f_ij for each pair (i, j) in C with capacity > 0\nflow = model.addVars(C.keys(), lb=0, ub=C, vtype=GRB.CONTINUOUS, name=\"f\")\n\n# Objective: maximize flow into the sink node (7)\nmodel.setObjective(sum(flow[i, 7] for i in N if (i, 7) in C), GRB.MAXIMIZE)\n\n# Add flow conservation constraints for each node except source (0) and sink (7)\nfor i in N:\n    if i not in [0, 7]:\n        model.addConstr(\n            sum(flow[j, i] for j in N if (j, i) in C) == sum(flow[i, j] for j in N if (i, j) in C),\n            name=f\"flow_conservation_{i}\"\n        )\n\n# Add source node flow constraint\nmodel.addConstr(\n    sum(flow[0, j] for j in N if (0, j) in C) == sum(flow[j, 0] for j in N if (j, 0) in C) + sum(flow[i, 7] for i in N if (i, 7) in C),\n    name=\"source_flow\"\n)\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Energy"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E055",
    "description": "Welcome to the challenge of optimizing the digital traffic flow in CyberCity, a bustling metropolis of the future. In this city, data packets travel through a sophisticated network of 8 digital relay stations, from the primary source node to a key destination node, facilitating seamless communication across the city.\n\nThe network is structured as follows, with each connection representing the maximum data capacity (measured in terabits per second, Tbps) that can flow from one relay station to another:\n\n- From Relay Station 0 (Source): Data can flow to Station 1 (3 Tbps), Station 2 (3 Tbps), Station 3 (5 Tbps), Station 4 (13 Tbps), Station 5 (7 Tbps), Station 6 (14 Tbps), and Station 7 (17 Tbps).\n- From Relay Station 1: Data can flow to Station 0 (5 Tbps), Station 3 (2 Tbps), Station 4 (18 Tbps), Station 5 (20 Tbps), Station 6 (1 Tbps), and Station 7 (17 Tbps).\n- From Relay Station 2: Data can flow to Station 0 (2 Tbps), Station 1 (18 Tbps), Station 3 (10 Tbps), Station 4 (14 Tbps), Station 5 (15 Tbps), Station 6 (8 Tbps), and Station 7 (18 Tbps).\n- From Relay Station 3: Data can flow to Station 0 (20 Tbps), Station 1 (7 Tbps), Station 2 (11 Tbps), Station 4 (13 Tbps), Station 5 (2 Tbps), Station 6 (8 Tbps), and Station 7 (12 Tbps).\n- From Relay Station 4: Data can flow to Station 0 (20 Tbps), Station 1 (20 Tbps), Station 2 (12 Tbps), Station 3 (7 Tbps), Station 5 (11 Tbps), Station 6 (2 Tbps), and Station 7 (14 Tbps).\n- From Relay Station 5: Data can flow to Station 0 (5 Tbps), Station 1 (16 Tbps), Station 2 (15 Tbps), Station 3 (19 Tbps), Station 4 (11 Tbps), Station 6 (1 Tbps), and Station 7 (8 Tbps).\n- From Relay Station 6: Data can flow to Station 0 (10 Tbps), Station 1 (3 Tbps), Station 2 (14 Tbps), Station 3 (18 Tbps), Station 4 (13 Tbps), Station 5 (6 Tbps), and Station 7 (7 Tbps).\n- From Relay Station 7 (Destination): Data can loop back to Station 0 (9 Tbps), Station 1 (3 Tbps), Station 2 (14 Tbps), Station 3 (13 Tbps), Station 4 (6 Tbps), Station 5 (5 Tbps), and Station 6 (9 Tbps).\n\nIn this system, a capacity of \"0\" means there is no direct data link between those two stations. The objective of this problem is to find the maximum amount of data that can be transmitted from Station 0 (the source) to Station 7 (the destination) per second, while ensuring the data flow through each connection doesn't exceed its maximum capacity.\n\nWhat is the maximum data flow, in terabits per second, that can be achieved from the source to the destination in this network?",
    "ground_truth": 62.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "run_error"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Telecommunications"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E070",
    "description": "Welcome to the challenge of optimizing the network of a futuristic transportation system that interconnects 7 strategic hubs across a thriving metropolis. These hubs, ranging from the central dispatch center to the main distribution hub, are connected by a network of high-speed transit lanes, each with a distinct capacity limitation for vehicles per hour. \n\nHere's a breakdown of the transit system's capabilities, indicating the maximum number of vehicles that can move from one hub to another within an hour:\n\n- From Hub 0 (Central Dispatch): Vehicles can move to Hub 1 (15 vehicles), Hub 2 (2 vehicles), Hub 3 (16 vehicles), Hub 4 (3 vehicles), Hub 5 (5 vehicles), and Hub 6 (3 vehicles).\n- From Hub 1: Vehicles can move to Hub 0 (7 vehicles), Hub 4 (19 vehicles), Hub 5 (15 vehicles), and Hub 6 (16 vehicles).\n- From Hub 2: Vehicles can move to Hub 0 (11 vehicles), Hub 1 (14 vehicles), Hub 3 (14 vehicles), Hub 4 (8 vehicles), Hub 5 (11 vehicles), and Hub 6 (6 vehicles).\n- From Hub 3: Vehicles can move to Hub 0 (17 vehicles), Hub 1 (11 vehicles), Hub 2 (11 vehicles), Hub 4 (11 vehicles), Hub 5 (16 vehicles), and Hub 6 (19 vehicles).\n- From Hub 4: Vehicles can move to Hub 0 (10 vehicles), Hub 1 (4 vehicles), Hub 2 (17 vehicles), Hub 3 (20 vehicles), Hub 5 (12 vehicles), and Hub 6 (17 vehicles).\n- From Hub 5: Vehicles can move to Hub 0 (3 vehicles), Hub 2 (4 vehicles), Hub 3 (5 vehicles), Hub 4 (20 vehicles), and Hub 6 (4 vehicles).\n- From Hub 6 (Main Distribution Hub): Vehicles can move back to Hub 0 (15 vehicles), Hub 1 (2 vehicles), Hub 2 (15 vehicles), Hub 3 (18 vehicles), Hub 4 (17 vehicles), and Hub 5 (7 vehicles).\n\nIn this advanced transit network, a capacity of \"0\" indicates that there is no direct transit lane connecting two specific hubs.\n\nThe objective is to determine the maximum capacity of vehicles that can be dispatched from Hub 0 (the Central Dispatch Center) to Hub 6 (the Main Distribution Hub) per hour, while ensuring that the flow through each transit lane does not exceed its specified capacity limit. \n\nWhat is the maximum number of vehicles that can be optimally dispatched from the Central Dispatch Center to the Main Distribution Hub within an hour?",
    "ground_truth": 44.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E059",
    "description": "Welcome to the virtual challenge of constructing a futuristic energy distribution network spanning across 8 pivotal nodes, designed to optimize the flow of a newly discovered renewable energy source from its origin to a central processing facility. This network, conceptualized within a high-tech cityscape, involves complex routes and capacities that dictate the maximum energy flow possible between nodes, each representing energy substations or relay points.\n\nHere’s a closer look at the energy flow capacities (in megawatts) between these substations:\n\n- From Substation 0 (Source): Energy can be directed to Substation 1 (19 MW), Substation 2 (4 MW), Substation 3 (1 MW), Substation 4 (9 MW), Substation 5 (13 MW), Substation 6 (8 MW), and Substation 7 (20 MW).\n- From Substation 1: Can relay energy to Substation 0 (10 MW), Substation 2 (12 MW), Substation 3 (12 MW), Substation 4 (8 MW), Substation 5 (12 MW), Substation 6 (7 MW), and Substation 7 (7 MW).\n- From Substation 2: Can transfer energy to Substation 0 (13 MW), Substation 1 (11 MW), Substation 3 (8 MW), Substation 4 (4 MW), Substation 5 (1 MW), Substation 6 (2 MW), and Substation 7 (3 MW).\n- From Substation 3: Can distribute energy to Substation 0 (4 MW), Substation 1 (12 MW), Substation 2 (13 MW), Substation 4 (18 MW), Substation 5 (6 MW), Substation 6 (19 MW), and Substation 7 (8 MW).\n- From Substation 4: Can send energy to Substation 0 (9 MW), Substation 1 (16 MW), Substation 2 (2 MW), Substation 5 (14 MW), Substation 6 (18 MW), and Substation 7 (7 MW).\n- From Substation 5: Can dispatch energy to Substation 0 (10 MW), Substation 1 (11 MW), Substation 2 (7 MW), Substation 3 (11 MW), Substation 4 (16 MW), Substation 6 (16 MW), and Substation 7 (5 MW).\n- From Substation 6: Capable of forwarding energy to Substation 0 (14 MW), Substation 1 (11 MW), Substation 2 (9 MW), Substation 3 (11 MW), Substation 4 (3 MW), Substation 5 (17 MW), and Substation 7 (19 MW).\n- From Substation 7 (Destination): Can receive energy and has the potential to send it back to Substation 0 (12 MW), Substation 1 (20 MW), Substation 2 (5 MW), Substation 3 (11 MW), Substation 4 (10 MW), Substation 5 (4 MW), and Substation 6 (6 MW).\n\nIn this setup, a capacity of \"0\" signifies the absence of a direct energy transfer link between the two respective substations.\n\nThe ultimate objective is to compute the maximum energy that can be transmitted from Substation 0 (the source) to Substation 7 (the destination) per time unit, with the condition that the energy flow through each link does not surpass its maximum capacity. What is the optimal value of energy (in megawatts) that can be efficiently relayed from the source to the destination per time unit?",
    "ground_truth": 69.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "run_error"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Energy"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E071",
    "description": "In the heart of a bustling metropolis, an expansive network of waterways and canals forms the lifeline for its residents, connecting 9 critical distribution centers that manage the flow of water from the city's reservoirs to its farthest suburbs. This intricate system, designed to ensure the smooth and efficient delivery of water, consists of channels with varying capacities, reflecting the maximum volumes of water (in thousands of gallons per hour) that can traverse these connections without causing overflow or damage.\n\nHere's a detailed look at the capacities of each channel in this vital network:\n\n- From Distribution Center 0 (Source), the water can be directed to Centers 1 through 8 with capacities of 9, 7, 18, 0, 0, 7, 0, and 2 thousand gallons per hour, respectively.\n- Center 1 has the capability to forward water to other centers, including sending 15, 11, 5, 20, 15, 18, 9, and 15 thousand gallons per hour to Centers 0 through 8 (excluding itself).\n- Similarly, the capacities from Center 2 to others are marked by flows of 3, 8, 0, 10, 16, 18, 8, 0, and 20 thousand gallons per hour to Centers 0 through 8, respectively.\n- The flow continues from Center 3 with capacities of 13, 3, 7, 0, 20, 13, 16, 6, and 20 thousand gallons per hour to the respective centers.\n- From Center 4, water can be distributed with capacities of 7, 20, 2, 4, 0, 9, 3, 14, and 2 thousand gallons per hour.\n- Center 5 allows for a distribution flow of 17, 10, 5, 1, 4, 0, 4, 3, and 20 thousand gallons per hour towards the respective centers.\n- The network from Center 6 can support flows of 0, 20, 10, 10, 15, 5, 0, 1, and 10 thousand gallons per hour.\n- From Center 7, water can be directed with capacities of 10, 3, 9, 4, 3, 13, 18, 0, and 20 thousand gallons per hour.\n- Finally, Center 8 can send back or redistribute water with capacities of 2, 12, 10, 5, 15, 14, 0, 10, and 0 thousand gallons per hour to the respective centers.\n\nIn this network, a capacity of \"0\" indicates the absence of a direct channel between two centers, necessitating the redirection of flow through other centers to ensure connectivity.\n\nGiven this complex and dynamic system, the city's water management team faces the challenging task of determining the maximum volume of water that can be efficiently distributed from Distribution Center 0 (the source) to all other centers, culminating at the final node (Center 8) which represents the city's outskirts. This calculation is crucial for optimizing the water supply and meeting the growing needs of the city's population.\n\nWhat is the maximum amount of water (in thousands of gallons per hour) that can be distributed from the source to the outskirts without exceeding the specified capacities of the channels in the network?",
    "ground_truth": 43.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"WaterDistribution\")\n\n# Parameters\nN = 9  # Number of distribution centers\nS = 0  # Source\nT = 8  # Sink\n\n# Capacity matrix C_ij\nC = [\n    [0, 9, 7, 18, 0, 0, 7, 0, 2],  # From center 0\n    [15, 0, 11, 5, 20, 15, 18, 9, 15],  # From center 1\n    [3, 8, 0, 10, 16, 18, 8, 0, 20],  # From center 2\n    [13, 3, 7, 0, 20, 13, 16, 6, 20],  # From center 3\n    [7, 20, 2, 4, 0, 9, 3, 14, 2],  # From center 4\n    [17, 10, 5, 1, 4, 0, 4, 3, 20],  # From center 5\n    [0, 20, 10, 10, 15, 5, 0, 1, 10],  # From center 6\n    [10, 3, 9, 4, 3, 13, 18, 0, 20],  # From center 7\n    [2, 12, 10, 5, 15, 14, 0, 10, 0]   # From center 8\n]\n\n# Decision variables: f_ij, flow from center i to center j\nf = model.addVars(N, N, lb=0, vtype=GRB.CONTINUOUS, name=\"f\")\n\n# Objective: Maximize the total flow from source S to sink T\nmodel.setObjective(gp.quicksum(f[S, j] for j in range(N)), GRB.MAXIMIZE)\n\n# Constraints\n# 1. Capacity constraints\nfor i in range(N):\n    for j in range(N):\n        model.addConstr(f[i, j] <= C[i][j])\n\n# 2. Flow conservation constraints\nfor i in range(N):\n    if i != S and i != T:\n        model.addConstr(gp.quicksum(f[i, j] for j in range(N)) == gp.quicksum(f[j, i] for j in range(N)))\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Utilities"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E067",
    "description": "Welcome to the challenge of optimizing the logistics network of a futuristic city, connected by an advanced transportation system comprising 8 crucial nodes. This city's system is designed to maximize the efficiency of goods transport from the central distribution hub to a primary delivery station, passing through various checkpoints and distribution centers along the way.\n\nHere's a detailed view of the transportation capacities (in thousands of units) that each route can handle:\n\n- From Node 0 (Source): Can dispatch goods to Node 1 (3 units), Node 2 (7 units), Node 3 (2 units), Node 4 (18 units), Node 5 (18 units), Node 6 (14 units), and Node 7 (10 units).\n- From Node 1: Can send goods to Node 0 (1 unit), Node 2 (10 units), Node 3 (16 units), Node 4 (14 units), Node 6 (6 units), and Node 7 (10 units).\n- From Node 2: Can transport goods to Node 0 (4 units), Node 3 (7 units), Node 4 (2 units), Node 5 (2 units), Node 6 (6 units), and Node 7 (10 units).\n- From Node 3: Can move goods to Node 0 (2 units), Node 1 (3 units), Node 2 (7 units), Node 4 (20 units), Node 5 (8 units), Node 6 (6 units), and Node 7 (10 units).\n- From Node 4: Can dispatch goods to Node 0 (1 unit), Node 1 (20 units), Node 2 (4 units), Node 3 (8 units), Node 5 (13 units), Node 6 (8 units), and Node 7 (1 unit).\n- From Node 5: Can send goods to Node 0 (16 units), Node 1 (9 units), Node 2 (17 units), Node 3 (17 units), Node 4 (11 units), Node 6 (7 units), and Node 7 (8 units).\n- From Node 6: Can transport goods to Node 0 (3 units), Node 1 (7 units), Node 2 (14 units), Node 3 (1 unit), Node 4 (20 units), Node 5 (5 units), and Node 7 (13 units).\n- From Node 7 (Destination): Can receive goods from Node 0 (3 units), Node 1 (6 units), Node 2 (5 units), Node 3 (1 unit), Node 4 (14 units), Node 5 (20 units), and Node 6 (9 units).\n\nA capacity of \"0\" indicates there is no direct route available between those two nodes.\n\nThe goal is to determine the maximum amount of goods (in thousands of units) that can be transported from the central distribution hub (Node 0) to the primary delivery station (Node 7) without exceeding the transport capacity of any route.\n\nWhat is the optimal value of goods (in thousands of units) that can be transported from the source to the destination?",
    "ground_truth": 62.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"LogisticsNetworkOptimization\")\n\n# Set of nodes\nN = range(8)\n\n# Capacity of routes\ncapacity = {\n    (0, 1): 3, (0, 2): 7, (0, 3): 2, (0, 4): 18, (0, 5): 18, (0, 6): 14, (0, 7): 10,\n    (1, 0): 1, (1, 2): 10, (1, 3): 16, (1, 4): 14, (1, 6): 6, (1, 7): 10,\n    (2, 0): 4, (2, 3): 7, (2, 4): 2, (2, 5): 2, (2, 6): 6, (2, 7): 10,\n    (3, 0): 2, (3, 1): 3, (3, 2): 7, (3, 4): 20, (3, 5): 8, (3, 6): 6, (3, 7): 10,\n    (4, 0): 1, (4, 1): 20, (4, 2): 4, (4, 3): 8, (4, 5): 13, (4, 6): 8, (4, 7): 1,\n    (5, 0): 16, (5, 1): 9, (5, 2): 17, (5, 3): 17, (5, 4): 11, (5, 6): 7, (5, 7): 8,\n    (6, 0): 3, (6, 1): 7, (6, 2): 14, (6, 3): 1, (6, 4): 20, (6, 5): 5, (6, 7): 13,\n    (7, 0): 3, (7, 1): 6, (7, 2): 5, (7, 3): 1, (7, 4): 14, (7, 5): 20, (7, 6): 9\n}\n\n# Add variables\nflow = model.addVars(capacity.keys(), lb=0, ub=capacity, vtype=GRB.CONTINUOUS, name=\"flow\")\n\n# Objective: Maximize flow from node 0 to node 7\nmodel.setObjective(flow.sum(0, '*') - flow.sum('*', 0), GRB.MAXIMIZE)\n\n# Add capacity constraints\nmodel.addConstrs((flow[i, j] <= capacity[i, j] for i, j in capacity), \"Capacity\")\n\n# Add flow conservation constraints\nmodel.addConstrs((flow.sum('*', i) == flow.sum(i, '*') for i in N if i != 0 and i != 7), \"FlowConservation\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E056",
    "description": "Imagine a bustling city where seven primary communication stations are in operation. These stations, ranging from a central source (Station 0) to the main endpoint (Station 6), are interconnected by a network of telecommunication lines with varying transfer capacities.\n\nHere are the capacities of each connection, representing the maximum amount of data (in terabytes) that can be transferred from one station to another:\n\n- From Station 0 (Source): Can send data to Station 1 (17TB), Station 2 (3TB), Station 3 (20TB), Station 4 (11TB), Station 5 (11TB), and Station 6 (3TB).\n- From Station 1: Can send data to Station 0 (11TB), Station 2 (12TB), Station 3 (18TB), Station 4 (5TB), Station 5 (6TB), and Station 6 (4TB).\n- From Station 2: Can send data to Station 0 (7TB), Station 1 (2TB), Station 3 (15TB), Station 4 (13TB), Station 5 (20TB), and Station 6 (18TB).\n- From Station 3: Can send data to Station 0 (7TB), Station 1 (4TB), Station 2 (2TB), Station 4 (2TB), Station 5 (15TB), and Station 6 (3TB).\n- From Station 4: Can send data to Station 0 (19TB), Station 1 (12TB), Station 2 (16TB), Station 3 (4TB), Station 5 (19TB), and Station 6 (4TB).\n- From Station 5: Can send data to Station 0 (13TB), Station 1 (20TB), Station 2 (10TB), Station 3 (14TB), Station 4 (15TB), and Station 6 (1TB).\n- From Station 6 (Endpoint): Can send data back to Station 0 (3TB), Station 1 (3TB), Station 2 (6TB), Station 3 (20TB), Station 4 (9TB), and Station 5 (10TB).\n\nIn this scenario, a capacity of \"0\" indicates there is no direct telecommunication link between the two respective stations.\n\nYour challenge is to determine the maximum amount of data that can be transferred from Station 0 (the source) to Station 6 (the endpoint) per hour, while ensuring the data flow along each telecommunication line does not exceed its set capacity. What is the maximum amount of data, in terabytes, that can be transferred from the source to the endpoint within one hour?",
    "ground_truth": 33.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Maximize_Data_Flow\")\n\n# Parameters\nV = range(7)  # Set of stations\nC = [\n    [0, 17, 3, 20, 11, 11, 3],\n    [11, 0, 12, 18, 5, 6, 4],\n    [7, 2, 0, 15, 13, 20, 18],\n    [7, 4, 2, 0, 2, 15, 3],\n    [19, 12, 16, 4, 0, 19, 4],\n    [13, 20, 10, 14, 15, 0, 1],\n    [3, 3, 6, 20, 9, 10, 0]\n]\n\n# Variables\nf = model.addVars(V, V, lb=0, ub=GRB.INFINITY, vtype=GRB.CONTINUOUS, name=\"f\")\n\n# Objective: Maximize the flow from source (Station 0) to endpoint (Station 6)\nmodel.setObjective(gp.quicksum(f[0, j] for j in V) - gp.quicksum(f[i, 0] for i in V), GRB.MAXIMIZE)\n\n# Constraints\n# Capacity constraints\nfor i in V:\n    for j in V:\n        if i != j:\n            model.addConstr(f[i, j] <= C[i][j], f\"capacity_{i}_{j}\")\n\n# Flow conservation constraints for each station except source and sink\nfor i in V:\n    if i not in [0, 6]:\n        model.addConstr(gp.quicksum(f[i, j] for j in V) - gp.quicksum(f[k, i] for k in V) == 0, f\"flow_conservation_{i}\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Telecommunications"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E053",
    "description": "Let's consider a complex transportation network comprised of 6 major cargo hubs, stretching from a main dispatch center to a primary delivery destination. These hubs are interconnected by roads, each with its own weight limit for cargo transportation.\n\nHere's how the weight limits of each road are distributed, reflecting the maximum amount of cargo (in tons) that can be transported from one hub to another:\n\n- From Hub 0 (Dispatch Center): Can send cargo to Hub 1 (7 tons), Hub 2 (8 tons), Hub 3 (1 ton), Hub 4 (2 tons), and Hub 5 (4 tons).\n- From Hub 1: Can send cargo to Hub 0 (15 tons), Hub 2 (16 tons), Hub 4 (9 tons), and Hub 5 (13 tons).\n- From Hub 2: Can send cargo to Hub 0 (9 tons), Hub 1 (1 ton), Hub 3 (9 tons), Hub 4 (13 tons), and Hub 5 (13 tons).\n- From Hub 3: Can send cargo to Hub 0 (10 tons), Hub 1 (11 tons), Hub 2 (19 tons), Hub 4 (1 ton), and Hub 5 (12 tons).\n- From Hub 4: Can send cargo to Hub 0 (15 tons), Hub 1 (16 tons), Hub 2 (7 tons), Hub 3 (11 tons), and Hub 5 (19 tons).\n- From Hub 5 (Destination): Can send cargo back to Hub 0 (10 tons), Hub 1 (12 tons), Hub 2 (12 tons), Hub 3 (12 tons), and Hub 4 (20 tons).\n\nIn this model, a capacity of \"0\" indicates there is no direct road connection between those two hubs.\n\nThe challenge is to determine the maximum amount of cargo that can be transported from Hub 0 (the dispatch center) to Hub 5 (the destination) per day, in a manner that the cargo on each road does not surpass its listed weight limit. What is the maximum amount of cargo that can be delivered from the dispatch center to the destination in tons per day? Please note that the answer should provide only the optimal value under the maximum flow scenario, and all the data in the problem details should be included in the created question.",
    "ground_truth": 22.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MaxFlowTransportation\")\n\n# Sets\nN = [0, 1, 2, 3, 4, 5]\n\n# Parameters: capacity of roads between hubs\nc = {\n    (0, 1): 7, (0, 2): 8, (0, 3): 1, (0, 4): 2, (0, 5): 4,\n    (1, 0): 15, (1, 2): 16, (1, 4): 9, (1, 5): 13,\n    (2, 0): 9, (2, 1): 1, (2, 3): 9, (2, 4): 13, (2, 5): 13,\n    (3, 0): 10, (3, 1): 11, (3, 2): 19, (3, 4): 1, (3, 5): 12,\n    (4, 0): 15, (4, 1): 16, (4, 2): 7, (4, 3): 11, (4, 5): 19,\n    (5, 0): 10, (5, 1): 12, (5, 2): 12, (5, 3): 12, (5, 4): 20\n}\n\n# Variables: flow of cargo from hub i to hub j\nf = model.addVars(N, N, name=\"f\", lb=0)\n\n# Objective: Maximize the total flow from hub 0 to hub 5\nmodel.setObjective(gp.quicksum(f[0, j] for j in N) - gp.quicksum(f[i, 0] for i in N), GRB.MAXIMIZE)\n\n# Constraints\n\n# Capacity constraints\nmodel.addConstrs((f[i, j] <= c[i, j] for i, j in c), name=\"capacity\")\n\n# Flow conservation constraints for each hub except source (0) and sink (5)\nmodel.addConstrs((gp.quicksum(f[i, j] for j in N) == gp.quicksum(f[j, i] for j in N) for i in N if i != 0 and i != 5), name=\"flow_conservation\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E069",
    "description": "Welcome to the fictional city of Aquaville, where the city's administration is working on a groundbreaking project to maximize the efficiency of its new water distribution network. This network is designed to ensure that every corner of the city has access to water, especially in times of need. The system is made up of 9 pivotal stations - including the main water source and the central distribution hub - connected by a series of pipelines with varying capacities.\n\nHere's a closer look at the capacities (in thousands of gallons per hour) that each pipeline can handle, showcasing the maximum flow from one station to another across the city:\n\n- From Station 0 (Source): Water can be directed to Station 1 (2 gallons), Station 2 (8 gallons), Station 3 (17 gallons), Station 4 (16 gallons), Station 5 (20 gallons), Station 6 (15 gallons), Station 7 (12 gallons), and Station 8 (9 gallons).\n- From Station 1: Water can flow to Station 0 (4 gallons), Station 2 (11 gallons), Station 3 (7 gallons), Station 4 (3 gallons), Station 5 (19 gallons), Station 6 (10 gallons), Station 7 (19 gallons), and Station 8 (8 gallons).\n- From Station 2: Water can move to Station 0 (14 gallons), Station 1 (7 gallons), Station 3 (7 gallons), Station 4 (13 gallons), Station 5 (19 gallons), Station 6 (18 gallons), Station 7 (20 gallons), and Station 8 (5 gallons).\n- From Station 3: Water can be sent to Station 0 (17 gallons), Station 1 (17 gallons), Station 2 (7 gallons), Station 4 (11 gallons), Station 5 (7 gallons), Station 6 (17 gallons), Station 7 (0 gallons), and Station 8 (10 gallons).\n- From Station 4: Water can be distributed to Station 0 (20 gallons), Station 1 (10 gallons), Station 2 (2 gallons), Station 3 (18 gallons), Station 5 (15 gallons), Station 6 (8 gallons), Station 7 (6 gallons), and Station 8 (18 gallons).\n- From Station 5: Water can be channeled to Station 0 (4 gallons), Station 1 (9 gallons), Station 2 (12 gallons), Station 3 (1 gallon), Station 4 (17 gallons), Station 6 (0 gallons), Station 7 (13 gallons), and Station 8 (18 gallons).\n- From Station 6: Water can flow to Station 0 (12 gallons), Station 1 (15 gallons), Station 2 (12 gallons), Station 3 (19 gallons), Station 4 (18 gallons), Station 5 (19 gallons), Station 7 (6 gallons), and Station 8 (17 gallons).\n- From Station 7: Water can be directed to Station 0 (14 gallons), Station 1 (1 gallon), Station 2 (17 gallons), Station 3 (20 gallons), Station 4 (11 gallons), Station 5 (20 gallons), Station 6 (6 gallons), and Station 8 (4 gallons).\n- From Station 8 (Destination): Water can be sent back to Station 0 (19 gallons), Station 1 (3 gallons), Station 2 (19 gallons), Station 3 (12 gallons), Station 4 (8 gallons), Station 5 (18 gallons), Station 6 (17 gallons), and Station 7 (13 gallons).\n\nIn this intricate network, a capacity of \"0\" implies that there is no direct connection for water flow between those two specific stations.\n\nThe critical mission is to determine the maximum quantity of water that can be efficiently distributed from Station 0, the primary source, to Station 8, the central distribution hub, per hour. The flow through each pipeline must not exceed its maximum specified capacity.\n\nWhat is the optimal amount of water (in thousands of gallons per hour) that can be transported from the source to the distribution hub, ensuring the network operates at its maximum potential?",
    "ground_truth": 89.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new Gurobi model\nmodel = gp.Model(\"WaterDistributionNetwork\")\n\n# Set the number of stations\nN = 9\n\n# Define the capacity matrix\nc = [\n    [0, 2, 8, 17, 16, 20, 15, 12, 9],\n    [4, 0, 11, 7, 3, 19, 10, 19, 8],\n    [14, 7, 0, 7, 13, 19, 18, 20, 5],\n    [17, 17, 7, 0, 11, 7, 17, 0, 10],\n    [20, 10, 2, 18, 0, 15, 8, 6, 18],\n    [4, 9, 12, 1, 17, 0, 0, 13, 18],\n    [12, 15, 12, 19, 18, 19, 0, 6, 17],\n    [14, 1, 17, 20, 11, 20, 6, 0, 4],\n    [19, 3, 19, 12, 8, 18, 17, 13, 0]\n]\n\n# Create a dictionary for flow variables\nflow = model.addVars(N, N, lb=0, ub=c, vtype=GRB.CONTINUOUS, name=\"flow\")\n\n# Set the objective to maximize the flow from station 0 to station 8\nmodel.setObjective(gp.quicksum(flow[0, j] for j in range(N)), GRB.MAXIMIZE)\n\n# Add capacity constraints\nfor i in range(N):\n    for j in range(N):\n        if c[i][j] > 0:\n            model.addConstr(flow[i, j] <= c[i][j], name=f\"capacity_{i}_{j}\")\n\n# Add flow conservation constraints for each station except source and destination\nfor i in range(1, N-1):\n    model.addConstr(gp.quicksum(flow[i, j] for j in range(N)) == gp.quicksum(flow[j, i] for j in range(N)), name=f\"flow_conservation_{i}\")\n\n# Add source and destination flow constraint\nmodel.addConstr(gp.quicksum(flow[0, j] for j in range(N)) == gp.quicksum(flow[i, 8] for i in range(N)), name=\"source_to_destination_flow\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Utilities"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E066",
    "description": "Embark on a journey through a bustling transport network in the heart of a bustling metropolis, featuring 9 critical nodes that form the backbone of this city's logistic framework. From the primary dispatch center to the ultimate distribution hub, each node plays a pivotal role in ensuring goods and resources flow seamlessly across the city.\n\nHere's a detailed glimpse into the transport capacities (in thousands of units) between these nodes, ensuring that every node is a cog in the machine that keeps the city running:\n\n- From Node 0 (The Source): Goods can be dispatched to Node 1 (13 units), Node 2 (19 units), Node 3 (17 units), Node 4 (7 units), Node 5 (7 units), Node 6 (11 units), Node 7 (7 units), and Node 8 (7 units).\n- From Node 1: Goods can move on to Node 0 (9 units), Node 2 (19 units), Node 3 (20 units), Node 4 (10 units), Node 5 (19 units), Node 6 (20 units), Node 7 (19 units), and Node 8 (3 units).\n- From Node 2: Goods can be transported to Node 0 (0 units), Node 1 (16 units), Node 3 (0 units), Node 4 (10 units), Node 5 (2 units), Node 6 (14 units), Node 7 (9 units), and Node 8 (9 units).\n- From Node 3: Goods can be routed to Node 0 (6 units), Node 1 (0 units), Node 2 (5 units), Node 4 (7 units), Node 5 (18 units), Node 6 (15 units), Node 7 (20 units), and Node 8 (7 units).\n- From Node 4: Goods can be forwarded to Node 0 (18 units), Node 1 (19 units), Node 2 (12 units), Node 3 (0 units), Node 5 (16 units), Node 6 (20 units), Node 7 (10 units), and Node 8 (4 units).\n- From Node 5: Goods can be sent to Node 0 (3 units), Node 1 (4 units), Node 2 (8 units), Node 3 (9 units), Node 4 (20 units), Node 6 (7 units), Node 7 (8 units), and Node 8 (1 unit).\n- From Node 6: Goods can be transported to Node 0 (3 units), Node 1 (14 units), Node 2 (14 units), Node 3 (16 units), Node 4 (1 unit), Node 5 (12 units), Node 7 (10 units), and Node 8 (10 units).\n- From Node 7: Goods can move on to Node 0 (9 units), Node 1 (20 units), Node 2 (19 units), Node 3 (4 units), Node 4 (9 units), Node 5 (16 units), Node 6 (1 unit), and Node 8 (6 units).\n- From Node 8 (The Destination): Goods from Node 0 (7 units), Node 1 (15 units), Node 2 (14 units), Node 3 (18 units), Node 4 (18 units), Node 5 (11 units), Node 6 (18 units) can be finally distributed.\n\nA capacity of \"0\" signifies the absence of a direct route between those particular nodes, indicating the need for strategic planning to navigate goods through this intricate network.\n\nYour mission is to calculate the maximum volume of goods (in thousands of units) that can be transported from Node 0, the primary dispatch center, to Node 8, the ultimate distribution hub, per unit time. This calculation must ensure that the flow of goods through each connection does not exceed its transportation capacity. What is the maximum volume of goods that can be moved from the source to the destination in thousands of units?",
    "ground_truth": 47.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Maximize_Flow\")\n\n# Nodes in the network\nnodes = range(9)\n\n# Define the capacity matrix\ncapacity = [\n    [0, 13, 19, 17, 7, 7, 11, 7, 7],\n    [9, 0, 19, 20, 10, 19, 20, 19, 3],\n    [0, 16, 0, 0, 10, 2, 14, 9, 9],\n    [6, 0, 5, 0, 7, 18, 15, 20, 7],\n    [18, 19, 12, 0, 0, 16, 20, 10, 4],\n    [3, 4, 8, 9, 20, 0, 7, 8, 1],\n    [3, 14, 14, 16, 1, 12, 0, 10, 10],\n    [9, 20, 19, 4, 9, 16, 1, 0, 6],\n    [7, 15, 14, 18, 18, 11, 18, 0, 0]\n]\n\n# Create variables for the flow between nodes\nflow = model.addVars(nodes, nodes, name=\"flow\", lb=0)\n\n# Set the objective function to maximize the flow from source to destination\nmodel.setObjective(gp.quicksum(flow[0, j] for j in nodes) - gp.quicksum(flow[i, 0] for i in nodes), GRB.MAXIMIZE)\n\n# Add capacity constraints\nmodel.addConstrs((flow[i, j] <= capacity[i][j] for i in nodes for j in nodes), \"Capacity\")\n\n# Add flow conservation constraints for all nodes except source (0) and sink (8)\nmodel.addConstrs((gp.quicksum(flow[i, j] for j in nodes) - gp.quicksum(flow[k, i] for k in nodes) == 0 for i in nodes if i not in [0, 8]), \"FlowConservation\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E057",
    "description": "Imagine a city that has a complex electrical network with 8 power stations (including source and the main receiving stations). The stations are connected with transmission lines, each capable of handling a certain amount of electricity.\n\nHere's the capacity of each transmission line, showing the maximum amount of electricity (in megawatts) that can flow from one station to another:\n\n- From Station 0 (Source): Can send electricity to Station 1 (9 MW), Station 2 (6 MW), Station 3 (1 MW), Station 4 (8 MW), Station 5 (14 MW), Station 6 (1 MW) and Station 7 (17 MW).\n- From Station 1: Can send electricity to Station 0 (1 MW), Station 2 (6 MW), Station 3 (14 MW), Station 4 (16 MW), Station 5 (8 MW), Station 6 (19 MW) and Station 7 (15 MW).\n- From Station 2: Can send electricity to Station 0 (4 MW), Station 1 (7 MW), Station 3 (9 MW), Station 4 (1 MW), Station 5 (2 MW), Station 6 (9 MW) and Station 7 (4 MW).\n- From Station 3: Can send electricity to Station 0 (11 MW), Station 1 (5 MW), Station 2 (14 MW), Station 4 (17 MW), Station 5 (6 MW), Station 6 (20 MW) and Station 7 (13 MW).\n- From Station 4: Can send electricity to Station 0 (8 MW), Station 1 (5 MW), Station 2 (20 MW), Station 3 (0 MW), Station 5 (16 MW), Station 6 (5 MW) and Station 7 (5 MW).\n- From Station 5: Can send electricity to Station 0 (15 MW), Station 1 (18 MW), Station 2 (9 MW), Station 3 (1 MW), Station 4 (19 MW), Station 6 (16 MW) and Station 7 (0 MW).\n- From Station 6: Can send electricity to Station 0 (20 MW), Station 1 (15 MW), Station 2 (1 MW), Station 3 (0 MW), Station 4 (11 MW), Station 5 (6 MW) and Station 7 (19 MW).\n- From Station 7 (Destination): Can send electricity back to Station 0 (4 MW), Station 1 (18 MW), Station 2 (10 MW), Station 3 (2 MW), Station 4 (1 MW), Station 5 (20 MW) and Station 6 (14 MW).\n\nIn this network, a capacity of \"0\" means there is no direct transmission line between those two stations.\n\nThe challenge is to calculate the maximum amount of electricity that can be transmitted from Station 0 (the source) to Station 7 (the main receiving station), ensuring that the flow through each transmission line does not exceed its capacity. What is the maximum amount of electricity that can be transmitted from the source to the destination in megawatts?",
    "ground_truth": 56.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Initialize model\nmodel = gp.Model(\"Electrical Network Flow Optimization\")\n\n# Set of stations\nstations = range(8)\n\n# Capacities dictionary\ncapacities = {\n    (0, 1): 9, (0, 2): 6, (0, 3): 1, (0, 4): 8, (0, 5): 14, (0, 6): 1, (0, 7): 17,\n    (1, 0): 1, (1, 2): 6, (1, 3): 14, (1, 4): 16, (1, 5): 8, (1, 6): 19, (1, 7): 15,\n    (2, 0): 4, (2, 1): 7, (2, 3): 9, (2, 4): 1, (2, 5): 2, (2, 6): 9, (2, 7): 4,\n    (3, 0): 11, (3, 1): 5, (3, 2): 14, (3, 4): 17, (3, 5): 6, (3, 6): 20, (3, 7): 13,\n    (4, 0): 8, (4, 1): 5, (4, 2): 20, (4, 5): 16, (4, 6): 5, (4, 7): 5,\n    (5, 0): 15, (5, 1): 18, (5, 2): 9, (5, 3): 1, (5, 4): 19, (5, 6): 16,\n    (6, 0): 20, (6, 1): 15, (6, 2): 1, (6, 4): 11, (6, 5): 6, (6, 7): 19,\n    (7, 0): 4, (7, 1): 18, (7, 2): 10, (7, 3): 2, (7, 4): 1, (7, 5): 20, (7, 6): 14\n}\n\n# Variables: Create flow variables for each station pair\nflow = model.addVars(capacities.keys(), lb=0, ub=[capacities[i, j] for i, j in capacities], vtype=GRB.CONTINUOUS, name=\"flow\")\n\n# Objective: Maximize the flow from Source (Station 0) to Destination (Station 7)\nmodel.setObjective(gp.quicksum(flow[0, j] for j in stations if (0, j) in capacities) \n                   - gp.quicksum(flow[i, 0] for i in stations if (i, 0) in capacities), GRB.MAXIMIZE)\n\n# Constraints: Capacity constraints\nmodel.addConstrs((flow[i, j] <= capacities[i, j] for i, j in capacities), name=\"capacity\")\n\n# Flow conservation constraints\nmodel.addConstrs((gp.quicksum(flow[i, j] for j in stations if (i, j) in capacities)\n                 - gp.quicksum(flow[k, i] for k in stations if (k, i) in capacities) == 0\n                 for i in stations if i != 0 and i != 7), name=\"flow_conservation\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Energy"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E052",
    "description": "Embark on a journey through a complex network of digital data highways, designed to facilitate the swift and secure transmission of information across 9 strategic relay stations. This network, vital for the operation of a futuristic city, relies on its capacity to handle vast amounts of data, ensuring that communication flows from its source to the intended destination without a hitch.\n\nHere's a detailed blueprint of the data flow capacities (in terabytes per hour) from one relay station to another within this intricate system:\n\n- From Station 0 (Source): Has the capability to dispatch data to Station 1 (15 TB), Station 2 (1 TB), Station 3 (9 TB), Station 4 (18 TB), Station 5 (12 TB), Station 6 (18 TB), Station 7 (6 TB), and Station 8 (17 TB).\n- From Station 1: Can transmit data to Station 0 (14 TB), Station 2 (13 TB), Station 3 (11 TB), Station 4 (14 TB), Station 5 (10 TB), Station 6 (15 TB), Station 7 (4 TB), and Station 8 (15 TB).\n- From Station 2: Can route data to Station 0 (3 TB), Station 3 (2 TB), Station 4 (14 TB), Station 5 (16 TB), Station 6 (7 TB), Station 7 (12 TB), and Station 8 (4 TB).\n- From Station 3: Can forward data to Station 0 (5 TB), Station 1 (20 TB), Station 4 (9 TB), Station 5 (1 TB), Station 6 (12 TB), Station 7 (1 TB), and Station 8 (20 TB).\n- From Station 4: Can push data to Station 0 (11 TB), Station 1 (18 TB), Station 2 (12 TB), Station 3 (3 TB), Station 5 (4 TB), Station 6 (16 TB), Station 7 (15 TB), and Station 8 (2 TB).\n- From Station 5: Can channel data to Station 0 (13 TB), Station 1 (8 TB), Station 2 (8 TB), Station 3 (6 TB), Station 4 (4 TB), Station 6 (8 TB), Station 7 (10 TB), and Station 8 (11 TB).\n- From Station 6: Can send data to Station 0 (12 TB), Station 1 (1 TB), Station 2 (3 TB), Station 3 (4 TB), Station 4 (11 TB), Station 5 (8 TB), Station 7 (10 TB), and Station 8 (19 TB).\n- From Station 7: Can relay data to Station 0 (18 TB), Station 1 (3 TB), Station 2 (9 TB), Station 3 (5 TB), Station 4 (9 TB), Station 5 (17 TB), Station 6 (10 TB), and Station 8 (13 TB).\n- From Station 8 (Destination): Data can be reflected back to Station 0 (9 TB), Station 1 (8 TB), Station 2 (12 TB), Station 3 (2 TB), Station 4 (5 TB), Station 5 (2 TB), Station 6 (16 TB), and Station 7 (5 TB).\n\nIn this virtual scenario, a capacity of \"0\" indicates that there is no direct data link between the specified stations, requiring the data to be rerouted through other nodes in the network.\n\nYour mission is to calculate the maximum amount of data (in terabytes per hour) that can be transmitted from Station 0 (the source) to Station 8 (the destination), ensuring that the traffic flowing through each data link does not exceed its maximum capacity. What is the optimal amount of data that can be relayed from the source to the destination per hour?",
    "ground_truth": 96.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Initialize model\nmodel = gp.Model(\"DataFlowOptimization\")\n\n# Parameters\nN = 9  # Total number of stations\nS = 0  # Source station\nD = 8  # Destination station\n\n# Capacity matrix C_ij\ncapacity = {\n    (0, 1): 15, (0, 2): 1, (0, 3): 9, (0, 4): 18, (0, 5): 12, (0, 6): 18, (0, 7): 6, (0, 8): 17,\n    (1, 0): 14, (1, 2): 13, (1, 3): 11, (1, 4): 14, (1, 5): 10, (1, 6): 15, (1, 7): 4, (1, 8): 15,\n    (2, 0): 3, (2, 3): 2, (2, 4): 14, (2, 5): 16, (2, 6): 7, (2, 7): 12, (2, 8): 4,\n    (3, 0): 5, (3, 1): 20, (3, 4): 9, (3, 5): 1, (3, 6): 12, (3, 7): 1, (3, 8): 20,\n    (4, 0): 11, (4, 1): 18, (4, 2): 12, (4, 3): 3, (4, 5): 4, (4, 6): 16, (4, 7): 15, (4, 8): 2,\n    (5, 0): 13, (5, 1): 8, (5, 2): 8, (5, 3): 6, (5, 4): 4, (5, 6): 8, (5, 7): 10, (5, 8): 11,\n    (6, 0): 12, (6, 1): 1, (6, 2): 3, (6, 3): 4, (6, 4): 11, (6, 5): 8, (6, 7): 10, (6, 8): 19,\n    (7, 0): 18, (7, 1): 3, (7, 2): 9, (7, 3): 5, (7, 4): 9, (7, 5): 17, (7, 6): 10, (7, 8): 13,\n    (8, 0): 9, (8, 1): 8, (8, 2): 12, (8, 3): 2, (8, 4): 5, (8, 5): 2, (8, 6): 16, (8, 7): 5\n}\n\n# Variables: Flow from station i to station j\nflow = model.addVars(capacity.keys(), name=\"flow\", lb=0, ub=capacity)\n\n# Objective: Maximize the total flow from source S to destination D\nmodel.setObjective(\n    gp.quicksum(flow[S, j] for j in range(N) if (S, j) in flow) -\n    gp.quicksum(flow[i, S] for i in range(N) if (i, S) in flow),\n    GRB.MAXIMIZE\n)\n\n# Constraints\n# Capacity constraints: f_ij <= C_ij\nmodel.addConstrs(\n    (flow[i, j] <= capacity[i, j] for i, j in capacity),\n    name=\"capacity_constraints\"\n)\n\n# Flow conservation constraints for each station i != S, D\nmodel.addConstrs(\n    (gp.quicksum(flow[i, j] for j in range(N) if (i, j) in flow) ==\n     gp.quicksum(flow[j, i] for j in range(N) if (j, i) in flow)\n     for i in range(N) if i != S and i != D),\n    name=\"flow_conservation_constraints\"\n)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "run_error"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Telecommunications"
      }
    ],
    "cluster": 6,
    "retrieved_insights": []
  },
  {
    "task_id": "E107",
    "description": "The China Railroad Ministry is in the process of planning relocations of freight cars among 5 regions of the country to get ready for the fall harvest. The following presents the costs of moving a car between each pair of regions. The costs are as follows: moving a car from region 1 to region 2 costs 10 units, to region 3 costs 12 units, to region 4 costs 17 units, and to region 5 costs 34 units. From region 2 to region 1 costs 10 units, to region 3 costs 18 units, to region 4 costs 8 units, and to region 5 costs 46 units. From region 3, moving a car to region 1 costs 12 units, to region 2 costs 18 units, to region 4 costs 9 units, and to region 5 costs 27 units. From region 4, the cost to move a car to region 1 is 17 units, to region 2 is 8 units, to region 3 is 9 units, and to region 5 is 20 units. Lastly, from region 5 to region 1 the cost is 34 units, to region 2 is 46 units, to region 3 is 27 units, and to region 4 is 20 units. The following displays the current number of cars and the number needed for harvest shipping in each region. Region 1 currently has 115 cars but needs 300. Region 2 has 385 cars available but requires 400. Region 3 has 410 cars against a need of 800. Region 4 is currently equipped with 480 cars, yet the need is only for 200. Finally, region 5 has 610 cars available, with a need for 300 cars. Minimize the cost to move the cars such as the need is met. Provide your answer rounded to the nearest dollar.",
    "ground_truth": 12170.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E038",
    "description": "Imagine you're the logistics coordinator in charge of distributing medical supplies among four different hospitals during an unexpected health crisis. Each hospital starts with a specific number of supplies but has varying needs based on the urgency and scale of cases they are handling.\n\nHere's what each hospital has and what they need:\n\n- Hospital 1 has 480 units of supplies but needs only 61 units.\n- Hospital 2 has 492 units but needs 313 units.\n- Hospital 3 has 74 units but needs 93 units.\n- Hospital 4 has 317 units but needs 199 units.\n\nDue to the urgent situation, you can transfer supplies between hospitals, but each transfer incurs a cost, which varies depending on the hospitals involved. Here’s a breakdown of the cost to transfer supplies from one hospital to another:\n\n- Moving supplies from/to Hospital 1: To Hospital 2 costs 8, to Hospital 3 costs 42, to Hospital 4 costs 27.\n- Moving supplies from/to Hospital 2: To Hospital 1 costs 17, to Hospital 3 costs 13, to Hospital 4 costs 30.\n- Moving supplies from/to Hospital 3: To Hospital 1 costs 4, to Hospital 2 costs 14, to Hospital 4 costs 16.\n- Moving supplies from/to Hospital 4: To Hospital 1 costs 33, to Hospital 2 costs 9, to Hospital 3 costs 42.\n\nYour objective is to ensure each hospital has the supplies it needs while minimizing the total cost of transfers. What would be the minimum cost to achieve this?",
    "ground_truth": 247.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "failure_solve"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Health"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E035",
    "description": "Welcome to the world of international logistics! You are a resource manager at a global company, responsible for the allocation of a valuable product among your six international warehouses.\n\nHere's what each warehouse currently has and what they need:\n\n- Warehouse 1 currently has 497 units but needs 161 units.\n- Warehouse 2 currently has 39 units but needs 257 units.\n- Warehouse 3 currently has 416 units but needs 252 units.\n- Warehouse 4 currently has 71 units but needs 251 units.\n- Warehouse 5 currently has 445 units but needs 372 units.\n- Warehouse 6 currently has 471 units but needs 370 units.\n\nYou need to orchestrate the movement of these resources to ensure every warehouse meets its required quantity. However, transportation between warehouses carries costs, and these costs vary depending on the pair of warehouses involved. Here's the cost matrix that shows the cost of moving a unit from one warehouse to another:\n\n- Moving product from/to Warehouse 1: To Warehouse 2 costs 5, to Warehouse 3 costs 7, to Warehouse 4 costs 5, to Warehouse 5 costs 27, and to Warehouse 6 costs 49.\n- Moving product from/to Warehouse 2: To Warehouse 1 costs 31, to Warehouse 3 costs 14, to Warehouse 4 costs 31, to Warehouse 5 costs 3, and to Warehouse 6 costs 4.\n- Moving product from/to Warehouse 3: To Warehouse 1 costs 9, to Warehouse 2 costs 13, to Warehouse 4 costs 23, to Warehouse 5 costs 38, and to Warehouse 6 costs 19.\n- Moving product from/to Warehouse 4: To Warehouse 1 costs 47, to Warehouse 2 costs 34, to Warehouse 3 costs 7, to Warehouse 5 costs 34, and to Warehouse 6 costs 35.\n- Moving product from/to Warehouse 5: To Warehouse 1 costs 21, to Warehouse 2 costs 11, to Warehouse 3 costs 6, to Warehouse 4 costs 7, and to Warehouse 6 costs 50.\n- Moving product from/to Warehouse 6: To Warehouse 1 costs 28, to Warehouse 2 costs 41, to Warehouse 3 costs 34, to Warehouse 4 costs 17, to Warehouse 5 costs 32.\n\nYour objective is to relocate the products such that all warehouse needs are met, but with the lowest possible total transportation cost. What is the minimum cost to ensure all warehouses have the quantities they need?",
    "ground_truth": 2114.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "failure_solve"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "B099",
    "description": "In network communication services, bandwidth plays an important role. Below is a bandwidth communication table between several communication nodes, showing the bandwidth between any two nodes. If two nodes cannot be directly connected, the corresponding bandwidth is $0$. It is required to establish a link between node $A$ and node $E$ that must pass through service node $C$ (without loops). The bandwidth of this link is defined as the minimum bandwidth value on the link. Please propose a reasonable link arrangement to maximize the bandwidth of this link and find out the maximum bandwidth.\n\n\\begin{table}[h]\n    \\centering\n    \\begin{tabular}{|c|c|c|c|c|c|}\n        \\hline\n        & A & B & C & D & E \\\\\n        \\hline\n        A & 0 & 90 & 85 & 0 & 65 \\\\\n        \\hline\n        B & 95 & 0 & 70 & 65 & 34 \\\\\n        \\hline\n        C & 60 & 0 & 0 & 88 & 80 \\\\\n        \\hline\n        D & 67 & 30 & 25 & 0 & 84 \\\\\n        \\hline\n        E & 0 & 51 & 0 & 56 & 0 \\\\\n        \\hline\n    \\end{tabular}\n\\end{table}",
    "ground_truth": 84.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_max_bandwidth_path():\n    \"\"\"\n    Solves the problem of finding a path from node A to E via node C\n    that maximizes the bottleneck bandwidth.\n    \"\"\"\n    try:\n        # --- Data ---\n        nodes_map = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}\n        nodes_rev_map = {v: k for k, v in nodes_map.items()}\n        num_nodes = len(nodes_map)\n        all_nodes = range(num_nodes)\n\n        start_node = nodes_map['A']\n        intermediate_node = nodes_map['C']\n        end_node = nodes_map['E']\n\n        # Bandwidth matrix BW[i][j]\n        #       A   B   C   D   E\n        bw_data = [\n            [0, 90, 85, 0, 65],  # A\n            [95, 0, 70, 65, 34],  # B\n            [60, 0, 0, 88, 80],  # C\n            [67, 30, 25, 0, 84],  # D\n            [0, 51, 0, 56, 0]  # E\n        ]\n\n        max_possible_bandwidth = 0\n        for row in bw_data:\n            for val in row:\n                if val > max_possible_bandwidth:\n                    max_possible_bandwidth = val\n        if max_possible_bandwidth == 0:  # Should not happen with given data\n            max_possible_bandwidth = 1000  # A large number\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"MaxBandwidthPathViaC\")\n\n        # --- Decision Variables ---\n        # x[i,j]: 1 if link (i,j) is in path A to C\n        x = model.addVars(all_nodes,\n                          all_nodes,\n                          vtype=GRB.BINARY,\n                          name=\"x_path_AC\")\n        # y[i,j]: 1 if link (i,j) is in path C to E\n        y = model.addVars(all_nodes,\n                          all_nodes,\n                          vtype=GRB.BINARY,\n                          name=\"y_path_CE\")\n\n        # B_overall: Overall bottleneck bandwidth of the A-C-E path\n        B_overall = model.addVar(name=\"OverallBandwidth\",\n                                 lb=0.0,\n                                 vtype=GRB.CONTINUOUS)\n\n        # Remove self-loops and links with zero bandwidth\n        for i in all_nodes:\n            x[i, i].UB = 0\n            y[i, i].UB = 0\n            for j in all_nodes:\n                if i == j: continue\n                if bw_data[i][j] == 0:\n                    x[i, j].UB = 0\n                    y[i, j].UB = 0\n\n        # --- Objective Function: Maximize B_overall ---\n        model.setObjective(B_overall, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # Path A (start_node) to C (intermediate_node) using x_vars\n        # 1. Flow out of start_node A for path x\n        model.addConstr(\n            gp.quicksum(x[start_node, j] for j in all_nodes\n                        if j != start_node) == 1, \"FlowOut_A_x\")\n        # 2. No flow into start_node A for path x\n        model.addConstr(\n            gp.quicksum(x[j, start_node] for j in all_nodes\n                        if j != start_node) == 0, \"FlowIn_A_x\")\n        # 3. Flow into intermediate_node C for path x\n        model.addConstr(\n            gp.quicksum(x[i, intermediate_node] for i in all_nodes\n                        if i != intermediate_node) == 1, \"FlowIn_C_x\")\n        # 4. No flow out of intermediate_node C for path x\n        model.addConstr(\n            gp.quicksum(x[intermediate_node, j] for j in all_nodes\n                        if j != intermediate_node) == 0, \"FlowOut_C_x\")\n        # 5. Flow conservation for other nodes in path x\n        for k in all_nodes:\n            if k != start_node and k != intermediate_node:\n                model.addConstr(gp.quicksum(x[i, k] for i in all_nodes\n                                            if i != k) == gp.quicksum(\n                                                x[k, j] for j in all_nodes\n                                                if j != k),\n                                name=f\"FlowCons_x_{k}\")\n                # Ensure intermediate nodes are visited at most once\n                model.addConstr(\n                    gp.quicksum(x[i, k] for i in all_nodes if i != k) <= 1,\n                    f\"VisitOnce_x_{k}\")\n\n        # Path C (intermediate_node) to E (end_node) using y_vars\n        # 6. Flow out of intermediate_node C for path y\n        model.addConstr(\n            gp.quicksum(y[intermediate_node, j] for j in all_nodes\n                        if j != intermediate_node) == 1, \"FlowOut_C_y\")\n        # 7. No flow into intermediate_node C for path y\n        model.addConstr(\n            gp.quicksum(y[j, intermediate_node] for j in all_nodes\n                        if j != intermediate_node) == 0, \"FlowIn_C_y\")\n        # 8. Flow into end_node E for path y\n        model.addConstr(\n            gp.quicksum(y[i, end_node] for i in all_nodes\n                        if i != end_node) == 1, \"FlowIn_E_y\")\n        # 9. No flow out of end_node E for path y\n        model.addConstr(\n            gp.quicksum(y[end_node, j] for j in all_nodes\n                        if j != end_node) == 0, \"FlowOut_E_y\")\n        # 10. Flow conservation for other nodes in path y\n        for k in all_nodes:\n            if k != intermediate_node and k != end_node:\n                model.addConstr(gp.quicksum(y[i, k] for i in all_nodes\n                                            if i != k) == gp.quicksum(\n                                                y[k, j] for j in all_nodes\n                                                if j != k),\n                                name=f\"FlowCons_y_{k}\")\n                # Ensure intermediate nodes are visited at most once\n                model.addConstr(\n                    gp.quicksum(y[i, k] for i in all_nodes if i != k) <= 1,\n                    f\"VisitOnce_y_{k}\")\n\n        # 11. Node Disjointness (except at C)\n        # Nodes B, D (indices 1, 3) cannot be intermediate in both paths.\n        # Node A (0) cannot be in path y. Node E (4) cannot be in path x.\n        for k in all_nodes:\n            if k != intermediate_node:  # For all nodes except C\n                # If node k is entered in path x, it cannot be entered in path y\n                model.addConstr(gp.quicksum(x[i, k]\n                                            for i in all_nodes if i != k) +\n                                gp.quicksum(y[i, k]\n                                            for i in all_nodes if i != k) <= 1,\n                                name=f\"NodeDisjoint_{k}\")\n\n        # 12. Bandwidth Definition\n        for i in all_nodes:\n            for j in all_nodes:\n                if i == j or bw_data[i][j] == 0:\n                    continue  # Skip self-loops and zero-bandwidth links\n                # If x[i,j] is 1, then B_overall <= bw_data[i][j]\n                model.addConstr(B_overall <= bw_data[i][j] +\n                                max_possible_bandwidth * (1 - x[i, j]),\n                                name=f\"B_limit_x_{i}_{j}\")\n                # If y[i,j] is 1, then B_overall <= bw_data[i][j]\n                model.addConstr(B_overall <= bw_data[i][j] +\n                                max_possible_bandwidth * (1 - y[i, j]),\n                                name=f\"B_limit_y_{i}_{j}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n        model.setParam('MIPGap', 0.001)  # Set a small MIP gap\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal link arrangement found.\")\n            print(\n                f\"Maximum Path Bandwidth (A through C to E): {B_overall.X:.2f}\"\n            )\n\n            path_AC_str = nodes_rev_map[start_node]\n            curr = start_node\n            visited_in_ac = {start_node}\n            for _ in range(num_nodes):  # Max possible length\n                found_next = False\n                for j_node in all_nodes:\n                    if curr != j_node and x[curr, j_node].X > 0.5:\n                        path_AC_str += f\" -> {nodes_rev_map[j_node]}\"\n                        curr = j_node\n                        visited_in_ac.add(curr)\n                        found_next = True\n                        break\n                if curr == intermediate_node or not found_next:\n                    break\n            print(f\"  Path A to C: {path_AC_str}\")\n\n            path_CE_str = nodes_rev_map[intermediate_node]\n            curr = intermediate_node\n            visited_in_ce = {intermediate_node}\n            for _ in range(num_nodes):  # Max possible length\n                found_next = False\n                for j_node in all_nodes:\n                    if curr != j_node and y[curr, j_node].X > 0.5:\n                        path_CE_str += f\" -> {nodes_rev_map[j_node]}\"\n                        curr = j_node\n                        visited_in_ce.add(curr)\n                        found_next = True\n                        break\n                if curr == end_node or not found_next:\n                    break\n            print(f\"  Path C to E: {path_CE_str}\")\n\n            print(\"\\n  Links used in A-C path and their bandwidths:\")\n            for i in all_nodes:\n                for j in all_nodes:\n                    if i != j and x[i, j].X > 0.5:\n                        print(\n                            f\"    {nodes_rev_map[i]} -> {nodes_rev_map[j]} (BW: {bw_data[i][j]})\"\n                        )\n\n            print(\"  Links used in C-E path and their bandwidths:\")\n            for i in all_nodes:\n                for j in all_nodes:\n                    if i != j and y[i, j].X > 0.5:\n                        print(\n                            f\"    {nodes_rev_map[i]} -> {nodes_rev_map[j]} (BW: {bw_data[i][j]})\"\n                        )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No path from A to E via C could be found or satisfies constraints.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"bandwidth_path_iis.ilp\")\n            print(\"IIS written to bandwidth_path_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_max_bandwidth_path()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "MILP",
        "industry_sector": "Telecommunications"
      }
    ],
    "cluster": 34,
    "retrieved_insights": []
  },
  {
    "task_id": "E102",
    "description": "There are four nodes connected by directed edges. Node 1, which could represent the starting point, is connected to two other nodes: There is an edge from node 1 to node 2 with a capacity of 5. There is an edge from node 1 to node 3 with a capacity of 7. Node 2 is situated at the top of the graph and acts as an intermediate node, with three edges connected to it: An edge leading from node 2 to node 3 with a capacity of 2. An edge leading from node 2 to node 4 with a capacity of 4. Node 3 is another intermediate node and has two edges: An edge from node 3 to node 4 with a substantial capacity of 12. Node 4, which could represent the target or terminal, does not have any edges leading to other nodes, implying that it could be the end point. Find the corresponding maximum flow of the graph. Provide your answer rounded to the nearest integar.",
    "ground_truth": 12.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MaxFlow\")\n\n# Sets\nN = [1, 2, 3, 4]\nA = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4)]\n\n# Parameters\ncapacities = {\n    (1, 2): 5,\n    (1, 3): 7,\n    (2, 3): 2,\n    (2, 4): 4,\n    (3, 4): 12\n}\n\n# Variables\nflow = model.addVars(A, name=\"flow\", lb=0)\n\n# Objective\nmodel.setObjective(gp.quicksum(flow[i, 4] for i in [2, 3] if (i, 4) in A), GRB.MAXIMIZE)\n\n# Constraints\n# Capacity constraints\nmodel.addConstrs((flow[i, j] <= capacities[i, j] for i, j in A), name=\"capacity\")\n\n# Flow conservation constraints\nmodel.addConstr(flow[1, 2] + flow[1, 3] == flow[1, 2] + flow[1, 3], name=\"flow_conservation_node_1\")\nmodel.addConstr(flow[1, 2] == flow[2, 3] + flow[2, 4], name=\"flow_conservation_node_2\")\nmodel.addConstr(flow[1, 3] + flow[2, 3] == flow[3, 4], name=\"flow_conservation_node_3\")\n\n# Optimize the model\nmodel.optimize()\n\n# Output the result\nif model.status == GRB.OPTIMAL:\n    max_flow = round(model.objVal)\n    print(f\"Maximum flow from node 1 to node 4 is: {max_flow}\")\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "General Optimization"
      }
    ],
    "cluster": 33,
    "retrieved_insights": []
  },
  {
    "task_id": "E103",
    "description": "There are four nodes connected by directed edges. Node 1, which could represent the starting point, is connected to two other nodes: There is an edge from node 1 to node 2 with a capacity of 8. There is an edge from node 1 to node 3 with a capacity of 7. Node 2 is situated at the top of the graph and acts as an intermediate node, with three edges connected to it: An edge leading from node 2 to node 3 with a capacity of 2. An edge leading from node 2 to node 4 with a capacity of 4. Node 3 is another intermediate node and has two edges: An edge from node 3 to node 4 with a substantial capacity of 7. Node 4, which could represent the target or terminal, does not have any edges leading to other nodes, implying that it could be the end point. Find the corresponding maximum flow of the graph. Provide your answer rounded to the nearest integar.",
    "ground_truth": 11.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "General"
      }
    ],
    "cluster": 33,
    "retrieved_insights": []
  },
  {
    "task_id": "E101",
    "description": "There are four nodes connected by directed edges. Node 1, which could represent the starting point, is connected to two other nodes: There is an edge from node 1 to node 2 with a capacity of 8. There is an edge from node 1 to node 3 with a capacity of 7. Node 2 is situated at the top of the graph and acts as an intermediate node, with three edges connected to it: An edge leading from node 2 to node 3 with a capacity of 2. An edge leading from node 2 to node 4 with a capacity of 4. Node 3 is another intermediate node and has two edges: An edge from node 3 to node 4 with a substantial capacity of 12. Node 4, which could represent the target or terminal, does not have any edges leading to other nodes, implying that it could be the end point. Find the corresponding maximum flow of the graph. Provide your answer rounded to the nearest integar.",
    "ground_truth": 13.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"MaxFlow\")\n\n# Add variables\nf_12 = model.addVar(lb=0, ub=8, vtype=GRB.CONTINUOUS, name=\"f_12\")\nf_13 = model.addVar(lb=0, ub=7, vtype=GRB.CONTINUOUS, name=\"f_13\")\nf_23 = model.addVar(lb=0, ub=2, vtype=GRB.CONTINUOUS, name=\"f_23\")\nf_24 = model.addVar(lb=0, ub=4, vtype=GRB.CONTINUOUS, name=\"f_24\")\nf_34 = model.addVar(lb=0, ub=12, vtype=GRB.CONTINUOUS, name=\"f_34\")\n\n# Set objective\nmodel.setObjective(f_24 + f_34, GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(f_12 <= 8, \"C1\")\nmodel.addConstr(f_13 <= 7, \"C2\")\nmodel.addConstr(f_23 <= 2, \"C3\")\nmodel.addConstr(f_24 <= 4, \"C4\")\nmodel.addConstr(f_34 <= 12, \"C5\")\nmodel.addConstr(f_12 == f_23 + f_24, \"C6\")\nmodel.addConstr(f_13 + f_23 == f_34, \"C7\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "General"
      }
    ],
    "cluster": 33,
    "retrieved_insights": []
  },
  {
    "task_id": "E094",
    "description": "SupplyCo is presented with a strategic conundrum to optimize its distribution network. They need to supply their four retail outlets from potential distribution centers. Each center has its own operating cost and supply capacity. Transportation costs from each center to the respective retail outlets also need to be factored in. SupplyCo's objective is to satisfy the demand at each retail outlet at the minimum possible total cost.\n\nHere are the case specifics:\n\n- Number of Potential Distribution Centers: 4\n- Number of Retail Outlets: 4\n\nThe opening costs for each center are as follows (in dollars):\n\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n\nThe transportation cost per unit from each distribution center to the outlets (in dollars) is as follows:\n\n- From Center 1: $5 to Outlet 1, $5 to Outlet 2, $2 to Outlet 3, $3 to Outlet 4\n- From Center 2: $3 to Outlet 1, $3 to Outlet 2, $5 to Outlet 3, $4 to Outlet 4\n- From Center 3: $3 to Outlet 1, $5 to Outlet 2, $2 to Outlet 3, $4 to Outlet 4\n- From Center 4: $2 to Outlet 1, $4 to Outlet 2, $5 to Outlet 3, $1 to Outlet 4\n\nThe demand at each retail outlet (in units) is:\n\n- Outlet 1: 859 units\n- Outlet 2: 713 units\n- Outlet 3: 421 units\n- Outlet 4: 652 units\n\nThe supply capacity of each distribution center (in units) is:\n\n- Center 1: 1547 units\n- Center 2: 1656 units\n- Center 3: 1274 units\n- Center 4: 1882 units\n\nQuestion:\nWhat is the optimal total cost for SupplyCo to open the distribution centers and transport goods to meet all retail outlets' demands, considering both the opening costs of the centers and the transportation costs for the goods?",
    "ground_truth": 273940.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SupplyCo_Distribution_Optimization\")\n\n# Sets\ncenters = [1, 2, 3, 4]\noutlets = [1, 2, 3, 4]\n\n# Parameters\nopening_costs = {1: 151000, 2: 192000, 3: 114000, 4: 171000}\ntransportation_costs = {\n    (1, 1): 5, (1, 2): 5, (1, 3): 2, (1, 4): 3,\n    (2, 1): 3, (2, 2): 3, (2, 3): 5, (2, 4): 4,\n    (3, 1): 3, (3, 2): 5, (3, 3): 2, (3, 4): 4,\n    (4, 1): 2, (4, 2): 4, (4, 3): 5, (4, 4): 1\n}\ndemands = {1: 859, 2: 713, 3: 421, 4: 652}\ncapacities = {1: 1547, 2: 1656, 3: 1274, 4: 1882}\n\n# Variables\nx = model.addVars(centers, outlets, vtype=GRB.INTEGER, name=\"x\")\ny = model.addVars(centers, vtype=GRB.BINARY, name=\"y\")\n\n# Objective Function\nmodel.setObjective(\n    gp.quicksum(opening_costs[i] * y[i] for i in centers) +\n    gp.quicksum(transportation_costs[i, j] * x[i, j] for i in centers for j in outlets),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand satisfaction\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in centers) == demands[j] for j in outlets),\n    name=\"DemandSatisfaction\"\n)\n\n# Supply capacity\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in outlets) <= capacities[i] * y[i] for i in centers),\n    name=\"SupplyCapacity\"\n)\n\n# Logical constraint for opening centers\nmodel.addConstrs(\n    (x[i, j] <= demands[j] * y[i] for i in centers for j in outlets),\n    name=\"LogicalOpening\"\n)\n\n# Non-negativity and integrality are automatically handled by variable types\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E090",
    "description": "LogistiCorp is at a pivotal juncture, faced with the challenge of efficiently supplying nine retail stores from a pool of seven possible distribution centers. Each center presents a unique opening cost and has a specific capacity limit. Moreover, transporting goods from these centers to the retail stores incurs varying costs. The aim is to fulfill the demand at each retail store while minimizing the overall cost, which encompasses the opening expenses of the distribution centers and the transportation costs of the goods.\n\nGiven Data:\n- Number of Possible Distribution Centers: 7\n- Number of Retail Stores to be Supplied: 9\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n- Center 6: $120,000\n- Center 7: $182,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1 to Stores: $3 to Store 1, $3 to Store 2, $5 to Store 3, $4 to Store 4, $3 to Store 5, $5 to Store 6, $2 to Store 7, $4 to Store 8, $2 to Store 9\n- From Center 2 to Stores: $4 to Store 1, $5 to Store 2, $1 to Store 3, $4 to Store 4, $2 to Store 5, $5 to Store 6, $4 to Store 7, $1 to Store 8, $1 to Store 9\n- From Center 3 to Stores: $3 to Store 1, $3 to Store 2, $2 to Store 3, $4 to Store 4, $4 to Store 5, $3 to Store 6, $4 to Store 7, $4 to Store 8, $1 to Store 9\n- From Center 4 to Stores: $3 to Store 1, $5 to Store 2, $3 to Store 3, $5 to Store 4, $1 to Store 5, $2 to Store 6, $4 to Store 7, $1 to Store 8, $4 to Store 9\n- From Center 5 to Stores: $2 to Store 1, $2 to Store 2, $1 to Store 3, $2 to Store 4, $5 to Store 5, $2 to Store 6, $4 to Store 7, $4 to Store 8, $4 to Store 9\n- From Center 6 to Stores: $4 to Store 1, $5 to Store 2, $3 to Store 3, $1 to Store 4, $4 to Store 5, $2 to Store 6, $4 to Store 7, $2 to Store 8, $2 to Store 9\n- From Center 7 to Stores: $4 to Store 1, $5 to Store 2, $2 to Store 3, $2 to Store 4, $4 to Store 5, $2 to Store 6, $2 to Store 7, $4 to Store 8, $4 to Store 9\n\nDemand of Each Retail Store (in units):\n- Store 1: 695 units\n- Store 2: 737 units\n- Store 3: 452 units\n- Store 4: 616 units\n- Store 5: 587 units\n- Store 6: 779 units\n- Store 7: 892 units\n- Store 8: 440 units\n- Store 9: 556 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 814 units\n- Center 2: 864 units\n- Center 3: 1,320 units\n- Center 4: 1,952 units\n- Center 5: 1,447 units\n- Center 6: 1,886 units\n- Center 7: 1,962 units\n\nQuestion:\nWhat is the optimal total cost for LogistiCorp to open distribution centers and transport goods to meet all retail stores' demands, including both the opening costs of the centers and the transportation costs of supplying the stores?",
    "ground_truth": 485771.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"LogistiCorp_Supply_Optimization\")\n\n# Sets\nI = range(7)  # Distribution centers\nJ = range(9)  # Retail stores\n\n# Parameters\nf = [151000, 192000, 114000, 171000, 160000, 120000, 182000]  # Opening costs\nc = [\n    [3, 3, 5, 4, 3, 5, 2, 4, 2],\n    [4, 5, 1, 4, 2, 5, 4, 1, 1],\n    [3, 3, 2, 4, 4, 3, 4, 4, 1],\n    [3, 5, 3, 5, 1, 2, 4, 1, 4],\n    [2, 2, 1, 2, 5, 2, 4, 4, 4],\n    [4, 5, 3, 1, 4, 2, 4, 2, 2],\n    [4, 5, 2, 2, 4, 2, 2, 4, 4]\n]\nd = [695, 737, 452, 616, 587, 779, 892, 440, 556]  # Demands\ns = [814, 864, 1320, 1952, 1447, 1886, 1962]  # Capacities\n\n# Variables\nx = model.addVars(I, J, name=\"x\", vtype=GRB.CONTINUOUS, lb=0)\ny = model.addVars(I, name=\"y\", vtype=GRB.BINARY)\n\n# Objective\nmodel.setObjective(\n    gp.quicksum(f[i] * y[i] for i in I) +\n    gp.quicksum(c[i][j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Fulfill demand for each retail store\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == d[j] for j in J),\n    name=\"Demand\"\n)\n\n# Do not exceed supply capacity of open distribution centers\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= s[i] * y[i] for i in I),\n    name=\"Capacity\"\n)\n\n# Ensure that no transportation occurs from a closed distribution center\nmodel.addConstrs(\n    (x[i, j] <= d[j] * y[i] for i in I for j in J),\n    name=\"NoTransportFromClosed\"\n)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E091",
    "description": "BestWay Logistics is in the process of determining the best strategy to distribute products from its warehouses to four retail stores. The company has six potential distribution centers to choose from, each with its own costs associated with opening the center and transporting goods to the stores. Each center also has a specified maximum capacity it can handle. The aim is to satisfy the demand at each store at the lowest possible total cost, while taking into account the cost of opening the distribution centers and the transportation costs of the goods.\n\nThe details of the scenario are as follows:\n\nNumber of Potential Distribution Centers: 6\nNumber of Retail Stores Needing Supply: 4\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: 151,000\n- Center 2: 192,000\n- Center 3: 114,000\n- Center 4: 171,000\n- Center 5: 160,000\n- Center 6: 120,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $2 to Store 1, $3 to Store 2, $3 to Store 3, $3 to Store 4\n- From Center 2: $5 to Store 1, $4 to Store 2, $3 to Store 3, $5 to Store 4\n- From Center 3: $2 to Store 1, $4 to Store 2, $2 to Store 3, $4 to Store 4\n- From Center 4: $5 to Store 1, $1 to Store 2, $4 to Store 3, $2 to Store 4\n- From Center 5: $5 to Store 1, $4 to Store 2, $1 to Store 3, $1 to Store 4\n- From Center 6: $3 to Store 1, $3 to Store 2, $2 to Store 3, $4 to Store 4\n\nDemand of Each Retail Store (in units):\n- Store 1: 589\n- Store 2: 962\n- Store 3: 966\n- Store 4: 643\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1631\n- Center 2: 1954\n- Center 3: 1446\n- Center 4: 820\n- Center 5: 1640\n- Center 6: 966\n\nQuestion:\nWhat is the optimal total cost for BestWay Logistics to open the necessary distribution centers and transport goods to meet the demand of all retail stores? This cost should include both the opening costs of the centers and the transportation costs of supplying the stores. Please provide only the optimal value.",
    "ground_truth": 316282.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nI = [1, 2, 3, 4, 5, 6]  # Distribution centers\nJ = [1, 2, 3, 4]        # Retail stores\n\n# Parameters\nF = {1: 151000, 2: 192000, 3: 114000, 4: 171000, 5: 160000, 6: 120000}\nc = {\n    (1, 1): 2, (1, 2): 3, (1, 3): 3, (1, 4): 3,\n    (2, 1): 5, (2, 2): 4, (2, 3): 3, (2, 4): 5,\n    (3, 1): 2, (3, 2): 4, (3, 3): 2, (3, 4): 4,\n    (4, 1): 5, (4, 2): 1, (4, 3): 4, (4, 4): 2,\n    (5, 1): 5, (5, 2): 4, (5, 3): 1, (5, 4): 1,\n    (6, 1): 3, (6, 2): 3, (6, 3): 2, (6, 4): 4,\n}\nD = {1: 589, 2: 962, 3: 966, 4: 643}\nS = {1: 1631, 2: 1954, 3: 1446, 4: 820, 5: 1640, 6: 966}\n\n# Variables\nx = model.addVars(I, J, name=\"x\", vtype=GRB.CONTINUOUS, lb=0)\ny = model.addVars(I, name=\"y\", vtype=GRB.BINARY)\n\n# Objective\nmodel.setObjective(\n    gp.quicksum(F[i] * y[i] for i in I) +\n    gp.quicksum(c[i, j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand satisfaction\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == D[j] for j in J),\n    name=\"Demand\"\n)\n\n# Capacity constraints\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= S[i] * y[i] for i in I),\n    name=\"Capacity\"\n)\n\n# Logical implication constraints\nmodel.addConstrs(\n    (x[i, j] <= D[j] * y[i] for i in I for j in J),\n    name=\"Logical\"\n)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E082",
    "description": "GlobalSupply Inc. is at a crucial juncture in streamlining its logistics to efficiently service six retail outlets spread across different locations. The company has narrowed down its options to four possible distribution centers, each with unique characteristics, including varying operational costs and different capacities for handling supply. Moreover, the cost to transport goods from these centers to each retail outlet is not uniform, adding layers of complexity to the decision-making process. The overarching goal for GlobalSupply Inc. is to ensure that the demands of all retail stores are met at the lowest possible total cost, incorporating both the opening expenses for these distribution centers and the costs associated with transporting goods to the stores.\n\nGiven Data:\n- Number of Potential Distribution Centers: 4\n- Number of Retail Stores to be Supplied: 6\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $5 to Store 1, $5 to Store 2, $2 to Store 3, $3 to Store 4, $3 to Store 5, $3 to Store 6\n- From Center 2: $5 to Store 1, $4 to Store 2, $3 to Store 3, $5 to Store 4, $2 to Store 5, $4 to Store 6\n- From Center 3: $2 to Store 1, $4 to Store 2, $5 to Store 3, $1 to Store 4, $4 to Store 5, $2 to Store 6\n- From Center 4: $5 to Store 1, $4 to Store 2, $1 to Store 3, $1 to Store 4, $3 to Store 5, $3 to Store 6\n\nDemand of Each Retail Store (in units):\n- Store 1: 910 units\n- Store 2: 875 units\n- Store 3: 589 units\n- Store 4: 962 units\n- Store 5: 966 units\n- Store 6: 643 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1631 units\n- Center 2: 1954 units\n- Center 3: 1446 units\n- Center 4: 820 units\n\nQuestion:\nWhat is the optimal total cost for GlobalSupply Inc. to open the necessary distribution centers and transport goods in such a way that all retail stores' demands are fulfilled? This total should encompass both the operational opening costs and the logistical costs of supply to the outlets.",
    "ground_truth": 469200.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nI = [1, 2, 3, 4]  # Distribution centers\nJ = [1, 2, 3, 4, 5, 6]  # Retail stores\n\n# Parameters\nF = {1: 151000, 2: 192000, 3: 114000, 4: 171000}  # Opening costs\nc = {\n    (1, 1): 5, (1, 2): 5, (1, 3): 2, (1, 4): 3, (1, 5): 3, (1, 6): 3,\n    (2, 1): 5, (2, 2): 4, (2, 3): 3, (2, 4): 5, (2, 5): 2, (2, 6): 4,\n    (3, 1): 2, (3, 2): 4, (3, 3): 5, (3, 4): 1, (3, 5): 4, (3, 6): 2,\n    (4, 1): 5, (4, 2): 4, (4, 3): 1, (4, 4): 1, (4, 5): 3, (4, 6): 3\n}\nd = {1: 910, 2: 875, 3: 589, 4: 962, 5: 966, 6: 643}  # Demands\nS = {1: 1631, 2: 1954, 3: 1446, 4: 820}  # Supply capacities\n\n# Variables\nx = model.addVars(I, J, name=\"x\", vtype=GRB.CONTINUOUS, lb=0)  # Transport quantities\ny = model.addVars(I, name=\"y\", vtype=GRB.BINARY)  # Open centers\n\n# Objective: Minimize total cost\nmodel.setObjective(gp.quicksum(F[i] * y[i] for i in I) +\n                   gp.quicksum(c[i, j] * x[i, j] for i in I for j in J), GRB.MINIMIZE)\n\n# Constraints\n# Demand satisfaction constraints\nmodel.addConstrs((gp.quicksum(x[i, j] for i in I) == d[j] for j in J), \"Demand\")\n\n# Supply capacity constraints\nmodel.addConstrs((gp.quicksum(x[i, j] for j in J) <= S[i] * y[i] for i in I), \"Capacity\")\n\n# Non-negativity and binary constraints are implicitly handled\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E097",
    "description": "In the bustling market of Logistico, a strategic dilemma looms over the horizon for the newly-established retail giant, SupplyChainMax. With an expansive network of five retail stores to cater to, the company stands at the crossroads of selecting the most cost-effective distribution strategy from a pool of eight potential distribution centers. Each center not only comes with its unique price tag for opening but also a specific capacity limit and variable transportation costs to each store. The crux of SupplyChainMax's challenge lies in opening the right blend of distribution centers that would minimally cost them to meet the retail stores' demands, ensuring a smooth flow of goods at the lowest possible overall cost.\n\nGiven Data:\n- Number of Potential Distribution Centers: 8\n- Number of Retail Stores to be Supplied: 5\n\nOpening Costs for Each Distribution Center (in dollars):\n- Distribution Center 1: $151,000\n- Distribution Center 2: $192,000\n- Distribution Center 3: $114,000\n- Distribution Center 4: $171,000\n- Distribution Center 5: $160,000\n- Distribution Center 6: $120,000\n- Distribution Center 7: $182,000\n- Distribution Center 8: $186,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Distribution Center 1: $3 to Store 1, $3 to Store 2, $5 to Store 3, $4 to Store 4, $3 to Store 5\n- From Distribution Center 2: $5 to Store 1, $2 to Store 2, $4 to Store 3, $2 to Store 4, $4 to Store 5\n- From Distribution Center 3: $5 to Store 1, $1 to Store 2, $4 to Store 3, $2 to Store 4, $5 to Store 5\n- From Distribution Center 4: $4 to Store 1, $1 to Store 2, $1 to Store 3, $3 to Store 4, $3 to Store 5\n- From Distribution Center 5: $2 to Store 1, $4 to Store 2, $4 to Store 3, $3 to Store 4, $4 to Store 5\n- From Distribution Center 6: $4 to Store 1, $1 to Store 2, $3 to Store 3, $5 to Store 4, $3 to Store 5\n- From Distribution Center 7: $5 to Store 1, $1 to Store 2, $2 to Store 3, $4 to Store 4, $1 to Store 5\n- From Distribution Center 8: $4 to Store 1, $2 to Store 2, $2 to Store 3, $1 to Store 4, $2 to Store 5\n\nDemand of Each Retail Store (in units):\n- Store 1: 964 units\n- Store 2: 739 units\n- Store 3: 491 units\n- Store 4: 766 units\n- Store 5: 854 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Distribution Center 1: 1,308 units\n- Distribution Center 2: 1,575 units\n- Distribution Center 3: 834 units\n- Distribution Center 4: 1,005 units\n- Distribution Center 5: 1,904 units\n- Distribution Center 6: 1,825 units\n- Distribution Center 7: 1,821 units\n- Distribution Center 8: 1,365 units\n\nQuestion:\nConsidering all the given data about opening costs, transportation costs per unit to stores, demand of each retail store, and supply capacity of each distribution center, what is the optimal total cost for SupplyChainMax to establish distribution centers and transport goods to fully meet the demands of all five retail stores? This optimal total cost includes both the opening costs of the selected distribution centers and the transportation costs of supplying the stores.",
    "ground_truth": 394198.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SupplyChainOptimization\")\n\n# Sets\nI = range(8)  # Distribution centers\nJ = range(5)  # Retail stores\n\n# Parameters\nf = [151000, 192000, 114000, 171000, 160000, 120000, 182000, 186000]  # Opening costs\nc = [\n    [3, 3, 5, 4, 3],\n    [5, 2, 4, 2, 4],\n    [5, 1, 4, 2, 5],\n    [4, 1, 1, 3, 3],\n    [2, 4, 4, 3, 4],\n    [4, 1, 3, 5, 3],\n    [5, 1, 2, 4, 1],\n    [4, 2, 2, 1, 2]\n]  # Transportation costs\nd = [964, 739, 491, 766, 854]  # Demands\ns = [1308, 1575, 834, 1005, 1904, 1825, 1821, 1365]  # Supply capacities\n\n# Variables\nx = model.addVars(I, J, lb=0, vtype=GRB.CONTINUOUS, name=\"x\")  # Units transported\ny = model.addVars(I, vtype=GRB.BINARY, name=\"y\")  # Distribution center open decision\n\n# Objective\nmodel.setObjective(gp.quicksum(f[i] * y[i] for i in I) + gp.quicksum(c[i][j] * x[i, j] for i in I for j in J), GRB.MINIMIZE)\n\n# Constraints\n# Demand fulfillment for each store\nmodel.addConstrs((gp.quicksum(x[i, j] for i in I) == d[j] for j in J), name=\"Demand\")\n\n# Supply capacity of each distribution center\nmodel.addConstrs((gp.quicksum(x[i, j] for j in J) <= s[i] * y[i] for i in I), name=\"Supply\")\n\n# Additional constraint ensuring x only if y is 1\nmodel.addConstrs((x[i, j] <= s[i] * y[i] for i in I for j in J), name=\"OpenCenter\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E098",
    "description": "LogiSphere Inc. is at a crossroads in determining the most cost-efficient strategy to supply nine retail stores with goods from a selection of five potential distribution centers. Each center has a unique opening cost and a maximum supply capacity. The challenge is further complicated by the variable transportation costs from these centers to the retail stores. LogiSphere's goal is to fulfill the demand at each retail store while minimizing the total cost, which encompasses the opening costs of the distribution centers and the transportation costs of the goods.\n\n**Given Data:**\n\n- **Number of Potential Distribution Centers:** 5\n- **Number of Retail Stores Needing Supply:** 9\n\n**Opening Costs for Each Distribution Center (in dollars):**\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n\n**Transportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):**\n- From Center 1 to Stores: $5 to Store 1, $2 to Store 2, $3 to Store 3, $3 to Store 4, $3 to Store 5, $5 to Store 6, $4 to Store 7, $3 to Store 8, $5 to Store 9\n- From Center 2 to Stores: $2 to Store 1, $4 to Store 2, $2 to Store 3, $4 to Store 4, $5 to Store 5, $1 to Store 6, $4 to Store 7, $2 to Store 8, $5 to Store 9\n- From Center 3 to Stores: $4 to Store 1, $1 to Store 2, $1 to Store 3, $3 to Store 4, $3 to Store 5, $2 to Store 6, $4 to Store 7, $4 to Store 8, $3 to Store 9\n- From Center 4 to Stores: $4 to Store 1, $4 to Store 2, $1 to Store 3, $3 to Store 4, $5 to Store 5, $3 to Store 6, $5 to Store 7, $1 to Store 8, $2 to Store 9\n- From Center 5 to Stores: $4 to Store 1, $1 to Store 2, $4 to Store 3, $2 to Store 4, $2 to Store 5, $1 to Store 6, $2 to Store 7, $5 to Store 8, $2 to Store 9\n\n**Demand of Each Retail Store (in units):**\n- Store 1: 739 units\n- Store 2: 491 units\n- Store 3: 766 units\n- Store 4: 854 units\n- Store 5: 827 units\n- Store 6: 908 units\n- Store 7: 434 units\n- Store 8: 605 units\n- Store 9: 480 units\n\n**Supply Capacity of Each Distribution Center (in units):**\n- Center 1: 1825 units\n- Center 2: 1821 units\n- Center 3: 1365 units\n- Center 4: 1929 units\n- Center 5: 1502 units\n\n**Question:**\n\nWhat is the optimal total cost for LogiSphere Inc. to open distribution centers and transport goods in order to meet all the retail stores' demands? This cost includes both the opening costs of the centers and the transportation costs of supplying the stores.",
    "ground_truth": 608437.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nI = range(5)  # Distribution centers\nJ = range(9)  # Retail stores\n\n# Parameters\nf = [151000, 192000, 114000, 171000, 160000]  # Opening costs\nc = [\n    [5, 2, 3, 3, 3, 5, 4, 3, 5],\n    [2, 4, 2, 4, 5, 1, 4, 2, 5],\n    [4, 1, 1, 3, 3, 2, 4, 4, 3],\n    [4, 4, 1, 3, 5, 3, 5, 1, 2],\n    [4, 1, 4, 2, 2, 1, 2, 5, 2]\n]\nd = [739, 491, 766, 854, 827, 908, 434, 605, 480]  # Demands\ns = [1825, 1821, 1365, 1929, 1502]  # Supply capacities\n\n# Decision variables\nx = model.addVars(I, J, vtype=GRB.CONTINUOUS, name=\"x\")  # Units transported\ny = model.addVars(I, vtype=GRB.BINARY, name=\"y\")  # Center open or not\n\n# Objective function\nmodel.setObjective(\n    gp.quicksum(f[i] * y[i] for i in I) +\n    gp.quicksum(c[i][j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand satisfaction\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == d[j] for j in J),\n    name=\"Demand\"\n)\n\n# Supply capacity\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= s[i] * y[i] for i in I),\n    name=\"Supply\"\n)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E088",
    "description": "Distribution Dynamics Inc. has a strategic challenge to efficiently supply its seven retail stores from a choice of five potential distribution centers. This operation has to manage not only the differing opening costs of each distribution center but also the variability in their capacity to meet demands and the transportation costs involved in shipping goods to each retail store. The company aims to fulfill the demand at each retail location while minimizing the total cost involved, which encompasses the opening costs of the distribution centers and the transportation costs of the goods.\n\nGiven Data:\n- Number of Potential Distribution Centers: 5\n- Number of Retail Stores Needing Supply: 7\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $5 to Store 1, $2 to Store 2, $3 to Store 3, $3 to Store 4, $3 to Store 5, $5 to Store 6, $4 to Store 7\n- From Center 2: $3 to Store 1, $5 to Store 2, $2 to Store 3, $4 to Store 4, $2 to Store 5, $4 to Store 6, $5 to Store 7\n- From Center 3: $1 to Store 1, $4 to Store 2, $2 to Store 3, $5 to Store 4, $4 to Store 5, $1 to Store 6, $1 to Store 7\n- From Center 4: $3 to Store 1, $3 to Store 2, $2 to Store 3, $4 to Store 4, $4 to Store 5, $3 to Store 6, $4 to Store 7\n- From Center 5: $4 to Store 1, $1 to Store 2, $3 to Store 3, $5 to Store 4, $3 to Store 5, $5 to Store 6, $1 to Store 7\n\nDemand of Each Retail Store (in units):\n- Store 1: 566 units\n- Store 2: 673 units\n- Store 3: 787 units\n- Store 4: 1000 units\n- Store 5: 715 units\n- Store 6: 413 units\n- Store 7: 641 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1576 units\n- Center 2: 1364 units\n- Center 3: 1697 units\n- Center 4: 891 units\n- Center 5: 1755 units\n\nQuestion:\nWhat is the optimal total cost for Distribution Dynamics Inc. to open the necessary distribution centers and transport goods in order to meet all retail stores' demands at the lowest possible cost, taking into account both the opening costs of the centers and the transportation costs of supplying the stores?",
    "ground_truth": 434081.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"DistributionDynamics\")\n\n# Sets\nM = 5  # Number of distribution centers\nN = 7  # Number of retail stores\n\n# Parameters\nopening_costs = [151000, 192000, 114000, 171000, 160000]\ntransportation_costs = [\n    [5, 2, 3, 3, 3, 5, 4],\n    [3, 5, 2, 4, 2, 4, 5],\n    [1, 4, 2, 5, 4, 1, 1],\n    [3, 3, 2, 4, 4, 3, 4],\n    [4, 1, 3, 5, 3, 5, 1]\n]\ndemands = [566, 673, 787, 1000, 715, 413, 641]\nsupply_capacities = [1576, 1364, 1697, 891, 1755]\n\n# Decision Variables\nx = model.addVars(M, N, vtype=GRB.INTEGER, name=\"x\")\ny = model.addVars(M, vtype=GRB.BINARY, name=\"y\")\n\n# Objective Function\nmodel.setObjective(\n    gp.quicksum(opening_costs[i] * y[i] for i in range(M)) +\n    gp.quicksum(transportation_costs[i][j] * x[i, j] for i in range(M) for j in range(N)),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# (C1) Demand fulfillment at each retail store\nfor j in range(N):\n    model.addConstr(gp.quicksum(x[i, j] for i in range(M)) == demands[j], f\"demand_fulfillment_{j}\")\n\n# (C2) Supply capacity constraint at each distribution center\nfor i in range(M):\n    model.addConstr(gp.quicksum(x[i, j] for j in range(N)) <= supply_capacities[i] * y[i], f\"supply_capacity_{i}\")\n\n# (C3) Binary constraints on y_i are automatically handled by the vtype=GRB.BINARY\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E078",
    "description": "In the bustling world of retail, LogiChain, a renowned logistics company, is at a crossroads in determining the most efficient way to distribute products to its network of eight retail stores. The challenge lies in selecting from four strategic distribution centers, each with its distinct opening costs and supply capacities. The goal is to ensure that each store's demand is met with the least total cost, incorporating both the opening of distribution centers and the transportation costs of delivering goods.\n\nHere are the specifics of the situation:\n\n- LogiChain can open any of the four distribution centers, each with a different opening cost.\n- There are eight retail stores in need of supplies, each with its unique demand.\n- The transportation cost per unit of product varies not only from one distribution center to another but also from one store to another.\n\nThe details are as follows:\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $5 to Store 1, $5 to Store 2, $2 to Store 3, $3 to Store 4, $3 to Store 5, $3 to Store 6, $5 to Store 7, $4 to Store 8\n- From Center 2: $3 to Store 1, $5 to Store 2, $2 to Store 3, $4 to Store 4, $2 to Store 5, $4 to Store 6, $5 to Store 7, $1 to Store 8\n- From Center 3: $4 to Store 1, $2 to Store 2, $5 to Store 3, $4 to Store 4, $1 to Store 5, $1 to Store 6, $3 to Store 7, $3 to Store 8\n- From Center 4: $2 to Store 1, $4 to Store 2, $4 to Store 3, $3 to Store 4, $4 to Store 5, $4 to Store 6, $1 to Store 7, $3 to Store 8\n\nDemand of Each Retail Store (in units):\n- Store 1: 884 units\n- Store 2: 420 units\n- Store 3: 566 units\n- Store 4: 673 units\n- Store 5: 787 units\n- Store 6: 1000 units\n- Store 7: 715 units\n- Store 8: 413 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1041 units\n- Center 2: 1576 units\n- Center 3: 1364 units\n- Center 4: 1697 units\n\nGiven these variables, LogiChain must make a calculated decision on which distribution centers to open and how to allocate shipments to meet the demands of the eight stores in the most cost-effective manner.\n\nQuestion:\nWhat is the optimal total cost for LogiChain to open distribution centers and transport goods to satisfy the demand of all eight retail stores, taking both the opening costs and transportation costs into account?",
    "ground_truth": 637573.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"LogiChain_Distribution\")\n\n# Sets\nI = range(4)  # Distribution centers (0 to 3)\nJ = range(8)  # Retail stores (0 to 7)\n\n# Parameters\nf = [151000, 192000, 114000, 171000]  # Opening costs\nc = [\n    [5, 5, 2, 3, 3, 3, 5, 4],  # Transportation costs from Center 1\n    [3, 5, 2, 4, 2, 4, 5, 1],  # Transportation costs from Center 2\n    [4, 2, 5, 4, 1, 1, 3, 3],  # Transportation costs from Center 3\n    [2, 4, 4, 3, 4, 4, 1, 3],  # Transportation costs from Center 4\n]\nd = [884, 420, 566, 673, 787, 1000, 715, 413]  # Demands\ns = [1041, 1576, 1364, 1697]  # Supply capacities\n\n# Variables\nx = model.addVars(I, J, vtype=GRB.CONTINUOUS, name=\"x\")  # Units transported\ny = model.addVars(I, vtype=GRB.BINARY, name=\"y\")  # Center open decision\n\n# Objective: Minimize total cost\nmodel.setObjective(\n    gp.quicksum(f[i] * y[i] for i in I) + gp.quicksum(c[i][j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand satisfaction for each store\nfor j in J:\n    model.addConstr(gp.quicksum(x[i, j] for i in I) == d[j], f\"demand_satisfaction_{j}\")\n\n# Supply capacity for each distribution center\nfor i in I:\n    model.addConstr(gp.quicksum(x[i, j] for j in J) <= s[i] * y[i], f\"supply_capacity_{i}\")\n\n# Opening constraint for transportation\nfor i in I:\n    for j in J:\n        model.addConstr(x[i, j] <= d[j] * y[i], f\"opening_constraint_{i}_{j}\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E086",
    "description": "In the bustling world of retail and distribution, a major company, GlobalSupply, is facing a strategic challenge. It needs to efficiently supply its products to eight different retail stores, each with its own demand for goods. To achieve this, GlobalSupply is considering opening up to eight different distribution centers, but each center comes with its own set of opening costs and has a specific capacity limit. Additionally, the cost of transporting goods from these distribution centers to the retail stores varies, adding another layer of complexity to the decision-making process. GlobalSupply's primary objective is to fulfill the demand at each retail store while minimizing the total cost, which includes both the opening costs of the distribution centers and the transportation costs of the goods.\n\nGiven Data:\n- Number of Potential Distribution Centers: 8\n- Number of Retail Stores Needing Supply: 8\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n- Center 6: $120,000\n- Center 7: $182,000\n- Center 8: $186,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1 to Stores: $3 to Store 1, $3 to Store 2, $5 to Store 3, $4 to Store 4, $3 to Store 5, $5 to Store 6, $2 to Store 7, $4 to Store 8\n- From Center 2 to Stores: $2 to Store 1, $4 to Store 2, $5 to Store 3, $1 to Store 4, $4 to Store 5, $2 to Store 6, $5 to Store 7, $4 to Store 8\n- From Center 3 to Stores: $1 to Store 1, $1 to Store 2, $3 to Store 3, $3 to Store 4, $2 to Store 5, $4 to Store 6, $4 to Store 7, $3 to Store 8\n- From Center 4 to Stores: $4 to Store 1, $4 to Store 2, $1 to Store 3, $3 to Store 4, $5 to Store 5, $3 to Store 6, $5 to Store 7, $1 to Store 8\n- From Center 5 to Stores: $2 to Store 1, $4 to Store 2, $1 to Store 3, $4 to Store 4, $2 to Store 5, $2 to Store 6, $1 to Store 7, $2 to Store 8\n- From Center 6 to Stores: $5 to Store 1, $2 to Store 2, $4 to Store 3, $4 to Store 4, $4 to Store 5, $4 to Store 6, $5 to Store 7, $3 to Store 8\n- From Center 7 to Stores: $1 to Store 1, $4 to Store 2, $2 to Store 3, $4 to Store 4, $2 to Store 5, $2 to Store 6, $4 to Store 7, $5 to Store 8\n- From Center 8 to Stores: $2 to Store 1, $2 to Store 2, $4 to Store 3, $2 to Store 4, $2 to Store 5, $4 to Store 6, $4 to Store 7, $1 to Store 8\n\nDemand of Each Retail Store (in units):\n- Store 1: 695 units\n- Store 2: 737 units\n- Store 3: 452 units\n- Store 4: 616 units\n- Store 5: 587 units\n- Store 6: 779 units\n- Store 7: 892 units\n- Store 8: 440 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1980 units\n- Center 2: 814 units\n- Center 3: 864 units\n- Center 4: 1320 units\n- Center 5: 1952 units\n- Center 6: 1447 units\n- Center 7: 1886 units\n- Center 8: 1962 units\n\nQuestion:\nConsidering these details, what is the optimal total cost for GlobalSupply to open distribution centers and transport goods to meet all retail stores' demands? This cost includes both the opening costs of the centers and the transportation costs of supplying the stores.",
    "ground_truth": 443177.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"GlobalSupplyOptimization\")\n\n# Sets\nI = range(1, 9)  # Distribution centers\nJ = range(1, 9)  # Retail stores\n\n# Parameters\nopening_costs = {\n    1: 151000, 2: 192000, 3: 114000, 4: 171000,\n    5: 160000, 6: 120000, 7: 182000, 8: 186000\n}\n\ntransportation_costs = {\n    (1, 1): 3, (1, 2): 3, (1, 3): 5, (1, 4): 4, (1, 5): 3, (1, 6): 5, (1, 7): 2, (1, 8): 4,\n    (2, 1): 2, (2, 2): 4, (2, 3): 5, (2, 4): 1, (2, 5): 4, (2, 6): 2, (2, 7): 5, (2, 8): 4,\n    (3, 1): 1, (3, 2): 1, (3, 3): 3, (3, 4): 3, (3, 5): 2, (3, 6): 4, (3, 7): 4, (3, 8): 3,\n    (4, 1): 4, (4, 2): 4, (4, 3): 1, (4, 4): 3, (4, 5): 5, (4, 6): 3, (4, 7): 5, (4, 8): 1,\n    (5, 1): 2, (5, 2): 4, (5, 3): 1, (5, 4): 4, (5, 5): 2, (5, 6): 2, (5, 7): 1, (5, 8): 2,\n    (6, 1): 5, (6, 2): 2, (6, 3): 4, (6, 4): 4, (6, 5): 4, (6, 6): 4, (6, 7): 5, (6, 8): 3,\n    (7, 1): 1, (7, 2): 4, (7, 3): 2, (7, 4): 4, (7, 5): 2, (7, 6): 2, (7, 7): 4, (7, 8): 5,\n    (8, 1): 2, (8, 2): 2, (8, 3): 4, (8, 4): 2, (8, 5): 2, (8, 6): 4, (8, 7): 4, (8, 8): 1\n}\n\ndemand = {\n    1: 695, 2: 737, 3: 452, 4: 616,\n    5: 587, 6: 779, 7: 892, 8: 440\n}\n\ncapacity = {\n    1: 1980, 2: 814, 3: 864, 4: 1320,\n    5: 1952, 6: 1447, 7: 1886, 8: 1962\n}\n\n# Decision Variables\nx = model.addVars(I, J, vtype=GRB.CONTINUOUS, name=\"x\", lb=0)\ny = model.addVars(I, vtype=GRB.BINARY, name=\"y\")\n\n# Objective Function\nmodel.setObjective(\n    gp.quicksum(opening_costs[i] * y[i] for i in I) +\n    gp.quicksum(transportation_costs[i, j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Supply capacity constraints\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= capacity[i] * y[i] for i in I),\n    name=\"SupplyCapacity\"\n)\n\n# Demand satisfaction constraints\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == demand[j] for j in J),\n    name=\"DemandSatisfaction\"\n)\n\n# Optimize\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E095",
    "description": "In the bustling world of retail, SupplyChain Solutions is faced with a critical challenge of efficiently supplying seven diverse retail stores. To achieve this goal, the company is considering opening up to six potential distribution centers, each with its unique operating costs and capacities. However, the logistical conundrum doesn't end there, as transporting goods from these centers to the stores incurs varying costs. The ultimate aim for SupplyChain Solutions is to ensure that each retail store's demand is met, while simultaneously minimizing the total operational and transportation expenses. Let's delve into the specifics of this optimization problem.\n\nGiven Data:\n- Number of Potential Distribution Centers: 6\n- Number of Retail Stores to be Supplied: 7\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n- Center 6: $120,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $2 to Store 1, $3 to Store 2, $3 to Store 3, $3 to Store 4, $5 to Store 5, $4 to Store 6, $3 to Store 7\n- From Center 2: $5 to Store 1, $2 to Store 2, $4 to Store 3, $2 to Store 4, $4 to Store 5, $5 to Store 6, $1 to Store 7\n- From Center 3: $4 to Store 1, $2 to Store 2, $5 to Store 3, $4 to Store 4, $1 to Store 5, $1 to Store 6, $3 to Store 7\n- From Center 4: $3 to Store 1, $2 to Store 2, $4 to Store 3, $4 to Store 4, $3 to Store 5, $4 to Store 6, $4 to Store 7\n- From Center 5: $1 to Store 1, $3 to Store 2, $5 to Store 3, $3 to Store 4, $5 to Store 5, $1 to Store 6, $2 to Store 7\n- From Center 6: $4 to Store 1, $1 to Store 2, $4 to Store 3, $2 to Store 4, $2 to Store 5, $1 to Store 6, $2 to Store 7\n\nDemand of Each Retail Store (in units):\n- Store 1: 964 units\n- Store 2: 739 units\n- Store 3: 491 units\n- Store 4: 766 units\n- Store 5: 854 units\n- Store 6: 827 units\n- Store 7: 908 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1575 units\n- Center 2: 834 units\n- Center 3: 1005 units\n- Center 4: 1904 units\n- Center 5: 1825 units\n- Center 6: 1821 units\n\nThe puzzle that SupplyChain Solutions needs to solve involves choosing which distribution centers to open and determining the most cost-efficient way to supply each retail store from these centers. The goal is to cover the demand at each store without exceeding the supply capacity of the chosen distribution centers, all while keeping an eye on minimizing the sum of opening and transportation costs.\n\nQuestion:\nWhat is the optimal total cost for SupplyChain Solutions to open the necessary distribution centers and transport goods to meet all seven retail stores' demands? This cost should include both the opening costs of the distribution centers and the transportation costs of supplying the stores.",
    "ground_truth": 461962.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SupplyChainOptimization\")\n\n# Parameters\nopening_costs = [151000, 192000, 114000, 171000, 160000, 120000]\ntransportation_costs = [\n    [2, 3, 3, 3, 5, 4, 3],\n    [5, 2, 4, 2, 4, 5, 1],\n    [4, 2, 5, 4, 1, 1, 3],\n    [3, 2, 4, 4, 3, 4, 4],\n    [1, 3, 5, 3, 5, 1, 2],\n    [4, 1, 4, 2, 2, 1, 2]\n]\ndemand = [964, 739, 491, 766, 854, 827, 908]\ncapacity = [1575, 834, 1005, 1904, 1825, 1821]\n\n# Sets\ncenters = range(6)\nstores = range(7)\n\n# Decision Variables\nx = model.addVars(centers, stores, vtype=GRB.CONTINUOUS, name=\"x\")\ny = model.addVars(centers, vtype=GRB.BINARY, name=\"y\")\n\n# Objective Function\nmodel.setObjective(\n    gp.quicksum(opening_costs[c] * y[c] for c in centers) + \n    gp.quicksum(transportation_costs[c][s] * x[c, s] for c in centers for s in stores),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand satisfaction for each store\nmodel.addConstrs(\n    (gp.quicksum(x[c, s] for c in centers) == demand[s] for s in stores), \"DemandSatisfaction\"\n)\n\n# Capacity restriction for each distribution center\nmodel.addConstrs(\n    (gp.quicksum(x[c, s] for s in stores) <= capacity[c] * y[c] for c in centers), \"CapacityRestriction\"\n)\n\n# Logical constraint for transportation\nmodel.addConstrs(\n    (x[c, s] <= demand[s] * y[c] for c in centers for s in stores), \"LogicalTransportation\"\n)\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E079",
    "description": "LogiChain Solutions is in the process of refining its logistics network to efficiently supply goods to nine retail stores, which are scattered across different locations. The company is considering the feasibility of opening up to eight different distribution centers. Each distribution center has a unique set of operational costs and capacities, as well as varying transportation costs for shipping goods to the retail stores. The challenge lies in selecting the most cost-effective combination of distribution centers to open and determining the optimal shipping routes to fulfill the demands of all retail stores while keeping the total operational and transportation costs as low as possible.\n\nGiven Data:\n- Number of Potential Distribution Centers: 8\n- Number of Retail Stores Needing Supply: 9\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n- Center 6: $120,000\n- Center 7: $182,000\n- Center 8: $186,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1 to Stores: $3 to Store 1, $3 to Store 2, $5 to Store 3, $4 to Store 4, $3 to Store 5, $5 to Store 6, $2 to Store 7, $4 to Store 8, $2 to Store 9\n- From Center 2 to Stores: $4 to Store 1, $5 to Store 2, $1 to Store 3, $4 to Store 4, $2 to Store 5, $5 to Store 6, $4 to Store 7, $1 to Store 8, $1 to Store 9\n- From Center 3 to Stores: $3 to Store 1, $3 to Store 2, $2 to Store 3, $4 to Store 4, $4 to Store 5, $3 to Store 6, $4 to Store 7, $4 to Store 8, $1 to Store 9\n- From Center 4 to Stores: $3 to Store 1, $5 to Store 2, $3 to Store 3, $5 to Store 4, $1 to Store 5, $2 to Store 6, $4 to Store 7, $1 to Store 8, $4 to Store 9\n- From Center 5 to Stores: $2 to Store 1, $2 to Store 2, $1 to Store 3, $2 to Store 4, $5 to Store 5, $2 to Store 6, $4 to Store 7, $4 to Store 8, $4 to Store 9\n- From Center 6 to Stores: $4 to Store 1, $5 to Store 2, $3 to Store 3, $1 to Store 4, $4 to Store 5, $2 to Store 6, $4 to Store 7, $2 to Store 8, $2 to Store 9\n- From Center 7 to Stores: $4 to Store 1, $5 to Store 2, $2 to Store 3, $2 to Store 4, $4 to Store 5, $2 to Store 6, $2 to Store 7, $4 to Store 8, $4 to Store 9\n- From Center 8 to Stores: $1 to Store 1, $5 to Store 2, $5 to Store 3, $2 to Store 4, $5 to Store 5, $2 to Store 6, $1 to Store 7, $4 to Store 8, $4 to Store 9\n\nDemand of Each Retail Store (in units):\n- Store 1: 779 units\n- Store 2: 892 units\n- Store 3: 440 units\n- Store 4: 556 units\n- Store 5: 414 units\n- Store 6: 464 units\n- Store 7: 920 units\n- Store 8: 743 units\n- Store 9: 528 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1447 units\n- Center 2: 1886 units\n- Center 3: 1962 units\n- Center 4: 1392 units\n- Center 5: 1191 units\n- Center 6: 1218 units\n- Center 7: 1088 units\n- Center 8: 1178 units\n\nQuestion:\nWhat is the optimal total cost for LogiChain Solutions to open the necessary distribution centers and transport goods to meet all the demands of the nine retail stores? This cost includes both the opening costs of the centers and the transportation costs of supplying the stores.",
    "ground_truth": 556908.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"LogiChain_Optimization\")\n\n# Sets\ncenters = range(8)  # Set of potential distribution centers (0 to 7)\nstores = range(9)   # Set of retail stores (0 to 8)\n\n# Parameters\nopening_costs = [151000, 192000, 114000, 171000, 160000, 120000, 182000, 186000]\ntransport_costs = [\n    [3, 3, 5, 4, 3, 5, 2, 4, 2],  # From Center 1\n    [4, 5, 1, 4, 2, 5, 4, 1, 1],  # From Center 2\n    [3, 3, 2, 4, 4, 3, 4, 4, 1],  # From Center 3\n    [3, 5, 3, 5, 1, 2, 4, 1, 4],  # From Center 4\n    [2, 2, 1, 2, 5, 2, 4, 4, 4],  # From Center 5\n    [4, 5, 3, 1, 4, 2, 4, 2, 2],  # From Center 6\n    [4, 5, 2, 2, 4, 2, 2, 4, 4],  # From Center 7\n    [1, 5, 5, 2, 5, 2, 1, 4, 4]   # From Center 8\n]\ndemands = [779, 892, 440, 556, 414, 464, 920, 743, 528]\ncapacities = [1447, 1886, 1962, 1392, 1191, 1218, 1088, 1178]\n\n# Variables\nx = model.addVars(centers, stores, vtype=GRB.INTEGER, name=\"x\")\ny = model.addVars(centers, vtype=GRB.BINARY, name=\"y\")\n\n# Objective: Minimize total cost\nmodel.setObjective(gp.quicksum(opening_costs[i] * y[i] for i in centers) +\n                   gp.quicksum(transport_costs[i][j] * x[i, j] for i in centers for j in stores), GRB.MINIMIZE)\n\n# Constraints\n# Demand fulfillment for each retail store\nmodel.addConstrs((gp.quicksum(x[i, j] for i in centers) == demands[j] for j in stores), name=\"Demand\")\n\n# Capacity constraint for each distribution center\nmodel.addConstrs((gp.quicksum(x[i, j] for j in stores) <= capacities[i] * y[i] for i in centers), name=\"Capacity\")\n\n# Non-negativity constraints are handled by default in integer variables\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E081",
    "description": "In the bustling landscape of retail and distribution, EfficientDistro Inc. is at a pivotal point of re-evaluating its logistics strategy to ensure the timely and cost-effective delivery of goods to its consumer base. The company has narrowed down its choice to four potential distribution centers, each with its own set of operational costs and capacities. These centers are tasked with the responsibility of distributing products to four retail stores, spread across different locations, each with its unique demand. The challenge lies in selecting the right mix of distribution centers to open and determining the most efficient distribution routes to minimize the overall operational costs, which include both the opening costs of the distribution centers and the transportation costs of goods to the retail stores.\n\nGiven Data:\n- Number of Potential Distribution Centers: 4\n- Number of Retail Stores Needing Supply: 4\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $5 to Store 1, $5 to Store 2, $2 to Store 3, $3 to Store 4\n- From Center 2: $3 to Store 1, $3 to Store 2, $5 to Store 3, $4 to Store 4\n- From Center 3: $3 to Store 1, $5 to Store 2, $2 to Store 3, $4 to Store 4\n- From Center 4: $2 to Store 1, $4 to Store 2, $5 to Store 3, $1 to Store 4\n\nDemand of Each Retail Store (in units):\n- Store 1: 859\n- Store 2: 713\n- Store 3: 421\n- Store 4: 652\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1,547\n- Center 2: 1,656\n- Center 3: 1,274\n- Center 4: 1,882\n\nEfficientDistro Inc. now faces the complex task of deciding which distribution centers to open and how to allocate shipments to meet the demand at each retail store in the most cost-effective manner. The solution must take into account the varying opening costs of the distribution centers, their capacities, the transportation costs involved in shipping goods to the retail stores, and the specific demand at each store location.\n\nQuestion:\nWhat is the optimal total cost for EfficientDistro Inc. to open the necessary distribution centers and transport goods to meet all retail stores' demands, including both the opening costs of the centers and the transportation costs of supplying the stores?",
    "ground_truth": 273940.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"EfficientDistroOptimization\")\n\n# Sets\nI = range(4)  # Distribution centers\nJ = range(4)  # Retail stores\n\n# Parameters\nF = [151000, 192000, 114000, 171000]  # Opening costs\nc = [\n    [5, 5, 2, 3],  # Transportation costs from center 1\n    [3, 3, 5, 4],  # Transportation costs from center 2\n    [3, 5, 2, 4],  # Transportation costs from center 3\n    [2, 4, 5, 1]   # Transportation costs from center 4\n]\nd = [859, 713, 421, 652]  # Demands\ns = [1547, 1656, 1274, 1882]  # Supply capacities\n\n# Variables\nx = model.addVars(I, J, vtype=GRB.CONTINUOUS, lb=0, name=\"x\")  # Units shipped\ny = model.addVars(I, vtype=GRB.BINARY, name=\"y\")  # Open centers\n\n# Objective function\nmodel.setObjective(\n    gp.quicksum(F[i] * y[i] for i in I) +\n    gp.quicksum(c[i][j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand constraints\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == d[j] for j in J), \"Demand\"\n)\n\n# Supply constraints\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= s[i] * y[i] for i in I), \"Supply\"\n)\n\n# Logical constraints for shipping\nmodel.addConstrs(\n    (x[i, j] <= s[i] * y[i] for i in I for j in J), \"Logical\"\n)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E080",
    "description": "GlobalSupply Inc. is at a strategic crossroads, looking to streamline its operations by identifying the most cost-effective way to distribute its products to six retail stores from a pool of five potential distribution centers. Each distribution center has not only a unique opening cost but also a specific supply capacity, which limits the amount of product it can dispatch. Moreover, the transport cost for shipping a unit of product from these centers to the retail stores varies, adding another layer of complexity to the decision-making process. The ultimate goal for GlobalSupply Inc. is to ensure that the demand at each retail store is met while keeping the total costs—comprising both the opening costs of the distribution centers and the transportation costs of the products—as low as possible.\n\nGiven Data:\n- Number of Potential Distribution Centers: 5\n- Number of Retail Stores Needing Supply: 6\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $5 to Store 1, $2 to Store 2, $3 to Store 3, $3 to Store 4, $3 to Store 5, $5 to Store 6\n- From Center 2: $4 to Store 1, $3 to Store 2, $5 to Store 3, $2 to Store 4, $4 to Store 5, $2 to Store 6\n- From Center 3: $4 to Store 1, $5 to Store 2, $1 to Store 3, $4 to Store 4, $2 to Store 5, $5 to Store 6\n- From Center 4: $4 to Store 1, $1 to Store 2, $1 to Store 3, $3 to Store 4, $3 to Store 5, $2 to Store 6\n- From Center 5: $4 to Store 1, $4 to Store 2, $3 to Store 3, $4 to Store 4, $4 to Store 5, $1 to Store 6\n\nDemand of Each Retail Store (in units):\n- Store 1: 530\n- Store 2: 884\n- Store 3: 420\n- Store 4: 566\n- Store 5: 673\n- Store 6: 787\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1400\n- Center 2: 1115\n- Center 3: 813\n- Center 4: 1041\n- Center 5: 1576\n\nQuestion:\nWhat is the optimal total cost for GlobalSupply Inc. to open the necessary distribution centers and transport goods in order to satisfy the demand of all six retail stores, including both the opening costs of the distribution centers and the transportation costs of supplying the stores?",
    "ground_truth": 490293.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nI = [1, 2, 3, 4, 5]  # Distribution centers\nJ = [1, 2, 3, 4, 5, 6]  # Retail stores\n\n# Parameters\nf = {1: 151000, 2: 192000, 3: 114000, 4: 171000, 5: 160000}  # Opening costs\nc = {\n    (1, 1): 5, (1, 2): 2, (1, 3): 3, (1, 4): 3, (1, 5): 3, (1, 6): 5,\n    (2, 1): 4, (2, 2): 3, (2, 3): 5, (2, 4): 2, (2, 5): 4, (2, 6): 2,\n    (3, 1): 4, (3, 2): 5, (3, 3): 1, (3, 4): 4, (3, 5): 2, (3, 6): 5,\n    (4, 1): 4, (4, 2): 1, (4, 3): 1, (4, 4): 3, (4, 5): 3, (4, 6): 2,\n    (5, 1): 4, (5, 2): 4, (5, 3): 3, (5, 4): 4, (5, 5): 4, (5, 6): 1\n}\nd = {1: 530, 2: 884, 3: 420, 4: 566, 5: 673, 6: 787}  # Demands\ns = {1: 1400, 2: 1115, 3: 813, 4: 1041, 5: 1576}  # Supply capacities\n\n# Decision variables\nx = model.addVars(I, J, name=\"x\", vtype=GRB.CONTINUOUS, lb=0)\ny = model.addVars(I, name=\"y\", vtype=GRB.BINARY)\n\n# Objective function\nmodel.setObjective(\n    gp.quicksum(f[i] * y[i] for i in I) +\n    gp.quicksum(c[i, j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand satisfaction\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == d[j] for j in J),\n    \"Demand\"\n)\n\n# Supply capacity\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= s[i] * y[i] for i in I),\n    \"Supply\"\n)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E073",
    "description": "SupplyLink, a major supplier, is looking to optimize its distribution network to ensure the efficient supply of goods to its five retail stores from a selection of five potential distribution centers. Each distribution center incurs an initial opening cost and has a limit on how much it can supply. The transportation cost of goods from these centers to the retail stores also varies. The goal is to meet the demand at each retail store at minimal total cost, which includes the opening costs of distribution centers and the transportation cost of the goods.\n\nGiven Data:\n- Number of Potential Distribution Centers: 5\n- Number of Retail Stores Needing Supply: 5\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: 151,000\n- Center 2: 192,000\n- Center 3: 114,000\n- Center 4: 171,000\n- Center 5: 160,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $5 to Store 1, $2 to Store 2, $3 to Store 3, $3 to Store 4, $3 to Store 5\n- From Center 2: $5 to Store 1, $4 to Store 2, $3 to Store 3, $5 to Store 4, $2 to Store 5\n- From Center 3: $4 to Store 1, $2 to Store 2, $4 to Store 3, $5 to Store 4, $1 to Store 5\n- From Center 4: $4 to Store 1, $2 to Store 2, $5 to Store 3, $4 to Store 4, $1 to Store 5\n- From Center 5: $1 to Store 1, $3 to Store 2, $3 to Store 3, $2 to Store 4, $4 to Store 5\n\nDemand of Each Retail Store (in units):\n- Store 1: 589\n- Store 2: 962\n- Store 3: 966\n- Store 4: 643\n- Store 5: 904\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1954\n- Center 2: 1446\n- Center 3: 820\n- Center 4: 1640\n- Center 5: 966\n\nQuestion:\nWhat is the minimum total cost that SupplyLink will incur to open distribution centers and transport goods in order to satisfy all retail stores' demands? This total cost includes both the opening costs of the centers and the transportation costs of supplying the stores.",
    "ground_truth": 446011.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nI = range(5)  # Distribution centers\nJ = range(5)  # Retail stores\n\n# Parameters\nf = [151000, 192000, 114000, 171000, 160000]  # Opening costs\nc = [\n    [5, 2, 3, 3, 3],\n    [5, 4, 3, 5, 2],\n    [4, 2, 4, 5, 1],\n    [4, 2, 5, 4, 1],\n    [1, 3, 3, 2, 4]\n]  # Transportation costs\n\nd = [589, 962, 966, 643, 904]  # Demands\ns = [1954, 1446, 820, 1640, 966]  # Supply capacities\n\n# Variables\nx = model.addVars(I, J, name=\"x\", lb=0)\ny = model.addVars(I, vtype=GRB.BINARY, name=\"y\")\n\n# Objective\nmodel.setObjective(gp.quicksum(f[i] * y[i] for i in I) +\n                   gp.quicksum(c[i][j] * x[i, j] for i in I for j in J),\n                   GRB.MINIMIZE)\n\n# Constraints\n# Demand satisfaction constraints\nfor j in J:\n    model.addConstr(gp.quicksum(x[i, j] for i in I) == d[j], name=f\"Demand_{j}\")\n\n# Supply capacity constraints\nfor i in I:\n    model.addConstr(gp.quicksum(x[i, j] for j in J) <= s[i] * y[i], name=f\"Supply_{i}\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E077",
    "description": "In a challenging and complex market, SwiftLogistics is at a crossroads to design an efficient distribution network to fulfill the needs of eight retail stores scattered across various locations. The company has the opportunity to choose from six potential distribution centers, each with its unique opening costs and capacities. The primary goal is to ensure all retail stores are adequately supplied while minimizing the total operational costs, which include both the opening of distribution centers and the transportation of goods.\n\nGiven Data:\n- Number of Potential Distribution Centers: 6\n- Number of Retail Stores Needing Supply: 8\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n- Center 6: $120,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $2 to Store 1, $3 to Store 2, $3 to Store 3, $3 to Store 4, $5 to Store 5, $4 to Store 6, $3 to Store 7, $5 to Store 8\n- From Center 2: $2 to Store 1, $4 to Store 2, $2 to Store 3, $4 to Store 4, $5 to Store 5, $1 to Store 6, $4 to Store 7, $2 to Store 8\n- From Center 3: $5 to Store 1, $4 to Store 2, $1 to Store 3, $1 to Store 4, $3 to Store 5, $3 to Store 6, $2 to Store 7, $4 to Store 8\n- From Center 4: $4 to Store 1, $3 to Store 2, $4 to Store 3, $4 to Store 4, $1 to Store 5, $3 to Store 6, $5 to Store 7, $3 to Store 8\n- From Center 5: $5 to Store 1, $1 to Store 2, $2 to Store 3, $4 to Store 4, $1 to Store 5, $4 to Store 6, $2 to Store 7, $2 to Store 8\n- From Center 6: $1 to Store 1, $2 to Store 2, $5 to Store 3, $2 to Store 4, $4 to Store 5, $4 to Store 6, $4 to Store 7, $4 to Store 8\n\nDemand of Each Retail Store (in units):\n- Store 1: 908 units\n- Store 2: 434 units\n- Store 3: 605 units\n- Store 4: 480 units\n- Store 5: 961 units\n- Store 6: 787 units\n- Store 7: 401 units\n- Store 8: 789 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1365 units\n- Center 2: 1929 units\n- Center 3: 1502 units\n- Center 4: 1201 units\n- Center 5: 1529 units\n- Center 6: 961 units\n\nSwiftLogistics now faces the intricate task of determining which distribution centers to open and how to distribute goods to meet the demands of all eight retail stores efficiently. The strategy must ensure that the total cost, including opening and transportation expenses, is minimized.\n\nQuestion:\nWhat is the optimal total cost for SwiftLogistics to open the necessary distribution centers and transport goods to satisfy the demands of all eight retail stores, keeping in mind the goal of minimizing the combined opening and transportation costs?",
    "ground_truth": 587428.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SwiftLogisticsOptimization\")\n\n# Sets\nI = range(1, 7)  # Distribution centers\nJ = range(1, 9)  # Retail stores\n\n# Parameters\nf = {1: 151000, 2: 192000, 3: 114000, 4: 171000, 5: 160000, 6: 120000}\nc = {\n    (1, 1): 2, (1, 2): 3, (1, 3): 3, (1, 4): 3, (1, 5): 5, (1, 6): 4, (1, 7): 3, (1, 8): 5,\n    (2, 1): 2, (2, 2): 4, (2, 3): 2, (2, 4): 4, (2, 5): 5, (2, 6): 1, (2, 7): 4, (2, 8): 2,\n    (3, 1): 5, (3, 2): 4, (3, 3): 1, (3, 4): 1, (3, 5): 3, (3, 6): 3, (3, 7): 2, (3, 8): 4,\n    (4, 1): 4, (4, 2): 3, (4, 3): 4, (4, 4): 4, (4, 5): 1, (4, 6): 3, (4, 7): 5, (4, 8): 3,\n    (5, 1): 5, (5, 2): 1, (5, 3): 2, (5, 4): 4, (5, 5): 1, (5, 6): 4, (5, 7): 2, (5, 8): 2,\n    (6, 1): 1, (6, 2): 2, (6, 3): 5, (6, 4): 2, (6, 5): 4, (6, 6): 4, (6, 7): 4, (6, 8): 4\n}\nd = {1: 908, 2: 434, 3: 605, 4: 480, 5: 961, 6: 787, 7: 401, 8: 789}\ns = {1: 1365, 2: 1929, 3: 1502, 4: 1201, 5: 1529, 6: 961}\n\n# Decision Variables\nx = model.addVars(I, J, name=\"x\", vtype=GRB.CONTINUOUS, lb=0)\ny = model.addVars(I, name=\"y\", vtype=GRB.BINARY)\n\n# Objective: Minimize total cost\nmodel.setObjective(\n    gp.quicksum(f[i] * y[i] for i in I) +\n    gp.quicksum(c[i, j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand satisfaction\nmodel.addConstrs((gp.quicksum(x[i, j] for i in I) == d[j] for j in J), name=\"Demand\")\n\n# Supply capacity\nmodel.addConstrs((gp.quicksum(x[i, j] for j in J) <= s[i] * y[i] for i in I), name=\"Supply\")\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E084",
    "description": "In the scenario presented, SupplyChain Solutions is faced with a complex decision in establishing its distribution network to efficiently serve six retail stores from a selection of seven distribution centers. Each distribution center has its own specific opening cost and a maximum supply capacity. Furthermore, the cost of transporting goods from these centers to the retail stores varies significantly. The goal is to fulfill the demand at each retail store while minimizing the total cost incurred, which encompasses both the opening costs of the distribution centers and the transportation costs of the goods.\n\nGiven Data:\n- Number of Potential Distribution Centers: 7\n- Number of Retail Stores Needing Supply: 6\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n- Center 6: $120,000\n- Center 7: $182,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $3 to Store 1, $3 to Store 2, $5 to Store 3, $4 to Store 4, $3 to Store 5, $5 to Store 6\n- From Center 2: $2 to Store 1, $4 to Store 2, $2 to Store 3, $4 to Store 4, $5 to Store 5, $1 to Store 6\n- From Center 3: $4 to Store 1, $2 to Store 2, $5 to Store 3, $4 to Store 4, $1 to Store 5, $1 to Store 6\n- From Center 4: $3 to Store 1, $3 to Store 2, $2 to Store 3, $4 to Store 4, $4 to Store 5, $3 to Store 6\n- From Center 5: $4 to Store 1, $4 to Store 2, $1 to Store 3, $3 to Store 4, $5 to Store 5, $3 to Store 6\n- From Center 6: $5 to Store 1, $1 to Store 2, $2 to Store 3, $4 to Store 4, $1 to Store 5, $4 to Store 6\n- From Center 7: $2 to Store 1, $2 to Store 2, $1 to Store 3, $2 to Store 4, $5 to Store 5, $2 to Store 6\n\nDemand of Each Retail Store (in units):\n- Store 1: 739\n- Store 2: 491\n- Store 3: 766\n- Store 4: 854\n- Store 5: 827\n- Store 6: 908\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1575\n- Center 2: 834\n- Center 3: 1005\n- Center 4: 1904\n- Center 5: 1825\n- Center 6: 1821\n- Center 7: 1365\n\nQuestion:\nWhat is the optimal total cost for SupplyChain Solutions to select distribution centers and transport goods to meet the demands of all retail stores, considering both the opening costs of the centers and the transportation costs of supplying the stores?",
    "ground_truth": 402947.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nI = range(1, 8)  # Distribution centers\nJ = range(1, 7)  # Retail stores\n\n# Parameters\nf = {1: 151000, 2: 192000, 3: 114000, 4: 171000, 5: 160000, 6: 120000, 7: 182000}  # Opening costs\nc = {\n    (1, 1): 3, (1, 2): 3, (1, 3): 5, (1, 4): 4, (1, 5): 3, (1, 6): 5,\n    (2, 1): 2, (2, 2): 4, (2, 3): 2, (2, 4): 4, (2, 5): 5, (2, 6): 1,\n    (3, 1): 4, (3, 2): 2, (3, 3): 5, (3, 4): 4, (3, 5): 1, (3, 6): 1,\n    (4, 1): 3, (4, 2): 3, (4, 3): 2, (4, 4): 4, (4, 5): 4, (4, 6): 3,\n    (5, 1): 4, (5, 2): 4, (5, 3): 1, (5, 4): 3, (5, 5): 5, (5, 6): 3,\n    (6, 1): 5, (6, 2): 1, (6, 3): 2, (6, 4): 4, (6, 5): 1, (6, 6): 4,\n    (7, 1): 2, (7, 2): 2, (7, 3): 1, (7, 4): 2, (7, 5): 5, (7, 6): 2\n}\nd = {1: 739, 2: 491, 3: 766, 4: 854, 5: 827, 6: 908}  # Demand\ns = {1: 1575, 2: 834, 3: 1005, 4: 1904, 5: 1825, 6: 1821, 7: 1365}  # Supply capacities\n\n# Decision Variables\nx = model.addVars(I, J, vtype=GRB.CONTINUOUS, name=\"x\", lb=0)  # Number of units transported\ny = model.addVars(I, vtype=GRB.BINARY, name=\"y\")  # Center open or not\n\n# Objective Function\nmodel.setObjective(\n    gp.quicksum(f[i] * y[i] for i in I) + gp.quicksum(c[i, j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand fulfillment for each store\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == d[j] for j in J), \n    name=\"Demand\"\n)\n\n# Supply capacity restriction for each distribution center\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= s[i] * y[i] for i in I), \n    name=\"Capacity\"\n)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Supply Chain"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E096",
    "description": "In the bustling world of retail, SupplyChain Solutions is faced with the challenge of efficiently distributing products to eight eager retail stores. With four potential distribution centers to choose from, each with its own unique costs and capacities, the company aims to devise a strategic plan to minimize overall expenses. This plan must account for the initial cost of opening distribution centers and the ongoing expenses of transporting goods to stores. The objective is clear: to fulfill the demand of each retail store at the lowest possible total cost.\n\nGiven Data:\n- Number of Potential Distribution Centers: 4\n- Number of Retail Stores Needing Supply: 8\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $5 to Store 1, $5 to Store 2, $2 to Store 3, $3 to Store 4, $3 to Store 5, $3 to Store 6, $5 to Store 7, $4 to Store 8\n- From Center 2: $3 to Store 1, $5 to Store 2, $2 to Store 3, $4 to Store 4, $2 to Store 5, $4 to Store 6, $5 to Store 7, $1 to Store 8\n- From Center 3: $4 to Store 1, $2 to Store 2, $5 to Store 3, $4 to Store 4, $1 to Store 5, $1 to Store 6, $3 to Store 7, $3 to Store 8\n- From Center 4: $2 to Store 1, $4 to Store 2, $4 to Store 3, $3 to Store 4, $4 to Store 5, $4 to Store 6, $1 to Store 7, $3 to Store 8\n\nDemand of Each Retail Store (in units):\n- Store 1: 884 units\n- Store 2: 420 units\n- Store 3: 566 units\n- Store 4: 673 units\n- Store 5: 787 units\n- Store 6: 1000 units\n- Store 7: 715 units\n- Store 8: 413 units\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1041 units\n- Center 2: 1576 units\n- Center 3: 1364 units\n- Center 4: 1697 units\n\nQuestion:\nWhat is the optimal total cost for SupplyChain Solutions to open distribution centers and transport goods to meet all retail stores' demands? This cost includes both the opening costs of the centers and the transportation costs of supplying the stores.",
    "ground_truth": 637573.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nI = range(4)  # Distribution centers\nJ = range(8)  # Retail stores\n\n# Parameters\nF = [151000, 192000, 114000, 171000]  # Opening costs\nc = [\n    [5, 5, 2, 3, 3, 3, 5, 4],\n    [3, 5, 2, 4, 2, 4, 5, 1],\n    [4, 2, 5, 4, 1, 1, 3, 3],\n    [2, 4, 4, 3, 4, 4, 1, 3]\n]  # Transportation costs\nd = [884, 420, 566, 673, 787, 1000, 715, 413]  # Demands\nS = [1041, 1576, 1364, 1697]  # Supply capacities\n\n# Variables\nx = model.addVars(I, J, name=\"x\", vtype=GRB.CONTINUOUS, lb=0.0)\ny = model.addVars(I, name=\"y\", vtype=GRB.BINARY)\n\n# Objective\nmodel.setObjective(\n    gp.quicksum(F[i] * y[i] for i in I) +\n    gp.quicksum(c[i][j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Fulfill the demand at each retail store (C1)\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == d[j] for j in J),\n    name=\"Demand\"\n)\n\n# Do not exceed supply capacity of the distribution centers (C2)\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= S[i] * y[i] for i in I),\n    name=\"SupplyCapacity\"\n)\n\n# Ensure x_{ij} = 0 if the distribution center i is not open (C3)\nmodel.addConstrs(\n    (x[i, j] <= d[j] * y[i] for i in I for j in J),\n    name=\"OpenCenter\"\n)\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E074",
    "description": "In the strategic planning of WareCo's distribution network, the company is evaluating how to efficiently supply seven retail stores from seven available distribution centers. Each distribution center has a unique opening cost and capacity that limits the volume of goods it can distribute. Additionally, the cost to transport goods from these centers to each retail store varies, making the task of minimizing the overall operational cost a complex puzzle. The goal is to determine the optimal setup that satisfies the demand at each retail store while incurring the lowest possible total cost, including both the opening of selected distribution centers and the transportation of goods.\n\nGiven Data:\n\n- Number of Potential Distribution Centers: 7\n- Number of Retail Stores to be Supplied: 7\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n- Center 5: $160,000\n- Center 6: $120,000\n- Center 7: $182,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $3 to Store 1, $3 to Store 2, $5 to Store 3, $4 to Store 4, $3 to Store 5, $5 to Store 6, $2 to Store 7\n- From Center 2: $4 to Store 1, $2 to Store 2, $4 to Store 3, $5 to Store 4, $1 to Store 5, $4 to Store 6, $2 to Store 7\n- From Center 3: $5 to Store 1, $4 to Store 2, $1 to Store 3, $1 to Store 4, $3 to Store 5, $3 to Store 6, $2 to Store 7\n- From Center 4: $4 to Store 1, $4 to Store 2, $3 to Store 3, $4 to Store 4, $4 to Store 5, $1 to Store 6, $3 to Store 7\n- From Center 5: $5 to Store 1, $3 to Store 2, $5 to Store 3, $1 to Store 4, $2 to Store 5, $4 to Store 6, $1 to Store 7\n- From Center 6: $4 to Store 1, $2 to Store 2, $2 to Store 3, $1 to Store 4, $2 to Store 5, $5 to Store 6, $2 to Store 7\n- From Center 7: $4 to Store 1, $4 to Store 2, $4 to Store 3, $4 to Store 4, $5 to Store 5, $3 to Store 6, $1 to Store 7\n\nDemand of Each Retail Store (in units):\n- Store 1: 961\n- Store 2: 787\n- Store 3: 401\n- Store 4: 789\n- Store 5: 965\n- Store 6: 505\n- Store 7: 876\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1502\n- Center 2: 1201\n- Center 3: 1529\n- Center 4: 961\n- Center 5: 1001\n- Center 6: 1795\n- Center 7: 1069\n\nQuestion:\nWhat is the optimal total cost for WareCo to meet the demand at all seven retail stores, considering both the opening costs of the distribution centers and the transportation costs of supplying the stores?",
    "ground_truth": 554968.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"WareCo_Distribution_Network\")\n\n# Sets\nI = range(7)  # Distribution centers\nJ = range(7)  # Retail stores\n\n# Parameters\nf = [151000, 192000, 114000, 171000, 160000, 120000, 182000]  # Opening costs\nc = [  # Transportation costs\n    [3, 3, 5, 4, 3, 5, 2],\n    [4, 2, 4, 5, 1, 4, 2],\n    [5, 4, 1, 1, 3, 3, 2],\n    [4, 4, 3, 4, 4, 1, 3],\n    [5, 3, 5, 1, 2, 4, 1],\n    [4, 2, 2, 1, 2, 5, 2],\n    [4, 4, 4, 4, 5, 3, 1]\n]\nd = [961, 787, 401, 789, 965, 505, 876]  # Demands\ns = [1502, 1201, 1529, 961, 1001, 1795, 1069]  # Supply capacities\n\n# Variables\nx = model.addVars(I, J, vtype=GRB.CONTINUOUS, name=\"x\")  # Shipment quantities\ny = model.addVars(I, vtype=GRB.BINARY, name=\"y\")  # Center open/close\n\n# Objective: Minimize total cost\nmodel.setObjective(\n    gp.quicksum(f[i] * y[i] for i in I) +\n    gp.quicksum(c[i][j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand satisfaction\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for i in I) == d[j] for j in J),\n    name=\"Demand\"\n)\n\n# Supply capacity\nmodel.addConstrs(\n    (gp.quicksum(x[i, j] for j in J) <= s[i] * y[i] for i in I),\n    name=\"Supply\"\n)\n\n# Optimize model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "B069",
    "description": "The famous Traveling Salesman Problem (TSP) in operations research can be described as follows: A traveling salesman departs from a certain city, visits two other cities to sell merchandise, and must visit each city exactly once before returning to the original starting city. The distances between the cities are provided in the table below.\n| City |    1    |    2    |    3    |    4    |\n| ---- | ------ | ------ | ------ | ------ |\n| 1    | 0    | 10   | 20   | 12   |\n| 2    | 10   | 0    | 5    | 10   |\n| 3    | 20   | 5    | 0    | 8    |\n| 4    | 15   | 12   | 8    | 0    |\n\nWhat route should the salesman choose to travel in order to minimize the total distance? Try to formulate an integer programming model for this problem.",
    "ground_truth": 35.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_tsp_mtz():\n    \"\"\"\n    Solves the Traveling Salesman Problem (TSP) for 4 cities\n    using the Miller-Tucker-Zemlin (MTZ) formulation for subtour elimination.\n    The objective is to minimize the total travel distance.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Number of cities\n        num_cities = 4\n        cities = range(num_cities)  # Indices 0, 1, 2, 3\n\n        # Distance matrix d[i][j] is distance from city i to city j.\n        # Mapping: City 1 -> 0, City 2 -> 1, City 3 -> 2, City 4 -> 3\n        # Original Table:\n        # | City |  1  |  2  |  3  |  4  |\n        # | ---- | --- | --- | --- | --- |\n        # | 1    | 0   | 10  | 20  | 12  |\n        # | 2    | 10  | 0   | 5   | 10  |\n        # | 3    | 20  | 5   | 0   | 8   |\n        # | 4    | 15  | 12  | 8   | 0   |\n\n        # Distances (costs) between cities. d[i][j] is cost from i to j.\n        # Using a dictionary for clarity with non-sequential/sparse connections if any.\n        # For a full matrix, a list of lists is also fine.\n        distances = {\n            (0, 1): 10,\n            (0, 2): 20,\n            (0, 3): 12,  # From City 1 (index 0)\n            (1, 0): 10,\n            (1, 2): 5,\n            (1, 3): 10,  # From City 2 (index 1)\n            (2, 0): 20,\n            (2, 1): 5,\n            (2, 3): 8,  # From City 3 (index 2)\n            (3, 0): 15,\n            (3, 1): 12,\n            (3, 2): 8  # From City 4 (index 3)\n        }\n        # Note: d[i,i] is implicitly infinity or such arcs are excluded.\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"TSP_MTZ\")\n\n        # --- Decision Variables ---\n        # x[i,j]: 1 if salesman travels from city i to city j, 0 otherwise\n        x = model.addVars(cities, cities, vtype=GRB.BINARY, name=\"x\")\n\n        # u[i]: auxiliary variable for MTZ subtour elimination (position of city i in tour)\n        # u[0] will be fixed to 0 (or 1). Let's use 1 for positions 1 to N.\n        u = model.addVars(cities,\n                          vtype=GRB.CONTINUOUS,\n                          name=\"u\",\n                          lb=1.0,\n                          ub=num_cities)\n\n        # --- Preprocessing: Remove x[i,i] variables (travel from a city to itself) ---\n        for i in cities:\n            x[i, i].ub = 0\n\n        # --- Objective Function: Minimize Total Travel Distance ---\n        model.setObjective(\n            gp.quicksum(\n                distances.get((i, j), 0) * x[i, j] for i in cities\n                for j in cities if i != j), GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Depart from each city exactly once\n        for i in cities:\n            model.addConstr(gp.quicksum(x[i, j] for j in cities\n                                        if j != i) == 1,\n                            name=f\"DepartOnce_{i}\")\n\n        # 2. Enter each city exactly once\n        for j in cities:\n            model.addConstr(gp.quicksum(x[i, j] for i in cities\n                                        if i != j) == 1,\n                            name=f\"EnterOnce_{j}\")\n\n        # 3. Subtour Elimination (MTZ constraints)\n        # Let city 0 be the \"depot\" for sequencing purposes.\n        model.addConstr(\n            u[0] == 1,\n            name=\"FixDepotOrder\")  # Fix position of depot city (index 0)\n\n        for i in cities:\n            if i == 0:\n                continue  # Skip depot for these u bounds if u[0] is fixed differently\n            model.addConstr(u[i] >= 2,\n                            name=f\"u_lower_bound_{i}\")  # Positions 2 to N\n            model.addConstr(u[i] <= num_cities, name=f\"u_upper_bound_{i}\")\n\n        for i in cities:\n            for j in cities:\n                if i == j or j == 0:  # Constraint is typically for non-depot j\n                    continue\n                # If x[i,j] = 1, then u[j] >= u[i] + 1\n                # u[i] - u[j] + num_cities * x[i,j] <= num_cities - 1\n                model.addConstr(u[i] - u[j] + num_cities * x[i, j]\n                                <= num_cities - 1,\n                                name=f\"MTZ_{i}_{j}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal TSP route found.\")\n            print(f\"Minimum Total Distance: {model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Route (Original City Numbers):\")\n            # Reconstruct the path\n            current_city_idx = 0  # Start from city 0 (Original City 1)\n            route = [current_city_idx + 1]  # Store original city numbers\n\n            for _ in range(num_cities - 1):\n                found_next = False\n                for j in cities:\n                    if j != current_city_idx and x[current_city_idx,\n                                                   j].X > 0.5:\n                        route.append(j + 1)\n                        current_city_idx = j\n                        found_next = True\n                        break\n                if not found_next:\n                    print(\"Error: Could not reconstruct full route.\")\n                    break\n\n            if len(\n                    route\n            ) == num_cities:  # and current_city_idx is now the last city before returning to start\n                # Check if it returns to start\n                if x[current_city_idx, 0].X > 0.5:\n                    route.append(route[0])  # Add starting city to show cycle\n                    print(\" -> \".join(map(str, route)))\n                else:\n                    print(\n                        \"Error: Route does not return to start or is incomplete.\"\n                    )\n                    print(\"Partial route:\", \" -> \".join(map(str, route)))\n            else:\n                print(\"Error: Route reconstruction failed or incomplete.\")\n                print(\"Partial route:\", \" -> \".join(map(str, route)))\n\n            print(\"\\nSequence variables u_i (Original City Numbers):\")\n            for i in cities:\n                print(f\"  City {i+1}: u = {u[i].X:.1f}\")\n\n            print(\"\\nArcs used (Original City Numbers):\")\n            for i in cities:\n                for j in cities:\n                    if i != j and x[i, j].X > 0.5:\n                        print(\n                            f\"  {i+1} -> {j+1} (Distance: {distances.get((i,j),0)})\"\n                        )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"tsp_mtz_iis.ilp\")\n            # print(\"IIS written to tsp_mtz_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_tsp_mtz()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "MILP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E043",
    "description": "Consider a scenario where a tour guide is planning a bus tour across five cities, named E, F, G, H, and I. The tour must start and end in the same city, and each city should be visited exactly once. The objective is to minimize the total cost of the tour, which could be influenced by factors such as distance, tolls, and fuel expenses.\n\nHere are the travel costs between the cities:\n\nFrom City E, it costs 37 units to travel to F, 72 units to G, 66 units to H, and 33 units to I.\nTravelling from City F, the costs are 37 units to E, 26 units to G, 56 units to H, and a whopping 100 units to I.\nIf the journey starts from City G, it takes 72 units to reach E, 26 units to F, 49 units to H, and 32 units to I.\nFrom City H, it costs 66 units to get to E, 56 units to F, 49 units to G, and a mere 13 units to I.\nLastly, from City I, the travel costs are 33 units to E, 100 units to F, 32 units to G, and 13 units to H.\n\nKeeping these costs in mind, what is the minimum total travel cost for the tour guide to take the bus to each city exactly once and return to the starting city?",
    "ground_truth": 158.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"TourOptimization\")\n\n# Set of cities\ncities = ['E', 'F', 'G', 'H', 'I']\n\n# Costs of travel between cities\ncosts = {\n    ('E', 'F'): 37, ('E', 'G'): 72, ('E', 'H'): 66, ('E', 'I'): 33,\n    ('F', 'E'): 37, ('F', 'G'): 26, ('F', 'H'): 56, ('F', 'I'): 100,\n    ('G', 'E'): 72, ('G', 'F'): 26, ('G', 'H'): 49, ('G', 'I'): 32,\n    ('H', 'E'): 66, ('H', 'F'): 56, ('H', 'G'): 49, ('H', 'I'): 13,\n    ('I', 'E'): 33, ('I', 'F'): 100, ('I', 'G'): 32, ('I', 'H'): 13\n}\n\n# Decision variables\nx = model.addVars(cities, cities, vtype=GRB.BINARY, name=\"x\")\n\n# Set objective\nmodel.setObjective(gp.quicksum(costs[i, j] * x[i, j] for i in cities for j in cities if i != j), GRB.MINIMIZE)\n\n# Constraints: Each city must be departed from exactly once\nfor i in cities:\n    model.addConstr(gp.quicksum(x[i, j] for j in cities if i != j) == 1, name=f\"depart_{i}\")\n\n# Constraints: Each city must be arrived at exactly once\nfor j in cities:\n    model.addConstr(gp.quicksum(x[i, j] for i in cities if i != j) == 1, name=f\"arrive_{j}\")\n\n# Subtour elimination constraints: Add lazy constraints\ndef subtour_elimination(model, where):\n    if where == GRB.Callback.MIPSOL:\n        selected = []\n        for i in cities:\n            for j in cities:\n                if i != j and model.cbGetSolution(x[i, j]) > 0.5:\n                    selected.append((i, j))\n        \n        # Find the shortest subtour\n        tour = subtour(selected)\n        \n        if len(tour) < len(cities):\n            model.cbLazy(gp.quicksum(x[i, j] for i in tour for j in tour if i != j) <= len(tour) - 1)\n\ndef subtour(edges):\n    unvisited = set(cities)\n    cycles = []\n    lengths = []\n    while unvisited:\n        thiscycle = []\n        neighbors = unvisited.pop()\n        while neighbors:\n            thiscycle.append(neighbors)\n            unvisited.remove(neighbors)\n            neighbors = [j for i, j in edges if i == neighbors and j in unvisited]\n            neighbors = neighbors[0] if neighbors else None\n        cycles.append(thiscycle)\n        lengths.append(len(thiscycle))\n    return cycles[lengths.index(min(lengths))]\n\n# Add start and end constraints (x[i,i] = 0)\nfor i in cities:\n    model.addConstr(x[i, i] == 0, name=f\"no_loop_{i}\")\n\n# Optimize model with the subtour elimination callback\nmodel.Params.LazyConstraints = 1\nmodel.optimize(subtour_elimination)\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E049",
    "description": "Imagine a scenario involving a salesperson who needs to visit five distinct cities to promote their products. These cities are uniquely numbered from 1 to 5. The objective for the salesperson is to undertake a journey starting from any one of these cities and cover all others once before returning to the starting point, all while incurring the least travel cost possible. The travel costs vary depending on the route between each city pair.\n\nHere's a breakdown of the travel costs between the cities:\n- The cost to travel from City 1 to City 2 is 73 units, to City 3 is 39 units, to City 4 is 79 units, and to City 5 is 38 units.\n- From City 2, it costs 73 units to reach City 1, 30 units to go to City 3, 46 units to visit City 4, and 29 units to get to City 5.\n- Traveling from City 3, the costs are 39 units to City 1, 30 units to City 2, 88 units to City 4, and 57 units to City 5.\n- From City 4, it costs 79 units to go to City 1, 46 units to City 2, 88 units to City 3, and 59 units to City 5.\n- Lastly, from City 5, the travel costs are 38 units to City 1, 29 units to City 2, 57 units to City 3, and 59 units to City 4.\n\nGiven these details, what is the minimum total travel cost for the salesperson to visit each city exactly once and return to the starting city?",
    "ground_truth": 212.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"SalespersonTravel\")\n\n# Parameters\nn = 5\nC = [\n    [0, 73, 39, 79, 38],\n    [73, 0, 30, 46, 29],\n    [39, 30, 0, 88, 57],\n    [79, 46, 88, 0, 59],\n    [38, 29, 57, 59, 0]\n]\n\n# Variables\nx = model.addVars(n, n, vtype=GRB.BINARY, name=\"x\")\nu = model.addVars(n, vtype=GRB.CONTINUOUS, name=\"u\")\n\n# Objective: Minimize the total travel cost\nmodel.setObjective(gp.quicksum(C[i][j] * x[i, j] for i in range(n) for j in range(n) if i != j), GRB.MINIMIZE)\n\n# Constraints\n# C1: Each city is left exactly once\nfor i in range(n):\n    model.addConstr(gp.quicksum(x[i, j] for j in range(n) if i != j) == 1, name=f\"leave_{i}\")\n\n# C2: Each city is entered exactly once\nfor j in range(n):\n    model.addConstr(gp.quicksum(x[i, j] for i in range(n) if i != j) == 1, name=f\"enter_{j}\")\n\n# C3: Subtour elimination constraints\nfor i in range(1, n):\n    for j in range(1, n):\n        if i != j:\n            model.addConstr(u[i] - u[j] + n * x[i, j] <= n-1, name=f\"subtour_{i}_{j}\")\n\n# C4: Domain constraints for u_i\nfor i in range(1, n):\n    model.addConstr(u[i] >= 0, name=f\"u_domain_{i}\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E045",
    "description": "Imagine a scenario where a salesperson is tasked with visiting four distinct cities to explore new market opportunities. These cities are uniquely identified as City 1, City 2, City 3, and City 4. The task for the salesperson is to plan a route that starts from any of these cities, traverses each city exactly once, and concludes by returning to the starting city. The overarching aim is to achieve this while incurring the minimum possible travel cost.\n\nHere’s a detailed breakdown of the travel costs between the cities:\n- The cost to travel from City 1 to City 2 is 17 units, to City 3 is 25 units, and to City 4 is 31 units.\n- From City 2, it costs 17 units to reach City 1, 93 units to get to City 3, and 45 units to City 4.\n- Traveling from City 3, the expenses are 25 units to City 1, 93 units to City 2, and 95 units to City 4.\n- Lastly, from City 4, the journey costs 31 units to City 1, 45 units to City 2, and 95 units to City 3.\n\nWhat is the minimum total travel cost for the salesperson to visit each city exactly once and return to the starting city?",
    "ground_truth": 140.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Initialize the model\nmodel = gp.Model(\"TravelingSalesperson\")\n\n# Set of cities\nN = [1, 2, 3, 4]\n\n# Travel costs between cities\nc = {\n    (1, 2): 17, (1, 3): 25, (1, 4): 31,\n    (2, 1): 17, (2, 3): 93, (2, 4): 45,\n    (3, 1): 25, (3, 2): 93, (3, 4): 95,\n    (4, 1): 31, (4, 2): 45, (4, 3): 95\n}\n\n# Decision variables: x[i,j] is 1 if the salesperson travels from city i to city j\nx = model.addVars(N, N, vtype=GRB.BINARY, name=\"x\")\n\n# Objective: Minimize the total travel cost\nmodel.setObjective(\n    gp.quicksum(c[i, j] * x[i, j] for i in N for j in N if i != j),\n    GRB.MINIMIZE\n)\n\n# Constraints: Each city must be departed exactly once\nfor i in N:\n    model.addConstr(gp.quicksum(x[i, j] for j in N if i != j) == 1, f\"Departure_{i}\")\n\n# Constraints: Each city must be arrived at exactly once\nfor j in N:\n    model.addConstr(gp.quicksum(x[i, j] for i in N if i != j) == 1, f\"Arrival_{j}\")\n\n# Callback to eliminate sub-tours\ndef subtourelim(model, where):\n    if where == GRB.Callback.MIPSOL:\n        # Get the solution\n        vals = model.cbGetSolution(model._vars)\n        # Find the tours\n        selected = gp.tuplelist((i, j) for i in N for j in N if i != j and vals[i, j] > 0.5)\n        # Find the connected components (tours) from the selected edges\n        tour = findsubtour(selected)\n        if len(tour) < len(N):\n            # Add a subtour elimination constraint\n            model.cbLazy(gp.quicksum(x[i, j] for i in tour for j in tour if i != j) <= len(tour) - 1)\n\n# Function to find a sub-tour from the selected edges\ndef findsubtour(edges):\n    unvisited = N[:]\n    cycle = N[:]\n    while unvisited:\n        thiscycle = []\n        neighbors = [unvisited[0]]\n        while neighbors:\n            current = neighbors.pop()\n            thiscycle.append(current)\n            unvisited.remove(current)\n            neighbors.extend(i for i, j in edges.select(current, '*') if i in unvisited)\n            neighbors.extend(j for i, j in edges.select('*', current) if j in unvisited)\n        if len(thiscycle) < len(cycle):\n            cycle = thiscycle\n    return cycle\n\n# Store the variables for callback\nmodel._vars = x\n\n# Add the callback for subtour elimination\nmodel.Params.LazyConstraints = 1\n\n# Optimize the model\nmodel.optimize(subtourelim)\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E041",
    "description": "Imagine a scenario where a salesperson needs to visit five different cities, identified as Cities 1 through 5, to present their products. The salesperson has the flexibility to choose any city as a starting point; however, they are required to visit each city exactly once and then return to the starting city. The primary goal is to complete this circuit while incurring the lowest possible travel cost.\n\nHere’s a summary of the travel costs between the cities:\n- The cost to travel from City 1 to City 2 is 28 units, to City 3 is 89 units, to City 4 is 59 units, and to City 5 is 41 units.\n- From City 2, it costs 28 units to reach City 1, 85 units to get to City 3, 12 units to City 4, and 68 units to City 5.\n- Traveling from City 3, the costs are 89 units to City 1, 85 units to City 2, 22 units to City 4, and 70 units to City 5.\n- From City 4, the journey costs 59 units to City 1, 12 units to City 2, 22 units to City 3, and 48 units to City 5.\n- Lastly, from City 5, it costs 41 units to travel to City 1, 68 units to City 2, 70 units to City 3, and 48 units to City 4.\n\nWhat is the minimum total travel cost for the salesperson to visit each of the five cities exactly once and return to the starting city?",
    "ground_truth": 173.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"TSP\")\n\n# Sets and Parameters\nC = [1, 2, 3, 4, 5]\ncost = {\n    (1, 2): 28, (1, 3): 89, (1, 4): 59, (1, 5): 41,\n    (2, 1): 28, (2, 3): 85, (2, 4): 12, (2, 5): 68,\n    (3, 1): 89, (3, 2): 85, (3, 4): 22, (3, 5): 70,\n    (4, 1): 59, (4, 2): 12, (4, 3): 22, (4, 5): 48,\n    (5, 1): 41, (5, 2): 68, (5, 3): 70, (5, 4): 48\n}\n\n# Variables\nx = model.addVars(C, C, vtype=GRB.BINARY, name=\"x\")\nu = model.addVars(C, lb=1, ub=len(C), vtype=GRB.CONTINUOUS, name=\"u\")\n\n# Objective\nmodel.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in C for j in C if i != j), GRB.MINIMIZE)\n\n# Constraints\n# (C1) Each city must be departed exactly once\nmodel.addConstrs((gp.quicksum(x[i, j] for j in C if i != j) == 1 for i in C), name=\"departure\")\n\n# (C2) Each city must be arrived at exactly once\nmodel.addConstrs((gp.quicksum(x[i, j] for i in C if i != j) == 1 for j in C), name=\"arrival\")\n\n# (C3) Subtour elimination constraints (MTZ formulation)\nmodel.addConstrs((u[i] - u[j] + len(C) * x[i, j] <= len(C) - 1 for i in C for j in C if i != j and i != 1 and j != 1), name=\"subtour\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "failure_solve"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E044",
    "description": "Imagine a scenario where a salesperson must visit four distinct cities to conduct business meetings. Let's label these cities as City 1, City 2, City 3, and City 4. The salesperson can start their trip from any city, but they must visit each city exactly once and then return to the starting point. The main objective is to minimize the total cost of traveling between these cities.\n\nHere’s a detailed breakdown of the travel costs:\n- From City 1, the travel cost is 27 units to City 2, 48 units to City 3, and 76 units to City 4.\n- From City 2, it costs 27 units to return to City 1, 82 units to reach City 3, and 88 units to go to City 4.\n- From City 3, traveling back to City 1 costs 48 units, moving to City 2 costs 82 units, and it is 97 units to journey to City 4.\n- Lastly, from City 4, it costs 76 units to go back to City 1, 88 units to travel to City 2, and 97 units to move to City 3.\n\nWhat is the minimum total travel cost for the salesperson to visit each of these cities exactly once and return to the starting city?",
    "ground_truth": 248.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "not_optimal"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E046",
    "description": "Consider a scenario where a delivery company needs to deliver packages to five different cities. These cities are labeled as E, F, G, H and I. The delivery van can start its route from any of these cities but must follow one rule: it must visit each city exactly once and then return to the starting city. The aim is to find the route that minimizes the total travel cost, which could be a function of fuel costs, labor costs, or road tolls.\n\nHere's a rundown of the travel costs between these cities:\n\nFrom City E (1), the cost to reach City F (2) is 35 units, to G (3) is 90 units, to H (4) is 23 units, and to I (5) is 62 units.\n\nFrom City F (2), the cost to City E (1) is 35 units, to G (3) is 53 units, to H (4) is 58 units, and to I (5) is 46 units.\n\nIf we start from City G (3), the cost to reach City E (1) is 90 units, to F (2) is 53 units, to H (4) is 28 units, and to I (5) is 91 units.\n\nFrom City H (4), the cost to City E (1) is 23 units, to F (2) is 58 units, to G (3) is 28 units, and to I (5) is 77 units.\n\nLastly, from City I (5), it costs 62 units to reach City E (1), 46 units to get to F (2), 91 units to reach G (3), and 77 units to reach H (4).\n\nWhat is the minimum total travel cost for the delivery van to visit each city exactly once and return to the starting city?",
    "ground_truth": 199.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "run_error"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E042",
    "description": "Consider a scenario where a logistics company needs to organize a delivery route across five warehouses. These warehouses are located in different cities labeled as A, B, C, D, and E. A delivery truck has to start from any one of these warehouses, deliver goods at each of the remaining four exactly once, and finally return to the starting warehouse. The challenge here is to plan the route in a way that minimizes the total travel cost. The cost could be based on various factors like distance, fuel usage, or time spent.\n\nHere are the details of the travel costs between the warehouses:\n\nThe cost to travel from Warehouse A to B is 15 units, to C is 88 units, to D is 54 units, and to E is 92 units.\n\nFrom Warehouse B, the cost to reach A is 15 units, to C is 29 units, to D is 98 units, and to E is 33 units.\n\nFor Warehouse C, the cost to get to A is 88 units, to B is 29 units, to D is 96 units, and to E is 96 units.\n\nMoving from Warehouse D, it costs 54 units to reach A, 98 units to get to B, 96 units to C, and 63 units to E.\n\nLastly, from Warehouse E, the cost to go to A is 92 units, to B is 33 units, to C is 96 units, and to D is 63 units.\n\nHow can the logistics company plan the route so that the total travel cost is minimized for the delivery truck to visit each warehouse exactly once and return to the starting warehouse?",
    "ground_truth": 257.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Define the data\nN = ['A', 'B', 'C', 'D', 'E']\ncost = {\n    ('A', 'B'): 15, ('A', 'C'): 88, ('A', 'D'): 54, ('A', 'E'): 92,\n    ('B', 'A'): 15, ('B', 'C'): 29, ('B', 'D'): 98, ('B', 'E'): 33,\n    ('C', 'A'): 88, ('C', 'B'): 29, ('C', 'D'): 96, ('C', 'E'): 96,\n    ('D', 'A'): 54, ('D', 'B'): 98, ('D', 'C'): 96, ('D', 'E'): 63,\n    ('E', 'A'): 92, ('E', 'B'): 33, ('E', 'C'): 96, ('E', 'D'): 63\n}\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Create variables\nx = model.addVars(N, N, vtype=GRB.BINARY, name=\"x\")\nu = model.addVars(N, vtype=GRB.CONTINUOUS, lb=0, ub=len(N)-1, name=\"u\")\n\n# Set objective\nmodel.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in N for j in N if i != j), GRB.MINIMIZE)\n\n# Add constraints\n# Each warehouse must be departed from exactly once\nmodel.addConstrs((gp.quicksum(x[i, j] for j in N if j != i) == 1 for i in N), \"c1\")\n\n# Each warehouse must be arrived at exactly once\nmodel.addConstrs((gp.quicksum(x[i, j] for i in N if i != j) == 1 for j in N), \"c2\")\n\n# Subtour elimination constraints (MTZ formulation)\nmodel.addConstrs((u[i] - u[j] + len(N) * x[i, j] <= len(N) - 1 for i in N for j in N if i != j and i != 'A' and j != 'A'), \"c3\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "failure_solve"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "IP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E050",
    "description": "Imagine a salesperson tasked with visiting four distinct cities—let's call them A, B, C, and D—to promote their products. The salesperson can commence their journey from any of these cities, with the requirement that they visit each city exactly once before returning to the starting point. The primary objective is to minimize the total travel cost incurred during this journey.\n\nHere's a breakdown of the travel costs between the cities:\n- To travel from City A to B, it costs 61 units.\n- To journey from City A to C, the cost is 65 units.\n- The travel cost from City A to D is 63 units.\n- If the salesperson begins from City B, it costs 61 units to reach A, 94 units to get to C, and 31 units to D.\n- From City C, the costs are 65 units to A, 94 units to B, and 19 units to D.\n- Finally, from City D, the costs are 63 units to A, 31 units to B, and 19 units to C.\n\nNow, what is the minimum total travel cost for the salesperson to visit each city exactly once and return to the starting city?",
    "ground_truth": 160.0,
    "formulation": null,
    "correct_program": null,
    "output_status": [
      "run_error"
    ],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "IP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "B006",
    "description": "An Italian transportation company needs to move some empty containers from its 6 warehouses (located in Verona, Perugia, Rome, Pescara, Taranto, and Lamezia) to major national ports (Genoa, Venice, Ancona, Naples, Bari). The container inventory at the warehouses is as follows:\n\n|  | Empty Containers |\n|:---:|:---:|\n| Verona | 10 |\n| Perugia | 12 |\n| Rome | 20 |\n| Pescara | 24 |\n| Taranto | 18 |\n| Lamezia | 40 |\n\nThe demand at the ports is as follows:\n\n|  | Container Demand |\n|:---:|:---:|\n| Genoa | 20 |\n| Venice | 15 |\n| Ancona | 25 |\n| Naples | 33 |\n| Bari | 21 |\n\nThe transport is carried out by a fleet of trucks. The cost to transport each container is proportional to the distance traveled by the trucks, with a rate of 30 euros per kilometer. Each truck can carry up to 2 containers. The distances are as follows:\n\n|  | Genoa | Venice | Ancona | Naples | Bari |\n|:---:|:---:|:---:|:---:|:---:|:---:|\n| Verona | $290 \\mathrm{~km}$ | $115 \\mathrm{~km}$ | $355 \\mathrm{~km}$ | $715 \\mathrm{~km}$ | $810 \\mathrm{~km}$ |\n| Perugia | $380 \\mathrm{~km}$ | $340 \\mathrm{~km}$ | $165 \\mathrm{~km}$ | $380 \\mathrm{~km}$ | $610 \\mathrm{~km}$ |\n| Rome | $505 \\mathrm{~km}$ | $530 \\mathrm{~km}$ | $285 \\mathrm{~km}$ | $220 \\mathrm{~km}$ | $450 \\mathrm{~km}$ |\n| Pescara | $655 \\mathrm{~km}$ | $450 \\mathrm{~km}$ | $155 \\mathrm{~km}$ | $240 \\mathrm{~km}$ | $315 \\mathrm{~km}$ |\n| Taranto | $1010 \\mathrm{~km}$ | $840 \\mathrm{~km}$ | $550 \\mathrm{~km}$ | $305 \\mathrm{~km}$ | $95 \\mathrm{~km}$ |\n| Lamezia | $1072 \\mathrm{~km}$ | $1097 \\mathrm{~km}$ | $747 \\mathrm{~km}$ | $372 \\mathrm{~km}$ | $333 \\mathrm{~km}$ |\n\nWrite a mathematical program to find the minimum cost transportation policy and solve it using COPTPY.",
    "ground_truth": 904590.0,
    "formulation": null,
    "correct_program": "def optimize_container_transportation():\n    from gurobipy import Model, GRB\n\n    # Data\n    warehouses = ['Verona', 'Perugia', 'Rome', 'Pescara', 'Taranto', 'Lamezia']\n    ports = ['Genoa', 'Venice', 'Ancona', 'Naples', 'Bari']\n\n    supply = [10, 12, 20, 24, 18, 40]\n    demand = [20, 15, 25, 33, 21]\n\n    # Distances in km\n    distances = [\n        [290, 115, 355, 715, 810],  # Verona\n        [380, 340, 165, 380, 610],  # Perugia\n        [505, 530, 285, 220, 450],  # Rome\n        [655, 450, 155, 240, 315],  # Pescara\n        [1010, 840, 550, 305, 95],  # Taranto\n        [1072, 1097, 747, 372, 333]  # Lamezia\n    ]\n\n    cost_per_km = 30\n\n    # Initialize model\n    m = Model(\"ContainerTransport\")\n\n    # Decision variables\n    x = {}  # containers shipped from warehouse i to port j\n    y = {}  # number of trucks on route i->j\n\n    for i in range(len(warehouses)):\n        for j in range(len(ports)):\n            var_name_x = f\"x_{i}_{j}\"\n            var_name_y = f\"y_{i}_{j}\"\n            x[i, j] = m.addVar(vtype=GRB.INTEGER, lb=0, name=var_name_x)\n            y[i, j] = m.addVar(vtype=GRB.INTEGER, lb=0, name=var_name_y)\n\n    m.update()\n\n    # Objective: minimize total transportation cost\n    total_cost = 0\n    for i in range(len(warehouses)):\n        for j in range(len(ports)):\n            c_ij = cost_per_km * distances[i][j]\n            total_cost += c_ij * x[i, j]\n    m.setObjective(total_cost, GRB.MINIMIZE)\n\n    # Supply constraints\n    for i in range(len(warehouses)):\n        m.addConstr(sum(x[i, j] for j in range(len(ports))) <= supply[i],\n                    name=f\"Supply_{i}\")\n\n    # Demand constraints\n    for j in range(len(ports)):\n        m.addConstr(sum(x[i, j] for i in range(len(warehouses))) >= demand[j],\n                    name=f\"Demand_{j}\")\n\n    # Truck capacity constraints\n    for i in range(len(warehouses)):\n        for j in range(len(ports)):\n            m.addConstr(x[i, j] <= 2 * y[i, j], name=f\"TruckCap_{i}_{j}\")\n\n    # Optimize\n    m.optimize()\n\n    # Check feasibility and return result\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    result = optimize_container_transportation()\n    if result is not None:\n        print(f\"Optimal transportation cost: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Transportation Problem",
        "modeling_type": "MILP",
        "industry_sector": "Transportation"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "B009",
    "description": "A convenience supermarket is planning to open several chain stores in a newly built residential area in the northwest suburb of the city. For shopping convenience, the distance from any residential area to one of the chain stores should not exceed $800 \\mathrm{~m}$. Table 5-1 shows the new residential areas and the residential areas within a radius of $800 \\mathrm{~m}$ from each of them. Question: What is the minimum number of chain stores the supermarket needs to build among the mentioned residential areas, and in which residential areas should they be built?\n\n| Area Code | Residential Areas within $800 \\mathrm{~m}$ Radius |\n|-----------|---------------------------------------------------|\n| A         | A, C, E, G, H, I                                  |\n| B         | B, H, I                                           |\n| C         | A, C, G, H, I                                     |\n| D         | D, J                                              |\n| E         | A, E, G                                           |\n| F         | F, J, K                                           |\n| G         | A, C, E, G                                        |\n| H         | A, B, C, H, I                                     |\n| I         | A, B, C, H, I                                     |\n| J         | D, F, J, K, L                                     |\n| K         | F, J, K, L                                        |\n| L         | J, K, L                                           |",
    "ground_truth": 3.0,
    "formulation": null,
    "correct_program": "from gurobipy import Model, GRB, quicksum\n\n\ndef solve_supermarket_location():\n    # --- 模型初始化 ---\n    model = Model(\"SupermarketSetCovering\")\n\n    # --- 集合定义 ---\n    # 住宅区既是潜在的建店地点，也是需要被覆盖的区域\n    locations = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\"]\n    areas_to_cover = locations[:]  # 创建一个副本\n\n    # --- 参数定义 ---\n    # coverage_data[loc] 是一个列表，包含地点loc建店可以覆盖的所有区域\n    coverage_data = {\n        \"A\": [\"A\", \"C\", \"E\", \"G\", \"H\", \"I\"],\n        \"B\": [\"B\", \"H\", \"I\"],\n        \"C\": [\"A\", \"C\", \"G\", \"H\", \"I\"],\n        \"D\": [\"D\", \"J\"],\n        \"E\": [\"A\", \"E\", \"G\"],\n        \"F\": [\"F\", \"J\", \"K\"],\n        \"G\": [\"A\", \"C\", \"E\", \"G\"],\n        \"H\": [\"A\", \"B\", \"C\", \"H\", \"I\"],\n        \"I\": [\"A\", \"B\", \"C\", \"H\", \"I\"],\n        \"J\": [\"D\", \"F\", \"J\", \"K\", \"L\"],\n        \"K\": [\"F\", \"J\", \"K\", \"L\"],\n        \"L\": [\"J\", \"K\", \"L\"],\n    }\n\n    # --- 决策变量 ---\n    # build[loc]: 是否在地点loc建店 (1=是, 0=否)\n    build = model.addVars(locations, name=\"BuildStore\", vtype=GRB.BINARY)\n\n    # --- 目标函数: 最小化建店数量 ---\n    model.setObjective(quicksum(build[loc] for loc in locations), GRB.MINIMIZE)\n\n    # --- 约束条件: 每个区域至少被一个店覆盖 ---\n    for area in areas_to_cover:\n        # 找出哪些潜在店址可以覆盖当前区域 area\n        covering_locations = []\n        for loc_candidate in locations:\n            if area in coverage_data[loc_candidate]:\n                covering_locations.append(loc_candidate)\n\n        # 添加约束: sum(build[loc] for loc in covering_locations) >= 1\n        if covering_locations:  # 确保列表不为空，尽管在此问题中每个区域都至少能被自己覆盖\n            model.addConstr(quicksum(build[loc] for loc in covering_locations)\n                            >= 1,\n                            name=f\"CoverArea_{area}\")\n        else:\n            print(f\"警告: 区域 {area} 无法被任何潜在店址覆盖。请检查数据。\")\n\n    # --- 模型求解 ---\n    model.optimize()\n\n    # --- 打印结果 ---\n    if model.status == GRB.OPTIMAL:\n        print(f\"\\n找到最优选址方案! 最少建店数量: {model.objVal:.0f}\")\n        print(\"建店地点:\")\n        for loc in locations:\n            if build[loc].X > 0.5:  # 检查二元变量是否为1\n                print(f\"  - 在区域 {loc} 建店\")\n\n        print(\"\\n各区域覆盖情况:\")\n        for area in areas_to_cover:\n            covered_by_stores = []\n            for loc in locations:\n                if build[loc].X > 0.5 and area in coverage_data[loc]:\n                    covered_by_stores.append(loc)\n            print(\n                f\"  区域 {area} 被以下店址覆盖: {', '.join(covered_by_stores) if covered_by_stores else '未被覆盖 (错误!)'}\"\n            )\n\n    elif model.status == GRB.INFEASIBLE:\n        print(\"模型不可行。请检查约束条件或覆盖数据。\")\n        print(\"可能原因：某个区域无法被任何潜在店址覆盖。\")\n    elif model.status == GRB.UNBOUNDED:\n        print(\"模型无界。(在此问题中不应发生)\")\n    else:\n        print(f\"优化过程因状态码 {model.status} 而停止。\")\n\n\nif __name__ == '__main__':\n    solve_supermarket_location()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Covering",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "B033",
    "description": "The current problem faced by the company is how to use the fewest number of containers to pack the currently needed goods for transportation, while considering the weight of the goods, specific packaging requirements, and inventory limitations. Professional modeling and analysis are needed for a batch of goods’ transportation strategy to ensure maximum utilization of the limited container space.\n\nThe company currently has a batch to be transported, with each container able to hold a maximum of 60 tons of goods and each container used must load at least 18 tons of goods. The goods to be loaded include five types: A, B, C, D, and E, with quantities of 120, 90, 300, 90, and 120 respectively. The weights are 0.5 tons for A, 1 ton for B, 0.4 tons for C, 0.6 tons for D, and 0.65 tons for E. Additionally, to meet specific usage requirements, every time A goods are loaded, at least 1 unit of C must also be loaded, but loading C alone does not require simultaneously loading A; and considering the demand limitation for D goods, each container must load at least 12 units of D.\n\nEstablish an operations research model so that the company can use the fewest number of containers to pack this batch of goods.",
    "ground_truth": 7.0,
    "formulation": null,
    "correct_program": "def optimize_container_usage():\n    from gurobipy import Model, GRB\n\n    # Data\n    demands = {'A': 120, 'B': 90, 'C': 300, 'D': 90, 'E': 120}\n    weights = {'A': 0.5, 'B': 1.0, 'C': 0.4, 'D': 0.6, 'E': 0.65}\n    max_containers = 20  # Sufficient upper bound\n\n    M = 1e5  # Large number for big-M method\n\n    # Initialize model\n    model = Model(\"ContainerPacking\")\n\n    # Decision variables\n    y = model.addVars(max_containers, vtype=GRB.BINARY,\n                      name='y')  # Container usage\n    z_A = model.addVars(max_containers, vtype=GRB.BINARY,\n                        name='zA')  # Indicator for A loaded\n    x = model.addVars(demands.keys(),\n                      max_containers,\n                      lb=0,\n                      ub=GRB.INFINITY,\n                      name='x')\n\n    # Set objective: minimize number of containers used\n    model.setObjective(y.sum(), GRB.MINIMIZE)\n\n    # Demand constraints\n    for i in demands:\n        model.addConstr(sum(x[i, k] for k in range(max_containers))\n                        >= demands[i],\n                        name=f'demand_{i}')\n\n    # Capacity and minimum load constraints\n    for k in range(max_containers):\n        # Capacity constraint\n        model.addConstr(sum(weights[i] * x[i, k] for i in demands)\n                        <= 60 * y[k],\n                        name=f'capacity_{k}')\n        # Minimum load constraint\n        model.addConstr(sum(weights[i] * x[i, k] for i in demands)\n                        >= 18 * y[k],\n                        name=f'min_load_{k}')\n        # D goods minimum per container\n        model.addConstr(x['D', k] >= 12 * y[k], name=f'D_min_{k}')\n        # A and C packaging constraints\n        # If A is loaded, at least 1 unit of C\n        model.addConstr(x['A', k] <= M * z_A[k], name=f'A_load_indicator_{k}')\n        model.addConstr(x['C', k] >= z_A[k], name=f'C_condition_{k}')\n\n    # Optional: limit goods to their total demand\n    for i in demands:\n        for k in range(max_containers):\n            model.addConstr(x[i, k] <= demands[i], name=f'limit_{i}_{k}')\n\n    # Optimize\n    model.optimize()\n\n    # Check feasibility and return the minimal number of containers\n    if model.status == GRB.OPTIMAL:\n        total_containers = sum(y[k].X for k in range(max_containers))\n        return total_containers\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_container_usage()\n    if result is not None:\n        print(f\"Optimal number of containers used: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Bin Packing",
        "modeling_type": "MILP",
        "industry_sector": "Logistics"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  },
  {
    "task_id": "E075",
    "description": "In the quest to streamline its distribution network, MarketFlow Inc. is faced with a critical decision regarding the allocation of resources to efficiently supply six retail stores. The company has narrowed down its options to four potential distribution centers, each with distinct opening costs and capabilities. The challenge lies in selecting the right mix of distribution centers and determining the optimal transportation routes to ensure that the demands of all retail stores are met at the lowest possible total cost. This cost encompasses both the opening expenses of the distribution centers and the costs associated with transporting goods to the stores.\n\nGiven Data:\n- Number of Potential Distribution Centers: 4\n- Number of Retail Stores Needing Supply: 6\n\nOpening Costs for Each Distribution Center (in dollars):\n- Center 1: $151,000\n- Center 2: $192,000\n- Center 3: $114,000\n- Center 4: $171,000\n\nTransportation Cost Per Unit from Each Distribution Center to Retail Stores (in dollars):\n- From Center 1: $5 to Store 1, $5 to Store 2, $2 to Store 3, $3 to Store 4, $3 to Store 5, $3 to Store 6\n- From Center 2: $5 to Store 1, $4 to Store 2, $3 to Store 3, $5 to Store 4, $2 to Store 5, $4 to Store 6\n- From Center 3: $2 to Store 1, $4 to Store 2, $5 to Store 3, $1 to Store 4, $4 to Store 5, $2 to Store 6\n- From Center 4: $5 to Store 1, $4 to Store 2, $1 to Store 3, $1 to Store 4, $3 to Store 5, $3 to Store 6\n\nDemand of Each Retail Store (in units):\n- Store 1: 910\n- Store 2: 875\n- Store 3: 589\n- Store 4: 962\n- Store 5: 966\n- Store 6: 643\n\nSupply Capacity of Each Distribution Center (in units):\n- Center 1: 1631\n- Center 2: 1954\n- Center 3: 1446\n- Center 4: 820\n\nMarketFlow Inc.'s objective is to fulfill the demand at each of its six retail stores efficiently while minimizing the total expenditure incurred from opening distribution centers and transporting goods. This scenario requires a strategic allocation of resources that entails choosing which distribution centers to open and determining the volume of goods to be transported from these centers to each retail store, all while staying within the supply constraints of the centers.\n\nQuestion:\nWhat is the optimal total cost for MarketFlow Inc. to open the necessary distribution centers and transport goods to all six retail stores, thereby meeting their demands while ensuring the cost is minimized, including both the opening costs of the centers and the transportation costs of supplying the stores?",
    "ground_truth": 469200.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"OptimizationProblem\")\n\n# Sets\nI = [1, 2, 3, 4]  # Distribution centers\nJ = [1, 2, 3, 4, 5, 6]  # Retail stores\n\n# Parameters\nf = {1: 151000, 2: 192000, 3: 114000, 4: 171000}  # Opening costs\nc = {\n    (1, 1): 5, (1, 2): 5, (1, 3): 2, (1, 4): 3, (1, 5): 3, (1, 6): 3,\n    (2, 1): 5, (2, 2): 4, (2, 3): 3, (2, 4): 5, (2, 5): 2, (2, 6): 4,\n    (3, 1): 2, (3, 2): 4, (3, 3): 5, (3, 4): 1, (3, 5): 4, (3, 6): 2,\n    (4, 1): 5, (4, 2): 4, (4, 3): 1, (4, 4): 1, (4, 5): 3, (4, 6): 3\n}\nd = {1: 910, 2: 875, 3: 589, 4: 962, 5: 966, 6: 643}  # Demand\ns = {1: 1631, 2: 1954, 3: 1446, 4: 820}  # Supply capacities\n\n# Variables\nx = model.addVars(I, J, name=\"x\", vtype=GRB.CONTINUOUS, lb=0)  # Transport quantities\ny = model.addVars(I, name=\"y\", vtype=GRB.BINARY)  # Open centers\n\n# Objective function\nmodel.setObjective(\n    gp.quicksum(f[i] * y[i] for i in I) +\n    gp.quicksum(c[i, j] * x[i, j] for i in I for j in J),\n    GRB.MINIMIZE\n)\n\n# Constraints\n# Demand fulfillment constraints\nfor j in J:\n    model.addConstr(gp.quicksum(x[i, j] for i in I) == d[j], name=f\"demand_{j}\")\n\n# Supply capacity constraints\nfor i in I:\n    model.addConstr(gp.quicksum(x[i, j] for j in J) <= s[i] * y[i], name=f\"supply_{i}\")\n\n# Optimize the model\nmodel.optimize()\n\nif model.Status == GRB.OPTIMAL:\n    print(\"Optimal value:\", model.ObjVal)\nelif model.Status == GRB.INFEASIBLE:\n    print(\"Model is infeasible.\")\nelif model.Status == GRB.UNBOUNDED:\n    print(\"Model is unbounded.\")\nelse:\n    print(\"Other status:\", model.Status)\n",
    "output_status": [
      "optimal"
    ],
    "success_count": 1,
    "success_confidence": 0,
    "fail_to_execute": 0,
    "fail_to_verify": 0,
    "tag": [
      {
        "problem_domain": "Facility Location & Transportation",
        "modeling_type": "MILP",
        "industry_sector": "Retail"
      }
    ],
    "cluster": 20,
    "retrieved_insights": []
  }
]